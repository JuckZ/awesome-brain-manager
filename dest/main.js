/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name2 in all3)
    __defProp(target, name2, { get: all3[name2], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __toBinary = /* @__PURE__ */ (() => {
  var table = new Uint8Array(128);
  for (var i3 = 0; i3 < 64; i3++)
    table[i3 < 26 ? i3 + 65 : i3 < 52 ? i3 + 71 : i3 < 62 ? i3 - 4 : i3 * 4 - 205] = i3;
  return (base64) => {
    var n2 = base64.length, bytes = new Uint8Array((n2 - (base64[n2 - 1] == "=") - (base64[n2 - 2] == "=")) * 3 / 4 | 0);
    for (var i4 = 0, j = 0; i4 < n2; ) {
      var c0 = table[base64.charCodeAt(i4++)], c1 = table[base64.charCodeAt(i4++)];
      var c22 = table[base64.charCodeAt(i4++)], c32 = table[base64.charCodeAt(i4++)];
      bytes[j++] = c0 << 2 | c1 >> 4;
      bytes[j++] = c1 << 4 | c22 >> 2;
      bytes[j++] = c22 << 6 | c32;
    }
    return bytes;
  };
})();

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports2, module2) {
    (function(global3, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global3.moment = factory();
    })(exports2, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback2) {
        hookCallback = callback2;
      }
      function isArray6(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject5(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a4, b2) {
        return Object.prototype.hasOwnProperty.call(a4, b2);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k2;
          for (k2 in obj) {
            if (hasOwnProp(obj, k2)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined2(input) {
        return input === void 0;
      }
      function isNumber4(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate3(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map4(arr, fn) {
        var res = [], i3, arrLen = arr.length;
        for (i3 = 0; i3 < arrLen; ++i3) {
          res.push(fn(arr[i3], i3));
        }
        return res;
      }
      function extend3(a4, b2) {
        for (var i3 in b2) {
          if (hasOwnProp(b2, i3)) {
            a4[i3] = b2[i3];
          }
        }
        if (hasOwnProp(b2, "toString")) {
          a4.toString = b2.toString;
        }
        if (hasOwnProp(b2, "valueOf")) {
          a4.valueOf = b2.valueOf;
        }
        return a4;
      }
      function createUTC(input, format3, locale4, strict) {
        return createLocalOrUTC(input, format3, locale4, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m3) {
        if (m3._pf == null) {
          m3._pf = defaultParsingFlags();
        }
        return m3._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t3 = Object(this), len = t3.length >>> 0, i3;
          for (i3 = 0; i3 < len; i3++) {
            if (i3 in t3 && fun.call(this, t3[i3], i3, t3)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid2(m3) {
        if (m3._isValid == null) {
          var flags = getParsingFlags(m3), parsedParts = some.call(flags.parsedDateParts, function(i3) {
            return i3 != null;
          }), isNowValid = !isNaN(m3._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m3._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m3)) {
            m3._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m3._isValid;
      }
      function createInvalid(flags) {
        var m3 = createUTC(NaN);
        if (flags != null) {
          extend3(getParsingFlags(m3), flags);
        } else {
          getParsingFlags(m3).userInvalidated = true;
        }
        return m3;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to3, from3) {
        var i3, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined2(from3._isAMomentObject)) {
          to3._isAMomentObject = from3._isAMomentObject;
        }
        if (!isUndefined2(from3._i)) {
          to3._i = from3._i;
        }
        if (!isUndefined2(from3._f)) {
          to3._f = from3._f;
        }
        if (!isUndefined2(from3._l)) {
          to3._l = from3._l;
        }
        if (!isUndefined2(from3._strict)) {
          to3._strict = from3._strict;
        }
        if (!isUndefined2(from3._tzm)) {
          to3._tzm = from3._tzm;
        }
        if (!isUndefined2(from3._isUTC)) {
          to3._isUTC = from3._isUTC;
        }
        if (!isUndefined2(from3._offset)) {
          to3._offset = from3._offset;
        }
        if (!isUndefined2(from3._pf)) {
          to3._pf = getParsingFlags(from3);
        }
        if (!isUndefined2(from3._locale)) {
          to3._locale = from3._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i3 = 0; i3 < momentPropertiesLen; i3++) {
            prop = momentProperties[i3];
            val = from3[prop];
            if (!isUndefined2(val)) {
              to3[prop] = val;
            }
          }
        }
        return to3;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn5(msg2) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg2);
        }
      }
      function deprecate(msg2, fn) {
        var firstTime = true;
        return extend3(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg2);
          }
          if (firstTime) {
            var args = [], arg, i3, key, argLen = arguments.length;
            for (i3 = 0; i3 < argLen; i3++) {
              arg = "";
              if (typeof arguments[i3] === "object") {
                arg += "\n[" + i3 + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i3];
              }
              args.push(arg);
            }
            warn5(msg2 + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name2, msg2) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name2, msg2);
        }
        if (!deprecations[name2]) {
          warn5(msg2);
          deprecations[name2] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction5(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set3(config) {
        var prop, i3;
        for (i3 in config) {
          if (hasOwnProp(config, i3)) {
            prop = config[i3];
            if (isFunction5(prop)) {
              this[i3] = prop;
            } else {
              this["_" + i3] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend3({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject5(parentConfig[prop]) && isObject5(childConfig[prop])) {
              res[prop] = {};
              extend3(res[prop], parentConfig[prop]);
              extend3(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject5(parentConfig[prop])) {
            res[prop] = extend3({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys2;
      if (Object.keys) {
        keys2 = Object.keys;
      } else {
        keys2 = function(obj) {
          var i3, res = [];
          for (i3 in obj) {
            if (hasOwnProp(obj, i3)) {
              res.push(i3);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction5(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign3 = number >= 0;
        return (sign3 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback2) {
        var func = callback2;
        if (typeof callback2 === "string") {
          func = function() {
            return this[callback2]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(func.apply(this, arguments), token2);
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format3) {
        var array = format3.match(formattingTokens), i3, length;
        for (i3 = 0, length = array.length; i3 < length; i3++) {
          if (formatTokenFunctions[array[i3]]) {
            array[i3] = formatTokenFunctions[array[i3]];
          } else {
            array[i3] = removeFormattingTokens(array[i3]);
          }
        }
        return function(mom) {
          var output = "", i4;
          for (i4 = 0; i4 < length; i4++) {
            output += isFunction5(array[i4]) ? array[i4].call(mom, format3) : array[i4];
          }
          return output;
        };
      }
      function formatMoment(m3, format3) {
        if (!m3.isValid()) {
          return m3.localeData().invalidDate();
        }
        format3 = expandFormat(format3, m3.localeData());
        formatFunctions[format3] = formatFunctions[format3] || makeFormatFunction(format3);
        return formatFunctions[format3](m3);
      }
      function expandFormat(format3, locale4) {
        var i3 = 5;
        function replaceLongDateFormatTokens(input) {
          return locale4.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i3 >= 0 && localFormattingTokens.test(format3)) {
          format3 = format3.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i3 -= 1;
        }
        return format3;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format3 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format3 || !formatUpper) {
          return format3;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction5(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format3 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction5(format3) ? format3(output) : format3.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u2;
        for (u2 in unitsObj) {
          if (hasOwnProp(unitsObj, u2)) {
            units.push({ unit: u2, priority: priorities[u2] });
          }
        }
        units.sort(function(a4, b2) {
          return a4.priority - b2.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$12(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get3(this, unit);
          }
        };
      }
      function get3(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$12(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction5(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i3, prioritizedLen = prioritized.length;
          for (i3 = 0; i3 < prioritizedLen; i3++) {
            this[prioritized[i3].unit](units[prioritized[i3].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction5(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match22 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction5(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s4) {
        return regexEscape(s4.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }));
      }
      function regexEscape(s4) {
        return s4.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback2) {
        var i3, func = callback2, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber4(callback2)) {
          func = function(input, array) {
            array[callback2] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i3 = 0; i3 < tokenLen; i3++) {
          tokens[token2[i3]] = func;
        }
      }
      function addWeekParseToken(token2, callback2) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback2(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n2, x2) {
        return (n2 % x2 + x2) % x2;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o2) {
          var i3;
          for (i3 = 0; i3 < this.length; ++i3) {
            if (this[i3] === o2) {
              return i3;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format3) {
        return this.localeData().monthsShort(this, format3);
      });
      addFormatToken("MMMM", 0, 0, function(format3) {
        return this.localeData().months(this, format3);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match22);
      addRegexToken("MMM", function(isStrict, locale4) {
        return locale4.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale4) {
        return locale4.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m3, format3) {
        if (!m3) {
          return isArray6(this._months) ? this._months : this._months["standalone"];
        }
        return isArray6(this._months) ? this._months[m3.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format3) ? "format" : "standalone"][m3.month()];
      }
      function localeMonthsShort(m3, format3) {
        if (!m3) {
          return isArray6(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray6(this._monthsShort) ? this._monthsShort[m3.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format3) ? "format" : "standalone"][m3.month()];
      }
      function handleStrictParse(monthName, format3, strict) {
        var i3, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i3 = 0; i3 < 12; ++i3) {
            mom = createUTC([2e3, i3]);
            this._shortMonthsParse[i3] = this.monthsShort(mom, "").toLocaleLowerCase();
            this._longMonthsParse[i3] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format3, strict) {
        var i3, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format3, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i3 = 0; i3 < 12; i3++) {
          mom = createUTC([2e3, i3]);
          if (strict && !this._longMonthsParse[i3]) {
            this._longMonthsParse[i3] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
            this._shortMonthsParse[i3] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
          }
          if (!strict && !this._monthsParse[i3]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i3] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format3 === "MMMM" && this._longMonthsParse[i3].test(monthName)) {
            return i3;
          } else if (strict && format3 === "MMM" && this._shortMonthsParse[i3].test(monthName)) {
            return i3;
          } else if (!strict && this._monthsParse[i3].test(monthName)) {
            return i3;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber4(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get3(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a4, b2) {
          return b2.length - a4.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i3, mom;
        for (i3 = 0; i3 < 12; i3++) {
          mom = createUTC([2e3, i3]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i3 = 0; i3 < 12; i3++) {
          shortPieces[i3] = regexEscape(shortPieces[i3]);
          longPieces[i3] = regexEscape(longPieces[i3]);
        }
        for (i3 = 0; i3 < 24; i3++) {
          mixedPieces[i3] = regexEscape(mixedPieces[i3]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
      }
      addFormatToken("Y", 0, 0, function() {
        var y3 = this.year();
        return y3 <= 9999 ? zeroFill(y3, 4) : "+" + y3;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match22);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y3, m3, d4, h6, M3, s4, ms) {
        var date;
        if (y3 < 100 && y3 >= 0) {
          date = new Date(y3 + 400, m3, d4, h6, M3, s4, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y3);
          }
        } else {
          date = new Date(y3, m3, d4, h6, M3, s4, ms);
        }
        return date;
      }
      function createUTCDate(y3) {
        var date, args;
        if (y3 < 100 && y3 >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y3 + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y3);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match22);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match22);
      addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        doy: 6
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format3) {
        return this.localeData().weekdaysMin(this, format3);
      });
      addFormatToken("ddd", 0, 0, function(format3) {
        return this.localeData().weekdaysShort(this, format3);
      });
      addFormatToken("dddd", 0, 0, function(format3) {
        return this.localeData().weekdays(this, format3);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale4) {
        return locale4.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale4) {
        return locale4.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale4) {
        return locale4.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday2(input, locale4) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale4.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale4) {
        if (typeof input === "string") {
          return locale4.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n2) {
        return ws.slice(n2, 7).concat(ws.slice(0, n2));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m3, format3) {
        var weekdays = isArray6(this._weekdays) ? this._weekdays : this._weekdays[m3 && m3 !== true && this._weekdays.isFormat.test(format3) ? "format" : "standalone"];
        return m3 === true ? shiftWeekdays(weekdays, this._week.dow) : m3 ? weekdays[m3.day()] : weekdays;
      }
      function localeWeekdaysShort(m3) {
        return m3 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m3 ? this._weekdaysShort[m3.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m3) {
        return m3 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m3 ? this._weekdaysMin[m3.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format3, strict) {
        var i3, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i3 = 0; i3 < 7; ++i3) {
            mom = createUTC([2e3, 1]).day(i3);
            this._minWeekdaysParse[i3] = this.weekdaysMin(mom, "").toLocaleLowerCase();
            this._shortWeekdaysParse[i3] = this.weekdaysShort(mom, "").toLocaleLowerCase();
            this._weekdaysParse[i3] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format3, strict) {
        var i3, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format3, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i3 = 0; i3 < 7; i3++) {
          mom = createUTC([2e3, 1]).day(i3);
          if (strict && !this._fullWeekdaysParse[i3]) {
            this._fullWeekdaysParse[i3] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
            this._shortWeekdaysParse[i3] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
            this._minWeekdaysParse[i3] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
          }
          if (!this._weekdaysParse[i3]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i3] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format3 === "dddd" && this._fullWeekdaysParse[i3].test(weekdayName)) {
            return i3;
          } else if (strict && format3 === "ddd" && this._shortWeekdaysParse[i3].test(weekdayName)) {
            return i3;
          } else if (strict && format3 === "dd" && this._minWeekdaysParse[i3].test(weekdayName)) {
            return i3;
          } else if (!strict && this._weekdaysParse[i3].test(weekdayName)) {
            return i3;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday2(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a4, b2) {
          return b2.length - a4.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i3, mom, minp, shortp, longp;
        for (i3 = 0; i3 < 7; i3++) {
          mom = createUTC([2e3, 1]).day(i3);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale4) {
        return locale4._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match22);
      addRegexToken("hh", match1to2, match22);
      addRegexToken("kk", match1to2, match22);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i3, minl = Math.min(arr1.length, arr2.length);
        for (i3 = 0; i3 < minl; i3 += 1) {
          if (arr1[i3] !== arr2[i3]) {
            return i3;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names2) {
        var i3 = 0, j, next, locale4, split2;
        while (i3 < names2.length) {
          split2 = normalizeLocale(names2[i3]).split("-");
          j = split2.length;
          next = normalizeLocale(names2[i3 + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale4 = loadLocale(split2.slice(0, j).join("-"));
            if (locale4) {
              return locale4;
            }
            if (next && next.length >= j && commonPrefix(split2, next) >= j - 1) {
              break;
            }
            j--;
          }
          i3++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name2) {
        return name2.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name2) {
        var oldLocale = null, aliasedRequire;
        if (locales[name2] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name2)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name2);
            getSetGlobalLocale(oldLocale);
          } catch (e3) {
            locales[name2] = null;
          }
        }
        return locales[name2];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined2(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("Locale " + key + " not found. Did you forget to load it?");
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name2, config) {
        if (config !== null) {
          var locale4, parentConfig = baseConfig;
          config.abbr = name2;
          if (locales[name2] != null) {
            deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
            parentConfig = locales[name2]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale4 = loadLocale(config.parentLocale);
              if (locale4 != null) {
                parentConfig = locale4._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name: name2,
                  config
                });
                return null;
              }
            }
          }
          locales[name2] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name2]) {
            localeFamilies[name2].forEach(function(x2) {
              defineLocale(x2.name, x2.config);
            });
          }
          getSetGlobalLocale(name2);
          return locales[name2];
        } else {
          delete locales[name2];
          return null;
        }
      }
      function updateLocale(name2, config) {
        if (config != null) {
          var locale4, tmpLocale, parentConfig = baseConfig;
          if (locales[name2] != null && locales[name2].parentLocale != null) {
            locales[name2].set(mergeConfigs(locales[name2]._config, config));
          } else {
            tmpLocale = loadLocale(name2);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name2;
            }
            locale4 = new Locale(config);
            locale4.parentLocale = locales[name2];
            locales[name2] = locale4;
          }
          getSetGlobalLocale(name2);
        } else {
          if (locales[name2] != null) {
            if (locales[name2].parentLocale != null) {
              locales[name2] = locales[name2].parentLocale;
              if (name2 === getSetGlobalLocale()) {
                getSetGlobalLocale(name2);
              }
            } else if (locales[name2] != null) {
              delete locales[name2];
            }
          }
        }
        return locales[name2];
      }
      function getLocale(key) {
        var locale4;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray6(key)) {
          locale4 = loadLocale(key);
          if (locale4) {
            return locale4;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys2(locales);
      }
      function checkOverflow(m3) {
        var overflow, a4 = m3._a;
        if (a4 && getParsingFlags(m3).overflow === -2) {
          overflow = a4[MONTH] < 0 || a4[MONTH] > 11 ? MONTH : a4[DATE] < 1 || a4[DATE] > daysInMonth(a4[YEAR], a4[MONTH]) ? DATE : a4[HOUR] < 0 || a4[HOUR] > 24 || a4[HOUR] === 24 && (a4[MINUTE] !== 0 || a4[SECOND] !== 0 || a4[MILLISECOND] !== 0) ? HOUR : a4[MINUTE] < 0 || a4[MINUTE] > 59 ? MINUTE : a4[SECOND] < 0 || a4[SECOND] > 59 ? SECOND : a4[MILLISECOND] < 0 || a4[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m3)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m3)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m3)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m3).overflow = overflow;
        }
        return m3;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i3, l2, string = config._i, match5 = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match5) {
          getParsingFlags(config).iso = true;
          for (i3 = 0, l2 = isoDatesLen; i3 < l2; i3++) {
            if (isoDates[i3][1].exec(match5[1])) {
              dateFormat = isoDates[i3][0];
              allowTime = isoDates[i3][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match5[3]) {
            for (i3 = 0, l2 = isoTimesLen; i3 < l2; i3++) {
              if (isoTimes[i3][1].exec(match5[3])) {
                timeFormat = (match5[2] || " ") + isoTimes[i3][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match5[4]) {
            if (tzRegex.exec(match5[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s4) {
        return s4.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m3 = hm % 100, h6 = (hm - m3) / 100;
          return h6 * 60 + m3;
        }
      }
      function configFromRFC2822(config) {
        var match5 = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match5) {
          parsedArray = extractFromRFC2822Strings(match5[4], match5[3], match5[2], match5[5], match5[6], match5[7]);
          if (!checkWeekday(match5[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match5[8], match5[9], match5[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
      });
      function defaults3(a4, b2, c6) {
        if (a4 != null) {
          return a4;
        }
        if (b2 != null) {
          return b2;
        }
        return c6;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i3, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults3(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i3 = 0; i3 < 3 && config._a[i3] == null; ++i3) {
          config._a[i3] = input[i3] = currentDate[i3];
        }
        for (; i3 < 7; i3++) {
          config._a[i3] = input[i3] = config._a[i3] == null ? i3 === 2 ? 1 : 0 : config._a[i3];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w3, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w3 = config._w;
        if (w3.GG != null || w3.W != null || w3.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults3(w3.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
          week = defaults3(w3.W, 1);
          weekday = defaults3(w3.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults3(w3.gg, config._a[YEAR], curWeek.year);
          week = defaults3(w3.w, curWeek.week);
          if (w3.d != null) {
            weekday = w3.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w3.e != null) {
            weekday = w3.e + dow;
            if (w3.e < 0 || w3.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i3, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i3 = 0; i3 < tokenLen; i3++) {
          token2 = tokens2[i3];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale4, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale4.meridiemHour != null) {
          return locale4.meridiemHour(hour, meridiem2);
        } else if (locale4.isPM != null) {
          isPm = locale4.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i3, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i3 = 0; i3 < configfLen; i3++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i3];
          configFromStringAndFormat(tempConfig);
          if (isValid2(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend3(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i3 = normalizeObjectUnits(config._i), dayOrDate = i3.day === void 0 ? i3.date : i3.day;
        config._a = map4([i3.year, i3.month, dayOrDate, i3.hour, i3.minute, i3.second, i3.millisecond], function(obj) {
          return obj && parseInt(obj, 10);
        });
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format3 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format3 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate3(input)) {
          config._d = input;
        } else if (isArray6(format3)) {
          configFromStringAndArray(config);
        } else if (format3) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid2(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined2(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate3(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray6(input)) {
          config._a = map4(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject5(input)) {
          configFromObject(config);
        } else if (isNumber4(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format3, locale4, strict, isUTC) {
        var c6 = {};
        if (format3 === true || format3 === false) {
          strict = format3;
          format3 = void 0;
        }
        if (locale4 === true || locale4 === false) {
          strict = locale4;
          locale4 = void 0;
        }
        if (isObject5(input) && isObjectEmpty(input) || isArray6(input) && input.length === 0) {
          input = void 0;
        }
        c6._isAMomentObject = true;
        c6._useUTC = c6._isUTC = isUTC;
        c6._l = locale4;
        c6._i = input;
        c6._f = format3;
        c6._strict = strict;
        return createFromConfig(c6);
      }
      function createLocal(input, format3, locale4, strict) {
        return createLocalOrUTC(input, format3, locale4, strict, false);
      }
      var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      });
      function pickBy(fn, moments) {
        var res, i3;
        if (moments.length === 1 && isArray6(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i3 = 1; i3 < moments.length; ++i3) {
          if (!moments[i3].isValid() || moments[i3][fn](res)) {
            res = moments[i3];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m3) {
        var key, unitHasDecimal = false, i3, orderLen = ordering.length;
        for (key in m3) {
          if (hasOwnProp(m3, key) && !(indexOf.call(ordering, key) !== -1 && (m3[key] == null || !isNaN(m3[key])))) {
            return false;
          }
        }
        for (i3 = 0; i3 < orderLen; ++i3) {
          if (m3[ordering[i3]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m3[ordering[i3]]) !== toInt(m3[ordering[i3]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days3 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
        this._days = +days3 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i3;
        for (i3 = 0; i3 < len; i3++) {
          if (dontConvert && array1[i3] !== array2[i3] || !dontConvert && toInt(array1[i3]) !== toInt(array2[i3])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign3 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign3 = "-";
          }
          return sign3 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate3(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m3) {
        return -Math.round(m3._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(this, createDuration(input - offset2, "m"), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined2(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c6 = {}, other;
        copyConfig(c6, this);
        c6 = prepareConfig(c6);
        if (c6._a) {
          other = c6._isUTC ? createUTC(c6._a) : createLocal(c6._a);
          this._isDSTShifted = this.isValid() && compareArrays(c6._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match5 = null, sign3, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber4(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match5 = aspNetRegex.exec(input)) {
          sign3 = match5[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match5[DATE]) * sign3,
            h: toInt(match5[HOUR]) * sign3,
            m: toInt(match5[MINUTE]) * sign3,
            s: toInt(match5[SECOND]) * sign3,
            ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign3
          };
        } else if (match5 = isoRegex.exec(input)) {
          sign3 = match5[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match5[2], sign3),
            M: parseIso(match5[3], sign3),
            w: parseIso(match5[4], sign3),
            d: parseIso(match5[5], sign3),
            h: parseIso(match5[6], sign3),
            m: parseIso(match5[7], sign3),
            s: parseIso(match5[8], sign3)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign3) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign3;
      }
      function positiveMomentsDifference(base3, other) {
        var res = {};
        res.months = other.month() - base3.month() + (other.year() - base3.year()) * 12;
        if (base3.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base3.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base3, other) {
        var res;
        if (!(base3.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base3);
        if (base3.isBefore(other)) {
          res = positiveMomentsDifference(base3, other);
        } else {
          res = positiveMomentsDifference(other, base3);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name2) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name2, "moment()." + name2 + "(period, number) is deprecated. Please use moment()." + name2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days3 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get3(mom, "Month") + months2 * isAdding);
        }
        if (days3) {
          set$12(mom, "Date", get3(mom, "Date") + days3 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days3 || months2);
        }
      }
      var add3 = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString3(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate3(input) || isString3(input) || isNumber4(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject5(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i3, property2, propertyLen = properties.length;
        for (i3 = 0; i3 < propertyLen; i3 += 1) {
          property2 = properties[i3];
          propertyTest = propertyTest || hasOwnProp(input, property2);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray6(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber4(item) && isString3(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject5(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i3, property2;
        for (i3 = 0; i3 < properties.length; i3 += 1) {
          property2 = properties[i3];
          propertyTest = propertyTest || hasOwnProp(input, property2);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time2, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time2 = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time2 = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time2 = void 0;
          }
        }
        var now2 = time2 || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format3 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction5(formats[format3]) ? formats[format3].call(this, now2) : formats[format3]);
        return this.format(output || this.localeData().calendar(format3, this, createLocal(now2)));
      }
      function clone3() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from3, to3, units, inclusivity) {
        var localFrom = isMoment(from3) ? from3 : createLocal(from3), localTo = isMoment(to3) ? to3 : createLocal(to3);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a4, b2) {
        if (a4.date() < b2.date()) {
          return -monthDiff(b2, a4);
        }
        var wholeMonthDiff = (b2.year() - a4.year()) * 12 + (b2.month() - a4.month()), anchor = a4.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b2 - anchor < 0) {
          anchor2 = a4.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b2 - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a4.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b2 - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString4() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m3 = utc ? this.clone().utc() : this;
        if (m3.year() < 0 || m3.year() > 9999) {
          return formatMoment(m3, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
        }
        if (isFunction5(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m3, "Z"));
          }
        }
        return formatMoment(m3, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
      }
      function inspect2() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix3, year, datetime, suffix2;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix3 = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix2 = zone + '[")]';
        return this.format(prefix3 + year + datetime + suffix2);
      }
      function format2(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from2(time2, withoutSuffix) {
        if (this.isValid() && (isMoment(time2) && time2.isValid() || createLocal(time2).isValid())) {
          return createDuration({ to: this, from: time2 }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to2(time2, withoutSuffix) {
        if (this.isValid() && (isMoment(time2) && time2.isValid() || createLocal(time2).isValid())) {
          return createDuration({ from: this, to: time2 }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale3(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      });
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y3, m3, d4) {
        if (y3 < 100 && y3 >= 0) {
          return new Date(y3 + 400, m3, d4) - MS_PER_400_YEARS;
        } else {
          return new Date(y3, m3, d4).valueOf();
        }
      }
      function utcStartOfDate(y3, m3, d4) {
        if (y3 < 100 && y3 >= 0) {
          return Date.UTC(y3 + 400, m3, d4) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y3, m3, d4);
        }
      }
      function startOf(units) {
        var time2, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time2 = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time2 = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;
          case "month":
            time2 = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time2 = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;
          case "isoWeek":
            time2 = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
          case "day":
          case "date":
            time2 = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time2 = this._d.valueOf();
            time2 -= mod$1(time2 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;
          case "minute":
            time2 = this._d.valueOf();
            time2 -= mod$1(time2, MS_PER_MINUTE);
            break;
          case "second":
            time2 = this._d.valueOf();
            time2 -= mod$1(time2, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time2);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time2, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time2 = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time2 = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
          case "month":
            time2 = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time2 = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
          case "isoWeek":
            time2 = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
          case "day":
          case "date":
            time2 = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time2 = this._d.valueOf();
            time2 += MS_PER_HOUR - mod$1(time2 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;
          case "minute":
            time2 = this._d.valueOf();
            time2 += MS_PER_MINUTE - mod$1(time2, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time2 = this._d.valueOf();
            time2 += MS_PER_SECOND - mod$1(time2, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time2);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate2() {
        return new Date(this.valueOf());
      }
      function toArray4() {
        var m3 = this;
        return [
          m3.year(),
          m3.month(),
          m3.date(),
          m3.hour(),
          m3.minute(),
          m3.second(),
          m3.millisecond()
        ];
      }
      function toObject() {
        var m3 = this;
        return {
          years: m3.year(),
          months: m3.month(),
          date: m3.date(),
          hours: m3.hours(),
          minutes: m3.minutes(),
          seconds: m3.seconds(),
          milliseconds: m3.milliseconds()
        };
      }
      function toJSON2() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid2(this);
      }
      function parsingFlags() {
        return extend3({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      });
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match5;
        if (config._locale._eraYearOrdinalRegex) {
          match5 = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match5);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m3, format3) {
        var i3, l2, date, eras = this._eras || getLocale("en")._eras;
        for (i3 = 0, l2 = eras.length; i3 < l2; ++i3) {
          switch (typeof eras[i3].since) {
            case "string":
              date = hooks(eras[i3].since).startOf("day");
              eras[i3].since = date.valueOf();
              break;
          }
          switch (typeof eras[i3].until) {
            case "undefined":
              eras[i3].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i3].until).startOf("day").valueOf();
              eras[i3].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format3, strict) {
        var i3, l2, eras = this.eras(), name2, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i3 = 0, l2 = eras.length; i3 < l2; ++i3) {
          name2 = eras[i3].name.toUpperCase();
          abbr = eras[i3].abbr.toUpperCase();
          narrow = eras[i3].narrow.toUpperCase();
          if (strict) {
            switch (format3) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i3];
                }
                break;
              case "NNNN":
                if (name2 === eraName) {
                  return eras[i3];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i3];
                }
                break;
            }
          } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i3];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i3, l2, val, eras = this.localeData().eras();
        for (i3 = 0, l2 = eras.length; i3 < l2; ++i3) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i3].since <= val && val <= eras[i3].until) {
            return eras[i3].name;
          }
          if (eras[i3].until <= val && val <= eras[i3].since) {
            return eras[i3].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i3, l2, val, eras = this.localeData().eras();
        for (i3 = 0, l2 = eras.length; i3 < l2; ++i3) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i3].since <= val && val <= eras[i3].until) {
            return eras[i3].narrow;
          }
          if (eras[i3].until <= val && val <= eras[i3].since) {
            return eras[i3].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i3, l2, val, eras = this.localeData().eras();
        for (i3 = 0, l2 = eras.length; i3 < l2; ++i3) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i3].since <= val && val <= eras[i3].until) {
            return eras[i3].abbr;
          }
          if (eras[i3].until <= val && val <= eras[i3].since) {
            return eras[i3].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i3, l2, dir, val, eras = this.localeData().eras();
        for (i3 = 0, l2 = eras.length; i3 < l2; ++i3) {
          dir = eras[i3].since <= eras[i3].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i3].since <= val && val <= eras[i3].until || eras[i3].until <= val && val <= eras[i3].since) {
            return (this.year() - hooks(eras[i3].since).year()) * dir + eras[i3].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale4) {
        return locale4.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale4) {
        return locale4.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale4) {
        return locale4.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale4) {
        return locale4._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i3, l2, eras = this.eras();
        for (i3 = 0, l2 = eras.length; i3 < l2; ++i3) {
          namePieces.push(regexEscape(eras[i3].name));
          abbrPieces.push(regexEscape(eras[i3].abbr));
          narrowPieces.push(regexEscape(eras[i3].narrow));
          mixedPieces.push(regexEscape(eras[i3].name));
          mixedPieces.push(regexEscape(eras[i3].abbr));
          mixedPieces.push(regexEscape(eras[i3].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match22);
      addRegexToken("gg", match1to2, match22);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match22);
      addRegexToken("Do", function(isStrict, locale4) {
        return isStrict ? locale4._dayOfMonthOrdinalParse || locale4._ordinalParse : locale4._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match22);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match22);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match22);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add3;
      proto.calendar = calendar$1;
      proto.clone = clone3;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format2;
      proto.from = from2;
      proto.fromNow = fromNow;
      proto.to = to2;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale3;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray4;
      proto.toObject = toObject;
      proto.toDate = toDate2;
      proto.toISOString = toISOString;
      proto.inspect = inspect2;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON2;
      proto.toString = toString4;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
      proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
      proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
      proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
      proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set3;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$12(format3, index2, field, setter) {
        var locale4 = getLocale(), utc = createUTC().set(setter, index2);
        return locale4[field](utc, format3);
      }
      function listMonthsImpl(format3, index2, field) {
        if (isNumber4(format3)) {
          index2 = format3;
          format3 = void 0;
        }
        format3 = format3 || "";
        if (index2 != null) {
          return get$12(format3, index2, field, "month");
        }
        var i3, out = [];
        for (i3 = 0; i3 < 12; i3++) {
          out[i3] = get$12(format3, i3, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format3, index2, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber4(format3)) {
            index2 = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        } else {
          format3 = localeSorted;
          index2 = format3;
          localeSorted = false;
          if (isNumber4(format3)) {
            index2 = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        }
        var locale4 = getLocale(), shift = localeSorted ? locale4._week.dow : 0, i3, out = [];
        if (index2 != null) {
          return get$12(format3, (index2 + shift) % 7, field, "day");
        }
        for (i3 = 0; i3 < 7; i3++) {
          out[i3] = get$12(format3, (i3 + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format3, index2) {
        return listMonthsImpl(format3, index2, "months");
      }
      function listMonthsShort(format3, index2) {
        return listMonthsImpl(format3, index2, "monthsShort");
      }
      function listWeekdays(localeSorted, format3, index2) {
        return listWeekdaysImpl(localeSorted, format3, index2, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format3, index2) {
        return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format3, index2) {
        return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b2 = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
      hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days3 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days3 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days3 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days3) * 864e5;
          days3 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days3 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days3));
        months2 += monthsFromDays;
        days3 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days3;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days3) {
        return days3 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days3, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days3 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days3);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days3 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days3 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days3 + milliseconds2 / 864e5;
            case "hour":
              return days3 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days3 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days3 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days3 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name2) {
        return function() {
          return this.isValid() ? this._data[name2] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days2 = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round2 = Math.round, thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        w: null,
        M: 11
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale4) {
        return locale4.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale4) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days3 = round2(duration.as("d")), months2 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a4 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days3 <= 1 && ["d"] || days3 < thresholds2.d && ["dd", days3];
        if (thresholds2.w != null) {
          a4 = a4 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a4 = a4 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a4[2] = withoutSuffix;
        a4[3] = +posNegDuration > 0;
        a4[4] = locale4;
        return substituteTimeAgo.apply(null, a4);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round2;
        }
        if (typeof roundingFunction === "function") {
          round2 = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale4, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale4 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale4);
        if (withSuffix) {
          output = locale4.pastFuture(+this, output);
        }
        return locale4.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign2(x2) {
        return (x2 > 0) - (x2 < 0) || +x2;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days3 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s4, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s4 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign2(this._months) !== sign2(total) ? "-" : "";
        daysSign = sign2(this._days) !== sign2(total) ? "-" : "";
        hmsSign = sign2(this._milliseconds) !== sign2(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days3 ? daysSign + days3 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s4 + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days2;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale3;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate3;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "GGGG-[W]WW",
        MONTH: "YYYY-MM"
      };
      return hooks;
    });
  }
});

// node_modules/obsidian-daily-notes-interface/dist/main.js
var require_main = __commonJS({
  "node_modules/obsidian-daily-notes-interface/dist/main.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var obsidian2 = require("obsidian");
    var DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
    var DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
    var DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
    var DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
    var DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";
    function shouldUsePeriodicNotesSettings(periodicity) {
      var _a3, _b2;
      const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b2 = (_a3 = periodicNotes.settings) == null ? void 0 : _a3[periodicity]) == null ? void 0 : _b2.enabled);
    }
    function getDailyNoteSettings3() {
      var _a3, _b2, _c, _d;
      try {
        const { internalPlugins, plugins: plugins2 } = window.app;
        if (shouldUsePeriodicNotesSettings("daily")) {
          const { format: format3, folder: folder2, template: template2 } = ((_b2 = (_a3 = plugins2.getPlugin("periodic-notes")) == null ? void 0 : _a3.settings) == null ? void 0 : _b2.daily) || {};
          return {
            format: format3 || DEFAULT_DAILY_NOTE_FORMAT,
            folder: (folder2 == null ? void 0 : folder2.trim()) || "",
            template: (template2 == null ? void 0 : template2.trim()) || ""
          };
        }
        const { folder, format: format2, template } = ((_d = (_c = internalPlugins.getPluginById("daily-notes")) == null ? void 0 : _c.instance) == null ? void 0 : _d.options) || {};
        return {
          format: format2 || DEFAULT_DAILY_NOTE_FORMAT,
          folder: (folder == null ? void 0 : folder.trim()) || "",
          template: (template == null ? void 0 : template.trim()) || ""
        };
      } catch (err) {
        console.info("No custom daily note settings found!", err);
      }
    }
    function getWeeklyNoteSettings() {
      var _a3, _b2, _c, _d, _e, _f, _g;
      try {
        const pluginManager = window.app.plugins;
        const calendarSettings = (_a3 = pluginManager.getPlugin("calendar")) == null ? void 0 : _a3.options;
        const periodicNotesSettings = (_c = (_b2 = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _b2.settings) == null ? void 0 : _c.weekly;
        if (shouldUsePeriodicNotesSettings("weekly")) {
          return {
            format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
            folder: ((_d = periodicNotesSettings.folder) == null ? void 0 : _d.trim()) || "",
            template: ((_e = periodicNotesSettings.template) == null ? void 0 : _e.trim()) || ""
          };
        }
        const settings = calendarSettings || {};
        return {
          format: settings.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
          folder: ((_f = settings.weeklyNoteFolder) == null ? void 0 : _f.trim()) || "",
          template: ((_g = settings.weeklyNoteTemplate) == null ? void 0 : _g.trim()) || ""
        };
      } catch (err) {
        console.info("No custom weekly note settings found!", err);
      }
    }
    function getMonthlyNoteSettings() {
      var _a3, _b2, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("monthly") && ((_b2 = (_a3 = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a3.settings) == null ? void 0 : _b2.monthly) || {};
        return {
          format: settings.format || DEFAULT_MONTHLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom monthly note settings found!", err);
      }
    }
    function getQuarterlyNoteSettings() {
      var _a3, _b2, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("quarterly") && ((_b2 = (_a3 = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a3.settings) == null ? void 0 : _b2.quarterly) || {};
        return {
          format: settings.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom quarterly note settings found!", err);
      }
    }
    function getYearlyNoteSettings() {
      var _a3, _b2, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("yearly") && ((_b2 = (_a3 = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a3.settings) == null ? void 0 : _b2.yearly) || {};
        return {
          format: settings.format || DEFAULT_YEARLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom yearly note settings found!", err);
      }
    }
    function join2(...partSegments) {
      let parts = [];
      for (let i3 = 0, l2 = partSegments.length; i3 < l2; i3++) {
        parts = parts.concat(partSegments[i3].split("/"));
      }
      const newParts = [];
      for (let i3 = 0, l2 = parts.length; i3 < l2; i3++) {
        const part = parts[i3];
        if (!part || part === ".")
          continue;
        else
          newParts.push(part);
      }
      if (parts[0] === "")
        newParts.unshift("");
      return newParts.join("/");
    }
    function basename(fullPath) {
      let base3 = fullPath.substring(fullPath.lastIndexOf("/") + 1);
      if (base3.lastIndexOf(".") != -1)
        base3 = base3.substring(0, base3.lastIndexOf("."));
      return base3;
    }
    async function ensureFolderExists2(path) {
      const dirs = path.replace(/\\/g, "/").split("/");
      dirs.pop();
      if (dirs.length) {
        const dir = join2(...dirs);
        if (!window.app.vault.getAbstractFileByPath(dir)) {
          await window.app.vault.createFolder(dir);
        }
      }
    }
    async function getNotePath2(directory, filename) {
      if (!filename.endsWith(".md")) {
        filename += ".md";
      }
      const path = obsidian2.normalizePath(join2(directory, filename));
      await ensureFolderExists2(path);
      return path;
    }
    async function getTemplateInfo(template) {
      const { metadataCache, vault } = window.app;
      const templatePath = obsidian2.normalizePath(template);
      if (templatePath === "/") {
        return Promise.resolve(["", null]);
      }
      try {
        const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
        const contents = await vault.cachedRead(templateFile);
        const IFoldInfo = window.app.foldManager.load(templateFile);
        return [contents, IFoldInfo];
      } catch (err) {
        console.error(`Failed to read the daily note template '${templatePath}'`, err);
        new obsidian2.Notice("Failed to read the daily note template");
        return ["", null];
      }
    }
    function getDateUID(date, granularity = "day") {
      const ts = date.clone().startOf(granularity).format();
      return `${granularity}-${ts}`;
    }
    function removeEscapedCharacters(format2) {
      return format2.replace(/\[[^\]]*\]/g, "");
    }
    function isFormatAmbiguous(format2, granularity) {
      if (granularity === "week") {
        const cleanFormat = removeEscapedCharacters(format2);
        return /w{1,2}/i.test(cleanFormat) && (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat));
      }
      return false;
    }
    function getDateFromFile(file, granularity) {
      return getDateFromFilename(file.basename, granularity);
    }
    function getDateFromPath(path, granularity) {
      return getDateFromFilename(basename(path), granularity);
    }
    function getDateFromFilename(filename, granularity) {
      const getSettings = {
        day: getDailyNoteSettings3,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      };
      const format2 = getSettings[granularity]().format.split("/").pop();
      const noteDate = window.moment(filename, format2, true);
      if (!noteDate.isValid()) {
        return null;
      }
      if (isFormatAmbiguous(format2, granularity)) {
        if (granularity === "week") {
          const cleanFormat = removeEscapedCharacters(format2);
          if (/w{1,2}/i.test(cleanFormat)) {
            return window.moment(filename, format2.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""), false);
          }
        }
      }
      return noteDate;
    }
    var DailyNotesFolderMissingError = class extends Error {
    };
    async function createDailyNote(date) {
      const app2 = window.app;
      const { vault } = app2;
      const moment9 = window.moment;
      const { template, format: format2, folder } = getDailyNoteSettings3();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath2(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, moment9().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = moment9();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format2)).replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format2)));
        app2.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian2.Notice("Unable to create new file.");
      }
    }
    function getDailyNote2(date, dailyNotes) {
      var _a3;
      return (_a3 = dailyNotes[getDateUID(date, "day")]) != null ? _a3 : null;
    }
    function getAllDailyNotes2() {
      const { vault } = window.app;
      const { folder } = getDailyNoteSettings3();
      const dailyNotesFolder = vault.getAbstractFileByPath(obsidian2.normalizePath(folder));
      if (!dailyNotesFolder) {
        throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
      }
      const dailyNotes = {};
      obsidian2.Vault.recurseChildren(dailyNotesFolder, (note) => {
        if (note instanceof obsidian2.TFile) {
          const date = getDateFromFile(note, "day");
          if (date) {
            const dateString = getDateUID(date, "day");
            dailyNotes[dateString] = note;
          }
        }
      });
      return dailyNotes;
    }
    var WeeklyNotesFolderMissingError = class extends Error {
    };
    function getDaysOfWeek() {
      const { moment: moment9 } = window;
      let weekStart = moment9.localeData()._week.dow;
      const daysOfWeek = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
      ];
      while (weekStart) {
        daysOfWeek.push(daysOfWeek.shift());
        weekStart--;
      }
      return daysOfWeek;
    }
    function getDayOfWeekNumericalValue(dayOfWeekName) {
      return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
    }
    async function createWeeklyNote(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getWeeklyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath2(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_, dayOfWeek, momentFormat) => {
          const day = getDayOfWeekNumericalValue(dayOfWeek);
          return date.weekday(day).format(momentFormat.trim());
        }));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian2.Notice("Unable to create new file.");
      }
    }
    function getWeeklyNote(date, weeklyNotes) {
      var _a3;
      return (_a3 = weeklyNotes[getDateUID(date, "week")]) != null ? _a3 : null;
    }
    function getAllWeeklyNotes() {
      const weeklyNotes = {};
      if (!appHasWeeklyNotesPluginLoaded()) {
        return weeklyNotes;
      }
      const { vault } = window.app;
      const { folder } = getWeeklyNoteSettings();
      const weeklyNotesFolder = vault.getAbstractFileByPath(obsidian2.normalizePath(folder));
      if (!weeklyNotesFolder) {
        throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
      }
      obsidian2.Vault.recurseChildren(weeklyNotesFolder, (note) => {
        if (note instanceof obsidian2.TFile) {
          const date = getDateFromFile(note, "week");
          if (date) {
            const dateString = getDateUID(date, "week");
            weeklyNotes[dateString] = note;
          }
        }
      });
      return weeklyNotes;
    }
    var MonthlyNotesFolderMissingError = class extends Error {
    };
    async function createMonthlyNote(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getMonthlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath2(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian2.Notice("Unable to create new file.");
      }
    }
    function getMonthlyNote(date, monthlyNotes) {
      var _a3;
      return (_a3 = monthlyNotes[getDateUID(date, "month")]) != null ? _a3 : null;
    }
    function getAllMonthlyNotes() {
      const monthlyNotes = {};
      if (!appHasMonthlyNotesPluginLoaded()) {
        return monthlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getMonthlyNoteSettings();
      const monthlyNotesFolder = vault.getAbstractFileByPath(obsidian2.normalizePath(folder));
      if (!monthlyNotesFolder) {
        throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
      }
      obsidian2.Vault.recurseChildren(monthlyNotesFolder, (note) => {
        if (note instanceof obsidian2.TFile) {
          const date = getDateFromFile(note, "month");
          if (date) {
            const dateString = getDateUID(date, "month");
            monthlyNotes[dateString] = note;
          }
        }
      });
      return monthlyNotes;
    }
    var QuarterlyNotesFolderMissingError = class extends Error {
    };
    async function createQuarterlyNote(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getQuarterlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath2(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian2.Notice("Unable to create new file.");
      }
    }
    function getQuarterlyNote(date, quarterly) {
      var _a3;
      return (_a3 = quarterly[getDateUID(date, "quarter")]) != null ? _a3 : null;
    }
    function getAllQuarterlyNotes() {
      const quarterly = {};
      if (!appHasQuarterlyNotesPluginLoaded()) {
        return quarterly;
      }
      const { vault } = window.app;
      const { folder } = getQuarterlyNoteSettings();
      const quarterlyFolder = vault.getAbstractFileByPath(obsidian2.normalizePath(folder));
      if (!quarterlyFolder) {
        throw new QuarterlyNotesFolderMissingError("Failed to find quarterly notes folder");
      }
      obsidian2.Vault.recurseChildren(quarterlyFolder, (note) => {
        if (note instanceof obsidian2.TFile) {
          const date = getDateFromFile(note, "quarter");
          if (date) {
            const dateString = getDateUID(date, "quarter");
            quarterly[dateString] = note;
          }
        }
      });
      return quarterly;
    }
    var YearlyNotesFolderMissingError = class extends Error {
    };
    async function createYearlyNote(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getYearlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath2(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian2.Notice("Unable to create new file.");
      }
    }
    function getYearlyNote(date, yearlyNotes) {
      var _a3;
      return (_a3 = yearlyNotes[getDateUID(date, "year")]) != null ? _a3 : null;
    }
    function getAllYearlyNotes() {
      const yearlyNotes = {};
      if (!appHasYearlyNotesPluginLoaded()) {
        return yearlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getYearlyNoteSettings();
      const yearlyNotesFolder = vault.getAbstractFileByPath(obsidian2.normalizePath(folder));
      if (!yearlyNotesFolder) {
        throw new YearlyNotesFolderMissingError("Failed to find yearly notes folder");
      }
      obsidian2.Vault.recurseChildren(yearlyNotesFolder, (note) => {
        if (note instanceof obsidian2.TFile) {
          const date = getDateFromFile(note, "year");
          if (date) {
            const dateString = getDateUID(date, "year");
            yearlyNotes[dateString] = note;
          }
        }
      });
      return yearlyNotes;
    }
    function appHasDailyNotesPluginLoaded() {
      var _a3, _b2;
      const { app: app2 } = window;
      const dailyNotesPlugin = app2.internalPlugins.plugins["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        return true;
      }
      const periodicNotes = app2.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b2 = (_a3 = periodicNotes.settings) == null ? void 0 : _a3.daily) == null ? void 0 : _b2.enabled);
    }
    function appHasWeeklyNotesPluginLoaded() {
      var _a3, _b2;
      const { app: app2 } = window;
      if (app2.plugins.getPlugin("calendar")) {
        return true;
      }
      const periodicNotes = app2.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b2 = (_a3 = periodicNotes.settings) == null ? void 0 : _a3.weekly) == null ? void 0 : _b2.enabled);
    }
    function appHasMonthlyNotesPluginLoaded() {
      var _a3, _b2;
      const { app: app2 } = window;
      const periodicNotes = app2.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b2 = (_a3 = periodicNotes.settings) == null ? void 0 : _a3.monthly) == null ? void 0 : _b2.enabled);
    }
    function appHasQuarterlyNotesPluginLoaded() {
      var _a3, _b2;
      const { app: app2 } = window;
      const periodicNotes = app2.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b2 = (_a3 = periodicNotes.settings) == null ? void 0 : _a3.quarterly) == null ? void 0 : _b2.enabled);
    }
    function appHasYearlyNotesPluginLoaded() {
      var _a3, _b2;
      const { app: app2 } = window;
      const periodicNotes = app2.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b2 = (_a3 = periodicNotes.settings) == null ? void 0 : _a3.yearly) == null ? void 0 : _b2.enabled);
    }
    function getPeriodicNoteSettings(granularity) {
      const getSettings = {
        day: getDailyNoteSettings3,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      }[granularity];
      return getSettings();
    }
    function createPeriodicNote(granularity, date) {
      const createFn = {
        day: createDailyNote,
        month: createMonthlyNote,
        week: createWeeklyNote
      };
      return createFn[granularity](date);
    }
    exports2.DEFAULT_DAILY_NOTE_FORMAT = DEFAULT_DAILY_NOTE_FORMAT;
    exports2.DEFAULT_MONTHLY_NOTE_FORMAT = DEFAULT_MONTHLY_NOTE_FORMAT;
    exports2.DEFAULT_QUARTERLY_NOTE_FORMAT = DEFAULT_QUARTERLY_NOTE_FORMAT;
    exports2.DEFAULT_WEEKLY_NOTE_FORMAT = DEFAULT_WEEKLY_NOTE_FORMAT;
    exports2.DEFAULT_YEARLY_NOTE_FORMAT = DEFAULT_YEARLY_NOTE_FORMAT;
    exports2.appHasDailyNotesPluginLoaded = appHasDailyNotesPluginLoaded;
    exports2.appHasMonthlyNotesPluginLoaded = appHasMonthlyNotesPluginLoaded;
    exports2.appHasQuarterlyNotesPluginLoaded = appHasQuarterlyNotesPluginLoaded;
    exports2.appHasWeeklyNotesPluginLoaded = appHasWeeklyNotesPluginLoaded;
    exports2.appHasYearlyNotesPluginLoaded = appHasYearlyNotesPluginLoaded;
    exports2.createDailyNote = createDailyNote;
    exports2.createMonthlyNote = createMonthlyNote;
    exports2.createPeriodicNote = createPeriodicNote;
    exports2.createQuarterlyNote = createQuarterlyNote;
    exports2.createWeeklyNote = createWeeklyNote;
    exports2.createYearlyNote = createYearlyNote;
    exports2.getAllDailyNotes = getAllDailyNotes2;
    exports2.getAllMonthlyNotes = getAllMonthlyNotes;
    exports2.getAllQuarterlyNotes = getAllQuarterlyNotes;
    exports2.getAllWeeklyNotes = getAllWeeklyNotes;
    exports2.getAllYearlyNotes = getAllYearlyNotes;
    exports2.getDailyNote = getDailyNote2;
    exports2.getDailyNoteSettings = getDailyNoteSettings3;
    exports2.getDateFromFile = getDateFromFile;
    exports2.getDateFromPath = getDateFromPath;
    exports2.getDateUID = getDateUID;
    exports2.getMonthlyNote = getMonthlyNote;
    exports2.getMonthlyNoteSettings = getMonthlyNoteSettings;
    exports2.getPeriodicNoteSettings = getPeriodicNoteSettings;
    exports2.getQuarterlyNote = getQuarterlyNote;
    exports2.getQuarterlyNoteSettings = getQuarterlyNoteSettings;
    exports2.getTemplateInfo = getTemplateInfo;
    exports2.getWeeklyNote = getWeeklyNote;
    exports2.getWeeklyNoteSettings = getWeeklyNoteSettings;
    exports2.getYearlyNote = getYearlyNote;
    exports2.getYearlyNoteSettings = getYearlyNoteSettings;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const min = Math.min(r, g, b2);
      const max = Math.max(r, g, b2);
      const delta = max - min;
      let h6;
      let s4;
      if (max === min) {
        h6 = 0;
      } else if (r === max) {
        h6 = (g - b2) / delta;
      } else if (g === max) {
        h6 = 2 + (b2 - r) / delta;
      } else if (b2 === max) {
        h6 = 4 + (r - g) / delta;
      }
      h6 = Math.min(h6 * 60, 360);
      if (h6 < 0) {
        h6 += 360;
      }
      const l2 = (min + max) / 2;
      if (max === min) {
        s4 = 0;
      } else if (l2 <= 0.5) {
        s4 = delta / (max + min);
      } else {
        s4 = delta / (2 - max - min);
      }
      return [h6, s4 * 100, l2 * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h6;
      let s4;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const v = Math.max(r, g, b2);
      const diff = v - Math.min(r, g, b2);
      const diffc = function(c6) {
        return (v - c6) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h6 = 0;
        s4 = 0;
      } else {
        s4 = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b2);
        if (r === v) {
          h6 = bdif - gdif;
        } else if (g === v) {
          h6 = 1 / 3 + rdif - bdif;
        } else if (b2 === v) {
          h6 = 2 / 3 + gdif - rdif;
        }
        if (h6 < 0) {
          h6 += 1;
        } else if (h6 > 1) {
          h6 -= 1;
        }
      }
      return [
        h6 * 360,
        s4 * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b2 = rgb[2];
      const h6 = convert.rgb.hsl(rgb)[0];
      const w3 = 1 / 255 * Math.min(r, Math.min(g, b2));
      b2 = 1 - 1 / 255 * Math.max(r, Math.max(g, b2));
      return [h6, w3 * 100, b2 * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const k2 = Math.min(1 - r, 1 - g, 1 - b2);
      const c6 = (1 - r - k2) / (1 - k2) || 0;
      const m3 = (1 - g - k2) / (1 - k2) || 0;
      const y3 = (1 - b2 - k2) / (1 - k2) || 0;
      return [c6 * 100, m3 * 100, y3 * 100, k2 * 100];
    };
    function comparativeDistance(x2, y3) {
      return (x2[0] - y3[0]) ** 2 + (x2[1] - y3[1]) ** 2 + (x2[2] - y3[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b2 = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
      const x2 = r * 0.4124 + g * 0.3576 + b2 * 0.1805;
      const y3 = r * 0.2126 + g * 0.7152 + b2 * 0.0722;
      const z2 = r * 0.0193 + g * 0.1192 + b2 * 0.9505;
      return [x2 * 100, y3 * 100, z2 * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x2 = xyz[0];
      let y3 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y3 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l2 = 116 * y3 - 16;
      const a4 = 500 * (x2 - y3);
      const b2 = 200 * (y3 - z2);
      return [l2, a4, b2];
    };
    convert.hsl.rgb = function(hsl) {
      const h6 = hsl[0] / 360;
      const s4 = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      let t22;
      let t3;
      let val;
      if (s4 === 0) {
        val = l2 * 255;
        return [val, val, val];
      }
      if (l2 < 0.5) {
        t22 = l2 * (1 + s4);
      } else {
        t22 = l2 + s4 - l2 * s4;
      }
      const t1 = 2 * l2 - t22;
      const rgb = [0, 0, 0];
      for (let i3 = 0; i3 < 3; i3++) {
        t3 = h6 + 1 / 3 * -(i3 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t22 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t22;
        } else if (3 * t3 < 2) {
          val = t1 + (t22 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i3] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h6 = hsl[0];
      let s4 = hsl[1] / 100;
      let l2 = hsl[2] / 100;
      let smin = s4;
      const lmin = Math.max(l2, 0.01);
      l2 *= 2;
      s4 *= l2 <= 1 ? l2 : 2 - l2;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l2 + s4) / 2;
      const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s4 / (l2 + s4);
      return [h6, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h6 = hsv[0] / 60;
      const s4 = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h6) % 6;
      const f = h6 - Math.floor(h6);
      const p2 = 255 * v * (1 - s4);
      const q2 = 255 * v * (1 - s4 * f);
      const t3 = 255 * v * (1 - s4 * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t3, p2];
        case 1:
          return [q2, v, p2];
        case 2:
          return [p2, v, t3];
        case 3:
          return [p2, q2, v];
        case 4:
          return [t3, p2, v];
        case 5:
          return [v, p2, q2];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h6 = hsv[0];
      const s4 = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l2;
      l2 = (2 - s4) * v;
      const lmin = (2 - s4) * vmin;
      sl = s4 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l2 /= 2;
      return [h6, sl * 100, l2 * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h6 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i3 = Math.floor(6 * h6);
      const v = 1 - bl;
      f = 6 * h6 - i3;
      if ((i3 & 1) !== 0) {
        f = 1 - f;
      }
      const n2 = wh + f * (v - wh);
      let r;
      let g;
      let b2;
      switch (i3) {
        default:
        case 6:
        case 0:
          r = v;
          g = n2;
          b2 = wh;
          break;
        case 1:
          r = n2;
          g = v;
          b2 = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b2 = n2;
          break;
        case 3:
          r = wh;
          g = n2;
          b2 = v;
          break;
        case 4:
          r = n2;
          g = wh;
          b2 = v;
          break;
        case 5:
          r = v;
          g = wh;
          b2 = n2;
          break;
      }
      return [r * 255, g * 255, b2 * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c6 = cmyk[0] / 100;
      const m3 = cmyk[1] / 100;
      const y3 = cmyk[2] / 100;
      const k2 = cmyk[3] / 100;
      const r = 1 - Math.min(1, c6 * (1 - k2) + k2);
      const g = 1 - Math.min(1, m3 * (1 - k2) + k2);
      const b2 = 1 - Math.min(1, y3 * (1 - k2) + k2);
      return [r * 255, g * 255, b2 * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x2 = xyz[0] / 100;
      const y3 = xyz[1] / 100;
      const z2 = xyz[2] / 100;
      let r;
      let g;
      let b2;
      r = x2 * 3.2406 + y3 * -1.5372 + z2 * -0.4986;
      g = x2 * -0.9689 + y3 * 1.8758 + z2 * 0.0415;
      b2 = x2 * 0.0557 + y3 * -0.204 + z2 * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b2 = Math.min(Math.max(0, b2), 1);
      return [r * 255, g * 255, b2 * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x2 = xyz[0];
      let y3 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y3 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l2 = 116 * y3 - 16;
      const a4 = 500 * (x2 - y3);
      const b2 = 200 * (y3 - z2);
      return [l2, a4, b2];
    };
    convert.lab.xyz = function(lab) {
      const l2 = lab[0];
      const a4 = lab[1];
      const b2 = lab[2];
      let x2;
      let y3;
      let z2;
      y3 = (l2 + 16) / 116;
      x2 = a4 / 500 + y3;
      z2 = y3 - b2 / 200;
      const y22 = y3 ** 3;
      const x22 = x2 ** 3;
      const z22 = z2 ** 3;
      y3 = y22 > 8856e-6 ? y22 : (y3 - 16 / 116) / 7.787;
      x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
      z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
      x2 *= 95.047;
      y3 *= 100;
      z2 *= 108.883;
      return [x2, y3, z2];
    };
    convert.lab.lch = function(lab) {
      const l2 = lab[0];
      const a4 = lab[1];
      const b2 = lab[2];
      let h6;
      const hr = Math.atan2(b2, a4);
      h6 = hr * 360 / 2 / Math.PI;
      if (h6 < 0) {
        h6 += 360;
      }
      const c6 = Math.sqrt(a4 * a4 + b2 * b2);
      return [l2, c6, h6];
    };
    convert.lch.lab = function(lch) {
      const l2 = lch[0];
      const c6 = lch[1];
      const h6 = lch[2];
      const hr = h6 / 360 * 2 * Math.PI;
      const a4 = c6 * Math.cos(hr);
      const b2 = c6 * Math.sin(hr);
      return [l2, a4, b2];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b2] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b2 = args[2];
      if (r === g && g === b2) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b2 / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color2 = args % 10;
      if (color2 === 0 || color2 === 7) {
        if (args > 50) {
          color2 += 3.5;
        }
        color2 = color2 / 10.5 * 255;
        return [color2, color2, color2];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color2 & 1) * mult * 255;
      const g = (color2 >> 1 & 1) * mult * 255;
      const b2 = (color2 >> 2 & 1) * mult * 255;
      return [r, g, b2];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c6 = (args - 232) * 10 + 8;
        return [c6, c6, c6];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b2 = rem % 6 / 5 * 255;
      return [r, g, b2];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match3 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match3) {
        return [0, 0, 0];
      }
      let colorString = match3[0];
      if (match3[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b2 = integer & 255;
      return [r, g, b2];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b2);
      const min = Math.min(Math.min(r, g), b2);
      const chroma = max - min;
      let grayscale;
      let hue2;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue2 = 0;
      } else if (max === r) {
        hue2 = (g - b2) / chroma % 6;
      } else if (max === g) {
        hue2 = 2 + (b2 - r) / chroma;
      } else {
        hue2 = 4 + (r - g) / chroma;
      }
      hue2 /= 6;
      hue2 %= 1;
      return [hue2 * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s4 = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      const c6 = l2 < 0.5 ? 2 * s4 * l2 : 2 * s4 * (1 - l2);
      let f = 0;
      if (c6 < 1) {
        f = (l2 - 0.5 * c6) / (1 - c6);
      }
      return [hsl[0], c6 * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s4 = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c6 = s4 * v;
      let f = 0;
      if (c6 < 1) {
        f = (v - c6) / (1 - c6);
      }
      return [hsv[0], c6 * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h6 = hcg[0] / 360;
      const c6 = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c6 === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h6 % 1 * 6;
      const v = hi % 1;
      const w3 = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w3;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w3;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w3;
      }
      mg = (1 - c6) * g;
      return [
        (c6 * pure[0] + mg) * 255,
        (c6 * pure[1] + mg) * 255,
        (c6 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c6 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c6 + g * (1 - c6);
      let f = 0;
      if (v > 0) {
        f = c6 / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c6 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l2 = g * (1 - c6) + 0.5 * c6;
      let s4 = 0;
      if (l2 > 0 && l2 < 0.5) {
        s4 = c6 / (2 * l2);
      } else if (l2 >= 0.5 && l2 < 1) {
        s4 = c6 / (2 * (1 - l2));
      }
      return [hcg[0], s4 * 100, l2 * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c6 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c6 + g * (1 - c6);
      return [hcg[0], (v - c6) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w3 = hwb[1] / 100;
      const b2 = hwb[2] / 100;
      const v = 1 - b2;
      const c6 = v - w3;
      let g = 0;
      if (c6 < 1) {
        g = (v - c6) / (1 - c6);
      }
      return [hwb[0], c6 * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i3 = 0; i3 < len; i3++) {
        graph[models[i3]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue2 = [fromModel];
      graph[fromModel].distance = 0;
      while (queue2.length) {
        const current = queue2.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i3 = 0; i3 < len; i3++) {
          const adjacent = adjacents[i3];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue2.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from2, to2) {
      return function(args) {
        return to2(from2(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i3 = 0; i3 < len; i3++) {
        const toModel = models[i3];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i3 = 0; i3 < len; i3++) {
            result[i3] = Math.round(result[i3]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n2) => n2;
    var rgb2rgb = (r, g, b2) => [r, g, b2];
    var setLazyProperty = (object, property2, get3) => {
      Object.defineProperty(object, property2, {
        get: () => {
          const value = get3();
          Object.defineProperty(object, property2, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity2, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name2] = wrap(identity2, offset);
        } else if (typeof suite === "object") {
          styles[name2] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style2] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style2[0]}m`,
            close: `\x1B[${style2[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style2[0], style2[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/supports-color/browser.js
var require_browser = __commonJS({
  "node_modules/supports-color/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer2) => {
      let index2 = string.indexOf(substring);
      if (index2 === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index2 - endIndex) + substring + replacer2;
        endIndex = index2 + substringLength;
        index2 = string.indexOf(substring, endIndex);
      } while (index2 !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix3, postfix, index2) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index2 - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index2 - 1 : index2) - endIndex) + prefix3 + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index2 + 1;
        index2 = string.indexOf("\n", endIndex);
      } while (index2 !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c6) {
      const u2 = c6[0] === "u";
      const bracket = c6[1] === "{";
      if (u2 && !bracket && c6.length === 5 || c6[0] === "x" && c6.length === 3) {
        return String.fromCharCode(parseInt(c6.slice(1), 16));
      }
      if (u2 && bracket) {
        return String.fromCodePoint(parseInt(c6.slice(2, -1), 16));
      }
      return ESCAPES.get(c6) || c6;
    }
    function parseArguments(name2, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m3, escape, character) => escape ? unescape2(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
        }
      }
      return results;
    }
    function parseStyle(style2) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style2)) !== null) {
        const name2 = matches[1];
        if (matches[2]) {
          const args = parseArguments(name2, matches[2]);
          results.push([name2].concat(args));
        } else {
          results.push([name2]);
        }
      }
      return results;
    }
    function buildStyle(chalk2, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style2 of layer.styles) {
          enabled[style2[0]] = layer.inverse ? null : style2.slice(1);
        }
      }
      let current = chalk2;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk2, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m3, escapeCharacter, inverse, style2, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style2) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk2, styles)(string));
          styles.push({ inverse, styles: parseStyle(style2) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk2, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_browser();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray: isArray6 } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions2 = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk3 = {};
      applyOptions2(chalk3, options);
      chalk3.template = (...arguments_) => chalkTag(chalk3.template, ...arguments_);
      Object.setPrototypeOf(chalk3, Chalk.prototype);
      Object.setPrototypeOf(chalk3.template, chalk3);
      chalk3.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk3.template.Instance = ChalkClass;
      return chalk3.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style2] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style2.open, style2.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self79, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray6(arguments_[0]) && isArray6(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self79;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self79, string) => {
      if (self79.level <= 0 || !string) {
        return self79._isEmpty ? "" : string;
      }
      let styler = self79._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk3, ...strings) => {
      const [firstString] = strings;
      if (!isArray6(firstString) || !isArray6(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i3 = 1; i3 < firstString.length; i3++) {
        parts.push(String(arguments_[i3 - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i3]));
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk3, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk2 = Chalk();
    chalk2.supportsColor = stdoutColor;
    chalk2.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk2.stderr.supportsColor = stderrColor;
    module2.exports = chalk2;
  }
});

// node_modules/rrule/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/rrule/node_modules/tslib/tslib.js"(exports2, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root2, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root2, createExporter(module2.exports)));
      } else {
        factory(createExporter(root2));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root2) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v) {
          return exports3[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
        d4.__proto__ = b2;
      } || function(d4, b2) {
        for (var p2 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p2))
            d4[p2] = b2[p2];
      };
      __extends2 = function(d4, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d4, b2);
        function __() {
          this.constructor = d4;
        }
        d4.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t3) {
        for (var s4, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s4 = arguments[i3];
          for (var p2 in s4)
            if (Object.prototype.hasOwnProperty.call(s4, p2))
              t3[p2] = s4[p2];
        }
        return t3;
      };
      __rest2 = function(s4, e3) {
        var t3 = {};
        for (var p2 in s4)
          if (Object.prototype.hasOwnProperty.call(s4, p2) && e3.indexOf(p2) < 0)
            t3[p2] = s4[p2];
        if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s4); i3 < p2.length; i3++) {
            if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p2[i3]))
              t3[p2[i3]] = s4[p2[i3]];
          }
        return t3;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c6 = arguments.length, r = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d4 = decorators[i3])
              r = (c6 < 3 ? d4(r) : c6 > 3 ? d4(target, key, r) : d4(target, key)) || r;
        return c6 > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f, y3, t3, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n2) {
          return function(v) {
            return step([n2, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _)
            try {
              if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
                return t3;
              if (y3 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t3 = _.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t3[1]) {
                    _.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _.label < t3[2]) {
                    _.label = t3[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e3) {
              op = [6, e3];
              y3 = 0;
            } finally {
              f = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m3, o2) {
        for (var p2 in m3)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
            __createBinding2(o2, m3, p2);
      };
      __createBinding2 = Object.create ? function(o2, m3, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m3, k2);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k2];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      } : function(o2, m3, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m3[k2];
      };
      __values2 = function(o2) {
        var s4 = typeof Symbol === "function" && Symbol.iterator, m3 = s4 && o2[s4], i3 = 0;
        if (m3)
          return m3.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i3 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i3++], done: !o2 };
            }
          };
        throw new TypeError(s4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o2, n2) {
        var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m3)
          return o2;
        var i3 = m3.call(o2), r, ar = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r = i3.next()).done)
            ar.push(r.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r && !r.done && (m3 = i3["return"]))
              m3.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i3 = 0; i3 < arguments.length; i3++)
          ar = ar.concat(__read2(arguments[i3]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s4 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s4 += arguments[i3].length;
        for (var r = Array(s4), k2 = 0, i3 = 0; i3 < il; i3++)
          for (var a4 = arguments[i3], j = 0, jl = a4.length; j < jl; j++, k2++)
            r[k2] = a4[j];
        return r;
      };
      __spreadArray2 = function(to2, from2, pack) {
        if (pack || arguments.length === 2)
          for (var i3 = 0, l2 = from2.length, ar; i3 < l2; i3++) {
            if (ar || !(i3 in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i3);
              ar[i3] = from2[i3];
            }
          }
        return to2.concat(ar || Array.prototype.slice.call(from2));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i3, q2 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g[n2])
            i3[n2] = function(v) {
              return new Promise(function(a4, b2) {
                q2.push([n2, v, a4, b2]) > 1 || resume(n2, v);
              });
            };
        }
        function resume(n2, v) {
          try {
            step(g[n2](v));
          } catch (e3) {
            settle2(q2[0][3], e3);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q2[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle2(f, v) {
          if (f(v), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator2 = function(o2) {
        var i3, p2;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f) {
          i3[n2] = o2[n2] ? function(v) {
            return (p2 = !p2) ? { value: __await2(o2[n2](v)), done: n2 === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o2[Symbol.asyncIterator], i3;
        return m3 ? m3.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o2[n2] && function(v) {
            return new Promise(function(resolve2, reject) {
              v = o2[n2](v), settle2(resolve2, reject, v.done, v.value);
            });
          };
        }
        function settle2(resolve2, reject, d4, v) {
          Promise.resolve(v).then(function(v2) {
            resolve2({ value: v2, done: d4 });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o2, v) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v });
      } : function(o2, v) {
        o2["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding2(result, mod, k2);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn2 = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});

// node_modules/party-js/lib/settings.js
var require_settings = __commonJS({
  "node_modules/party-js/lib/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.settings = void 0;
    exports2.settings = {
      debug: false,
      gravity: 800,
      zIndex: 99999,
      respectReducedMotion: true
    };
  }
});

// node_modules/party-js/lib/util/config.js
var require_config = __commonJS({
  "node_modules/party-js/lib/util/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.overrideDefaults = void 0;
    function overrideDefaults(defaults3, overrides2) {
      return Object.assign({}, defaults3, overrides2);
    }
    exports2.overrideDefaults = overrideDefaults;
  }
});

// node_modules/party-js/lib/components/circle.js
var require_circle = __commonJS({
  "node_modules/party-js/lib/components/circle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Circle = void 0;
    var Circle = function() {
      function Circle2(x2, y3, radius) {
        if (radius === void 0) {
          radius = 0;
        }
        this.x = x2;
        this.y = y3;
        this.radius = radius;
      }
      Circle2.zero = new Circle2(0, 0);
      return Circle2;
    }();
    exports2.Circle = Circle;
  }
});

// node_modules/party-js/lib/systems/math.js
var require_math = __commonJS({
  "node_modules/party-js/lib/systems/math.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.approximately = exports2.clamp = exports2.invlerp = exports2.slerp = exports2.lerp = exports2.epsilon = exports2.rad2deg = exports2.deg2rad = void 0;
    exports2.deg2rad = Math.PI / 180;
    exports2.rad2deg = 180 / Math.PI;
    exports2.epsilon = 1e-6;
    function lerp(a4, b2, t3) {
      return (1 - t3) * a4 + t3 * b2;
    }
    exports2.lerp = lerp;
    function slerp(a4, b2, t3) {
      return lerp(a4, b2, (1 - Math.cos(t3 * Math.PI)) / 2);
    }
    exports2.slerp = slerp;
    function invlerp(a4, b2, v) {
      return (v - a4) / (b2 - a4);
    }
    exports2.invlerp = invlerp;
    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }
    exports2.clamp = clamp;
    function approximately(a4, b2) {
      return Math.abs(a4 - b2) < exports2.epsilon;
    }
    exports2.approximately = approximately;
  }
});

// node_modules/party-js/lib/components/color.js
var require_color = __commonJS({
  "node_modules/party-js/lib/components/color.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Color = void 0;
    var math_1 = require_math();
    var Color2 = function() {
      function Color3(r, g, b2) {
        this.values = new Float32Array(3);
        this.rgb = [r, g, b2];
      }
      Object.defineProperty(Color3.prototype, "r", {
        get: function() {
          return this.values[0];
        },
        set: function(value) {
          this.values[0] = Math.floor(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Color3.prototype, "g", {
        get: function() {
          return this.values[1];
        },
        set: function(value) {
          this.values[1] = Math.floor(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Color3.prototype, "b", {
        get: function() {
          return this.values[2];
        },
        set: function(value) {
          this.values[2] = Math.floor(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Color3.prototype, "rgb", {
        get: function() {
          return [this.r, this.g, this.b];
        },
        set: function(values) {
          this.r = values[0];
          this.g = values[1];
          this.b = values[2];
        },
        enumerable: false,
        configurable: true
      });
      Color3.prototype.mix = function(color2, weight) {
        if (weight === void 0) {
          weight = 0.5;
        }
        return new Color3(math_1.lerp(this.r, color2.r, weight), math_1.lerp(this.g, color2.g, weight), math_1.lerp(this.b, color2.b, weight));
      };
      Color3.prototype.toHex = function() {
        var hex3 = function(v) {
          return v.toString(16).padStart(2, "0");
        };
        return "#" + hex3(this.r) + hex3(this.g) + hex3(this.b);
      };
      Color3.prototype.toString = function() {
        return "rgb(" + this.values.join(", ") + ")";
      };
      Color3.fromHex = function(hex3) {
        if (hex3.startsWith("#")) {
          hex3 = hex3.substr(1);
        }
        return new Color3(parseInt(hex3.substr(0, 2), 16), parseInt(hex3.substr(2, 2), 16), parseInt(hex3.substr(4, 2), 16));
      };
      Color3.fromHsl = function(h6, s4, l2) {
        h6 /= 360;
        s4 /= 100;
        l2 /= 100;
        if (s4 === 0) {
          return new Color3(l2, l2, l2);
        } else {
          var hue2rgb = function(p3, q3, t3) {
            if (t3 < 0)
              t3 += 1;
            if (t3 > 1)
              t3 -= 1;
            if (t3 < 1 / 6)
              return p3 + (q3 - p3) * 6 * t3;
            if (t3 < 1 / 2)
              return q3;
            if (t3 < 2 / 3)
              return p3 + (q3 - p3) * (2 / 3 - t3) * 6;
            return p3;
          };
          var to255 = function(v) {
            return Math.min(255, 256 * v);
          };
          var q2 = l2 < 0.5 ? l2 * (1 + s4) : l2 + s4 - l2 * s4;
          var p2 = 2 * l2 - q2;
          return new Color3(to255(hue2rgb(p2, q2, h6 + 1 / 3)), to255(hue2rgb(p2, q2, h6)), to255(hue2rgb(p2, q2, h6 - 1 / 3)));
        }
      };
      Color3.white = new Color3(255, 255, 255);
      Color3.black = new Color3(0, 0, 0);
      return Color3;
    }();
    exports2.Color = Color2;
  }
});

// node_modules/party-js/lib/components/spline.js
var require_spline = __commonJS({
  "node_modules/party-js/lib/components/spline.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Spline = void 0;
    var math_1 = require_math();
    var Spline = function() {
      function Spline2() {
        var keys2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys2[_i] = arguments[_i];
        }
        if (keys2.length === 0) {
          throw new Error("Splines require at least one key.");
        }
        if (Array.isArray(keys2[0])) {
          throw new Error("You are trying to pass an array to the spline constructor, which is not supported. Try to spread the array into the constructor instead.");
        }
        this.keys = keys2;
      }
      Spline2.prototype.evaluate = function(time2) {
        if (this.keys.length === 0) {
          throw new Error("Attempt to evaluate a spline with no keys.");
        }
        if (this.keys.length === 1) {
          return this.keys[0].value;
        }
        var ascendingKeys = this.keys.sort(function(a4, b2) {
          return a4.time - b2.time;
        });
        var upperKeyIndex = ascendingKeys.findIndex(function(g) {
          return g.time > time2;
        });
        if (upperKeyIndex === 0) {
          return ascendingKeys[0].value;
        }
        if (upperKeyIndex === -1) {
          return ascendingKeys[ascendingKeys.length - 1].value;
        }
        var lowerKey = ascendingKeys[upperKeyIndex - 1];
        var upperKey = ascendingKeys[upperKeyIndex];
        var containedTime = math_1.invlerp(lowerKey.time, upperKey.time, time2);
        return this.interpolate(lowerKey.value, upperKey.value, containedTime);
      };
      return Spline2;
    }();
    exports2.Spline = Spline;
  }
});

// node_modules/party-js/lib/components/gradient.js
var require_gradient = __commonJS({
  "node_modules/party-js/lib/components/gradient.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d4, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b3) {
          d5.__proto__ = b3;
        } || function(d5, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d5[p2] = b3[p2];
        };
        return extendStatics(d4, b2);
      };
      return function(d4, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d4, b2);
        function __() {
          this.constructor = d4;
        }
        d4.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to2, from2) {
      for (var i3 = 0, il = from2.length, j = to2.length; i3 < il; i3++, j++)
        to2[j] = from2[i3];
      return to2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Gradient = void 0;
    var spline_1 = require_spline();
    var Gradient = function(_super) {
      __extends2(Gradient2, _super);
      function Gradient2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Gradient2.prototype.interpolate = function(a4, b2, t3) {
        return a4.mix(b2, t3);
      };
      Gradient2.solid = function(color2) {
        return new Gradient2({ value: color2, time: 0.5 });
      };
      Gradient2.simple = function() {
        var colors2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          colors2[_i] = arguments[_i];
        }
        var step = 1 / (colors2.length - 1);
        return new (Gradient2.bind.apply(Gradient2, __spreadArray2([void 0], colors2.map(function(color2, index2) {
          return {
            value: color2,
            time: index2 * step
          };
        }))))();
      };
      return Gradient2;
    }(spline_1.Spline);
    exports2.Gradient = Gradient;
  }
});

// node_modules/party-js/lib/components/numericSpline.js
var require_numericSpline = __commonJS({
  "node_modules/party-js/lib/components/numericSpline.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d4, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b3) {
          d5.__proto__ = b3;
        } || function(d5, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d5[p2] = b3[p2];
        };
        return extendStatics(d4, b2);
      };
      return function(d4, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d4, b2);
        function __() {
          this.constructor = d4;
        }
        d4.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NumericSpline = void 0;
    var math_1 = require_math();
    var spline_1 = require_spline();
    var NumericSpline = function(_super) {
      __extends2(NumericSpline2, _super);
      function NumericSpline2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NumericSpline2.prototype.interpolate = function(a4, b2, t3) {
        return math_1.slerp(a4, b2, t3);
      };
      return NumericSpline2;
    }(spline_1.Spline);
    exports2.NumericSpline = NumericSpline;
  }
});

// node_modules/party-js/lib/components/rect.js
var require_rect = __commonJS({
  "node_modules/party-js/lib/components/rect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Rect = void 0;
    var Rect = function() {
      function Rect2(x2, y3, width, height) {
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        this.x = x2;
        this.y = y3;
        this.width = width;
        this.height = height;
      }
      Rect2.fromScreen = function() {
        return new Rect2(window.scrollX, window.scrollY, window.innerWidth, window.innerHeight);
      };
      Rect2.fromElement = function(element2) {
        var r = element2.getBoundingClientRect();
        return new Rect2(window.scrollX + r.x, window.scrollY + r.y, r.width, r.height);
      };
      Rect2.zero = new Rect2(0, 0);
      return Rect2;
    }();
    exports2.Rect = Rect;
  }
});

// node_modules/party-js/lib/components/vector.js
var require_vector = __commonJS({
  "node_modules/party-js/lib/components/vector.js"(exports2) {
    "use strict";
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to2, from2) {
      for (var i3 = 0, il = from2.length, j = to2.length; i3 < il; i3++, j++)
        to2[j] = from2[i3];
      return to2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Vector = void 0;
    var math_1 = require_math();
    var Vector = function() {
      function Vector2(x2, y3, z2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y3 === void 0) {
          y3 = 0;
        }
        if (z2 === void 0) {
          z2 = 0;
        }
        this.values = new Float32Array(3);
        this.xyz = [x2, y3, z2];
      }
      Object.defineProperty(Vector2.prototype, "x", {
        get: function() {
          return this.values[0];
        },
        set: function(value) {
          this.values[0] = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Vector2.prototype, "y", {
        get: function() {
          return this.values[1];
        },
        set: function(value) {
          this.values[1] = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Vector2.prototype, "z", {
        get: function() {
          return this.values[2];
        },
        set: function(value) {
          this.values[2] = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Vector2.prototype, "xyz", {
        get: function() {
          return [this.x, this.y, this.z];
        },
        set: function(values) {
          this.values[0] = values[0];
          this.values[1] = values[1];
          this.values[2] = values[2];
        },
        enumerable: false,
        configurable: true
      });
      Vector2.prototype.magnitude = function() {
        return Math.sqrt(this.sqrMagnitude());
      };
      Vector2.prototype.sqrMagnitude = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      };
      Vector2.prototype.add = function(vector) {
        return new Vector2(this.x + vector.x, this.y + vector.y, this.z + vector.z);
      };
      Vector2.prototype.subtract = function(vector) {
        return new Vector2(this.x - vector.x, this.y - vector.y, this.z - vector.z);
      };
      Vector2.prototype.scale = function(scalar) {
        if (typeof scalar === "number") {
          return new Vector2(this.x * scalar, this.y * scalar, this.z * scalar);
        } else {
          return new Vector2(this.x * scalar.x, this.y * scalar.y, this.z * scalar.z);
        }
      };
      Vector2.prototype.normalized = function() {
        var magnitude = this.magnitude();
        if (magnitude !== 0) {
          return this.scale(1 / magnitude);
        }
        return new (Vector2.bind.apply(Vector2, __spreadArray2([void 0], this.xyz)))();
      };
      Vector2.prototype.angle = function(vector) {
        return math_1.rad2deg * Math.acos((this.x * vector.x + this.y * vector.y + this.z * vector.z) / (this.magnitude() * vector.magnitude()));
      };
      Vector2.prototype.cross = function(vector) {
        return new Vector2(this.y * vector.z - this.z * vector.y, this.z * vector.x - this.x * vector.z, this.x * vector.y - this.y * vector.x);
      };
      Vector2.prototype.dot = function(vector) {
        return this.magnitude() * vector.magnitude() * Math.cos(math_1.deg2rad * this.angle(vector));
      };
      Vector2.prototype.toString = function() {
        return "Vector(" + this.values.join(", ") + ")";
      };
      Vector2.from2dAngle = function(angle) {
        return new Vector2(Math.cos(angle * math_1.deg2rad), Math.sin(angle * math_1.deg2rad));
      };
      Vector2.zero = new Vector2(0, 0, 0);
      Vector2.one = new Vector2(1, 1, 1);
      Vector2.right = new Vector2(1, 0, 0);
      Vector2.up = new Vector2(0, 1, 0);
      Vector2.forward = new Vector2(0, 0, 1);
      return Vector2;
    }();
    exports2.Vector = Vector;
  }
});

// node_modules/party-js/lib/components/index.js
var require_components = __commonJS({
  "node_modules/party-js/lib/components/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k2];
      } });
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m3, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_circle(), exports2);
    __exportStar2(require_color(), exports2);
    __exportStar2(require_gradient(), exports2);
    __exportStar2(require_numericSpline(), exports2);
    __exportStar2(require_rect(), exports2);
    __exportStar2(require_vector(), exports2);
  }
});

// node_modules/party-js/lib/util/rotation.js
var require_rotation = __commonJS({
  "node_modules/party-js/lib/util/rotation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rotationToNormal = void 0;
    var components_1 = require_components();
    var math_1 = require_math();
    function rotationToNormal(rotation) {
      var alpha2 = rotation.x * math_1.deg2rad;
      var beta = rotation.y * math_1.deg2rad;
      var a4 = new components_1.Vector(Math.cos(beta), 0, Math.sin(beta));
      var b2 = new components_1.Vector(0, Math.cos(alpha2), Math.sin(alpha2));
      return a4.cross(b2);
    }
    exports2.rotationToNormal = rotationToNormal;
  }
});

// node_modules/party-js/lib/util/rules.js
var require_rules = __commonJS({
  "node_modules/party-js/lib/util/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.despawningRules = void 0;
    exports2.despawningRules = {
      lifetime: function(particle) {
        return particle.lifetime <= 0;
      },
      bounds: function(particle) {
        var height = document.documentElement.scrollHeight;
        return particle.location.y > height;
      }
    };
  }
});

// node_modules/party-js/lib/util/lazy.js
var require_lazy = __commonJS({
  "node_modules/party-js/lib/util/lazy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Lazy = void 0;
    var Lazy = function() {
      function Lazy2(factory, exists2) {
        if (exists2 === void 0) {
          exists2 = Lazy2.defaultExists;
        }
        this.factory = factory;
        this.exists = exists2;
      }
      Object.defineProperty(Lazy2.prototype, "current", {
        get: function() {
          if (!this.exists(this.value)) {
            this.value = this.factory();
          }
          return this.value;
        },
        enumerable: false,
        configurable: true
      });
      Lazy2.defaultExists = function(value) {
        return typeof value !== "undefined";
      };
      return Lazy2;
    }();
    exports2.Lazy = Lazy;
  }
});

// node_modules/party-js/lib/util/index.js
var require_util2 = __commonJS({
  "node_modules/party-js/lib/util/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k2];
      } });
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m3, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_config(), exports2);
    __exportStar2(require_rotation(), exports2);
    __exportStar2(require_rules(), exports2);
    __exportStar2(require_lazy(), exports2);
  }
});

// node_modules/party-js/lib/containers.js
var require_containers = __commonJS({
  "node_modules/party-js/lib/containers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.particleContainer = exports2.debugContainer = exports2.rootContainer = void 0;
    var settings_1 = require_settings();
    var util_1 = require_util2();
    var containerPrefix = "party-js-";
    function isContainerActive(container) {
      return container && container.isConnected;
    }
    function makeContainer(name2, styles, parent) {
      var container = document.createElement("div");
      container.id = containerPrefix + name2;
      Object.assign(container.style, styles);
      return parent.appendChild(container);
    }
    exports2.rootContainer = new util_1.Lazy(function() {
      return makeContainer("container", {
        position: "fixed",
        left: "0",
        top: "0",
        height: "100vh",
        width: "100vw",
        pointerEvents: "none",
        userSelect: "none",
        zIndex: settings_1.settings.zIndex.toString()
      }, document.body);
    }, isContainerActive);
    exports2.debugContainer = new util_1.Lazy(function() {
      return makeContainer("debug", {
        position: "absolute",
        top: "0",
        left: "0",
        margin: "0.5em",
        padding: "0.5em 1em",
        border: "2px solid rgb(0, 0, 0, 0.2)",
        background: "rgb(0, 0, 0, 0.1)",
        color: "#555",
        fontFamily: "monospace"
      }, exports2.rootContainer.current);
    }, isContainerActive);
    exports2.particleContainer = new util_1.Lazy(function() {
      return makeContainer("particles", {
        width: "100%",
        height: "100%",
        overflow: "hidden",
        perspective: "1200px"
      }, exports2.rootContainer.current);
    }, isContainerActive);
  }
});

// node_modules/party-js/lib/debug.js
var require_debug = __commonJS({
  "node_modules/party-js/lib/debug.js"(exports2) {
    "use strict";
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to2, from2) {
      for (var i3 = 0, il = from2.length, j = to2.length; i3 < il; i3++, j++)
        to2[j] = from2[i3];
      return to2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Debug = void 0;
    var containers_1 = require_containers();
    var settings_1 = require_settings();
    var Debug = function() {
      function Debug2(scene) {
        this.scene = scene;
        this.refreshRate = 8;
        this.refreshTimer = 1 / this.refreshRate;
      }
      Debug2.prototype.tick = function(delta) {
        var container = containers_1.debugContainer.current;
        var displayStyle = settings_1.settings.debug ? "block" : "none";
        if (container.style.display !== displayStyle) {
          container.style.display = displayStyle;
        }
        if (!settings_1.settings.debug) {
          return;
        }
        this.refreshTimer += delta;
        if (this.refreshTimer > 1 / this.refreshRate) {
          this.refreshTimer = 0;
          container.innerHTML = this.getDebugInformation(delta).join("<br>");
        }
      };
      Debug2.prototype.getDebugInformation = function(delta) {
        var emitters = this.scene.emitters.length;
        var particles2 = this.scene.emitters.reduce(function(acc, cur) {
          return acc + cur.particles.length;
        }, 0);
        var infos = [
          "<b>party.js Debug</b>",
          "--------------",
          "FPS: " + Math.round(1 / delta),
          "Emitters: " + emitters,
          "Particles: " + particles2
        ];
        var emitterInfos = this.scene.emitters.map(function(emitter) {
          return [
            "\u2B6F: " + (emitter["currentLoop"] + 1) + "/" + (emitter.options.loops >= 0 ? emitter.options.loops : "\u221E"),
            "\u03A3p: " + emitter.particles.length,
            !emitter.isExpired ? "\u03A3t: " + emitter["durationTimer"].toFixed(3) + "s" : "<i>expired</i>"
          ].join(", ");
        });
        infos.push.apply(infos, __spreadArray2(["--------------"], emitterInfos));
        return infos;
      };
      return Debug2;
    }();
    exports2.Debug = Debug;
  }
});

// node_modules/party-js/lib/systems/random.js
var require_random = __commonJS({
  "node_modules/party-js/lib/systems/random.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomInsideCircle = exports2.randomInsideRect = exports2.randomUnitVector = exports2.pick = exports2.randomRange = void 0;
    var components_1 = require_components();
    var math_1 = require_math();
    function randomRange(min, max) {
      if (min === void 0) {
        min = 0;
      }
      if (max === void 0) {
        max = 1;
      }
      return math_1.lerp(min, max, Math.random());
    }
    exports2.randomRange = randomRange;
    function pick(arr) {
      return arr.length === 0 ? void 0 : arr[Math.floor(Math.random() * arr.length)];
    }
    exports2.pick = pick;
    function randomUnitVector() {
      var theta = randomRange(0, 2 * Math.PI);
      var z2 = randomRange(-1, 1);
      return new components_1.Vector(Math.sqrt(1 - z2 * z2) * Math.cos(theta), Math.sqrt(1 - z2 * z2) * Math.sin(theta), z2);
    }
    exports2.randomUnitVector = randomUnitVector;
    function randomInsideRect(rect) {
      return new components_1.Vector(rect.x + randomRange(0, rect.width), rect.y + randomRange(0, rect.height));
    }
    exports2.randomInsideRect = randomInsideRect;
    function randomInsideCircle(circle) {
      var theta = randomRange(0, 2 * Math.PI);
      var radius = randomRange(0, circle.radius);
      return new components_1.Vector(circle.x + Math.cos(theta) * radius, circle.y + Math.sin(theta) * radius);
    }
    exports2.randomInsideCircle = randomInsideCircle;
  }
});

// node_modules/party-js/lib/systems/variation.js
var require_variation = __commonJS({
  "node_modules/party-js/lib/systems/variation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.gradientSample = exports2.splineSample = exports2.skewRelative = exports2.skew = exports2.range = exports2.evaluateVariation = void 0;
    var random_1 = require_random();
    function evaluateVariation(variation) {
      if (Array.isArray(variation))
        return random_1.pick(variation);
      if (typeof variation === "function")
        return variation();
      return variation;
    }
    exports2.evaluateVariation = evaluateVariation;
    function range2(min, max) {
      return function() {
        return random_1.randomRange(min, max);
      };
    }
    exports2.range = range2;
    function skew(value, amount) {
      return function() {
        return value + random_1.randomRange(-amount, amount);
      };
    }
    exports2.skew = skew;
    function skewRelative(value, percentage) {
      return function() {
        return value * (1 + random_1.randomRange(-percentage, percentage));
      };
    }
    exports2.skewRelative = skewRelative;
    function splineSample(spline) {
      return function() {
        return spline.evaluate(Math.random());
      };
    }
    exports2.splineSample = splineSample;
    function gradientSample(gradient) {
      return splineSample(gradient);
    }
    exports2.gradientSample = gradientSample;
  }
});

// node_modules/party-js/lib/particles/options/emitterOptions.js
var require_emitterOptions = __commonJS({
  "node_modules/party-js/lib/particles/options/emitterOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultEmitterOptions = void 0;
    var rules_1 = require_rules();
    function getDefaultEmitterOptions() {
      return {
        duration: 5,
        loops: 1,
        useGravity: true,
        maxParticles: 300,
        despawningRules: [rules_1.despawningRules.lifetime, rules_1.despawningRules.bounds],
        modules: []
      };
    }
    exports2.getDefaultEmitterOptions = getDefaultEmitterOptions;
  }
});

// node_modules/party-js/lib/systems/sources.js
var require_sources = __commonJS({
  "node_modules/party-js/lib/systems/sources.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.circleSource = exports2.rectSource = exports2.mouseSource = exports2.elementSource = exports2.dynamicSource = void 0;
    var components_1 = require_components();
    var random_1 = require_random();
    function dynamicSource(source) {
      if (source instanceof HTMLElement) {
        return elementSource(source);
      }
      if (source instanceof components_1.Circle) {
        return circleSource(source);
      }
      if (source instanceof components_1.Rect) {
        return rectSource(source);
      }
      if (source instanceof MouseEvent) {
        return mouseSource(source);
      }
      throw new Error("Cannot infer the source type of '" + source + "'.");
    }
    exports2.dynamicSource = dynamicSource;
    function elementSource(source) {
      return function() {
        return random_1.randomInsideRect(components_1.Rect.fromElement(source));
      };
    }
    exports2.elementSource = elementSource;
    function mouseSource(source) {
      return function() {
        return new components_1.Vector(window.scrollX + source.clientX, window.scrollY + source.clientY);
      };
    }
    exports2.mouseSource = mouseSource;
    function rectSource(source) {
      return function() {
        return random_1.randomInsideRect(source);
      };
    }
    exports2.rectSource = rectSource;
    function circleSource(source) {
      return function() {
        return random_1.randomInsideCircle(source);
      };
    }
    exports2.circleSource = circleSource;
  }
});

// node_modules/party-js/lib/particles/options/emissionOptions.js
var require_emissionOptions = __commonJS({
  "node_modules/party-js/lib/particles/options/emissionOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultEmissionOptions = void 0;
    var components_1 = require_components();
    var sources_1 = require_sources();
    function getDefaultEmissionOptions() {
      return {
        rate: 10,
        angle: 0,
        bursts: [],
        sourceSampler: sources_1.rectSource(components_1.Rect.zero),
        initialLifetime: 5,
        initialSpeed: 5,
        initialSize: 1,
        initialRotation: components_1.Vector.zero,
        initialColor: components_1.Color.white
      };
    }
    exports2.getDefaultEmissionOptions = getDefaultEmissionOptions;
  }
});

// node_modules/party-js/lib/particles/options/renderOptions.js
var require_renderOptions = __commonJS({
  "node_modules/party-js/lib/particles/options/renderOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultRendererOptions = void 0;
    function getDefaultRendererOptions() {
      return {
        shapeFactory: "square",
        applyColor: defaultApplyColor,
        applyOpacity: defaultApplyOpacity,
        applyLighting: defaultApplyLighting,
        applyTransform: defaultApplyTransform
      };
    }
    exports2.getDefaultRendererOptions = getDefaultRendererOptions;
    function defaultApplyColor(color2, element2) {
      var hex3 = color2.toHex();
      switch (element2.nodeName.toLowerCase()) {
        case "div":
          element2.style.background = hex3;
          break;
        case "svg":
          element2.style.fill = element2.style.color = hex3;
          break;
        default:
          element2.style.color = hex3;
          break;
      }
    }
    function defaultApplyOpacity(opacity, element2) {
      element2.style.opacity = opacity.toString();
    }
    function defaultApplyLighting(lighting, element2) {
      element2.style.filter = "brightness(" + (0.5 + Math.abs(lighting)) + ")";
    }
    function defaultApplyTransform(particle, element2) {
      element2.style.transform = "translateX(" + (particle.location.x - window.scrollX).toFixed(3) + "px) " + ("translateY(" + (particle.location.y - window.scrollY).toFixed(3) + "px) ") + ("translateZ(" + particle.location.z.toFixed(3) + "px) ") + ("rotateX(" + particle.rotation.x.toFixed(3) + "deg) ") + ("rotateY(" + particle.rotation.y.toFixed(3) + "deg) ") + ("rotateZ(" + particle.rotation.z.toFixed(3) + "deg) ") + ("scale(" + particle.size.toFixed(3) + ")");
    }
  }
});

// node_modules/party-js/lib/particles/options/index.js
var require_options = __commonJS({
  "node_modules/party-js/lib/particles/options/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k2];
      } });
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m3, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_emitterOptions(), exports2);
    __exportStar2(require_emissionOptions(), exports2);
    __exportStar2(require_renderOptions(), exports2);
  }
});

// node_modules/party-js/lib/particles/particle.js
var require_particle = __commonJS({
  "node_modules/party-js/lib/particles/particle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Particle = void 0;
    var components_1 = require_components();
    var config_1 = require_config();
    var Particle = function() {
      function Particle2(options) {
        var populatedOptions = config_1.overrideDefaults({
          lifetime: 0,
          size: 1,
          location: components_1.Vector.zero,
          rotation: components_1.Vector.zero,
          velocity: components_1.Vector.zero,
          color: components_1.Color.white,
          opacity: 1
        }, options);
        this.id = Symbol();
        this.size = this.initialSize = populatedOptions.size;
        this.lifetime = this.initialLifetime = populatedOptions.lifetime;
        this.rotation = this.initialRotation = populatedOptions.rotation;
        this.location = populatedOptions.location;
        this.velocity = populatedOptions.velocity;
        this.color = populatedOptions.color;
        this.opacity = populatedOptions.opacity;
      }
      return Particle2;
    }();
    exports2.Particle = Particle;
  }
});

// node_modules/party-js/lib/particles/emitter.js
var require_emitter = __commonJS({
  "node_modules/party-js/lib/particles/emitter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = void 0;
    var vector_1 = require_vector();
    var settings_1 = require_settings();
    var variation_1 = require_variation();
    var config_1 = require_config();
    var options_1 = require_options();
    var particle_1 = require_particle();
    var Emitter = function() {
      function Emitter2(options) {
        this.particles = [];
        this.currentLoop = 0;
        this.durationTimer = 0;
        this.emissionTimer = 0;
        this.attemptedBurstIndices = [];
        this.options = config_1.overrideDefaults(options_1.getDefaultEmitterOptions(), options === null || options === void 0 ? void 0 : options.emitterOptions);
        this.emission = config_1.overrideDefaults(options_1.getDefaultEmissionOptions(), options === null || options === void 0 ? void 0 : options.emissionOptions);
        this.renderer = config_1.overrideDefaults(options_1.getDefaultRendererOptions(), options === null || options === void 0 ? void 0 : options.rendererOptions);
      }
      Object.defineProperty(Emitter2.prototype, "isExpired", {
        get: function() {
          return this.options.loops >= 0 && this.currentLoop >= this.options.loops;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Emitter2.prototype, "canRemove", {
        get: function() {
          return this.particles.length === 0;
        },
        enumerable: false,
        configurable: true
      });
      Emitter2.prototype.clearParticles = function() {
        return this.particles.splice(0).length;
      };
      Emitter2.prototype.tick = function(delta) {
        if (!this.isExpired) {
          this.durationTimer += delta;
          if (this.durationTimer >= this.options.duration) {
            this.currentLoop++;
            this.durationTimer = 0;
            this.attemptedBurstIndices = [];
          }
          if (!this.isExpired) {
            var burstIndex = 0;
            for (var _i = 0, _a3 = this.emission.bursts; _i < _a3.length; _i++) {
              var burst = _a3[_i];
              if (burst.time <= this.durationTimer) {
                if (!this.attemptedBurstIndices.includes(burstIndex)) {
                  var count = variation_1.evaluateVariation(burst.count);
                  for (var i3 = 0; i3 < count; i3++) {
                    this.emitParticle();
                  }
                  this.attemptedBurstIndices.push(burstIndex);
                }
              }
              burstIndex++;
            }
            this.emissionTimer += delta;
            var delay = 1 / this.emission.rate;
            while (this.emissionTimer > delay) {
              this.emissionTimer -= delay;
              this.emitParticle();
            }
          }
        }
        var _loop_1 = function(i4) {
          var particle = this_1.particles[i4];
          this_1.tickParticle(particle, delta);
          if (this_1.options.despawningRules.some(function(rule) {
            return rule(particle);
          })) {
            this_1.particles.splice(i4, 1);
          }
        };
        var this_1 = this;
        for (var i3 = this.particles.length - 1; i3 >= 0; i3--) {
          _loop_1(i3);
        }
      };
      Emitter2.prototype.tickParticle = function(particle, delta) {
        particle.lifetime -= delta;
        if (this.options.useGravity) {
          particle.velocity = particle.velocity.add(vector_1.Vector.up.scale(settings_1.settings.gravity * delta));
        }
        particle.location = particle.location.add(particle.velocity.scale(delta));
        for (var _i = 0, _a3 = this.options.modules; _i < _a3.length; _i++) {
          var moduleFunction = _a3[_i];
          moduleFunction(particle);
        }
      };
      Emitter2.prototype.emitParticle = function() {
        var particle = new particle_1.Particle({
          location: this.emission.sourceSampler(),
          lifetime: variation_1.evaluateVariation(this.emission.initialLifetime),
          velocity: vector_1.Vector.from2dAngle(variation_1.evaluateVariation(this.emission.angle)).scale(variation_1.evaluateVariation(this.emission.initialSpeed)),
          size: variation_1.evaluateVariation(this.emission.initialSize),
          rotation: variation_1.evaluateVariation(this.emission.initialRotation),
          color: variation_1.evaluateVariation(this.emission.initialColor)
        });
        this.particles.push(particle);
        if (this.particles.length > this.options.maxParticles) {
          this.particles.shift();
        }
        return particle;
      };
      return Emitter2;
    }();
    exports2.Emitter = Emitter;
  }
});

// node_modules/party-js/lib/systems/shapes.js
var require_shapes = __commonJS({
  "node_modules/party-js/lib/systems/shapes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveShapeFactory = exports2.resolvableShapes = void 0;
    var variation_1 = require_variation();
    exports2.resolvableShapes = {
      square: '<div style="height: 10px; width: 10px;"></div>',
      rectangle: '<div style="height: 6px; width: 10px;"></div>',
      circle: '<svg viewBox="0 0 2 2" width="10" height="10"><circle cx="1" cy="1" r="1" fill="currentColor"/></svg>',
      roundedSquare: '<div style="height: 10px; width: 10px; border-radius: 3px;"></div>',
      roundedRectangle: '<div style="height: 6px; width: 10px; border-radius: 3px;"></div>',
      star: '<svg viewBox="0 0 512 512" width="15" height="15"><polygon fill="currentColor" points="512,197.816 325.961,185.585 255.898,9.569 185.835,185.585 0,197.816 142.534,318.842 95.762,502.431 255.898,401.21 416.035,502.431 369.263,318.842"/></svg>'
    };
    function resolveShapeFactory(factory) {
      var shape = variation_1.evaluateVariation(factory);
      if (typeof shape === "string") {
        var resolved = exports2.resolvableShapes[shape];
        if (!resolved) {
          throw new Error("Failed to resolve shape key '" + shape + "'. Did you forget to add it to the 'resolvableShapes' lookup?");
        }
        var dummy = document.createElement("div");
        dummy.innerHTML = resolved;
        return dummy.firstElementChild;
      }
      return shape;
    }
    exports2.resolveShapeFactory = resolveShapeFactory;
  }
});

// node_modules/party-js/lib/particles/renderer.js
var require_renderer = __commonJS({
  "node_modules/party-js/lib/particles/renderer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Renderer = void 0;
    var __1 = require_lib();
    var vector_1 = require_vector();
    var containers_1 = require_containers();
    var shapes_1 = require_shapes();
    var util_1 = require_util2();
    var Renderer = function() {
      function Renderer2() {
        this.elements = /* @__PURE__ */ new Map();
        this.light = new vector_1.Vector(0, 0, 1);
        this.enabled = true;
        this.enabled = !__1.settings.respectReducedMotion || !window.matchMedia("(prefers-reduced-motion)").matches;
      }
      Renderer2.prototype.begin = function() {
        this.renderedParticles = [];
      };
      Renderer2.prototype.end = function() {
        var it = this.elements.keys();
        var result = it.next();
        while (!result.done) {
          var id = result.value;
          if (!this.renderedParticles.includes(id)) {
            this.elements.get(id).remove();
            this.elements.delete(id);
          }
          result = it.next();
        }
        return this.renderedParticles.length;
      };
      Renderer2.prototype.renderParticle = function(particle, emitter) {
        if (!this.enabled)
          return;
        var options = emitter.renderer;
        var element2 = this.elements.has(particle.id) ? this.elements.get(particle.id) : this.createParticleElement(particle, options);
        if (options.applyColor) {
          options.applyColor(particle.color, element2);
        }
        if (options.applyOpacity) {
          options.applyOpacity(particle.opacity, element2);
        }
        if (options.applyLighting) {
          var normal = util_1.rotationToNormal(particle.rotation);
          var lightingCoefficient = normal.dot(this.light);
          options.applyLighting(lightingCoefficient, element2);
        }
        if (options.applyTransform) {
          options.applyTransform(particle, element2);
        }
        this.renderedParticles.push(particle.id);
      };
      Renderer2.prototype.createParticleElement = function(particle, options) {
        var resolved = shapes_1.resolveShapeFactory(options.shapeFactory);
        var element2 = resolved.cloneNode(true);
        element2.style.position = "absolute";
        this.elements.set(particle.id, containers_1.particleContainer.current.appendChild(element2));
        return element2;
      };
      return Renderer2;
    }();
    exports2.Renderer = Renderer;
  }
});

// node_modules/party-js/lib/scene.js
var require_scene = __commonJS({
  "node_modules/party-js/lib/scene.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Scene = void 0;
    var debug_1 = require_debug();
    var emitter_1 = require_emitter();
    var renderer_1 = require_renderer();
    var Scene = function() {
      function Scene2() {
        this.emitters = [];
        this.debug = new debug_1.Debug(this);
        this.renderer = new renderer_1.Renderer();
        this.scheduledTickId = void 0;
        this.lastTickTimestamp = performance.now();
        this.tick = this.tick.bind(this);
        this.scheduleTick();
      }
      Scene2.prototype.createEmitter = function(options) {
        var emitter = new emitter_1.Emitter(options);
        this.emitters.push(emitter);
        return emitter;
      };
      Scene2.prototype.clearEmitters = function() {
        return this.emitters.splice(0).length;
      };
      Scene2.prototype.clearParticles = function() {
        return this.emitters.reduce(function(sum, emitter) {
          return sum + emitter.clearParticles();
        }, 0);
      };
      Scene2.prototype.scheduleTick = function() {
        this.scheduledTickId = window.requestAnimationFrame(this.tick);
      };
      Scene2.prototype.cancelTick = function() {
        window.cancelAnimationFrame(this.scheduledTickId);
      };
      Scene2.prototype.tick = function(timestamp) {
        var delta = (timestamp - this.lastTickTimestamp) / 1e3;
        try {
          for (var i3 = 0; i3 < this.emitters.length; i3++) {
            var emitter = this.emitters[i3];
            emitter.tick(delta);
            if (emitter.isExpired && emitter.canRemove) {
              this.emitters.splice(i3--, 1);
            }
          }
        } catch (error) {
          console.error(`An error occurred while updating the scene's emitters:
"` + error + '"');
        }
        try {
          this.renderer.begin();
          for (var _i = 0, _a3 = this.emitters; _i < _a3.length; _i++) {
            var emitter = _a3[_i];
            for (var _b2 = 0, _c = emitter.particles; _b2 < _c.length; _b2++) {
              var particle = _c[_b2];
              this.renderer.renderParticle(particle, emitter);
            }
          }
          this.renderer.end();
        } catch (error) {
          console.error(`An error occurred while rendering the scene's particles:
"` + error + '"');
        }
        this.debug.tick(delta);
        this.lastTickTimestamp = timestamp;
        this.scheduleTick();
      };
      return Scene2;
    }();
    exports2.Scene = Scene;
  }
});

// node_modules/party-js/lib/systems/modules.js
var require_modules = __commonJS({
  "node_modules/party-js/lib/systems/modules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ModuleBuilder = void 0;
    var components_1 = require_components();
    var ModuleBuilder = function() {
      function ModuleBuilder2() {
        this.factor = "lifetime";
        this.isRelative = false;
      }
      ModuleBuilder2.prototype.drive = function(key) {
        this.driverKey = key;
        return this;
      };
      ModuleBuilder2.prototype.through = function(factor) {
        this.factor = factor;
        return this;
      };
      ModuleBuilder2.prototype.by = function(driver) {
        this.driverValue = driver;
        return this;
      };
      ModuleBuilder2.prototype.relative = function(isRelative) {
        if (isRelative === void 0) {
          isRelative = true;
        }
        this.isRelative = isRelative;
        return this;
      };
      ModuleBuilder2.prototype.build = function() {
        var _this = this;
        if (typeof this.driverKey === "undefined") {
          throw new Error("No driving key was provided in the module builder. Did you forget a '.drive()' call?");
        }
        if (typeof this.driverValue === "undefined") {
          throw new Error("No driving value was provided in the module builder. Did you forget a '.through()' call?");
        }
        return function(particle) {
          updateDrivenProperty(particle, _this.driverKey, evaluateModuleDriver(_this.driverValue, calculateModuleFactor(_this.factor, particle), particle), _this.isRelative);
        };
      };
      return ModuleBuilder2;
    }();
    exports2.ModuleBuilder = ModuleBuilder;
    function evaluateModuleDriver(driver, factor, particle) {
      if (typeof driver === "object" && "evaluate" in driver) {
        return driver.evaluate(factor);
      }
      if (typeof driver === "function") {
        return driver(factor, particle);
      }
      return driver;
    }
    function calculateModuleFactor(factor, particle) {
      switch (factor) {
        case "lifetime":
          return particle.initialLifetime - particle.lifetime;
        case "relativeLifetime":
          return (particle.initialLifetime - particle.lifetime) / particle.initialLifetime;
        case "size":
          return particle.size;
        default:
          throw new Error("Invalid driving factor '" + factor + "'.");
      }
    }
    function updateDrivenProperty(particle, key, value, relative) {
      if (relative === void 0) {
        relative = false;
      }
      if (!relative) {
        particle[key] = value;
      } else {
        var initial = particle["initial" + key[0].toUpperCase() + key.substr(1)];
        if (typeof initial === "undefined") {
          throw new Error("Unable to use relative chaining with key '" + key + "'; no initial value exists.");
        }
        if (value instanceof components_1.Vector) {
          updateDrivenProperty(particle, key, initial.add(value));
        } else if (typeof value === "number") {
          updateDrivenProperty(particle, key, initial * value);
        } else {
          throw new Error("Unable to use relative chaining with particle key '" + key + "'; no relative operation for '" + value + "' could be inferred.");
        }
      }
    }
  }
});

// node_modules/party-js/lib/templates/confetti.js
var require_confetti = __commonJS({
  "node_modules/party-js/lib/templates/confetti.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.confetti = void 0;
    var __1 = require_lib();
    var components_1 = require_components();
    var modules_1 = require_modules();
    var random2 = require_random();
    var sources = require_sources();
    var variation = require_variation();
    var util = require_util2();
    function confetti(source, options) {
      var populated = util.overrideDefaults({
        count: variation.range(20, 40),
        spread: variation.range(35, 45),
        speed: variation.range(300, 600),
        size: variation.skew(1, 0.2),
        rotation: function() {
          return random2.randomUnitVector().scale(180);
        },
        color: function() {
          return components_1.Color.fromHsl(random2.randomRange(0, 360), 100, 70);
        },
        modules: [
          new modules_1.ModuleBuilder().drive("size").by(function(t3) {
            return Math.min(1, t3 * 3);
          }).relative().build(),
          new modules_1.ModuleBuilder().drive("rotation").by(function(t3) {
            return new components_1.Vector(140, 200, 260).scale(t3);
          }).relative().build()
        ],
        shapes: ["square", "circle"]
      }, options);
      var emitter = __1.scene.current.createEmitter({
        emitterOptions: {
          loops: 1,
          duration: 8,
          modules: populated.modules
        },
        emissionOptions: {
          rate: 0,
          bursts: [{ time: 0, count: populated.count }],
          sourceSampler: sources.dynamicSource(source),
          angle: variation.skew(-90, variation.evaluateVariation(populated.spread)),
          initialLifetime: 8,
          initialSpeed: populated.speed,
          initialSize: populated.size,
          initialRotation: populated.rotation,
          initialColor: populated.color
        },
        rendererOptions: {
          shapeFactory: populated.shapes
        }
      });
      return emitter;
    }
    exports2.confetti = confetti;
  }
});

// node_modules/party-js/lib/templates/sparkles.js
var require_sparkles = __commonJS({
  "node_modules/party-js/lib/templates/sparkles.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sparkles = void 0;
    var __1 = require_lib();
    var components_1 = require_components();
    var modules_1 = require_modules();
    var random2 = require_random();
    var sources = require_sources();
    var variation = require_variation();
    var util = require_util2();
    function sparkles(source, options) {
      var populated = util.overrideDefaults({
        lifetime: variation.range(1, 2),
        count: variation.range(10, 20),
        speed: variation.range(100, 200),
        size: variation.range(0.8, 1.8),
        rotation: function() {
          return new components_1.Vector(0, 0, random2.randomRange(0, 360));
        },
        color: function() {
          return components_1.Color.fromHsl(50, 100, random2.randomRange(55, 85));
        },
        modules: [
          new modules_1.ModuleBuilder().drive("rotation").by(function(t3) {
            return new components_1.Vector(0, 0, 200).scale(t3);
          }).relative().build(),
          new modules_1.ModuleBuilder().drive("size").by(new components_1.NumericSpline({ time: 0, value: 0 }, { time: 0.3, value: 1 }, { time: 0.7, value: 1 }, { time: 1, value: 0 })).through("relativeLifetime").relative().build(),
          new modules_1.ModuleBuilder().drive("opacity").by(new components_1.NumericSpline({ time: 0, value: 1 }, { time: 0.5, value: 1 }, { time: 1, value: 0 })).through("relativeLifetime").build()
        ],
        shapes: "star"
      }, options);
      var emitter = __1.scene.current.createEmitter({
        emitterOptions: {
          loops: 1,
          duration: 3,
          useGravity: false,
          modules: populated.modules
        },
        emissionOptions: {
          rate: 0,
          bursts: [{ time: 0, count: populated.count }],
          sourceSampler: sources.dynamicSource(source),
          angle: variation.range(0, 360),
          initialLifetime: populated.lifetime,
          initialSpeed: populated.speed,
          initialSize: populated.size,
          initialRotation: populated.rotation,
          initialColor: populated.color
        },
        rendererOptions: {
          applyLighting: void 0,
          shapeFactory: populated.shapes
        }
      });
      return emitter;
    }
    exports2.sparkles = sparkles;
  }
});

// node_modules/party-js/lib/templates/index.js
var require_templates2 = __commonJS({
  "node_modules/party-js/lib/templates/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k2];
      } });
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m3, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_confetti(), exports2);
    __exportStar2(require_sparkles(), exports2);
  }
});

// node_modules/party-js/lib/index.js
var require_lib = __commonJS({
  "node_modules/party-js/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k2];
      } });
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m3, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2.forceInit = exports2.util = exports2.math = exports2.random = exports2.sources = exports2.variation = exports2.Emitter = exports2.Particle = exports2.settings = exports2.scene = void 0;
    var scene_1 = require_scene();
    var util_1 = require_util2();
    __exportStar2(require_components(), exports2);
    __exportStar2(require_templates2(), exports2);
    __exportStar2(require_shapes(), exports2);
    __exportStar2(require_modules(), exports2);
    exports2.scene = new util_1.Lazy(function() {
      if (typeof document === "undefined" || typeof window === "undefined") {
        throw new Error("It seems like you are trying to run party.js in a non-browser-like environment, which is not supported.");
      }
      return new scene_1.Scene();
    });
    var settings_1 = require_settings();
    Object.defineProperty(exports2, "settings", { enumerable: true, get: function() {
      return settings_1.settings;
    } });
    var particle_1 = require_particle();
    Object.defineProperty(exports2, "Particle", { enumerable: true, get: function() {
      return particle_1.Particle;
    } });
    var emitter_1 = require_emitter();
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return emitter_1.Emitter;
    } });
    exports2.variation = require_variation();
    exports2.sources = require_sources();
    exports2.random = require_random();
    exports2.math = require_math();
    exports2.util = require_util2();
    function forceInit() {
      exports2.scene.current;
    }
    exports2.forceInit = forceInit;
    exports2.default = require_lib();
  }
});

// node_modules/form-data/lib/browser.js
var require_browser2 = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports2, module2) {
    module2.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// node_modules/sql.js/dist/sql-wasm.js
var require_sql_wasm = __commonJS({
  "node_modules/sql.js/dist/sql-wasm.js"(exports2, module2) {
    var initSqlJsPromise = void 0;
    var initSqlJs2 = function(moduleConfig) {
      if (initSqlJsPromise) {
        return initSqlJsPromise;
      }
      initSqlJsPromise = new Promise(function(resolveModule, reject) {
        var Module = typeof moduleConfig !== "undefined" ? moduleConfig : {};
        var originalOnAbortFunction = Module["onAbort"];
        Module["onAbort"] = function(errorThatCausedAbort) {
          reject(new Error(errorThatCausedAbort));
          if (originalOnAbortFunction) {
            originalOnAbortFunction(errorThatCausedAbort);
          }
        };
        Module["postRun"] = Module["postRun"] || [];
        Module["postRun"].push(function() {
          resolveModule(Module);
        });
        module2 = void 0;
        var e3;
        e3 || (e3 = typeof Module !== "undefined" ? Module : {});
        null;
        e3.onRuntimeInitialized = function() {
          function a4(g, m3) {
            switch (typeof m3) {
              case "boolean":
                gc(g, m3 ? 1 : 0);
                break;
              case "number":
                hc(g, m3);
                break;
              case "string":
                ic(g, m3, -1, -1);
                break;
              case "object":
                if (m3 === null)
                  kb(g);
                else if (m3.length != null) {
                  var n2 = aa(m3);
                  jc(g, n2, m3.length, -1);
                  ba(n2);
                } else
                  xa(g, "Wrong API use : tried to return a value of an unknown type (" + m3 + ").", -1);
                break;
              default:
                kb(g);
            }
          }
          function b2(g, m3) {
            for (var n2 = [], p2 = 0; p2 < g; p2 += 1) {
              var v = l2(m3 + 4 * p2, "i32"), y3 = kc(v);
              if (y3 === 1 || y3 === 2)
                v = lc(v);
              else if (y3 === 3)
                v = mc(v);
              else if (y3 === 4) {
                y3 = v;
                v = nc(y3);
                y3 = oc(y3);
                for (var L2 = new Uint8Array(v), G2 = 0; G2 < v; G2 += 1)
                  L2[G2] = r[y3 + G2];
                v = L2;
              } else
                v = null;
              n2.push(v);
            }
            return n2;
          }
          function c6(g, m3) {
            this.La = g;
            this.db = m3;
            this.Ja = 1;
            this.fb = [];
          }
          function d4(g, m3) {
            this.db = m3;
            m3 = ca(g) + 1;
            this.Ya = da(m3);
            if (this.Ya === null)
              throw Error("Unable to allocate memory for the SQL string");
            t3(g, u2, this.Ya, m3);
            this.eb = this.Ya;
            this.Ua = this.ib = null;
          }
          function f(g) {
            this.filename = "dbfile_" + (4294967295 * Math.random() >>> 0);
            if (g != null) {
              var m3 = this.filename, n2 = "/", p2 = m3;
              n2 && (n2 = typeof n2 == "string" ? n2 : ea(n2), p2 = m3 ? z2(n2 + "/" + m3) : n2);
              m3 = fa(true, true);
              p2 = ha(p2, (m3 !== void 0 ? m3 : 438) & 4095 | 32768, 0);
              if (g) {
                if (typeof g == "string") {
                  n2 = Array(g.length);
                  for (var v = 0, y3 = g.length; v < y3; ++v)
                    n2[v] = g.charCodeAt(v);
                  g = n2;
                }
                ia(p2, m3 | 146);
                n2 = ja(p2, 577);
                ka(n2, g, 0, g.length, 0);
                la(n2);
                ia(p2, m3);
              }
            }
            this.handleError(q2(this.filename, h6));
            this.db = l2(h6, "i32");
            pc(this.db);
            this.Za = {};
            this.Na = {};
          }
          var h6 = B2(4), k2 = e3.cwrap, q2 = k2("sqlite3_open", "number", ["string", "number"]), x2 = k2("sqlite3_close_v2", "number", ["number"]), w3 = k2("sqlite3_exec", "number", ["number", "string", "number", "number", "number"]), A2 = k2("sqlite3_changes", "number", ["number"]), S3 = k2("sqlite3_prepare_v2", "number", ["number", "string", "number", "number", "number"]), nb = k2("sqlite3_sql", "string", ["number"]), qc = k2("sqlite3_normalized_sql", "string", ["number"]), ob = k2("sqlite3_prepare_v2", "number", ["number", "number", "number", "number", "number"]), rc = k2("sqlite3_bind_text", "number", ["number", "number", "number", "number", "number"]), pb = k2("sqlite3_bind_blob", "number", ["number", "number", "number", "number", "number"]), sc = k2("sqlite3_bind_double", "number", ["number", "number", "number"]), tc = k2("sqlite3_bind_int", "number", ["number", "number", "number"]), uc = k2("sqlite3_bind_parameter_index", "number", ["number", "string"]), vc = k2("sqlite3_step", "number", ["number"]), wc = k2("sqlite3_errmsg", "string", ["number"]), xc = k2("sqlite3_column_count", "number", ["number"]), yc = k2("sqlite3_data_count", "number", ["number"]), zc = k2("sqlite3_column_double", "number", ["number", "number"]), qb = k2("sqlite3_column_text", "string", ["number", "number"]), Ac = k2("sqlite3_column_blob", "number", ["number", "number"]), Bc = k2("sqlite3_column_bytes", "number", ["number", "number"]), Cc = k2("sqlite3_column_type", "number", ["number", "number"]), Dc = k2("sqlite3_column_name", "string", ["number", "number"]), Ec = k2("sqlite3_reset", "number", ["number"]), Fc = k2("sqlite3_clear_bindings", "number", ["number"]), Gc = k2("sqlite3_finalize", "number", ["number"]), rb = k2("sqlite3_create_function_v2", "number", "number string number number number number number number number".split(" ")), kc = k2("sqlite3_value_type", "number", ["number"]), nc = k2("sqlite3_value_bytes", "number", ["number"]), mc = k2("sqlite3_value_text", "string", ["number"]), oc = k2("sqlite3_value_blob", "number", ["number"]), lc = k2("sqlite3_value_double", "number", ["number"]), hc = k2("sqlite3_result_double", "", ["number", "number"]), kb = k2("sqlite3_result_null", "", ["number"]), ic = k2("sqlite3_result_text", "", ["number", "string", "number", "number"]), jc = k2("sqlite3_result_blob", "", ["number", "number", "number", "number"]), gc = k2("sqlite3_result_int", "", ["number", "number"]), xa = k2("sqlite3_result_error", "", ["number", "string", "number"]), sb = k2("sqlite3_aggregate_context", "number", ["number", "number"]), pc = k2("RegisterExtensionFunctions", "number", ["number"]);
          c6.prototype.bind = function(g) {
            if (!this.La)
              throw "Statement closed";
            this.reset();
            return Array.isArray(g) ? this.xb(g) : g != null && typeof g === "object" ? this.yb(g) : true;
          };
          c6.prototype.step = function() {
            if (!this.La)
              throw "Statement closed";
            this.Ja = 1;
            var g = vc(this.La);
            switch (g) {
              case 100:
                return true;
              case 101:
                return false;
              default:
                throw this.db.handleError(g);
            }
          };
          c6.prototype.sb = function(g) {
            g == null && (g = this.Ja, this.Ja += 1);
            return zc(this.La, g);
          };
          c6.prototype.Cb = function(g) {
            g == null && (g = this.Ja, this.Ja += 1);
            g = qb(this.La, g);
            if (typeof BigInt !== "function")
              throw Error("BigInt is not supported");
            return BigInt(g);
          };
          c6.prototype.Db = function(g) {
            g == null && (g = this.Ja, this.Ja += 1);
            return qb(this.La, g);
          };
          c6.prototype.getBlob = function(g) {
            g == null && (g = this.Ja, this.Ja += 1);
            var m3 = Bc(this.La, g);
            g = Ac(this.La, g);
            for (var n2 = new Uint8Array(m3), p2 = 0; p2 < m3; p2 += 1)
              n2[p2] = r[g + p2];
            return n2;
          };
          c6.prototype.get = function(g, m3) {
            m3 = m3 || {};
            g != null && this.bind(g) && this.step();
            g = [];
            for (var n2 = yc(this.La), p2 = 0; p2 < n2; p2 += 1)
              switch (Cc(this.La, p2)) {
                case 1:
                  var v = m3.useBigInt ? this.Cb(p2) : this.sb(p2);
                  g.push(v);
                  break;
                case 2:
                  g.push(this.sb(p2));
                  break;
                case 3:
                  g.push(this.Db(p2));
                  break;
                case 4:
                  g.push(this.getBlob(p2));
                  break;
                default:
                  g.push(null);
              }
            return g;
          };
          c6.prototype.getColumnNames = function() {
            for (var g = [], m3 = xc(this.La), n2 = 0; n2 < m3; n2 += 1)
              g.push(Dc(this.La, n2));
            return g;
          };
          c6.prototype.getAsObject = function(g, m3) {
            g = this.get(g, m3);
            m3 = this.getColumnNames();
            for (var n2 = {}, p2 = 0; p2 < m3.length; p2 += 1)
              n2[m3[p2]] = g[p2];
            return n2;
          };
          c6.prototype.getSQL = function() {
            return nb(this.La);
          };
          c6.prototype.getNormalizedSQL = function() {
            return qc(this.La);
          };
          c6.prototype.run = function(g) {
            g != null && this.bind(g);
            this.step();
            return this.reset();
          };
          c6.prototype.nb = function(g, m3) {
            m3 == null && (m3 = this.Ja, this.Ja += 1);
            g = ma(g);
            var n2 = aa(g);
            this.fb.push(n2);
            this.db.handleError(rc(this.La, m3, n2, g.length - 1, 0));
          };
          c6.prototype.wb = function(g, m3) {
            m3 == null && (m3 = this.Ja, this.Ja += 1);
            var n2 = aa(g);
            this.fb.push(n2);
            this.db.handleError(pb(this.La, m3, n2, g.length, 0));
          };
          c6.prototype.mb = function(g, m3) {
            m3 == null && (m3 = this.Ja, this.Ja += 1);
            this.db.handleError((g === (g | 0) ? tc : sc)(this.La, m3, g));
          };
          c6.prototype.zb = function(g) {
            g == null && (g = this.Ja, this.Ja += 1);
            pb(this.La, g, 0, 0, 0);
          };
          c6.prototype.ob = function(g, m3) {
            m3 == null && (m3 = this.Ja, this.Ja += 1);
            switch (typeof g) {
              case "string":
                this.nb(g, m3);
                return;
              case "number":
                this.mb(g, m3);
                return;
              case "bigint":
                this.nb(g.toString(), m3);
                return;
              case "boolean":
                this.mb(g + 0, m3);
                return;
              case "object":
                if (g === null) {
                  this.zb(m3);
                  return;
                }
                if (g.length != null) {
                  this.wb(g, m3);
                  return;
                }
            }
            throw "Wrong API use : tried to bind a value of an unknown type (" + g + ").";
          };
          c6.prototype.yb = function(g) {
            var m3 = this;
            Object.keys(g).forEach(function(n2) {
              var p2 = uc(m3.La, n2);
              p2 !== 0 && m3.ob(g[n2], p2);
            });
            return true;
          };
          c6.prototype.xb = function(g) {
            for (var m3 = 0; m3 < g.length; m3 += 1)
              this.ob(g[m3], m3 + 1);
            return true;
          };
          c6.prototype.reset = function() {
            this.freemem();
            return Fc(this.La) === 0 && Ec(this.La) === 0;
          };
          c6.prototype.freemem = function() {
            for (var g; (g = this.fb.pop()) !== void 0; )
              ba(g);
          };
          c6.prototype.free = function() {
            this.freemem();
            var g = Gc(this.La) === 0;
            delete this.db.Za[this.La];
            this.La = 0;
            return g;
          };
          d4.prototype.next = function() {
            if (this.Ya === null)
              return { done: true };
            this.Ua !== null && (this.Ua.free(), this.Ua = null);
            if (!this.db.db)
              throw this.gb(), Error("Database closed");
            var g = oa(), m3 = B2(4);
            pa(h6);
            pa(m3);
            try {
              this.db.handleError(ob(this.db.db, this.eb, -1, h6, m3));
              this.eb = l2(m3, "i32");
              var n2 = l2(h6, "i32");
              if (n2 === 0)
                return this.gb(), { done: true };
              this.Ua = new c6(n2, this.db);
              this.db.Za[n2] = this.Ua;
              return { value: this.Ua, done: false };
            } catch (p2) {
              throw this.ib = C(this.eb), this.gb(), p2;
            } finally {
              qa(g);
            }
          };
          d4.prototype.gb = function() {
            ba(this.Ya);
            this.Ya = null;
          };
          d4.prototype.getRemainingSQL = function() {
            return this.ib !== null ? this.ib : C(this.eb);
          };
          typeof Symbol === "function" && typeof Symbol.iterator === "symbol" && (d4.prototype[Symbol.iterator] = function() {
            return this;
          });
          f.prototype.run = function(g, m3) {
            if (!this.db)
              throw "Database closed";
            if (m3) {
              g = this.prepare(g, m3);
              try {
                g.step();
              } finally {
                g.free();
              }
            } else
              this.handleError(w3(this.db, g, 0, 0, h6));
            return this;
          };
          f.prototype.exec = function(g, m3, n2) {
            if (!this.db)
              throw "Database closed";
            var p2 = oa(), v = null;
            try {
              var y3 = ca(g) + 1, L2 = B2(y3);
              t3(g, r, L2, y3);
              var G2 = L2;
              var H3 = B2(4);
              for (g = []; l2(G2, "i8") !== 0; ) {
                pa(h6);
                pa(H3);
                this.handleError(ob(this.db, G2, -1, h6, H3));
                var I2 = l2(h6, "i32");
                G2 = l2(H3, "i32");
                if (I2 !== 0) {
                  y3 = null;
                  v = new c6(I2, this);
                  for (m3 != null && v.bind(m3); v.step(); )
                    y3 === null && (y3 = { columns: v.getColumnNames(), values: [] }, g.push(y3)), y3.values.push(v.get(null, n2));
                  v.free();
                }
              }
              return g;
            } catch (na) {
              throw v && v.free(), na;
            } finally {
              qa(p2);
            }
          };
          f.prototype.each = function(g, m3, n2, p2, v) {
            typeof m3 === "function" && (p2 = n2, n2 = m3, m3 = void 0);
            g = this.prepare(g, m3);
            try {
              for (; g.step(); )
                n2(g.getAsObject(null, v));
            } finally {
              g.free();
            }
            if (typeof p2 === "function")
              return p2();
          };
          f.prototype.prepare = function(g, m3) {
            pa(h6);
            this.handleError(S3(this.db, g, -1, h6, 0));
            g = l2(h6, "i32");
            if (g === 0)
              throw "Nothing to prepare";
            var n2 = new c6(g, this);
            m3 != null && n2.bind(m3);
            return this.Za[g] = n2;
          };
          f.prototype.iterateStatements = function(g) {
            return new d4(g, this);
          };
          f.prototype["export"] = function() {
            Object.values(this.Za).forEach(function(m3) {
              m3.free();
            });
            Object.values(this.Na).forEach(ra);
            this.Na = {};
            this.handleError(x2(this.db));
            var g = sa(this.filename);
            this.handleError(q2(this.filename, h6));
            this.db = l2(h6, "i32");
            return g;
          };
          f.prototype.close = function() {
            this.db !== null && (Object.values(this.Za).forEach(function(g) {
              g.free();
            }), Object.values(this.Na).forEach(ra), this.Na = {}, this.handleError(x2(this.db)), ta("/" + this.filename), this.db = null);
          };
          f.prototype.handleError = function(g) {
            if (g === 0)
              return null;
            g = wc(this.db);
            throw Error(g);
          };
          f.prototype.getRowsModified = function() {
            return A2(this.db);
          };
          f.prototype.create_function = function(g, m3) {
            Object.prototype.hasOwnProperty.call(this.Na, g) && (ra(this.Na[g]), delete this.Na[g]);
            var n2 = ua(function(p2, v, y3) {
              v = b2(v, y3);
              try {
                var L2 = m3.apply(null, v);
              } catch (G2) {
                xa(p2, G2, -1);
                return;
              }
              a4(p2, L2);
            }, "viii");
            this.Na[g] = n2;
            this.handleError(rb(this.db, g, m3.length, 1, 0, n2, 0, 0, 0));
            return this;
          };
          f.prototype.create_aggregate = function(g, m3) {
            var n2 = m3.init || function() {
              return null;
            }, p2 = m3.finalize || function(H3) {
              return H3;
            }, v = m3.step;
            if (!v)
              throw "An aggregate function must have a step function in " + g;
            var y3 = {};
            Object.hasOwnProperty.call(this.Na, g) && (ra(this.Na[g]), delete this.Na[g]);
            m3 = g + "__finalize";
            Object.hasOwnProperty.call(this.Na, m3) && (ra(this.Na[m3]), delete this.Na[m3]);
            var L2 = ua(function(H3, I2, na) {
              var Z = sb(H3, 1);
              Object.hasOwnProperty.call(y3, Z) || (y3[Z] = n2());
              I2 = b2(I2, na);
              I2 = [y3[Z]].concat(I2);
              try {
                y3[Z] = v.apply(null, I2);
              } catch (Ic) {
                delete y3[Z], xa(H3, Ic, -1);
              }
            }, "viii"), G2 = ua(function(H3) {
              var I2 = sb(H3, 1);
              try {
                var na = p2(y3[I2]);
              } catch (Z) {
                delete y3[I2];
                xa(H3, Z, -1);
                return;
              }
              a4(H3, na);
              delete y3[I2];
            }, "vi");
            this.Na[g] = L2;
            this.Na[m3] = G2;
            this.handleError(rb(this.db, g, v.length - 1, 1, 0, 0, L2, G2, 0));
            return this;
          };
          e3.Database = f;
        };
        var va = Object.assign({}, e3), wa = "./this.program", ya = typeof window == "object", za = typeof importScripts == "function", Aa = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", D2 = "", Ba, Ca, Da, fs, Ea, Fa;
        if (Aa)
          D2 = za ? require("path").dirname(D2) + "/" : __dirname + "/", Fa = () => {
            Ea || (fs = require("fs"), Ea = require("path"));
          }, Ba = function(a4, b2) {
            Fa();
            a4 = Ea.normalize(a4);
            return fs.readFileSync(a4, b2 ? void 0 : "utf8");
          }, Da = (a4) => {
            a4 = Ba(a4, true);
            a4.buffer || (a4 = new Uint8Array(a4));
            return a4;
          }, Ca = (a4, b2, c6) => {
            Fa();
            a4 = Ea.normalize(a4);
            fs.readFile(a4, function(d4, f) {
              d4 ? c6(d4) : b2(f.buffer);
            });
          }, 1 < process.argv.length && (wa = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), typeof module2 != "undefined" && (module2.exports = e3), e3.inspect = function() {
            return "[Emscripten Module object]";
          };
        else if (ya || za)
          za ? D2 = self.location.href : typeof document != "undefined" && document.currentScript && (D2 = document.currentScript.src), D2 = D2.indexOf("blob:") !== 0 ? D2.substr(0, D2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", Ba = (a4) => {
            var b2 = new XMLHttpRequest();
            b2.open("GET", a4, false);
            b2.send(null);
            return b2.responseText;
          }, za && (Da = (a4) => {
            var b2 = new XMLHttpRequest();
            b2.open("GET", a4, false);
            b2.responseType = "arraybuffer";
            b2.send(null);
            return new Uint8Array(b2.response);
          }), Ca = (a4, b2, c6) => {
            var d4 = new XMLHttpRequest();
            d4.open("GET", a4, true);
            d4.responseType = "arraybuffer";
            d4.onload = () => {
              d4.status == 200 || d4.status == 0 && d4.response ? b2(d4.response) : c6();
            };
            d4.onerror = c6;
            d4.send(null);
          };
        var Ga = e3.print || console.log.bind(console), Ha = e3.printErr || console.warn.bind(console);
        Object.assign(e3, va);
        va = null;
        e3.thisProgram && (wa = e3.thisProgram);
        var Ia;
        e3.wasmBinary && (Ia = e3.wasmBinary);
        var noExitRuntime = e3.noExitRuntime || true;
        typeof WebAssembly != "object" && E2("no native wasm support detected");
        var Ja, Ka = false, La = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
        function Ma(a4, b2, c6) {
          var d4 = b2 + c6;
          for (c6 = b2; a4[c6] && !(c6 >= d4); )
            ++c6;
          if (16 < c6 - b2 && a4.buffer && La)
            return La.decode(a4.subarray(b2, c6));
          for (d4 = ""; b2 < c6; ) {
            var f = a4[b2++];
            if (f & 128) {
              var h6 = a4[b2++] & 63;
              if ((f & 224) == 192)
                d4 += String.fromCharCode((f & 31) << 6 | h6);
              else {
                var k2 = a4[b2++] & 63;
                f = (f & 240) == 224 ? (f & 15) << 12 | h6 << 6 | k2 : (f & 7) << 18 | h6 << 12 | k2 << 6 | a4[b2++] & 63;
                65536 > f ? d4 += String.fromCharCode(f) : (f -= 65536, d4 += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023));
              }
            } else
              d4 += String.fromCharCode(f);
          }
          return d4;
        }
        function C(a4, b2) {
          return a4 ? Ma(u2, a4, b2) : "";
        }
        function t3(a4, b2, c6, d4) {
          if (!(0 < d4))
            return 0;
          var f = c6;
          d4 = c6 + d4 - 1;
          for (var h6 = 0; h6 < a4.length; ++h6) {
            var k2 = a4.charCodeAt(h6);
            if (55296 <= k2 && 57343 >= k2) {
              var q2 = a4.charCodeAt(++h6);
              k2 = 65536 + ((k2 & 1023) << 10) | q2 & 1023;
            }
            if (127 >= k2) {
              if (c6 >= d4)
                break;
              b2[c6++] = k2;
            } else {
              if (2047 >= k2) {
                if (c6 + 1 >= d4)
                  break;
                b2[c6++] = 192 | k2 >> 6;
              } else {
                if (65535 >= k2) {
                  if (c6 + 2 >= d4)
                    break;
                  b2[c6++] = 224 | k2 >> 12;
                } else {
                  if (c6 + 3 >= d4)
                    break;
                  b2[c6++] = 240 | k2 >> 18;
                  b2[c6++] = 128 | k2 >> 12 & 63;
                }
                b2[c6++] = 128 | k2 >> 6 & 63;
              }
              b2[c6++] = 128 | k2 & 63;
            }
          }
          b2[c6] = 0;
          return c6 - f;
        }
        function ca(a4) {
          for (var b2 = 0, c6 = 0; c6 < a4.length; ++c6) {
            var d4 = a4.charCodeAt(c6);
            127 >= d4 ? b2++ : 2047 >= d4 ? b2 += 2 : 55296 <= d4 && 57343 >= d4 ? (b2 += 4, ++c6) : b2 += 3;
          }
          return b2;
        }
        var Na, r, u2, Oa, F, J, Pa, Qa;
        function Ra() {
          var a4 = Ja.buffer;
          Na = a4;
          e3.HEAP8 = r = new Int8Array(a4);
          e3.HEAP16 = Oa = new Int16Array(a4);
          e3.HEAP32 = F = new Int32Array(a4);
          e3.HEAPU8 = u2 = new Uint8Array(a4);
          e3.HEAPU16 = new Uint16Array(a4);
          e3.HEAPU32 = J = new Uint32Array(a4);
          e3.HEAPF32 = Pa = new Float32Array(a4);
          e3.HEAPF64 = Qa = new Float64Array(a4);
        }
        var K2, Sa = [], Ta = [], Ua = [];
        function Va() {
          var a4 = e3.preRun.shift();
          Sa.unshift(a4);
        }
        var Wa = 0, Xa = null, Ya = null;
        function E2(a4) {
          if (e3.onAbort)
            e3.onAbort(a4);
          a4 = "Aborted(" + a4 + ")";
          Ha(a4);
          Ka = true;
          throw new WebAssembly.RuntimeError(a4 + ". Build with -sASSERTIONS for more info.");
        }
        function Za() {
          return M3.startsWith("data:application/octet-stream;base64,");
        }
        var M3;
        M3 = "sql-wasm.wasm";
        if (!Za()) {
          var $a = M3;
          M3 = e3.locateFile ? e3.locateFile($a, D2) : D2 + $a;
        }
        function ab() {
          var a4 = M3;
          try {
            if (a4 == M3 && Ia)
              return new Uint8Array(Ia);
            if (Da)
              return Da(a4);
            throw "both async and sync fetching of the wasm failed";
          } catch (b2) {
            E2(b2);
          }
        }
        function bb() {
          if (!Ia && (ya || za)) {
            if (typeof fetch == "function" && !M3.startsWith("file://"))
              return fetch(M3, { credentials: "same-origin" }).then(function(a4) {
                if (!a4.ok)
                  throw "failed to load wasm binary file at '" + M3 + "'";
                return a4.arrayBuffer();
              }).catch(function() {
                return ab();
              });
            if (Ca)
              return new Promise(function(a4, b2) {
                Ca(M3, function(c6) {
                  a4(new Uint8Array(c6));
                }, b2);
              });
          }
          return Promise.resolve().then(function() {
            return ab();
          });
        }
        var N, O2;
        function cb(a4) {
          for (; 0 < a4.length; )
            a4.shift()(e3);
        }
        function l2(a4, b2 = "i8") {
          b2.endsWith("*") && (b2 = "*");
          switch (b2) {
            case "i1":
              return r[a4 >> 0];
            case "i8":
              return r[a4 >> 0];
            case "i16":
              return Oa[a4 >> 1];
            case "i32":
              return F[a4 >> 2];
            case "i64":
              return F[a4 >> 2];
            case "float":
              return Pa[a4 >> 2];
            case "double":
              return Qa[a4 >> 3];
            case "*":
              return J[a4 >> 2];
            default:
              E2("invalid type for getValue: " + b2);
          }
          return null;
        }
        function pa(a4) {
          var b2 = "i32";
          b2.endsWith("*") && (b2 = "*");
          switch (b2) {
            case "i1":
              r[a4 >> 0] = 0;
              break;
            case "i8":
              r[a4 >> 0] = 0;
              break;
            case "i16":
              Oa[a4 >> 1] = 0;
              break;
            case "i32":
              F[a4 >> 2] = 0;
              break;
            case "i64":
              O2 = [0, (N = 0, 1 <= +Math.abs(N) ? 0 < N ? (Math.min(+Math.floor(N / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)];
              F[a4 >> 2] = O2[0];
              F[a4 + 4 >> 2] = O2[1];
              break;
            case "float":
              Pa[a4 >> 2] = 0;
              break;
            case "double":
              Qa[a4 >> 3] = 0;
              break;
            case "*":
              J[a4 >> 2] = 0;
              break;
            default:
              E2("invalid type for setValue: " + b2);
          }
        }
        var db = (a4, b2) => {
          for (var c6 = 0, d4 = a4.length - 1; 0 <= d4; d4--) {
            var f = a4[d4];
            f === "." ? a4.splice(d4, 1) : f === ".." ? (a4.splice(d4, 1), c6++) : c6 && (a4.splice(d4, 1), c6--);
          }
          if (b2)
            for (; c6; c6--)
              a4.unshift("..");
          return a4;
        }, z2 = (a4) => {
          var b2 = a4.charAt(0) === "/", c6 = a4.substr(-1) === "/";
          (a4 = db(a4.split("/").filter((d4) => !!d4), !b2).join("/")) || b2 || (a4 = ".");
          a4 && c6 && (a4 += "/");
          return (b2 ? "/" : "") + a4;
        }, eb = (a4) => {
          var b2 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(a4).slice(1);
          a4 = b2[0];
          b2 = b2[1];
          if (!a4 && !b2)
            return ".";
          b2 && (b2 = b2.substr(0, b2.length - 1));
          return a4 + b2;
        }, fb = (a4) => {
          if (a4 === "/")
            return "/";
          a4 = z2(a4);
          a4 = a4.replace(/\/$/, "");
          var b2 = a4.lastIndexOf("/");
          return b2 === -1 ? a4 : a4.substr(b2 + 1);
        };
        function gb() {
          if (typeof crypto == "object" && typeof crypto.getRandomValues == "function") {
            var a4 = new Uint8Array(1);
            return () => {
              crypto.getRandomValues(a4);
              return a4[0];
            };
          }
          if (Aa)
            try {
              var b2 = require("crypto");
              return () => b2.randomBytes(1)[0];
            } catch (c6) {
            }
          return () => E2("randomDevice");
        }
        function hb() {
          for (var a4 = "", b2 = false, c6 = arguments.length - 1; -1 <= c6 && !b2; c6--) {
            b2 = 0 <= c6 ? arguments[c6] : "/";
            if (typeof b2 != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!b2)
              return "";
            a4 = b2 + "/" + a4;
            b2 = b2.charAt(0) === "/";
          }
          a4 = db(a4.split("/").filter((d4) => !!d4), !b2).join("/");
          return (b2 ? "/" : "") + a4 || ".";
        }
        function ma(a4, b2) {
          var c6 = Array(ca(a4) + 1);
          a4 = t3(a4, c6, 0, c6.length);
          b2 && (c6.length = a4);
          return c6;
        }
        var ib = [];
        function jb(a4, b2) {
          ib[a4] = { input: [], output: [], Xa: b2 };
          lb(a4, mb);
        }
        var mb = { open: function(a4) {
          var b2 = ib[a4.node.rdev];
          if (!b2)
            throw new P(43);
          a4.tty = b2;
          a4.seekable = false;
        }, close: function(a4) {
          a4.tty.Xa.fsync(a4.tty);
        }, fsync: function(a4) {
          a4.tty.Xa.fsync(a4.tty);
        }, read: function(a4, b2, c6, d4) {
          if (!a4.tty || !a4.tty.Xa.tb)
            throw new P(60);
          for (var f = 0, h6 = 0; h6 < d4; h6++) {
            try {
              var k2 = a4.tty.Xa.tb(a4.tty);
            } catch (q2) {
              throw new P(29);
            }
            if (k2 === void 0 && f === 0)
              throw new P(6);
            if (k2 === null || k2 === void 0)
              break;
            f++;
            b2[c6 + h6] = k2;
          }
          f && (a4.node.timestamp = Date.now());
          return f;
        }, write: function(a4, b2, c6, d4) {
          if (!a4.tty || !a4.tty.Xa.jb)
            throw new P(60);
          try {
            for (var f = 0; f < d4; f++)
              a4.tty.Xa.jb(a4.tty, b2[c6 + f]);
          } catch (h6) {
            throw new P(29);
          }
          d4 && (a4.node.timestamp = Date.now());
          return f;
        } }, tb = { tb: function(a4) {
          if (!a4.input.length) {
            var b2 = null;
            if (Aa) {
              var c6 = Buffer.alloc(256), d4 = 0;
              try {
                d4 = fs.readSync(process.stdin.fd, c6, 0, 256, -1);
              } catch (f) {
                if (f.toString().includes("EOF"))
                  d4 = 0;
                else
                  throw f;
              }
              0 < d4 ? b2 = c6.slice(0, d4).toString("utf-8") : b2 = null;
            } else
              typeof window != "undefined" && typeof window.prompt == "function" ? (b2 = window.prompt("Input: "), b2 !== null && (b2 += "\n")) : typeof readline == "function" && (b2 = readline(), b2 !== null && (b2 += "\n"));
            if (!b2)
              return null;
            a4.input = ma(b2, true);
          }
          return a4.input.shift();
        }, jb: function(a4, b2) {
          b2 === null || b2 === 10 ? (Ga(Ma(a4.output, 0)), a4.output = []) : b2 != 0 && a4.output.push(b2);
        }, fsync: function(a4) {
          a4.output && 0 < a4.output.length && (Ga(Ma(a4.output, 0)), a4.output = []);
        } }, ub = { jb: function(a4, b2) {
          b2 === null || b2 === 10 ? (Ha(Ma(a4.output, 0)), a4.output = []) : b2 != 0 && a4.output.push(b2);
        }, fsync: function(a4) {
          a4.output && 0 < a4.output.length && (Ha(Ma(a4.output, 0)), a4.output = []);
        } }, Q2 = { Qa: null, Ra: function() {
          return Q2.createNode(null, "/", 16895, 0);
        }, createNode: function(a4, b2, c6, d4) {
          if ((c6 & 61440) === 24576 || (c6 & 61440) === 4096)
            throw new P(63);
          Q2.Qa || (Q2.Qa = { dir: { node: { Pa: Q2.Ga.Pa, Oa: Q2.Ga.Oa, lookup: Q2.Ga.lookup, ab: Q2.Ga.ab, rename: Q2.Ga.rename, unlink: Q2.Ga.unlink, rmdir: Q2.Ga.rmdir, readdir: Q2.Ga.readdir, symlink: Q2.Ga.symlink }, stream: { Ta: Q2.Ha.Ta } }, file: { node: { Pa: Q2.Ga.Pa, Oa: Q2.Ga.Oa }, stream: { Ta: Q2.Ha.Ta, read: Q2.Ha.read, write: Q2.Ha.write, lb: Q2.Ha.lb, bb: Q2.Ha.bb, cb: Q2.Ha.cb } }, link: { node: { Pa: Q2.Ga.Pa, Oa: Q2.Ga.Oa, readlink: Q2.Ga.readlink }, stream: {} }, pb: {
            node: { Pa: Q2.Ga.Pa, Oa: Q2.Ga.Oa },
            stream: vb
          } });
          c6 = wb(a4, b2, c6, d4);
          (c6.mode & 61440) === 16384 ? (c6.Ga = Q2.Qa.dir.node, c6.Ha = Q2.Qa.dir.stream, c6.Ia = {}) : (c6.mode & 61440) === 32768 ? (c6.Ga = Q2.Qa.file.node, c6.Ha = Q2.Qa.file.stream, c6.Ma = 0, c6.Ia = null) : (c6.mode & 61440) === 40960 ? (c6.Ga = Q2.Qa.link.node, c6.Ha = Q2.Qa.link.stream) : (c6.mode & 61440) === 8192 && (c6.Ga = Q2.Qa.pb.node, c6.Ha = Q2.Qa.pb.stream);
          c6.timestamp = Date.now();
          a4 && (a4.Ia[b2] = c6, a4.timestamp = c6.timestamp);
          return c6;
        }, Jb: function(a4) {
          return a4.Ia ? a4.Ia.subarray ? a4.Ia.subarray(0, a4.Ma) : new Uint8Array(a4.Ia) : new Uint8Array(0);
        }, qb: function(a4, b2) {
          var c6 = a4.Ia ? a4.Ia.length : 0;
          c6 >= b2 || (b2 = Math.max(b2, c6 * (1048576 > c6 ? 2 : 1.125) >>> 0), c6 != 0 && (b2 = Math.max(b2, 256)), c6 = a4.Ia, a4.Ia = new Uint8Array(b2), 0 < a4.Ma && a4.Ia.set(c6.subarray(0, a4.Ma), 0));
        }, Gb: function(a4, b2) {
          if (a4.Ma != b2)
            if (b2 == 0)
              a4.Ia = null, a4.Ma = 0;
            else {
              var c6 = a4.Ia;
              a4.Ia = new Uint8Array(b2);
              c6 && a4.Ia.set(c6.subarray(0, Math.min(b2, a4.Ma)));
              a4.Ma = b2;
            }
        }, Ga: { Pa: function(a4) {
          var b2 = {};
          b2.dev = (a4.mode & 61440) === 8192 ? a4.id : 1;
          b2.ino = a4.id;
          b2.mode = a4.mode;
          b2.nlink = 1;
          b2.uid = 0;
          b2.gid = 0;
          b2.rdev = a4.rdev;
          (a4.mode & 61440) === 16384 ? b2.size = 4096 : (a4.mode & 61440) === 32768 ? b2.size = a4.Ma : (a4.mode & 61440) === 40960 ? b2.size = a4.link.length : b2.size = 0;
          b2.atime = new Date(a4.timestamp);
          b2.mtime = new Date(a4.timestamp);
          b2.ctime = new Date(a4.timestamp);
          b2.Ab = 4096;
          b2.blocks = Math.ceil(b2.size / b2.Ab);
          return b2;
        }, Oa: function(a4, b2) {
          b2.mode !== void 0 && (a4.mode = b2.mode);
          b2.timestamp !== void 0 && (a4.timestamp = b2.timestamp);
          b2.size !== void 0 && Q2.Gb(a4, b2.size);
        }, lookup: function() {
          throw xb[44];
        }, ab: function(a4, b2, c6, d4) {
          return Q2.createNode(a4, b2, c6, d4);
        }, rename: function(a4, b2, c6) {
          if ((a4.mode & 61440) === 16384) {
            try {
              var d4 = yb(b2, c6);
            } catch (h6) {
            }
            if (d4)
              for (var f in d4.Ia)
                throw new P(55);
          }
          delete a4.parent.Ia[a4.name];
          a4.parent.timestamp = Date.now();
          a4.name = c6;
          b2.Ia[c6] = a4;
          b2.timestamp = a4.parent.timestamp;
          a4.parent = b2;
        }, unlink: function(a4, b2) {
          delete a4.Ia[b2];
          a4.timestamp = Date.now();
        }, rmdir: function(a4, b2) {
          var c6 = yb(a4, b2), d4;
          for (d4 in c6.Ia)
            throw new P(55);
          delete a4.Ia[b2];
          a4.timestamp = Date.now();
        }, readdir: function(a4) {
          var b2 = [".", ".."], c6;
          for (c6 in a4.Ia)
            a4.Ia.hasOwnProperty(c6) && b2.push(c6);
          return b2;
        }, symlink: function(a4, b2, c6) {
          a4 = Q2.createNode(a4, b2, 41471, 0);
          a4.link = c6;
          return a4;
        }, readlink: function(a4) {
          if ((a4.mode & 61440) !== 40960)
            throw new P(28);
          return a4.link;
        } }, Ha: { read: function(a4, b2, c6, d4, f) {
          var h6 = a4.node.Ia;
          if (f >= a4.node.Ma)
            return 0;
          a4 = Math.min(a4.node.Ma - f, d4);
          if (8 < a4 && h6.subarray)
            b2.set(h6.subarray(f, f + a4), c6);
          else
            for (d4 = 0; d4 < a4; d4++)
              b2[c6 + d4] = h6[f + d4];
          return a4;
        }, write: function(a4, b2, c6, d4, f, h6) {
          b2.buffer === r.buffer && (h6 = false);
          if (!d4)
            return 0;
          a4 = a4.node;
          a4.timestamp = Date.now();
          if (b2.subarray && (!a4.Ia || a4.Ia.subarray)) {
            if (h6)
              return a4.Ia = b2.subarray(c6, c6 + d4), a4.Ma = d4;
            if (a4.Ma === 0 && f === 0)
              return a4.Ia = b2.slice(c6, c6 + d4), a4.Ma = d4;
            if (f + d4 <= a4.Ma)
              return a4.Ia.set(b2.subarray(c6, c6 + d4), f), d4;
          }
          Q2.qb(a4, f + d4);
          if (a4.Ia.subarray && b2.subarray)
            a4.Ia.set(b2.subarray(c6, c6 + d4), f);
          else
            for (h6 = 0; h6 < d4; h6++)
              a4.Ia[f + h6] = b2[c6 + h6];
          a4.Ma = Math.max(a4.Ma, f + d4);
          return d4;
        }, Ta: function(a4, b2, c6) {
          c6 === 1 ? b2 += a4.position : c6 === 2 && (a4.node.mode & 61440) === 32768 && (b2 += a4.node.Ma);
          if (0 > b2)
            throw new P(28);
          return b2;
        }, lb: function(a4, b2, c6) {
          Q2.qb(a4.node, b2 + c6);
          a4.node.Ma = Math.max(a4.node.Ma, b2 + c6);
        }, bb: function(a4, b2, c6, d4, f) {
          if ((a4.node.mode & 61440) !== 32768)
            throw new P(43);
          a4 = a4.node.Ia;
          if (f & 2 || a4.buffer !== Na) {
            if (0 < c6 || c6 + b2 < a4.length)
              a4.subarray ? a4 = a4.subarray(c6, c6 + b2) : a4 = Array.prototype.slice.call(a4, c6, c6 + b2);
            c6 = true;
            b2 = 65536 * Math.ceil(b2 / 65536);
            (f = zb(65536, b2)) ? (u2.fill(0, f, f + b2), b2 = f) : b2 = 0;
            if (!b2)
              throw new P(48);
            r.set(a4, b2);
          } else
            c6 = false, b2 = a4.byteOffset;
          return { Fb: b2, vb: c6 };
        }, cb: function(a4, b2, c6, d4, f) {
          if ((a4.node.mode & 61440) !== 32768)
            throw new P(43);
          if (f & 2)
            return 0;
          Q2.Ha.write(a4, b2, 0, d4, c6, false);
          return 0;
        } } }, Ab = null, Bb = {}, R2 = [], Cb = 1, T3 = null, Db = true, P = null, xb = {}, U = (a4, b2 = {}) => {
          a4 = hb("/", a4);
          if (!a4)
            return { path: "", node: null };
          b2 = Object.assign({ rb: true, kb: 0 }, b2);
          if (8 < b2.kb)
            throw new P(32);
          a4 = db(a4.split("/").filter((k2) => !!k2), false);
          for (var c6 = Ab, d4 = "/", f = 0; f < a4.length; f++) {
            var h6 = f === a4.length - 1;
            if (h6 && b2.parent)
              break;
            c6 = yb(c6, a4[f]);
            d4 = z2(d4 + "/" + a4[f]);
            c6.Va && (!h6 || h6 && b2.rb) && (c6 = c6.Va.root);
            if (!h6 || b2.Sa) {
              for (h6 = 0; (c6.mode & 61440) === 40960; )
                if (c6 = Eb(d4), d4 = hb(eb(d4), c6), c6 = U(d4, { kb: b2.kb + 1 }).node, 40 < h6++)
                  throw new P(32);
            }
          }
          return { path: d4, node: c6 };
        }, ea = (a4) => {
          for (var b2; ; ) {
            if (a4 === a4.parent)
              return a4 = a4.Ra.ub, b2 ? a4[a4.length - 1] !== "/" ? a4 + "/" + b2 : a4 + b2 : a4;
            b2 = b2 ? a4.name + "/" + b2 : a4.name;
            a4 = a4.parent;
          }
        }, Fb = (a4, b2) => {
          for (var c6 = 0, d4 = 0; d4 < b2.length; d4++)
            c6 = (c6 << 5) - c6 + b2.charCodeAt(d4) | 0;
          return (a4 + c6 >>> 0) % T3.length;
        }, Gb = (a4) => {
          var b2 = Fb(a4.parent.id, a4.name);
          if (T3[b2] === a4)
            T3[b2] = a4.Wa;
          else
            for (b2 = T3[b2]; b2; ) {
              if (b2.Wa === a4) {
                b2.Wa = a4.Wa;
                break;
              }
              b2 = b2.Wa;
            }
        }, yb = (a4, b2) => {
          var c6;
          if (c6 = (c6 = Hb(a4, "x")) ? c6 : a4.Ga.lookup ? 0 : 2)
            throw new P(c6, a4);
          for (c6 = T3[Fb(a4.id, b2)]; c6; c6 = c6.Wa) {
            var d4 = c6.name;
            if (c6.parent.id === a4.id && d4 === b2)
              return c6;
          }
          return a4.Ga.lookup(a4, b2);
        }, wb = (a4, b2, c6, d4) => {
          a4 = new Ib(a4, b2, c6, d4);
          b2 = Fb(a4.parent.id, a4.name);
          a4.Wa = T3[b2];
          return T3[b2] = a4;
        }, Jb = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }, Kb = (a4) => {
          var b2 = ["r", "w", "rw"][a4 & 3];
          a4 & 512 && (b2 += "w");
          return b2;
        }, Hb = (a4, b2) => {
          if (Db)
            return 0;
          if (!b2.includes("r") || a4.mode & 292) {
            if (b2.includes("w") && !(a4.mode & 146) || b2.includes("x") && !(a4.mode & 73))
              return 2;
          } else
            return 2;
          return 0;
        }, Lb = (a4, b2) => {
          try {
            return yb(a4, b2), 20;
          } catch (c6) {
          }
          return Hb(a4, "wx");
        }, Mb = (a4, b2, c6) => {
          try {
            var d4 = yb(a4, b2);
          } catch (f) {
            return f.Ka;
          }
          if (a4 = Hb(a4, "wx"))
            return a4;
          if (c6) {
            if ((d4.mode & 61440) !== 16384)
              return 54;
            if (d4 === d4.parent || ea(d4) === "/")
              return 10;
          } else if ((d4.mode & 61440) === 16384)
            return 31;
          return 0;
        }, Nb = (a4 = 0) => {
          for (; 4096 >= a4; a4++)
            if (!R2[a4])
              return a4;
          throw new P(33);
        }, Pb = (a4, b2) => {
          Ob || (Ob = function() {
            this.$a = {};
          }, Ob.prototype = {}, Object.defineProperties(Ob.prototype, { object: { get: function() {
            return this.node;
          }, set: function(c6) {
            this.node = c6;
          } }, flags: { get: function() {
            return this.$a.flags;
          }, set: function(c6) {
            this.$a.flags = c6;
          } }, position: { get: function() {
            return this.$a.position;
          }, set: function(c6) {
            this.$a.position = c6;
          } } }));
          a4 = Object.assign(new Ob(), a4);
          b2 = Nb(b2);
          a4.fd = b2;
          return R2[b2] = a4;
        }, vb = { open: (a4) => {
          a4.Ha = Bb[a4.node.rdev].Ha;
          a4.Ha.open && a4.Ha.open(a4);
        }, Ta: () => {
          throw new P(70);
        } }, lb = (a4, b2) => {
          Bb[a4] = { Ha: b2 };
        }, Qb = (a4, b2) => {
          var c6 = b2 === "/", d4 = !b2;
          if (c6 && Ab)
            throw new P(10);
          if (!c6 && !d4) {
            var f = U(b2, { rb: false });
            b2 = f.path;
            f = f.node;
            if (f.Va)
              throw new P(10);
            if ((f.mode & 61440) !== 16384)
              throw new P(54);
          }
          b2 = { type: a4, Kb: {}, ub: b2, Eb: [] };
          a4 = a4.Ra(b2);
          a4.Ra = b2;
          b2.root = a4;
          c6 ? Ab = a4 : f && (f.Va = b2, f.Ra && f.Ra.Eb.push(b2));
        }, ha = (a4, b2, c6) => {
          var d4 = U(a4, { parent: true }).node;
          a4 = fb(a4);
          if (!a4 || a4 === "." || a4 === "..")
            throw new P(28);
          var f = Lb(d4, a4);
          if (f)
            throw new P(f);
          if (!d4.Ga.ab)
            throw new P(63);
          return d4.Ga.ab(d4, a4, b2, c6);
        }, V = (a4, b2) => ha(a4, (b2 !== void 0 ? b2 : 511) & 1023 | 16384, 0), Rb = (a4, b2, c6) => {
          typeof c6 == "undefined" && (c6 = b2, b2 = 438);
          ha(a4, b2 | 8192, c6);
        }, Sb = (a4, b2) => {
          if (!hb(a4))
            throw new P(44);
          var c6 = U(b2, { parent: true }).node;
          if (!c6)
            throw new P(44);
          b2 = fb(b2);
          var d4 = Lb(c6, b2);
          if (d4)
            throw new P(d4);
          if (!c6.Ga.symlink)
            throw new P(63);
          c6.Ga.symlink(c6, b2, a4);
        }, Tb = (a4) => {
          var b2 = U(a4, { parent: true }).node;
          a4 = fb(a4);
          var c6 = yb(b2, a4), d4 = Mb(b2, a4, true);
          if (d4)
            throw new P(d4);
          if (!b2.Ga.rmdir)
            throw new P(63);
          if (c6.Va)
            throw new P(10);
          b2.Ga.rmdir(b2, a4);
          Gb(c6);
        }, ta = (a4) => {
          var b2 = U(a4, { parent: true }).node;
          if (!b2)
            throw new P(44);
          a4 = fb(a4);
          var c6 = yb(b2, a4), d4 = Mb(b2, a4, false);
          if (d4)
            throw new P(d4);
          if (!b2.Ga.unlink)
            throw new P(63);
          if (c6.Va)
            throw new P(10);
          b2.Ga.unlink(b2, a4);
          Gb(c6);
        }, Eb = (a4) => {
          a4 = U(a4).node;
          if (!a4)
            throw new P(44);
          if (!a4.Ga.readlink)
            throw new P(28);
          return hb(ea(a4.parent), a4.Ga.readlink(a4));
        }, Ub = (a4, b2) => {
          a4 = U(a4, { Sa: !b2 }).node;
          if (!a4)
            throw new P(44);
          if (!a4.Ga.Pa)
            throw new P(63);
          return a4.Ga.Pa(a4);
        }, Vb = (a4) => Ub(a4, true), ia = (a4, b2) => {
          a4 = typeof a4 == "string" ? U(a4, { Sa: true }).node : a4;
          if (!a4.Ga.Oa)
            throw new P(63);
          a4.Ga.Oa(a4, { mode: b2 & 4095 | a4.mode & -4096, timestamp: Date.now() });
        }, Wb = (a4, b2) => {
          if (0 > b2)
            throw new P(28);
          a4 = typeof a4 == "string" ? U(a4, { Sa: true }).node : a4;
          if (!a4.Ga.Oa)
            throw new P(63);
          if ((a4.mode & 61440) === 16384)
            throw new P(31);
          if ((a4.mode & 61440) !== 32768)
            throw new P(28);
          var c6 = Hb(a4, "w");
          if (c6)
            throw new P(c6);
          a4.Ga.Oa(a4, { size: b2, timestamp: Date.now() });
        }, ja = (a4, b2, c6) => {
          if (a4 === "")
            throw new P(44);
          if (typeof b2 == "string") {
            var d4 = Jb[b2];
            if (typeof d4 == "undefined")
              throw Error("Unknown file open mode: " + b2);
            b2 = d4;
          }
          c6 = b2 & 64 ? (typeof c6 == "undefined" ? 438 : c6) & 4095 | 32768 : 0;
          if (typeof a4 == "object")
            var f = a4;
          else {
            a4 = z2(a4);
            try {
              f = U(a4, { Sa: !(b2 & 131072) }).node;
            } catch (h6) {
            }
          }
          d4 = false;
          if (b2 & 64)
            if (f) {
              if (b2 & 128)
                throw new P(20);
            } else
              f = ha(a4, c6, 0), d4 = true;
          if (!f)
            throw new P(44);
          (f.mode & 61440) === 8192 && (b2 &= -513);
          if (b2 & 65536 && (f.mode & 61440) !== 16384)
            throw new P(54);
          if (!d4 && (c6 = f ? (f.mode & 61440) === 40960 ? 32 : (f.mode & 61440) === 16384 && (Kb(b2) !== "r" || b2 & 512) ? 31 : Hb(f, Kb(b2)) : 44))
            throw new P(c6);
          b2 & 512 && !d4 && Wb(f, 0);
          b2 &= -131713;
          f = Pb({ node: f, path: ea(f), flags: b2, seekable: true, position: 0, Ha: f.Ha, Ib: [], error: false });
          f.Ha.open && f.Ha.open(f);
          !e3.logReadFiles || b2 & 1 || (Xb || (Xb = {}), a4 in Xb || (Xb[a4] = 1));
          return f;
        }, la = (a4) => {
          if (a4.fd === null)
            throw new P(8);
          a4.hb && (a4.hb = null);
          try {
            a4.Ha.close && a4.Ha.close(a4);
          } catch (b2) {
            throw b2;
          } finally {
            R2[a4.fd] = null;
          }
          a4.fd = null;
        }, Yb = (a4, b2, c6) => {
          if (a4.fd === null)
            throw new P(8);
          if (!a4.seekable || !a4.Ha.Ta)
            throw new P(70);
          if (c6 != 0 && c6 != 1 && c6 != 2)
            throw new P(28);
          a4.position = a4.Ha.Ta(a4, b2, c6);
          a4.Ib = [];
        }, Zb = (a4, b2, c6, d4, f) => {
          if (0 > d4 || 0 > f)
            throw new P(28);
          if (a4.fd === null)
            throw new P(8);
          if ((a4.flags & 2097155) === 1)
            throw new P(8);
          if ((a4.node.mode & 61440) === 16384)
            throw new P(31);
          if (!a4.Ha.read)
            throw new P(28);
          var h6 = typeof f != "undefined";
          if (!h6)
            f = a4.position;
          else if (!a4.seekable)
            throw new P(70);
          b2 = a4.Ha.read(a4, b2, c6, d4, f);
          h6 || (a4.position += b2);
          return b2;
        }, ka = (a4, b2, c6, d4, f) => {
          if (0 > d4 || 0 > f)
            throw new P(28);
          if (a4.fd === null)
            throw new P(8);
          if ((a4.flags & 2097155) === 0)
            throw new P(8);
          if ((a4.node.mode & 61440) === 16384)
            throw new P(31);
          if (!a4.Ha.write)
            throw new P(28);
          a4.seekable && a4.flags & 1024 && Yb(a4, 0, 2);
          var h6 = typeof f != "undefined";
          if (!h6)
            f = a4.position;
          else if (!a4.seekable)
            throw new P(70);
          b2 = a4.Ha.write(a4, b2, c6, d4, f, void 0);
          h6 || (a4.position += b2);
          return b2;
        }, sa = (a4) => {
          var b2 = "binary";
          if (b2 !== "utf8" && b2 !== "binary")
            throw Error('Invalid encoding type "' + b2 + '"');
          var c6;
          var d4 = ja(a4, d4 || 0);
          a4 = Ub(a4).size;
          var f = new Uint8Array(a4);
          Zb(d4, f, 0, a4, 0);
          b2 === "utf8" ? c6 = Ma(f, 0) : b2 === "binary" && (c6 = f);
          la(d4);
          return c6;
        }, $b = () => {
          P || (P = function(a4, b2) {
            this.node = b2;
            this.Hb = function(c6) {
              this.Ka = c6;
            };
            this.Hb(a4);
            this.message = "FS error";
          }, P.prototype = Error(), P.prototype.constructor = P, [44].forEach((a4) => {
            xb[a4] = new P(a4);
            xb[a4].stack = "<generic error, no stack>";
          }));
        }, ac, fa = (a4, b2) => {
          var c6 = 0;
          a4 && (c6 |= 365);
          b2 && (c6 |= 146);
          return c6;
        }, cc = (a4, b2, c6) => {
          a4 = z2("/dev/" + a4);
          var d4 = fa(!!b2, !!c6);
          bc || (bc = 64);
          var f = bc++ << 8 | 0;
          lb(f, { open: (h6) => {
            h6.seekable = false;
          }, close: () => {
            c6 && c6.buffer && c6.buffer.length && c6(10);
          }, read: (h6, k2, q2, x2) => {
            for (var w3 = 0, A2 = 0; A2 < x2; A2++) {
              try {
                var S3 = b2();
              } catch (nb) {
                throw new P(29);
              }
              if (S3 === void 0 && w3 === 0)
                throw new P(6);
              if (S3 === null || S3 === void 0)
                break;
              w3++;
              k2[q2 + A2] = S3;
            }
            w3 && (h6.node.timestamp = Date.now());
            return w3;
          }, write: (h6, k2, q2, x2) => {
            for (var w3 = 0; w3 < x2; w3++)
              try {
                c6(k2[q2 + w3]);
              } catch (A2) {
                throw new P(29);
              }
            x2 && (h6.node.timestamp = Date.now());
            return w3;
          } });
          Rb(a4, d4, f);
        }, bc, W = {}, Ob, Xb;
        function dc(a4, b2, c6) {
          if (b2.charAt(0) === "/")
            return b2;
          a4 = a4 === -100 ? "/" : X2(a4).path;
          if (b2.length == 0) {
            if (!c6)
              throw new P(44);
            return a4;
          }
          return z2(a4 + "/" + b2);
        }
        function ec(a4, b2, c6) {
          try {
            var d4 = a4(b2);
          } catch (f) {
            if (f && f.node && z2(b2) !== z2(ea(f.node)))
              return -54;
            throw f;
          }
          F[c6 >> 2] = d4.dev;
          F[c6 + 8 >> 2] = d4.ino;
          F[c6 + 12 >> 2] = d4.mode;
          J[c6 + 16 >> 2] = d4.nlink;
          F[c6 + 20 >> 2] = d4.uid;
          F[c6 + 24 >> 2] = d4.gid;
          F[c6 + 28 >> 2] = d4.rdev;
          O2 = [d4.size >>> 0, (N = d4.size, 1 <= +Math.abs(N) ? 0 < N ? (Math.min(+Math.floor(N / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)];
          F[c6 + 40 >> 2] = O2[0];
          F[c6 + 44 >> 2] = O2[1];
          F[c6 + 48 >> 2] = 4096;
          F[c6 + 52 >> 2] = d4.blocks;
          O2 = [Math.floor(d4.atime.getTime() / 1e3) >>> 0, (N = Math.floor(d4.atime.getTime() / 1e3), 1 <= +Math.abs(N) ? 0 < N ? (Math.min(+Math.floor(N / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)];
          F[c6 + 56 >> 2] = O2[0];
          F[c6 + 60 >> 2] = O2[1];
          J[c6 + 64 >> 2] = 0;
          O2 = [Math.floor(d4.mtime.getTime() / 1e3) >>> 0, (N = Math.floor(d4.mtime.getTime() / 1e3), 1 <= +Math.abs(N) ? 0 < N ? (Math.min(+Math.floor(N / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)];
          F[c6 + 72 >> 2] = O2[0];
          F[c6 + 76 >> 2] = O2[1];
          J[c6 + 80 >> 2] = 0;
          O2 = [Math.floor(d4.ctime.getTime() / 1e3) >>> 0, (N = Math.floor(d4.ctime.getTime() / 1e3), 1 <= +Math.abs(N) ? 0 < N ? (Math.min(+Math.floor(N / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)];
          F[c6 + 88 >> 2] = O2[0];
          F[c6 + 92 >> 2] = O2[1];
          J[c6 + 96 >> 2] = 0;
          O2 = [d4.ino >>> 0, (N = d4.ino, 1 <= +Math.abs(N) ? 0 < N ? (Math.min(+Math.floor(N / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)];
          F[c6 + 104 >> 2] = O2[0];
          F[c6 + 108 >> 2] = O2[1];
          return 0;
        }
        var fc = void 0;
        function Hc() {
          fc += 4;
          return F[fc - 4 >> 2];
        }
        function X2(a4) {
          a4 = R2[a4];
          if (!a4)
            throw new P(8);
          return a4;
        }
        function Jc(a4) {
          return J[a4 >> 2] + 4294967296 * F[a4 + 4 >> 2];
        }
        function Kc(a4) {
          var b2 = ca(a4) + 1, c6 = da(b2);
          c6 && t3(a4, r, c6, b2);
          return c6;
        }
        function Lc(a4, b2, c6) {
          function d4(x2) {
            return (x2 = x2.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? x2[1] : "GMT";
          }
          var f = new Date().getFullYear(), h6 = new Date(f, 0, 1), k2 = new Date(f, 6, 1);
          f = h6.getTimezoneOffset();
          var q2 = k2.getTimezoneOffset();
          F[a4 >> 2] = 60 * Math.max(f, q2);
          F[b2 >> 2] = Number(f != q2);
          a4 = d4(h6);
          b2 = d4(k2);
          a4 = Kc(a4);
          b2 = Kc(b2);
          q2 < f ? (J[c6 >> 2] = a4, J[c6 + 4 >> 2] = b2) : (J[c6 >> 2] = b2, J[c6 + 4 >> 2] = a4);
        }
        function Mc(a4, b2, c6) {
          Mc.Bb || (Mc.Bb = true, Lc(a4, b2, c6));
        }
        var Nc;
        Nc = Aa ? () => {
          var a4 = process.hrtime();
          return 1e3 * a4[0] + a4[1] / 1e6;
        } : () => performance.now();
        var Oc = {};
        function Pc() {
          if (!Qc) {
            var a4 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: wa || "./this.program" }, b2;
            for (b2 in Oc)
              Oc[b2] === void 0 ? delete a4[b2] : a4[b2] = Oc[b2];
            var c6 = [];
            for (b2 in a4)
              c6.push(b2 + "=" + a4[b2]);
            Qc = c6;
          }
          return Qc;
        }
        var Qc, Y2 = void 0, Rc = [];
        function ua(a4, b2) {
          if (!Y2) {
            Y2 = /* @__PURE__ */ new WeakMap();
            var c6 = K2.length;
            if (Y2)
              for (var d4 = 0; d4 < 0 + c6; d4++) {
                var f = K2.get(d4);
                f && Y2.set(f, d4);
              }
          }
          if (Y2.has(a4))
            return Y2.get(a4);
          if (Rc.length)
            c6 = Rc.pop();
          else {
            try {
              K2.grow(1);
            } catch (q2) {
              if (!(q2 instanceof RangeError))
                throw q2;
              throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            c6 = K2.length - 1;
          }
          try {
            K2.set(c6, a4);
          } catch (q2) {
            if (!(q2 instanceof TypeError))
              throw q2;
            if (typeof WebAssembly.Function == "function") {
              d4 = WebAssembly.Function;
              f = { i: "i32", j: "i64", f: "f32", d: "f64", p: "i32" };
              for (var h6 = { parameters: [], results: b2[0] == "v" ? [] : [f[b2[0]]] }, k2 = 1; k2 < b2.length; ++k2)
                h6.parameters.push(f[b2[k2]]);
              b2 = new d4(h6, a4);
            } else {
              d4 = [1, 96];
              f = b2.slice(0, 1);
              b2 = b2.slice(1);
              h6 = { i: 127, p: 127, j: 126, f: 125, d: 124 };
              k2 = b2.length;
              128 > k2 ? d4.push(k2) : d4.push(k2 % 128 | 128, k2 >> 7);
              for (k2 = 0; k2 < b2.length; ++k2)
                d4.push(h6[b2[k2]]);
              f == "v" ? d4.push(0) : d4.push(1, h6[f]);
              b2 = [0, 97, 115, 109, 1, 0, 0, 0, 1];
              f = d4.length;
              128 > f ? b2.push(f) : b2.push(f % 128 | 128, f >> 7);
              b2.push.apply(b2, d4);
              b2.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
              b2 = new WebAssembly.Module(new Uint8Array(b2));
              b2 = new WebAssembly.Instance(b2, { e: { f: a4 } }).exports.f;
            }
            K2.set(c6, b2);
          }
          Y2.set(a4, c6);
          return c6;
        }
        function ra(a4) {
          Y2.delete(K2.get(a4));
          Rc.push(a4);
        }
        var Sc = 0, Tc = 1;
        function aa(a4) {
          var b2 = Sc == Tc ? B2(a4.length) : da(a4.length);
          a4.subarray || a4.slice || (a4 = new Uint8Array(a4));
          u2.set(a4, b2);
          return b2;
        }
        function Uc(a4, b2, c6, d4) {
          var f = { string: (w3) => {
            var A2 = 0;
            if (w3 !== null && w3 !== void 0 && w3 !== 0) {
              var S3 = (w3.length << 2) + 1;
              A2 = B2(S3);
              t3(w3, u2, A2, S3);
            }
            return A2;
          }, array: (w3) => {
            var A2 = B2(w3.length);
            r.set(w3, A2);
            return A2;
          } };
          a4 = e3["_" + a4];
          var h6 = [], k2 = 0;
          if (d4)
            for (var q2 = 0; q2 < d4.length; q2++) {
              var x2 = f[c6[q2]];
              x2 ? (k2 === 0 && (k2 = oa()), h6[q2] = x2(d4[q2])) : h6[q2] = d4[q2];
            }
          c6 = a4.apply(null, h6);
          return c6 = function(w3) {
            k2 !== 0 && qa(k2);
            return b2 === "string" ? C(w3) : b2 === "boolean" ? !!w3 : w3;
          }(c6);
        }
        function Ib(a4, b2, c6, d4) {
          a4 || (a4 = this);
          this.parent = a4;
          this.Ra = a4.Ra;
          this.Va = null;
          this.id = Cb++;
          this.name = b2;
          this.mode = c6;
          this.Ga = {};
          this.Ha = {};
          this.rdev = d4;
        }
        Object.defineProperties(Ib.prototype, { read: { get: function() {
          return (this.mode & 365) === 365;
        }, set: function(a4) {
          a4 ? this.mode |= 365 : this.mode &= -366;
        } }, write: { get: function() {
          return (this.mode & 146) === 146;
        }, set: function(a4) {
          a4 ? this.mode |= 146 : this.mode &= -147;
        } } });
        $b();
        T3 = Array(4096);
        Qb(Q2, "/");
        V("/tmp");
        V("/home");
        V("/home/web_user");
        (() => {
          V("/dev");
          lb(259, { read: () => 0, write: (b2, c6, d4, f) => f });
          Rb("/dev/null", 259);
          jb(1280, tb);
          jb(1536, ub);
          Rb("/dev/tty", 1280);
          Rb("/dev/tty1", 1536);
          var a4 = gb();
          cc("random", a4);
          cc("urandom", a4);
          V("/dev/shm");
          V("/dev/shm/tmp");
        })();
        (() => {
          V("/proc");
          var a4 = V("/proc/self");
          V("/proc/self/fd");
          Qb({ Ra: () => {
            var b2 = wb(a4, "fd", 16895, 73);
            b2.Ga = { lookup: (c6, d4) => {
              var f = R2[+d4];
              if (!f)
                throw new P(8);
              c6 = { parent: null, Ra: { ub: "fake" }, Ga: { readlink: () => f.path } };
              return c6.parent = c6;
            } };
            return b2;
          } }, "/proc/self/fd");
        })();
        var Wc = { a: function(a4, b2, c6, d4) {
          E2("Assertion failed: " + C(a4) + ", at: " + [b2 ? C(b2) : "unknown filename", c6, d4 ? C(d4) : "unknown function"]);
        }, h: function(a4, b2) {
          try {
            return a4 = C(a4), ia(a4, b2), 0;
          } catch (c6) {
            if (typeof W == "undefined" || !(c6 instanceof P))
              throw c6;
            return -c6.Ka;
          }
        }, H: function(a4, b2, c6) {
          try {
            b2 = C(b2);
            b2 = dc(a4, b2);
            if (c6 & -8)
              return -28;
            var d4 = U(b2, { Sa: true }).node;
            if (!d4)
              return -44;
            a4 = "";
            c6 & 4 && (a4 += "r");
            c6 & 2 && (a4 += "w");
            c6 & 1 && (a4 += "x");
            return a4 && Hb(d4, a4) ? -2 : 0;
          } catch (f) {
            if (typeof W == "undefined" || !(f instanceof P))
              throw f;
            return -f.Ka;
          }
        }, i: function(a4, b2) {
          try {
            var c6 = R2[a4];
            if (!c6)
              throw new P(8);
            ia(c6.node, b2);
            return 0;
          } catch (d4) {
            if (typeof W == "undefined" || !(d4 instanceof P))
              throw d4;
            return -d4.Ka;
          }
        }, g: function(a4) {
          try {
            var b2 = R2[a4];
            if (!b2)
              throw new P(8);
            var c6 = b2.node;
            var d4 = typeof c6 == "string" ? U(c6, { Sa: true }).node : c6;
            if (!d4.Ga.Oa)
              throw new P(63);
            d4.Ga.Oa(d4, { timestamp: Date.now() });
            return 0;
          } catch (f) {
            if (typeof W == "undefined" || !(f instanceof P))
              throw f;
            return -f.Ka;
          }
        }, b: function(a4, b2, c6) {
          fc = c6;
          try {
            var d4 = X2(a4);
            switch (b2) {
              case 0:
                var f = Hc();
                return 0 > f ? -28 : Pb(d4, f).fd;
              case 1:
              case 2:
                return 0;
              case 3:
                return d4.flags;
              case 4:
                return f = Hc(), d4.flags |= f, 0;
              case 5:
                return f = Hc(), Oa[f + 0 >> 1] = 2, 0;
              case 6:
              case 7:
                return 0;
              case 16:
              case 8:
                return -28;
              case 9:
                return F[Vc() >> 2] = 28, -1;
              default:
                return -28;
            }
          } catch (h6) {
            if (typeof W == "undefined" || !(h6 instanceof P))
              throw h6;
            return -h6.Ka;
          }
        }, G: function(a4, b2) {
          try {
            var c6 = X2(a4);
            return ec(Ub, c6.path, b2);
          } catch (d4) {
            if (typeof W == "undefined" || !(d4 instanceof P))
              throw d4;
            return -d4.Ka;
          }
        }, l: function(a4, b2, c6) {
          try {
            b2 = c6 + 2097152 >>> 0 < 4194305 - !!b2 ? (b2 >>> 0) + 4294967296 * c6 : NaN;
            if (isNaN(b2))
              return -61;
            var d4 = R2[a4];
            if (!d4)
              throw new P(8);
            if ((d4.flags & 2097155) === 0)
              throw new P(28);
            Wb(d4.node, b2);
            return 0;
          } catch (f) {
            if (typeof W == "undefined" || !(f instanceof P))
              throw f;
            return -f.Ka;
          }
        }, B: function(a4, b2) {
          try {
            if (b2 === 0)
              return -28;
            var c6 = ca("/") + 1;
            if (b2 < c6)
              return -68;
            t3("/", u2, a4, b2);
            return c6;
          } catch (d4) {
            if (typeof W == "undefined" || !(d4 instanceof P))
              throw d4;
            return -d4.Ka;
          }
        }, E: function(a4, b2) {
          try {
            return a4 = C(a4), ec(Vb, a4, b2);
          } catch (c6) {
            if (typeof W == "undefined" || !(c6 instanceof P))
              throw c6;
            return -c6.Ka;
          }
        }, y: function(a4, b2, c6) {
          try {
            return b2 = C(b2), b2 = dc(a4, b2), b2 = z2(b2), b2[b2.length - 1] === "/" && (b2 = b2.substr(0, b2.length - 1)), V(b2, c6), 0;
          } catch (d4) {
            if (typeof W == "undefined" || !(d4 instanceof P))
              throw d4;
            return -d4.Ka;
          }
        }, D: function(a4, b2, c6, d4) {
          try {
            b2 = C(b2);
            var f = d4 & 256;
            b2 = dc(a4, b2, d4 & 4096);
            return ec(f ? Vb : Ub, b2, c6);
          } catch (h6) {
            if (typeof W == "undefined" || !(h6 instanceof P))
              throw h6;
            return -h6.Ka;
          }
        }, v: function(a4, b2, c6, d4) {
          fc = d4;
          try {
            b2 = C(b2);
            b2 = dc(a4, b2);
            var f = d4 ? Hc() : 0;
            return ja(b2, c6, f).fd;
          } catch (h6) {
            if (typeof W == "undefined" || !(h6 instanceof P))
              throw h6;
            return -h6.Ka;
          }
        }, t: function(a4, b2, c6, d4) {
          try {
            b2 = C(b2);
            b2 = dc(a4, b2);
            if (0 >= d4)
              return -28;
            var f = Eb(b2), h6 = Math.min(d4, ca(f)), k2 = r[c6 + h6];
            t3(f, u2, c6, d4 + 1);
            r[c6 + h6] = k2;
            return h6;
          } catch (q2) {
            if (typeof W == "undefined" || !(q2 instanceof P))
              throw q2;
            return -q2.Ka;
          }
        }, s: function(a4) {
          try {
            return a4 = C(a4), Tb(a4), 0;
          } catch (b2) {
            if (typeof W == "undefined" || !(b2 instanceof P))
              throw b2;
            return -b2.Ka;
          }
        }, F: function(a4, b2) {
          try {
            return a4 = C(a4), ec(Ub, a4, b2);
          } catch (c6) {
            if (typeof W == "undefined" || !(c6 instanceof P))
              throw c6;
            return -c6.Ka;
          }
        }, p: function(a4, b2, c6) {
          try {
            return b2 = C(b2), b2 = dc(a4, b2), c6 === 0 ? ta(b2) : c6 === 512 ? Tb(b2) : E2("Invalid flags passed to unlinkat"), 0;
          } catch (d4) {
            if (typeof W == "undefined" || !(d4 instanceof P))
              throw d4;
            return -d4.Ka;
          }
        }, o: function(a4, b2, c6) {
          try {
            b2 = C(b2);
            b2 = dc(a4, b2, true);
            if (c6) {
              var d4 = Jc(c6), f = F[c6 + 8 >> 2];
              h6 = 1e3 * d4 + f / 1e6;
              c6 += 16;
              d4 = Jc(c6);
              f = F[c6 + 8 >> 2];
              k2 = 1e3 * d4 + f / 1e6;
            } else
              var h6 = Date.now(), k2 = h6;
            a4 = h6;
            var q2 = U(b2, { Sa: true }).node;
            q2.Ga.Oa(q2, { timestamp: Math.max(a4, k2) });
            return 0;
          } catch (x2) {
            if (typeof W == "undefined" || !(x2 instanceof P))
              throw x2;
            return -x2.Ka;
          }
        }, e: function() {
          return Date.now();
        }, j: function(a4, b2) {
          a4 = new Date(1e3 * Jc(a4));
          F[b2 >> 2] = a4.getSeconds();
          F[b2 + 4 >> 2] = a4.getMinutes();
          F[b2 + 8 >> 2] = a4.getHours();
          F[b2 + 12 >> 2] = a4.getDate();
          F[b2 + 16 >> 2] = a4.getMonth();
          F[b2 + 20 >> 2] = a4.getFullYear() - 1900;
          F[b2 + 24 >> 2] = a4.getDay();
          var c6 = new Date(a4.getFullYear(), 0, 1);
          F[b2 + 28 >> 2] = (a4.getTime() - c6.getTime()) / 864e5 | 0;
          F[b2 + 36 >> 2] = -(60 * a4.getTimezoneOffset());
          var d4 = new Date(a4.getFullYear(), 6, 1).getTimezoneOffset();
          c6 = c6.getTimezoneOffset();
          F[b2 + 32 >> 2] = (d4 != c6 && a4.getTimezoneOffset() == Math.min(c6, d4)) | 0;
        }, w: function(a4, b2, c6, d4, f, h6) {
          try {
            var k2 = X2(d4);
            if ((b2 & 2) !== 0 && (c6 & 2) === 0 && (k2.flags & 2097155) !== 2)
              throw new P(2);
            if ((k2.flags & 2097155) === 1)
              throw new P(2);
            if (!k2.Ha.bb)
              throw new P(43);
            var q2 = k2.Ha.bb(k2, a4, f, b2, c6);
            var x2 = q2.Fb;
            F[h6 >> 2] = q2.vb;
            return x2;
          } catch (w3) {
            if (typeof W == "undefined" || !(w3 instanceof P))
              throw w3;
            return -w3.Ka;
          }
        }, x: function(a4, b2, c6, d4, f, h6) {
          try {
            var k2 = X2(f);
            if (c6 & 2) {
              var q2 = u2.slice(a4, a4 + b2);
              k2 && k2.Ha.cb && k2.Ha.cb(k2, q2, h6, b2, d4);
            }
          } catch (x2) {
            if (typeof W == "undefined" || !(x2 instanceof P))
              throw x2;
            return -x2.Ka;
          }
        }, n: Mc, q: function() {
          return 2147483648;
        }, d: Nc, c: function(a4) {
          var b2 = u2.length;
          a4 >>>= 0;
          if (2147483648 < a4)
            return false;
          for (var c6 = 1; 4 >= c6; c6 *= 2) {
            var d4 = b2 * (1 + 0.2 / c6);
            d4 = Math.min(d4, a4 + 100663296);
            var f = Math;
            d4 = Math.max(a4, d4);
            f = f.min.call(f, 2147483648, d4 + (65536 - d4 % 65536) % 65536);
            a: {
              try {
                Ja.grow(f - Na.byteLength + 65535 >>> 16);
                Ra();
                var h6 = 1;
                break a;
              } catch (k2) {
              }
              h6 = void 0;
            }
            if (h6)
              return true;
          }
          return false;
        }, z: function(a4, b2) {
          var c6 = 0;
          Pc().forEach(function(d4, f) {
            var h6 = b2 + c6;
            f = J[a4 + 4 * f >> 2] = h6;
            for (h6 = 0; h6 < d4.length; ++h6)
              r[f++ >> 0] = d4.charCodeAt(h6);
            r[f >> 0] = 0;
            c6 += d4.length + 1;
          });
          return 0;
        }, A: function(a4, b2) {
          var c6 = Pc();
          J[a4 >> 2] = c6.length;
          var d4 = 0;
          c6.forEach(function(f) {
            d4 += f.length + 1;
          });
          J[b2 >> 2] = d4;
          return 0;
        }, f: function(a4) {
          try {
            var b2 = X2(a4);
            la(b2);
            return 0;
          } catch (c6) {
            if (typeof W == "undefined" || !(c6 instanceof P))
              throw c6;
            return c6.Ka;
          }
        }, m: function(a4, b2) {
          try {
            var c6 = X2(a4);
            r[b2 >> 0] = c6.tty ? 2 : (c6.mode & 61440) === 16384 ? 3 : (c6.mode & 61440) === 40960 ? 7 : 4;
            return 0;
          } catch (d4) {
            if (typeof W == "undefined" || !(d4 instanceof P))
              throw d4;
            return d4.Ka;
          }
        }, u: function(a4, b2, c6, d4) {
          try {
            a: {
              var f = X2(a4);
              a4 = b2;
              for (var h6 = b2 = 0; h6 < c6; h6++) {
                var k2 = J[a4 >> 2], q2 = J[a4 + 4 >> 2];
                a4 += 8;
                var x2 = Zb(f, r, k2, q2);
                if (0 > x2) {
                  var w3 = -1;
                  break a;
                }
                b2 += x2;
                if (x2 < q2)
                  break;
              }
              w3 = b2;
            }
            J[d4 >> 2] = w3;
            return 0;
          } catch (A2) {
            if (typeof W == "undefined" || !(A2 instanceof P))
              throw A2;
            return A2.Ka;
          }
        }, k: function(a4, b2, c6, d4, f) {
          try {
            b2 = c6 + 2097152 >>> 0 < 4194305 - !!b2 ? (b2 >>> 0) + 4294967296 * c6 : NaN;
            if (isNaN(b2))
              return 61;
            var h6 = X2(a4);
            Yb(h6, b2, d4);
            O2 = [h6.position >>> 0, (N = h6.position, 1 <= +Math.abs(N) ? 0 < N ? (Math.min(+Math.floor(N / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)];
            F[f >> 2] = O2[0];
            F[f + 4 >> 2] = O2[1];
            h6.hb && b2 === 0 && d4 === 0 && (h6.hb = null);
            return 0;
          } catch (k2) {
            if (typeof W == "undefined" || !(k2 instanceof P))
              throw k2;
            return k2.Ka;
          }
        }, C: function(a4) {
          try {
            var b2 = X2(a4);
            return b2.Ha && b2.Ha.fsync ? b2.Ha.fsync(b2) : 0;
          } catch (c6) {
            if (typeof W == "undefined" || !(c6 instanceof P))
              throw c6;
            return c6.Ka;
          }
        }, r: function(a4, b2, c6, d4) {
          try {
            a: {
              var f = X2(a4);
              a4 = b2;
              for (var h6 = b2 = 0; h6 < c6; h6++) {
                var k2 = J[a4 >> 2], q2 = J[a4 + 4 >> 2];
                a4 += 8;
                var x2 = ka(f, r, k2, q2);
                if (0 > x2) {
                  var w3 = -1;
                  break a;
                }
                b2 += x2;
              }
              w3 = b2;
            }
            J[d4 >> 2] = w3;
            return 0;
          } catch (A2) {
            if (typeof W == "undefined" || !(A2 instanceof P))
              throw A2;
            return A2.Ka;
          }
        } };
        (function() {
          function a4(f) {
            e3.asm = f.exports;
            Ja = e3.asm.I;
            Ra();
            K2 = e3.asm.Aa;
            Ta.unshift(e3.asm.J);
            Wa--;
            e3.monitorRunDependencies && e3.monitorRunDependencies(Wa);
            Wa == 0 && (Xa !== null && (clearInterval(Xa), Xa = null), Ya && (f = Ya, Ya = null, f()));
          }
          function b2(f) {
            a4(f.instance);
          }
          function c6(f) {
            return bb().then(function(h6) {
              return WebAssembly.instantiate(h6, d4);
            }).then(function(h6) {
              return h6;
            }).then(f, function(h6) {
              Ha("failed to asynchronously prepare wasm: " + h6);
              E2(h6);
            });
          }
          var d4 = { a: Wc };
          Wa++;
          e3.monitorRunDependencies && e3.monitorRunDependencies(Wa);
          if (e3.instantiateWasm)
            try {
              return e3.instantiateWasm(d4, a4);
            } catch (f) {
              return Ha("Module.instantiateWasm callback failed with error: " + f), false;
            }
          (function() {
            return Ia || typeof WebAssembly.instantiateStreaming != "function" || Za() || M3.startsWith("file://") || Aa || typeof fetch != "function" ? c6(b2) : fetch(M3, { credentials: "same-origin" }).then(function(f) {
              return WebAssembly.instantiateStreaming(f, d4).then(b2, function(h6) {
                Ha("wasm streaming compile failed: " + h6);
                Ha("falling back to ArrayBuffer instantiation");
                return c6(b2);
              });
            });
          })();
          return {};
        })();
        e3.___wasm_call_ctors = function() {
          return (e3.___wasm_call_ctors = e3.asm.J).apply(null, arguments);
        };
        e3._sqlite3_free = function() {
          return (e3._sqlite3_free = e3.asm.K).apply(null, arguments);
        };
        e3._sqlite3_value_double = function() {
          return (e3._sqlite3_value_double = e3.asm.L).apply(null, arguments);
        };
        e3._sqlite3_value_text = function() {
          return (e3._sqlite3_value_text = e3.asm.M).apply(null, arguments);
        };
        var Vc = e3.___errno_location = function() {
          return (Vc = e3.___errno_location = e3.asm.N).apply(null, arguments);
        };
        e3._sqlite3_prepare_v2 = function() {
          return (e3._sqlite3_prepare_v2 = e3.asm.O).apply(null, arguments);
        };
        e3._sqlite3_step = function() {
          return (e3._sqlite3_step = e3.asm.P).apply(null, arguments);
        };
        e3._sqlite3_finalize = function() {
          return (e3._sqlite3_finalize = e3.asm.Q).apply(null, arguments);
        };
        e3._sqlite3_reset = function() {
          return (e3._sqlite3_reset = e3.asm.R).apply(null, arguments);
        };
        e3._sqlite3_value_int = function() {
          return (e3._sqlite3_value_int = e3.asm.S).apply(null, arguments);
        };
        e3._sqlite3_clear_bindings = function() {
          return (e3._sqlite3_clear_bindings = e3.asm.T).apply(null, arguments);
        };
        e3._sqlite3_value_blob = function() {
          return (e3._sqlite3_value_blob = e3.asm.U).apply(null, arguments);
        };
        e3._sqlite3_value_bytes = function() {
          return (e3._sqlite3_value_bytes = e3.asm.V).apply(null, arguments);
        };
        e3._sqlite3_value_type = function() {
          return (e3._sqlite3_value_type = e3.asm.W).apply(null, arguments);
        };
        e3._sqlite3_result_blob = function() {
          return (e3._sqlite3_result_blob = e3.asm.X).apply(null, arguments);
        };
        e3._sqlite3_result_double = function() {
          return (e3._sqlite3_result_double = e3.asm.Y).apply(null, arguments);
        };
        e3._sqlite3_result_error = function() {
          return (e3._sqlite3_result_error = e3.asm.Z).apply(null, arguments);
        };
        e3._sqlite3_result_int = function() {
          return (e3._sqlite3_result_int = e3.asm._).apply(null, arguments);
        };
        e3._sqlite3_result_int64 = function() {
          return (e3._sqlite3_result_int64 = e3.asm.$).apply(null, arguments);
        };
        e3._sqlite3_result_null = function() {
          return (e3._sqlite3_result_null = e3.asm.aa).apply(null, arguments);
        };
        e3._sqlite3_result_text = function() {
          return (e3._sqlite3_result_text = e3.asm.ba).apply(null, arguments);
        };
        e3._sqlite3_sql = function() {
          return (e3._sqlite3_sql = e3.asm.ca).apply(null, arguments);
        };
        e3._sqlite3_aggregate_context = function() {
          return (e3._sqlite3_aggregate_context = e3.asm.da).apply(null, arguments);
        };
        e3._sqlite3_column_count = function() {
          return (e3._sqlite3_column_count = e3.asm.ea).apply(null, arguments);
        };
        e3._sqlite3_data_count = function() {
          return (e3._sqlite3_data_count = e3.asm.fa).apply(null, arguments);
        };
        e3._sqlite3_column_blob = function() {
          return (e3._sqlite3_column_blob = e3.asm.ga).apply(null, arguments);
        };
        e3._sqlite3_column_bytes = function() {
          return (e3._sqlite3_column_bytes = e3.asm.ha).apply(null, arguments);
        };
        e3._sqlite3_column_double = function() {
          return (e3._sqlite3_column_double = e3.asm.ia).apply(null, arguments);
        };
        e3._sqlite3_column_text = function() {
          return (e3._sqlite3_column_text = e3.asm.ja).apply(null, arguments);
        };
        e3._sqlite3_column_type = function() {
          return (e3._sqlite3_column_type = e3.asm.ka).apply(null, arguments);
        };
        e3._sqlite3_column_name = function() {
          return (e3._sqlite3_column_name = e3.asm.la).apply(null, arguments);
        };
        e3._sqlite3_bind_blob = function() {
          return (e3._sqlite3_bind_blob = e3.asm.ma).apply(null, arguments);
        };
        e3._sqlite3_bind_double = function() {
          return (e3._sqlite3_bind_double = e3.asm.na).apply(null, arguments);
        };
        e3._sqlite3_bind_int = function() {
          return (e3._sqlite3_bind_int = e3.asm.oa).apply(null, arguments);
        };
        e3._sqlite3_bind_text = function() {
          return (e3._sqlite3_bind_text = e3.asm.pa).apply(null, arguments);
        };
        e3._sqlite3_bind_parameter_index = function() {
          return (e3._sqlite3_bind_parameter_index = e3.asm.qa).apply(null, arguments);
        };
        e3._sqlite3_normalized_sql = function() {
          return (e3._sqlite3_normalized_sql = e3.asm.ra).apply(null, arguments);
        };
        e3._sqlite3_errmsg = function() {
          return (e3._sqlite3_errmsg = e3.asm.sa).apply(null, arguments);
        };
        e3._sqlite3_exec = function() {
          return (e3._sqlite3_exec = e3.asm.ta).apply(null, arguments);
        };
        e3._sqlite3_changes = function() {
          return (e3._sqlite3_changes = e3.asm.ua).apply(null, arguments);
        };
        e3._sqlite3_close_v2 = function() {
          return (e3._sqlite3_close_v2 = e3.asm.va).apply(null, arguments);
        };
        e3._sqlite3_create_function_v2 = function() {
          return (e3._sqlite3_create_function_v2 = e3.asm.wa).apply(null, arguments);
        };
        e3._sqlite3_open = function() {
          return (e3._sqlite3_open = e3.asm.xa).apply(null, arguments);
        };
        var da = e3._malloc = function() {
          return (da = e3._malloc = e3.asm.ya).apply(null, arguments);
        }, ba = e3._free = function() {
          return (ba = e3._free = e3.asm.za).apply(null, arguments);
        };
        e3._RegisterExtensionFunctions = function() {
          return (e3._RegisterExtensionFunctions = e3.asm.Ba).apply(null, arguments);
        };
        var zb = e3._emscripten_builtin_memalign = function() {
          return (zb = e3._emscripten_builtin_memalign = e3.asm.Ca).apply(null, arguments);
        }, oa = e3.stackSave = function() {
          return (oa = e3.stackSave = e3.asm.Da).apply(null, arguments);
        }, qa = e3.stackRestore = function() {
          return (qa = e3.stackRestore = e3.asm.Ea).apply(null, arguments);
        }, B2 = e3.stackAlloc = function() {
          return (B2 = e3.stackAlloc = e3.asm.Fa).apply(null, arguments);
        };
        e3.UTF8ToString = C;
        e3.stackAlloc = B2;
        e3.stackSave = oa;
        e3.stackRestore = qa;
        e3.cwrap = function(a4, b2, c6, d4) {
          c6 = c6 || [];
          var f = c6.every((h6) => h6 === "number" || h6 === "boolean");
          return b2 !== "string" && f && !d4 ? e3["_" + a4] : function() {
            return Uc(a4, b2, c6, arguments);
          };
        };
        var Xc;
        Ya = function Yc() {
          Xc || Zc();
          Xc || (Ya = Yc);
        };
        function Zc() {
          function a4() {
            if (!Xc && (Xc = true, e3.calledRun = true, !Ka)) {
              e3.noFSInit || ac || (ac = true, $b(), e3.stdin = e3.stdin, e3.stdout = e3.stdout, e3.stderr = e3.stderr, e3.stdin ? cc("stdin", e3.stdin) : Sb("/dev/tty", "/dev/stdin"), e3.stdout ? cc("stdout", null, e3.stdout) : Sb("/dev/tty", "/dev/stdout"), e3.stderr ? cc("stderr", null, e3.stderr) : Sb("/dev/tty1", "/dev/stderr"), ja("/dev/stdin", 0), ja("/dev/stdout", 1), ja("/dev/stderr", 1));
              Db = false;
              cb(Ta);
              if (e3.onRuntimeInitialized)
                e3.onRuntimeInitialized();
              if (e3.postRun)
                for (typeof e3.postRun == "function" && (e3.postRun = [e3.postRun]); e3.postRun.length; ) {
                  var b2 = e3.postRun.shift();
                  Ua.unshift(b2);
                }
              cb(Ua);
            }
          }
          if (!(0 < Wa)) {
            if (e3.preRun)
              for (typeof e3.preRun == "function" && (e3.preRun = [e3.preRun]); e3.preRun.length; )
                Va();
            cb(Sa);
            0 < Wa || (e3.setStatus ? (e3.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                e3.setStatus("");
              }, 1);
              a4();
            }, 1)) : a4());
          }
        }
        if (e3.preInit)
          for (typeof e3.preInit == "function" && (e3.preInit = [e3.preInit]); 0 < e3.preInit.length; )
            e3.preInit.pop()();
        Zc();
        return Module;
      });
      return initSqlJsPromise;
    };
    if (typeof exports2 === "object" && typeof module2 === "object") {
      module2.exports = initSqlJs2;
      module2.exports.default = initSqlJs2;
    } else if (typeof define === "function" && define["amd"]) {
      define([], function() {
        return initSqlJs2;
      });
    } else if (typeof exports2 === "object") {
      exports2["Module"] = initSqlJs2;
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianManagerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");
var import_obsidian16 = require("obsidian");
var import_moment8 = __toESM(require_moment());

// src/types.ts
var import_obsidian = require("obsidian");
var OneDay = class {
  constructor(fileVal, oldContentVal) {
    this.fileVal = fileVal;
    this.oldContentVal = oldContentVal;
    this.oldContent = "";
    this.file = fileVal;
    this.oldContent = oldContentVal;
  }
};
var UndoHistoryInstance = class {
  constructor(previousDayVal, todayVal) {
    this.previousDayVal = previousDayVal;
    this.todayVal = todayVal;
    this.previousDay = previousDayVal;
    this.today = todayVal;
  }
};
var Tag = class {
  constructor(colorVal, bgColorVal, typeVal, iconVal, fontVal) {
    this.color = "var(--white)";
    this.bgColor = "var(--stag1-bg)";
    this.color = colorVal;
    this.bgColor = bgColorVal;
    this.type = typeVal;
    this.icon = iconVal;
    this.font = fontVal;
  }
};
var EditDetector = class {
  constructor(editDetectionSec) {
    this.editDetectionSec = editDetectionSec;
  }
  fileChanged() {
    this.lastModified = new Date();
  }
  isEditing() {
    if (this.editDetectionSec.value <= 0) {
      return false;
    }
    if (this.lastModified == null) {
      return false;
    }
    const elapsedSec = (new Date().getTime() - this.lastModified.getTime()) / 1e3;
    return elapsedSec < this.editDetectionSec.value;
  }
};

// src/types/types.ts
var eventTypes = {
  selectedFileChange: "mkmd-selected-file-change",
  activeFileChange: "mkmd-active-file-change",
  refreshView: "mkmd-refresh-view",
  revealFile: "mkmd-reveal-file",
  tagsChange: "mkmd-tags-change",
  vaultChange: "mkmd-vault-change",
  mdbChange: "mkmd-mdb-change",
  spacesChange: "mkmd-spaces-change",
  pomodoroChange: "awesome-brain-manager-pomodoro-change",
  updateSections: "mkmd-update-sections",
  settingsChanged: "mkmd-settings-changed",
  spawnPortal: "mkmd-portal-spawn",
  loadPortal: "mkmd-portal-load",
  openFilePortal: "mkmd-portal-file",
  focusPortal: "mkmd-portal-focus"
};

// src/main.ts
var import_obsidian_daily_notes_interface2 = __toESM(require_main());

// src/controller.ts
var import_obsidian2 = require("obsidian");

// src/model/format/markdown.ts
var _Todo = class {
  constructor(lineIndex, prefix3, check, suffix2, body) {
    this.lineIndex = lineIndex;
    this.prefix = prefix3;
    this.check = check;
    this.suffix = suffix2;
    this.body = body;
  }
  static parse(lineIndex, line) {
    const match3 = _Todo.regexp.exec(line);
    if (match3) {
      return new _Todo(lineIndex, match3.groups["prefix"], match3.groups["check"], match3.groups["suffix"], match3.groups["body"]);
    }
    return null;
  }
  toMarkdown() {
    return `${this.prefix}${this.check}${this.suffix}${this.body}`;
  }
  isChecked() {
    return this.check === "x";
  }
  setChecked(checked) {
    this.check = checked ? "x" : " ";
  }
  getHeaderLength() {
    return this.prefix.length + this.check.length + this.suffix.length;
  }
  clone() {
    return _Todo.parse(this.lineIndex, this.toMarkdown());
  }
};
var Todo = _Todo;
Todo.regexp = /^(?<prefix>((> ?)*)?\s*[-*] \[)(?<check>.)(?<suffix>\]\s+)(?<body>.*)$/;
var MarkdownDocument = class {
  constructor(file, content) {
    this.file = file;
    this.lines = [];
    this.todos = [];
    this.parse(content);
  }
  parse(content) {
    this.lines = content.split("\n");
    this.todos = [];
    this.lines.forEach((line, lineIndex) => {
      const todo = Todo.parse(lineIndex, line);
      if (todo) {
        this.todos.push(todo);
      }
    });
  }
  getTodos() {
    return this.todos;
  }
  insertTodo(lineIndex, todo) {
    todo.lineIndex = lineIndex;
    this.lines.splice(lineIndex, 0, todo.toMarkdown());
    let todoIndex = -1;
    for (const i3 in this.todos) {
      const todo2 = this.todos[i3];
      if (todo2.lineIndex >= lineIndex) {
        if (todoIndex < 0) {
          todoIndex = parseInt(i3);
        }
        todo2.lineIndex++;
      }
    }
    if (todoIndex <= 0) {
      this.todos.splice(0, 0, todo);
    } else {
      this.todos.splice(todoIndex, 0, todo);
    }
  }
  getTodo(lineIndex) {
    const found = this.todos.find((todo) => todo.lineIndex === lineIndex);
    if (found == null) {
      return null;
    }
    return found;
  }
  applyChanges() {
    this.todos.forEach((todo) => {
      this.lines[todo.lineIndex] = todo.toMarkdown();
    });
  }
  toMarkdown() {
    this.applyChanges();
    return this.lines.join("\n");
  }
};

// src/model/ref.ts
var ConstantReference = class {
  constructor(_value) {
    this._value = _value;
  }
  get value() {
    return this._value;
  }
};
var Reference = class {
  constructor(_value) {
    this._value = _value;
    this.onChangeFunctions = [];
  }
  onChanged(listener) {
    this.onChangeFunctions.push(listener);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    const oldValue = this._value;
    this._value = value;
    this.onChangeFunctions.forEach((f) => {
      f(oldValue, value);
    });
  }
};

// src/model/time.ts
var import_moment = __toESM(require_moment());
var DateTime = class {
  constructor(time2, _hasTimePart) {
    this.time = time2;
    this._hasTimePart = _hasTimePart;
  }
  static now() {
    return new DateTime((0, import_moment.default)(), true);
  }
  static parse(time2) {
    if (time2.length > 10) {
      return new DateTime((0, import_moment.default)(time2, "YYYY-MM-DD HH:mm"), true);
    } else {
      return new DateTime((0, import_moment.default)(time2, "YYYY-MM-DD"), false);
    }
  }
  static duration(from2, to2, unit, defaultTime) {
    return to2.fixedTime(defaultTime).diff(from2.fixedTime(defaultTime), unit);
  }
  getTimeInMillis(defaultTime) {
    return this.fixedTime(defaultTime).valueOf();
  }
  format(format2, defaultTime) {
    return this.fixedTime(defaultTime).format(format2);
  }
  toYYYYMMMM(defaultTime) {
    return this.fixedTime(defaultTime).format("YYYY, MMMM");
  }
  toYYYYMMDD(defaultTime) {
    return this.fixedTime(defaultTime).format("YYYY-MM-DD");
  }
  add(amount, unit, defaultTime) {
    return new DateTime(this.fixedTime(defaultTime).clone().add(amount, unit), this._hasTimePart);
  }
  fixedTime(defaultTime) {
    if (this._hasTimePart) {
      return this.time;
    }
    if (defaultTime === void 0) {
      return this.time;
    }
    return this.time.clone().add(defaultTime.minutes, "minutes");
  }
  get hasTimePart() {
    return this._hasTimePart;
  }
  moment() {
    return this.time;
  }
  isValid() {
    return this.time.isValid();
  }
  clone(hasTimePart) {
    const withTimePart = hasTimePart == null ? this._hasTimePart : hasTimePart;
    const clone3 = this.time.clone();
    return new DateTime(clone3, withTimePart);
  }
  toString() {
    if (this._hasTimePart) {
      return this.format("YYYY-MM-DD HH:mm");
    } else {
      return this.format("YYYY-MM-DD");
    }
  }
  equals(time2) {
    return this._hasTimePart === time2._hasTimePart && this.time.isSame(time2.time);
  }
};
var Time = class {
  constructor(hour, minute) {
    this.hour = hour;
    this.minute = minute;
  }
  static parse(text2) {
    if (!text2.match(/^\d{1,2}:\d{1,2}$/)) {
      throw `Unexpected format time(${text2}). Time must be HH:mm.`;
    }
    const s4 = text2.split(":");
    if (s4.length !== 2) {
      throw `Unexpected format time(${text2}).  time must be HH:mm.`;
    }
    const hour = parseInt(s4[0]);
    const minute = parseInt(s4[1]);
    if (hour > 23 || hour < 0) {
      throw "hour must be 0~23";
    }
    if (minute > 59 || minute < 0) {
      throw "minute must be 0~59";
    }
    return new Time(hour, minute);
  }
  get minutes() {
    return this.hour * 60 + this.minute;
  }
  toString() {
    const pad = (n2) => {
      if (n2 < 10) {
        return "0" + n2;
      }
      return "" + n2;
    };
    return `${pad(this.hour)}:${pad(this.minute)}`;
  }
};
function add(amount, unit) {
  return () => {
    return new DateTime((0, import_moment.default)(), true).add(amount, unit);
  };
}
function inMinutes(minutes) {
  return add(minutes, "minutes");
}
function inHours(hours) {
  return add(hours, "hours");
}
function inDays(days2) {
  return add(days2, "days");
}
function inWeeks(weeks) {
  return add(weeks, "weeks");
}
function inMonths(months) {
  return add(months, "months");
}
function inYears(years) {
  return add(years, "years");
}
function nextWeekday(weekday) {
  return () => {
    const today = (0, import_moment.default)();
    if (today.isoWeekday() <= weekday) {
      return new DateTime(today.isoWeekday(weekday), false);
    } else {
      return new DateTime(today.add(1, "weeks").isoWeekday(weekday), false);
    }
  };
}
function tomorrow() {
  return () => {
    return new DateTime((0, import_moment.default)().add(1, "days"), false);
  };
}
function nextWeek() {
  return () => {
    return new DateTime((0, import_moment.default)().add(1, "weeks"), false);
  };
}
function nextMonth() {
  return () => {
    return new DateTime((0, import_moment.default)().add(1, "months"), false);
  };
}
function nextYear() {
  return () => {
    return new DateTime((0, import_moment.default)().add(1, "years"), false);
  };
}
var Later = class {
  constructor(label, later) {
    this.label = label;
    this.later = later;
  }
};
function parseLaters(laters) {
  return laters.split("\n").map((l2) => parseLater(l2.trim()));
}
function parseLater(later) {
  later = later.toLowerCase();
  if (later.startsWith("in")) {
    const tokens = later.split(" ");
    if (tokens.length !== 3) {
      throw "Unsupported format.  Should be 'In N (minutes|hours)'";
    }
    const n2 = tokens[1] === "a" || tokens[1] === "an" ? 1 : parseInt(tokens[1]);
    switch (tokens[2]) {
      case "minute":
      case "minutes": {
        const unit = n2 == 1 ? "minute" : "minutes";
        return new Later(`In ${n2} ${unit}`, inMinutes(n2));
      }
      case "hour":
      case "hours": {
        const unit = n2 == 1 ? "hour" : "hours";
        return new Later(`In ${n2} ${unit}`, inHours(n2));
      }
      case "day":
      case "days": {
        const unit = n2 == 1 ? "day" : "days";
        return new Later(`In ${n2} ${unit}`, inDays(n2));
      }
      case "week":
      case "weeks": {
        const unit = n2 == 1 ? "week" : "weeks";
        return new Later(`In ${n2} ${unit}`, inWeeks(n2));
      }
      case "month":
      case "months": {
        const unit = n2 == 1 ? "month" : "months";
        return new Later(`In ${n2} ${unit}`, inMonths(n2));
      }
      case "year":
      case "years": {
        const unit = n2 == 1 ? "year" : "years";
        return new Later(`In ${n2} ${unit}`, inYears(n2));
      }
    }
  } else if (later.startsWith("next")) {
    const weekday = later.substring(5);
    switch (weekday) {
      case "sunday":
        return new Later("Next Sunday", nextWeekday(0));
      case "monday":
        return new Later("Next Monday", nextWeekday(1));
      case "tuesday":
        return new Later("Next Tuesday", nextWeekday(2));
      case "wednesday":
        return new Later("Next Wednesday", nextWeekday(3));
      case "thursday":
        return new Later("Next Thursday", nextWeekday(4));
      case "friday":
        return new Later("Next Friday", nextWeekday(5));
      case "saturday":
        return new Later("Next Saturday", nextWeekday(6));
      case "day":
        return new Later("Tomorrow", tomorrow());
      case "week":
        return new Later("Next week", nextWeek());
      case "month":
        return new Later("Next month", nextMonth());
      case "year":
        return new Later("Next year", nextYear());
      default:
        throw `Unsupported weekday: ${weekday}`;
    }
  } else if (later === "tomorrow") {
    return new Later("Tomorrow", tomorrow());
  }
  throw `Unsupported format: ${later}`;
}
var DEFAULT_LATERS = [
  new Later("In 30 minutes", inMinutes(30)),
  new Later("In 1 hours", inHours(1)),
  new Later("In 3 hours", inHours(3)),
  new Later("Tomorrow", tomorrow()),
  new Later("Next week", nextWeek())
];
var DateTimeFormatter = class {
  constructor() {
    this.dateFormat = new ConstantReference("YYYY-MM-DD");
    this.dateTimeFormat = new ConstantReference("YYYY-MM-DD HH:mm");
    this.strict = new ConstantReference(false);
  }
  setTimeFormat(dateFormat, dateTimeFormat, strict) {
    this.dateFormat = dateFormat;
    this.dateTimeFormat = dateTimeFormat;
    this.strict = strict;
  }
  parse(text2) {
    const parsed = this.doParse(text2, true);
    if (parsed != null) {
      return parsed;
    }
    if (this.strict.value) {
      return null;
    }
    return this.doParse(text2, false);
  }
  doParse(text2, strict) {
    const dateTime = (0, import_moment.default)(text2, this.dateTimeFormat.value, strict);
    if (dateTime.isValid()) {
      return new DateTime(dateTime, true);
    }
    const date = (0, import_moment.default)(text2, this.dateFormat.value, strict);
    if (date.isValid()) {
      return new DateTime(date, false);
    }
    return null;
  }
  toString(time2) {
    if (time2.hasTimePart) {
      return time2.format(this.dateTimeFormat.value);
    } else {
      return time2.format(this.dateFormat.value);
    }
  }
};
var DATE_TIME_FORMATTER = new DateTimeFormatter();

// src/utils/logger.ts
var import_util = require("util");
var import_chalk = __toESM(require_source());
import_chalk.default.level = 3;
var debugEnable = new ConstantReference(false);
var initLogger = (debugEnableVal) => {
  debugEnable = debugEnableVal;
};
var printer = (args, chalkify) => {
  if (!debugEnable.value) {
    return;
  }
  if (args.length === 0)
    throw "::::::error::::: no argument supplied to logger";
  args.forEach((element2) => {
    if (typeof element2 === "object") {
      console.error(chalkify((0, import_util.inspect)(element2)));
    } else {
      console.error(chalkify(element2));
    }
  });
};
var Logger = class {
  log(...args) {
    printer(args, import_chalk.default.bgCyanBright.blackBright.bold);
  }
  dir(...args) {
    printer(args, import_chalk.default.bgBlueBright.blackBright.bold);
  }
  info(...args) {
    printer(args, import_chalk.default.bgBlueBright.blackBright.bold);
  }
  warn(...args) {
    printer(args, import_chalk.default.bgYellowBright.blackBright.bold);
  }
  error(...args) {
    printer(args, import_chalk.default.bgRedBright.blackBright.bold);
  }
  debug(...args) {
    printer(args, import_chalk.default.bgRedBright.blackBright.bold);
  }
};
var LoggerUtil = new Proxy(new Logger(), console);
var logger_default = LoggerUtil;

// src/model/reminder.ts
var Reminder = class {
  constructor(file, title, time2, rowNumber, done) {
    this.file = file;
    this.title = title;
    this.time = time2;
    this.rowNumber = rowNumber;
    this.done = done;
    this.muteNotification = false;
    this.beingDisplayed = false;
  }
  key() {
    return this.file + this.title + this.time.toString();
  }
  equals(reminder) {
    return this.rowNumber === reminder.rowNumber && this.title === reminder.title && this.time.equals(reminder.time) && this.file === reminder.file;
  }
  getFileName() {
    const p2 = this.file.split(/[/\\]/);
    return p2[p2.length - 1].replace(/^(.*?)(\..+)?$/, "$1");
  }
  static extractFileName(path) {
    const p2 = path.split(/[/\\]/);
    return p2[p2.length - 1].replace(/^(.*?)(\..+)?$/, "$1");
  }
};
var Reminders = class {
  constructor(onChange) {
    this.onChange = onChange;
    this.fileToReminders = /* @__PURE__ */ new Map();
    this.reminders = [];
  }
  getExpiredReminders(defaultTime) {
    const now = new Date().getTime();
    const result = [];
    for (let i3 = 0; i3 < this.reminders.length; i3++) {
      const reminder = this.reminders[i3];
      if (reminder.time.getTimeInMillis(defaultTime) <= now) {
        result.push(reminder);
      } else {
        break;
      }
    }
    return result;
  }
  byDate(date) {
    return this.reminders.filter((reminder) => reminder.time.toYYYYMMDD() === date.toYYYYMMDD());
  }
  removeReminder(reminder) {
    logger_default.debug("Remove reminder: %o", reminder);
    this.reminders.remove(reminder);
    const file = this.fileToReminders.get(reminder.file);
    if (file) {
      file.remove(reminder);
      if (file.length === 0) {
        this.fileToReminders.delete(reminder.file);
      }
    }
    this.onChange();
  }
  clear() {
    this.fileToReminders.clear();
    this.reminders = [];
    this.onChange();
  }
  removeFile(filePath) {
    if (this.fileToReminders.delete(filePath)) {
      this.sortReminders();
      return true;
    }
    return false;
  }
  replaceFile(filePath, reminders) {
    const oldReminders = this.fileToReminders.get(filePath);
    if (oldReminders) {
      if (this.equals(oldReminders, reminders)) {
        return false;
      }
      const reminderToNotificationVisible = /* @__PURE__ */ new Map();
      for (const reminder of oldReminders) {
        reminderToNotificationVisible.set(reminder.key(), reminder.muteNotification);
      }
      for (const reminder of reminders) {
        const visible = reminderToNotificationVisible.get(reminder.key());
        reminderToNotificationVisible.set(reminder.key(), reminder.muteNotification);
        if (visible !== void 0) {
          reminder.muteNotification = visible;
        }
      }
    }
    this.fileToReminders.set(filePath, reminders);
    this.sortReminders();
    return true;
  }
  equals(r1, r2) {
    if (r1.length !== r2.length) {
      return false;
    }
    this.sort(r1);
    this.sort(r2);
    for (const i3 in r1) {
      const reminder1 = r1[i3];
      const reminder2 = r2[i3];
      if (reminder1 == null && reminder2 != null) {
        return false;
      }
      if (reminder2 == null && reminder1 != null) {
        return false;
      }
      if (reminder1 == null && reminder2 == null) {
        continue;
      }
      if (!reminder1.equals(reminder2)) {
        return false;
      }
    }
    return true;
  }
  sortReminders() {
    const reminders = [];
    for (const r of this.fileToReminders.values()) {
      reminders.push(...r);
    }
    this.sort(reminders);
    this.reminders = reminders;
    this.onChange();
  }
  sort(reminders) {
    reminders.sort((a4, b2) => {
      var _a3, _b2;
      const d4 = a4.time.getTimeInMillis((_a3 = this.reminderTime) == null ? void 0 : _a3.value) - b2.time.getTimeInMillis((_b2 = this.reminderTime) == null ? void 0 : _b2.value);
      return d4 > 0 ? 1 : d4 < 0 ? -1 : 0;
    });
  }
};

// src/model/format/reminder-base.ts
var _ReminderFormatParameterKey = class {
  constructor(key, defaultValue) {
    this.key = key;
    this.defaultValue = defaultValue;
  }
};
var ReminderFormatParameterKey = _ReminderFormatParameterKey;
ReminderFormatParameterKey.now = new _ReminderFormatParameterKey("now", DateTime.now());
ReminderFormatParameterKey.useCustomEmojiForTasksPlugin = new _ReminderFormatParameterKey("useCustomEmojiForTasksPlugin", false);
ReminderFormatParameterKey.removeTagsForTasksPlugin = new _ReminderFormatParameterKey("removeTagsForTasksPlugin", false);
ReminderFormatParameterKey.linkDatesToDailyNotes = new _ReminderFormatParameterKey("linkDatesToDailyNotes", false);
ReminderFormatParameterKey.strictDateFormat = new _ReminderFormatParameterKey("strictDateFormat", false);
var ReminderFormatConfig = class {
  constructor() {
    this.parameters = /* @__PURE__ */ new Map();
  }
  setParameter(key, value) {
    this.parameters.set(key.key, () => value.value);
  }
  setParameterFunc(key, f) {
    this.parameters.set(key.key, f);
  }
  setParameterValue(key, value) {
    this.parameters.set(key.key, () => value);
  }
  getParameter(key) {
    const value = this.parameters.get(key.key);
    if (value == null) {
      return key.defaultValue;
    }
    return value();
  }
};
var TodoBasedReminderFormat = class {
  constructor() {
    this.config = new ReminderFormatConfig();
  }
  setConfig(config) {
    this.config = config;
  }
  parse(doc2) {
    return doc2.getTodos().map((todo) => {
      const parsed = this.parseValidReminder(todo);
      if (parsed == null) {
        return null;
      }
      const title = parsed.getTitle();
      if (title == null) {
        return null;
      }
      const time2 = parsed.getTime();
      if (time2 == null) {
        return null;
      }
      return new Reminder(doc2.file, title, time2, todo.lineIndex, todo.isChecked());
    }).filter((reminder) => reminder != null);
  }
  async modify(doc2, reminder, edit) {
    const todo = doc2.getTodo(reminder.rowNumber);
    if (todo === null) {
      logger_default.warn("Not a todo: reminder=%o", reminder);
      return false;
    }
    const parsed = this.parseValidReminder(todo);
    if (parsed === null) {
      return false;
    }
    if (!this.modifyReminder(doc2, todo, parsed, edit)) {
      return false;
    }
    todo.body = parsed.toMarkdown();
    return true;
  }
  parseValidReminder(todo) {
    const parsed = this.parseReminder(todo);
    if (parsed === null) {
      return null;
    }
    if (!this.isValidReminder(parsed)) {
      return null;
    }
    return parsed;
  }
  isValidReminder(reminder) {
    return reminder.getTime() !== null;
  }
  modifyReminder(doc2, todo, parsed, edit) {
    if (edit.rawTime !== void 0) {
      if (!parsed.setRawTime(edit.rawTime)) {
        logger_default.warn("The reminder doesn't support raw time: parsed=%o", parsed);
        return false;
      }
    } else if (edit.time !== void 0) {
      parsed.setTime(edit.time);
    }
    if (edit.checked !== void 0) {
      todo.setChecked(edit.checked);
    }
    return true;
  }
  appendReminder(line, time2, insertAt) {
    const todo = Todo.parse(0, line);
    if (todo == null) {
      return null;
    }
    let parsed = this.parseReminder(todo);
    const todoHeaderLength = todo.getHeaderLength();
    if (insertAt != null) {
      insertAt -= todoHeaderLength;
    }
    if (parsed != null) {
      parsed.setTime(time2, insertAt);
    } else {
      parsed = this.newReminder(todo.body, time2, insertAt);
      parsed.setTime(time2);
    }
    todo.body = parsed.toMarkdown();
    return {
      insertedLine: todo.toMarkdown(),
      caretPosition: todoHeaderLength + parsed.getEndOfTimeTextIndex()
    };
  }
  isStrictDateFormat() {
    return this.config.getParameter(ReminderFormatParameterKey.strictDateFormat);
  }
};
var CompositeReminderFormat = class {
  constructor() {
    this.formats = [];
  }
  setConfig(config) {
    this.config = config;
    this.syncConfig();
  }
  parse(doc2) {
    const reminders = [];
    for (const format2 of this.formats) {
      const parsed = format2.parse(doc2);
      if (parsed == null) {
        continue;
      }
      reminders.push(...parsed);
    }
    return reminders;
  }
  async modify(doc2, reminder, edit) {
    for (const format2 of this.formats) {
      const modified = await format2.modify(doc2, reminder, edit);
      if (modified) {
        return true;
      }
    }
    return false;
  }
  resetFormat(formats) {
    this.formats = formats;
    this.syncConfig();
  }
  syncConfig() {
    if (this.config == null) {
      return;
    }
    this.formats.forEach((f) => f.setConfig(this.config));
  }
  appendReminder(line, time2) {
    if (this.formats[0] == null) {
      return null;
    }
    return this.formats[0].appendReminder(line, time2);
  }
};

// src/model/format/reminder-default.ts
var _DefaultReminderModel = class {
  constructor(linkDatesToDailyNotes, title1, time2, title2) {
    this.linkDatesToDailyNotes = linkDatesToDailyNotes;
    this.title1 = title1;
    this.time = time2;
    this.title2 = title2;
  }
  static parse(line, linkDatesToDailyNotes) {
    if (linkDatesToDailyNotes == null) {
      linkDatesToDailyNotes = false;
    }
    const result = _DefaultReminderModel.regexp.exec(line);
    if (result == null) {
      return null;
    }
    const title1 = result.groups["title1"];
    let time2 = result.groups["time"];
    if (time2 == null) {
      return null;
    }
    const title2 = result.groups["title2"];
    if (linkDatesToDailyNotes) {
      time2 = time2.replace("[[", "");
      time2 = time2.replace("]]", "");
    }
    return new _DefaultReminderModel(linkDatesToDailyNotes, title1, time2, title2);
  }
  getTitle() {
    return `${this.title1.trim()} ${this.title2.trim()}`.trim();
  }
  getTime() {
    return DATE_TIME_FORMATTER.parse(this.time);
  }
  setTime(time2) {
    this.time = DATE_TIME_FORMATTER.toString(time2);
  }
  setRawTime(rawTime) {
    this.time = rawTime;
    return true;
  }
  getEndOfTimeTextIndex() {
    return this.toMarkdown().length - this.title2.length;
  }
  toMarkdown() {
    const result = `${this.title1}(@${this.time})${this.title2}`;
    if (!this.linkDatesToDailyNotes) {
      return result;
    }
    const time2 = DATE_TIME_FORMATTER.parse(this.time);
    if (!time2) {
      return result;
    }
    const date = DATE_TIME_FORMATTER.toString(time2.clone(false));
    return result.replace(date, `[[${date}]]`);
  }
};
var DefaultReminderModel = _DefaultReminderModel;
DefaultReminderModel.regexp = /^(?<title1>.*?)\(@(?<time>.+?)\)(?<title2>.*)$/;
var _DefaultReminderFormat = class extends TodoBasedReminderFormat {
  parseReminder(todo) {
    return DefaultReminderModel.parse(todo.body, this.linkDatesToDailyNotes());
  }
  newReminder(title, time2, insertAt) {
    let title1;
    let title2;
    if (insertAt != null) {
      title1 = title.substring(0, insertAt);
      title2 = title.substring(insertAt);
    } else {
      title1 = title;
      title2 = "";
    }
    return new DefaultReminderModel(this.linkDatesToDailyNotes(), title1, time2.toString(), title2);
  }
  linkDatesToDailyNotes() {
    return this.config.getParameter(ReminderFormatParameterKey.linkDatesToDailyNotes);
  }
};
var DefaultReminderFormat = _DefaultReminderFormat;
DefaultReminderFormat.instance = new _DefaultReminderFormat();

// src/model/format/reminder-kanban-plugin.ts
var import_moment2 = __toESM(require_moment());

// src/model/format/util.ts
function escapeRegExpChars(text2) {
  return text2.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
}

// src/model/format/reminder-kanban-plugin.ts
var kanbanSetting = new class KanbanSetting {
  get dateTrigger() {
    return this.get("date-trigger", "@");
  }
  get dateFormat() {
    return this.get("date-format", "YYYY-MM-DD");
  }
  get timeTrigger() {
    return this.get("time-trigger", "@@");
  }
  get timeFormat() {
    return this.get("time-format", "HH:mm");
  }
  get linkDateToDailyNote() {
    return this.get("link-date-to-daily-note", false);
  }
  get(key, defaultValue) {
    var _a3, _b2;
    if (!window) {
      return defaultValue;
    }
    const plugins2 = (_b2 = (_a3 = window == null ? void 0 : window.app) == null ? void 0 : _a3.plugins) == null ? void 0 : _b2.plugins;
    if (!plugins2) {
      return defaultValue;
    }
    const plugin3 = plugins2["obsidian-kanban"];
    if (!plugin3) {
      return defaultValue;
    }
    const settings = plugin3.settings;
    if (!settings) {
      return defaultValue;
    }
    const value = plugin3.settings[key];
    if (value === null || value === void 0) {
      return defaultValue;
    }
    return value;
  }
}();
var _KanbanDateTimeFormat = class {
  constructor(setting) {
    this.setting = setting;
    let dateRegExpStr;
    if (setting.linkDateToDailyNote) {
      dateRegExpStr = `${escapeRegExpChars(this.setting.dateTrigger)}\\[\\[(?<date>.+?)\\]\\]`;
    } else {
      dateRegExpStr = `${escapeRegExpChars(this.setting.dateTrigger)}\\{(?<date>.+?)\\}`;
    }
    const timeRegExpStr = `${escapeRegExpChars(this.setting.timeTrigger)}\\{(?<time>.+?)\\}`;
    this.dateRegExp = new RegExp(dateRegExpStr);
    this.timeRegExp = new RegExp(timeRegExpStr);
  }
  format(time2) {
    let datePart;
    if (this.setting.linkDateToDailyNote) {
      datePart = `${this.setting.dateTrigger}[[${time2.format(this.setting.dateFormat)}]]`;
    } else {
      datePart = `${this.setting.dateTrigger}{${time2.format(this.setting.dateFormat)}}`;
    }
    if (!time2.hasTimePart) {
      return datePart;
    }
    return `${datePart} ${this.setting.timeTrigger}{${time2.format(this.setting.timeFormat)}}`;
  }
  split(text2, strictDateFormat) {
    const originalText = text2;
    let date;
    let time2;
    const dateMatch = this.dateRegExp.exec(text2);
    if (dateMatch) {
      date = dateMatch.groups["date"];
      text2 = text2.replace(this.dateRegExp, "");
    } else {
      return { title: originalText };
    }
    const timeMatch = this.timeRegExp.exec(text2);
    if (timeMatch) {
      time2 = timeMatch.groups["time"];
      text2 = text2.replace(this.timeRegExp, "");
    }
    const title = text2.trim();
    let parsedTime;
    const strict = strictDateFormat != null ? strictDateFormat : true;
    if (time2) {
      parsedTime = new DateTime((0, import_moment2.default)(`${date} ${time2}`, `${this.setting.dateFormat} ${this.setting.timeFormat}`, strict), true);
    } else {
      parsedTime = new DateTime((0, import_moment2.default)(date, this.setting.dateFormat, strict), false);
    }
    if (parsedTime.isValid()) {
      return { title, time: parsedTime };
    }
    return { title: originalText };
  }
};
var KanbanDateTimeFormat = _KanbanDateTimeFormat;
KanbanDateTimeFormat.instance = new _KanbanDateTimeFormat(kanbanSetting);
var KanbanReminderModel = class {
  constructor(title, time2) {
    this.title = title;
    this.time = time2;
  }
  static parse(line, strictDateFormat) {
    const splitted = KanbanDateTimeFormat.instance.split(line, strictDateFormat);
    if (splitted.time == null) {
      return null;
    }
    return new KanbanReminderModel(splitted.title, splitted.time);
  }
  getTitle() {
    return this.title.trim();
  }
  getTime() {
    if (this.time) {
      return this.time;
    }
    return null;
  }
  setTime(time2) {
    this.time = time2;
  }
  setRawTime() {
    return false;
  }
  getEndOfTimeTextIndex() {
    return this.toMarkdown().length;
  }
  toMarkdown() {
    return `${this.title.trim()} ${KanbanDateTimeFormat.instance.format(this.time)}`;
  }
};
var _KanbanReminderFormat = class extends TodoBasedReminderFormat {
  parseReminder(todo) {
    return KanbanReminderModel.parse(todo.body, this.isStrictDateFormat());
  }
  newReminder(title, time2) {
    const parsed = new KanbanReminderModel(title, time2);
    parsed.setTime(time2);
    return parsed;
  }
};
var KanbanReminderFormat = _KanbanReminderFormat;
KanbanReminderFormat.instance = new _KanbanReminderFormat();

// src/model/format/reminder-tasks-plugin.ts
var import_moment3 = __toESM(require_moment());

// node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = function() {
  function Weekday2(weekday, n2) {
    if (n2 === 0)
      throw new Error("Can't create weekday with n == 0");
    this.weekday = weekday;
    this.n = n2;
  }
  Weekday2.fromStr = function(str) {
    return new Weekday2(ALL_WEEKDAYS.indexOf(str));
  };
  Weekday2.prototype.nth = function(n2) {
    return this.n === n2 ? this : new Weekday2(this.weekday, n2);
  };
  Weekday2.prototype.equals = function(other) {
    return this.weekday === other.weekday && this.n === other.n;
  };
  Weekday2.prototype.toString = function() {
    var s4 = ALL_WEEKDAYS[this.weekday];
    if (this.n)
      s4 = (this.n > 0 ? "+" : "") + String(this.n) + s4;
    return s4;
  };
  Weekday2.prototype.getJsWeekday = function() {
    return this.weekday === 6 ? 0 : this.weekday + 1;
  };
  return Weekday2;
}();

// node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value) {
  return value !== null && value !== void 0;
};
var isNumber = function(value) {
  return typeof value === "number";
};
var isWeekdayStr = function(value) {
  return typeof value === "string" && ALL_WEEKDAYS.includes(value);
};
var isArray = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i3 = start; i3 < end; i3++)
    rang.push(i3);
  return rang;
};
var repeat = function(value, times) {
  var i3 = 0;
  var array = [];
  if (isArray(value)) {
    for (; i3 < times; i3++)
      array[i3] = [].concat(value);
  } else {
    for (; i3 < times; i3++)
      array[i3] = value;
  }
  return array;
};
var toArray = function(item) {
  if (isArray(item)) {
    return item;
  }
  return [item];
};
function padStart(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a4, b2) {
  var r = a4 % b2;
  return r * b2 < 0 ? r + b2 : r;
};
var divmod = function(a4, b2) {
  return { div: Math.floor(a4 / b2), mod: pymod(a4, b2) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// node_modules/rrule/dist/esm/dateutil.js
var dateutil;
(function(dateutil2) {
  dateutil2.MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  dateutil2.ONE_DAY = 1e3 * 60 * 60 * 24;
  dateutil2.MAXYEAR = 9999;
  dateutil2.ORDINAL_BASE = new Date(Date.UTC(1970, 0, 1));
  dateutil2.PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
  dateutil2.getYearDay = function(date) {
    var dateNoTime = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    return Math.ceil((dateNoTime.valueOf() - new Date(date.getUTCFullYear(), 0, 1).valueOf()) / dateutil2.ONE_DAY) + 1;
  };
  dateutil2.isLeapYear = function(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  };
  dateutil2.isDate = function(value) {
    return value instanceof Date;
  };
  dateutil2.isValidDate = function(value) {
    return dateutil2.isDate(value) && !isNaN(value.getTime());
  };
  dateutil2.tzOffset = function(date) {
    return date.getTimezoneOffset() * 60 * 1e3;
  };
  dateutil2.daysBetween = function(date1, date2) {
    var date1ms = date1.getTime() - dateutil2.tzOffset(date1);
    var date2ms = date2.getTime() - dateutil2.tzOffset(date2);
    var differencems = date1ms - date2ms;
    return Math.round(differencems / dateutil2.ONE_DAY);
  };
  dateutil2.toOrdinal = function(date) {
    return dateutil2.daysBetween(date, dateutil2.ORDINAL_BASE);
  };
  dateutil2.fromOrdinal = function(ordinal) {
    return new Date(dateutil2.ORDINAL_BASE.getTime() + ordinal * dateutil2.ONE_DAY);
  };
  dateutil2.getMonthDays = function(date) {
    var month = date.getUTCMonth();
    return month === 1 && dateutil2.isLeapYear(date.getUTCFullYear()) ? 29 : dateutil2.MONTH_DAYS[month];
  };
  dateutil2.getWeekday = function(date) {
    return dateutil2.PY_WEEKDAYS[date.getUTCDay()];
  };
  dateutil2.monthRange = function(year, month) {
    var date = new Date(Date.UTC(year, month, 1));
    return [dateutil2.getWeekday(date), dateutil2.getMonthDays(date)];
  };
  dateutil2.combine = function(date, time2) {
    time2 = time2 || date;
    return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time2.getHours(), time2.getMinutes(), time2.getSeconds(), time2.getMilliseconds()));
  };
  dateutil2.clone = function(date) {
    var dolly = new Date(date.getTime());
    return dolly;
  };
  dateutil2.cloneDates = function(dates) {
    var clones = [];
    for (var i3 = 0; i3 < dates.length; i3++) {
      clones.push(dateutil2.clone(dates[i3]));
    }
    return clones;
  };
  dateutil2.sort = function(dates) {
    dates.sort(function(a4, b2) {
      return a4.getTime() - b2.getTime();
    });
  };
  dateutil2.timeToUntilString = function(time2, utc) {
    if (utc === void 0) {
      utc = true;
    }
    var date = new Date(time2);
    return [
      padStart(date.getUTCFullYear().toString(), 4, "0"),
      padStart(date.getUTCMonth() + 1, 2, "0"),
      padStart(date.getUTCDate(), 2, "0"),
      "T",
      padStart(date.getUTCHours(), 2, "0"),
      padStart(date.getUTCMinutes(), 2, "0"),
      padStart(date.getUTCSeconds(), 2, "0"),
      utc ? "Z" : ""
    ].join("");
  };
  dateutil2.untilStringToDate = function(until) {
    var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
    var bits = re.exec(until);
    if (!bits)
      throw new Error("Invalid UNTIL value: ".concat(until));
    return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
  };
})(dateutil || (dateutil = {}));
var dateutil_default = dateutil;

// node_modules/rrule/dist/esm/iterresult.js
var IterResult = function() {
  function IterResult2(method, args) {
    this.minDate = null;
    this.maxDate = null;
    this._result = [];
    this.total = 0;
    this.method = method;
    this.args = args;
    if (method === "between") {
      this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
      this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
    } else if (method === "before") {
      this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
    } else if (method === "after") {
      this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
    }
  }
  IterResult2.prototype.accept = function(date) {
    ++this.total;
    var tooEarly = this.minDate && date < this.minDate;
    var tooLate = this.maxDate && date > this.maxDate;
    if (this.method === "between") {
      if (tooEarly)
        return true;
      if (tooLate)
        return false;
    } else if (this.method === "before") {
      if (tooLate)
        return false;
    } else if (this.method === "after") {
      if (tooEarly)
        return true;
      this.add(date);
      return false;
    }
    return this.add(date);
  };
  IterResult2.prototype.add = function(date) {
    this._result.push(date);
    return true;
  };
  IterResult2.prototype.getValue = function() {
    var res = this._result;
    switch (this.method) {
      case "all":
      case "between":
        return res;
      case "before":
      case "after":
      default:
        return res.length ? res[res.length - 1] : null;
    }
  };
  IterResult2.prototype.clone = function() {
    return new IterResult2(this.method, this.args);
  };
  return IterResult2;
}();
var iterresult_default = IterResult;

// node_modules/rrule/node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
} = import_tslib.default;

// node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = function(_super) {
  __extends(CallbackIterResult2, _super);
  function CallbackIterResult2(method, args, iterator) {
    var _this = _super.call(this, method, args) || this;
    _this.iterator = iterator;
    return _this;
  }
  CallbackIterResult2.prototype.add = function(date) {
    if (this.iterator(date, this._result.length)) {
      this._result.push(date);
      return true;
    }
    return false;
  };
  return CallbackIterResult2;
}(iterresult_default);
var callbackiterresult_default = CallbackIterResult;

// node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// node_modules/rrule/dist/esm/nlp/totext.js
var contains = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = function() {
  function ToText2(rrule, gettext, language, dateFormatter) {
    if (gettext === void 0) {
      gettext = defaultGetText;
    }
    if (language === void 0) {
      language = i18n_default;
    }
    if (dateFormatter === void 0) {
      dateFormatter = defaultDateFormatter;
    }
    this.text = [];
    this.language = language || i18n_default;
    this.gettext = gettext;
    this.dateFormatter = dateFormatter;
    this.rrule = rrule;
    this.options = rrule.options;
    this.origOptions = rrule.origOptions;
    if (this.origOptions.bymonthday) {
      var bymonthday = [].concat(this.options.bymonthday);
      var bynmonthday = [].concat(this.options.bynmonthday);
      bymonthday.sort(function(a4, b2) {
        return a4 - b2;
      });
      bynmonthday.sort(function(a4, b2) {
        return b2 - a4;
      });
      this.bymonthday = bymonthday.concat(bynmonthday);
      if (!this.bymonthday.length)
        this.bymonthday = null;
    }
    if (isPresent(this.origOptions.byweekday)) {
      var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
      var days2 = String(byweekday);
      this.byweekday = {
        allWeeks: byweekday.filter(function(weekday) {
          return !weekday.n;
        }),
        someWeeks: byweekday.filter(function(weekday) {
          return Boolean(weekday.n);
        }),
        isWeekdays: days2.indexOf("MO") !== -1 && days2.indexOf("TU") !== -1 && days2.indexOf("WE") !== -1 && days2.indexOf("TH") !== -1 && days2.indexOf("FR") !== -1 && days2.indexOf("SA") === -1 && days2.indexOf("SU") === -1,
        isEveryDay: days2.indexOf("MO") !== -1 && days2.indexOf("TU") !== -1 && days2.indexOf("WE") !== -1 && days2.indexOf("TH") !== -1 && days2.indexOf("FR") !== -1 && days2.indexOf("SA") !== -1 && days2.indexOf("SU") !== -1
      };
      var sortWeekDays = function(a4, b2) {
        return a4.weekday - b2.weekday;
      };
      this.byweekday.allWeeks.sort(sortWeekDays);
      this.byweekday.someWeeks.sort(sortWeekDays);
      if (!this.byweekday.allWeeks.length)
        this.byweekday.allWeeks = null;
      if (!this.byweekday.someWeeks.length)
        this.byweekday.someWeeks = null;
    } else {
      this.byweekday = null;
    }
  }
  ToText2.isFullyConvertible = function(rrule) {
    var canConvert = true;
    if (!(rrule.options.freq in ToText2.IMPLEMENTED))
      return false;
    if (rrule.origOptions.until && rrule.origOptions.count)
      return false;
    for (var key in rrule.origOptions) {
      if (contains(["dtstart", "wkst", "freq"], key))
        return true;
      if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
        return false;
    }
    return canConvert;
  };
  ToText2.prototype.isFullyConvertible = function() {
    return ToText2.isFullyConvertible(this.rrule);
  };
  ToText2.prototype.toString = function() {
    var gettext = this.gettext;
    if (!(this.options.freq in ToText2.IMPLEMENTED)) {
      return gettext("RRule error: Unable to fully convert this rrule to text");
    }
    this.text = [gettext("every")];
    this[RRule.FREQUENCIES[this.options.freq]]();
    if (this.options.until) {
      this.add(gettext("until"));
      var until = this.options.until;
      this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
    } else if (this.options.count) {
      this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
    }
    if (!this.isFullyConvertible())
      this.add(gettext("(~ approximate)"));
    return this.text.join("");
  };
  ToText2.prototype.HOURLY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
  };
  ToText2.prototype.MINUTELY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
  };
  ToText2.prototype.DAILY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    if (this.byweekday && this.byweekday.isWeekdays) {
      this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
    } else {
      this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
    }
    if (this.origOptions.bymonth) {
      this.add(gettext("in"));
      this._bymonth();
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    } else if (this.origOptions.byhour) {
      this._byhour();
    }
  };
  ToText2.prototype.WEEKLY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1) {
      this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
    }
    if (this.byweekday && this.byweekday.isWeekdays) {
      if (this.options.interval === 1) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(gettext("on")).add(gettext("weekdays"));
      }
    } else if (this.byweekday && this.byweekday.isEveryDay) {
      this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
    } else {
      if (this.options.interval === 1)
        this.add(gettext("week"));
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
    }
  };
  ToText2.prototype.MONTHLY = function() {
    var gettext = this.gettext;
    if (this.origOptions.bymonth) {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(gettext("months"));
        if (this.plural(this.options.interval))
          this.add(gettext("in"));
      } else {
      }
      this._bymonth();
    } else {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
      }
      this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday && this.byweekday.isWeekdays) {
      this.add(gettext("on")).add(gettext("weekdays"));
    } else if (this.byweekday) {
      this._byweekday();
    }
  };
  ToText2.prototype.YEARLY = function() {
    var gettext = this.gettext;
    if (this.origOptions.bymonth) {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
        this.add(gettext("years"));
      } else {
      }
      this._bymonth();
    } else {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
      }
      this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    }
    if (this.options.byyearday) {
      this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
    }
    if (this.options.byweekno) {
      this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
    }
  };
  ToText2.prototype._bymonthday = function() {
    var gettext = this.gettext;
    if (this.byweekday && this.byweekday.allWeeks) {
      this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
    } else {
      this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
    }
  };
  ToText2.prototype._byweekday = function() {
    var gettext = this.gettext;
    if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
      this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
    }
    if (this.byweekday.someWeeks) {
      if (this.byweekday.allWeeks)
        this.add(gettext("and"));
      this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
    }
  };
  ToText2.prototype._byhour = function() {
    var gettext = this.gettext;
    this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
  };
  ToText2.prototype._bymonth = function() {
    this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
  };
  ToText2.prototype.nth = function(n2) {
    n2 = parseInt(n2.toString(), 10);
    var nth;
    var gettext = this.gettext;
    if (n2 === -1)
      return gettext("last");
    var npos = Math.abs(n2);
    switch (npos) {
      case 1:
      case 21:
      case 31:
        nth = npos + gettext("st");
        break;
      case 2:
      case 22:
        nth = npos + gettext("nd");
        break;
      case 3:
      case 23:
        nth = npos + gettext("rd");
        break;
      default:
        nth = npos + gettext("th");
    }
    return n2 < 0 ? nth + " " + gettext("last") : nth;
  };
  ToText2.prototype.monthtext = function(m3) {
    return this.language.monthNames[m3 - 1];
  };
  ToText2.prototype.weekdaytext = function(wday) {
    var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
    return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
  };
  ToText2.prototype.plural = function(n2) {
    return n2 % 100 !== 1;
  };
  ToText2.prototype.add = function(s4) {
    this.text.push(" ");
    this.text.push(s4);
    return this;
  };
  ToText2.prototype.list = function(arr, callback2, finalDelim, delim) {
    var _this = this;
    if (delim === void 0) {
      delim = ",";
    }
    if (!isArray(arr)) {
      arr = [arr];
    }
    var delimJoin = function(array, delimiter, finalDelimiter) {
      var list = "";
      for (var i3 = 0; i3 < array.length; i3++) {
        if (i3 !== 0) {
          if (i3 === array.length - 1) {
            list += " " + finalDelimiter + " ";
          } else {
            list += delimiter + " ";
          }
        }
        list += array[i3];
      }
      return list;
    };
    callback2 = callback2 || function(o2) {
      return o2.toString();
    };
    var realCallback = function(arg) {
      return callback2 && callback2.call(_this, arg);
    };
    if (finalDelim) {
      return delimJoin(arr.map(realCallback), delim, finalDelim);
    } else {
      return arr.map(realCallback).join(delim + " ");
    }
  };
  return ToText2;
}();
var totext_default = ToText;

// node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = function() {
  function Parser2(rules) {
    this.done = true;
    this.rules = rules;
  }
  Parser2.prototype.start = function(text2) {
    this.text = text2;
    this.done = false;
    return this.nextSymbol();
  };
  Parser2.prototype.isDone = function() {
    return this.done && this.symbol === null;
  };
  Parser2.prototype.nextSymbol = function() {
    var best;
    var bestSymbol;
    this.symbol = null;
    this.value = null;
    do {
      if (this.done)
        return false;
      var rule = void 0;
      best = null;
      for (var name_1 in this.rules) {
        rule = this.rules[name_1];
        var match3 = rule.exec(this.text);
        if (match3) {
          if (best === null || match3[0].length > best[0].length) {
            best = match3;
            bestSymbol = name_1;
          }
        }
      }
      if (best != null) {
        this.text = this.text.substr(best[0].length);
        if (this.text === "")
          this.done = true;
      }
      if (best == null) {
        this.done = true;
        this.symbol = null;
        this.value = null;
        return;
      }
    } while (bestSymbol === "SKIP");
    this.symbol = bestSymbol;
    this.value = best;
    return true;
  };
  Parser2.prototype.accept = function(name2) {
    if (this.symbol === name2) {
      if (this.value) {
        var v = this.value;
        this.nextSymbol();
        return v;
      }
      this.nextSymbol();
      return true;
    }
    return false;
  };
  Parser2.prototype.acceptNumber = function() {
    return this.accept("number");
  };
  Parser2.prototype.expect = function(name2) {
    if (this.accept(name2))
      return true;
    throw new Error("expected " + name2 + " but found " + this.symbol);
  };
  return Parser2;
}();
function parseText(text2, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text2))
    return null;
  S3();
  return options;
  function S3() {
    ttr.expect("every");
    var n2 = ttr.acceptNumber();
    if (n2)
      options.interval = parseInt(n2[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        F();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        MDAYs();
        F();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m3 = decodeM();
          if (!m3) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m3);
          ttr.nextSymbol();
        }
        ON();
        F();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on2 = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on2 || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m3 = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n2 = ttr.acceptNumber();
        if (!n2) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n2[0], 10)];
        while (ttr.accept("comma")) {
          n2 = ttr.acceptNumber();
          if (!n2) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n2[0], 10));
        }
      } else if (m3) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m3);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n2 = ttr.acceptNumber();
      if (!n2) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n2[0], 10)];
      while (ttr.accept("comma")) {
        n2 = ttr.acceptNumber();
        if (!n2) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n2[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v = parseInt(ttr.value[1], 10);
        if (v < -366 || v > 366)
          throw new Error("Nth out of range: " + v);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v : v;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text2, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text2, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// node_modules/rrule/dist/esm/datetime.js
var Time3 = function() {
  function Time5(hour, minute, second, millisecond) {
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond || 0;
  }
  Time5.prototype.getHours = function() {
    return this.hour;
  };
  Time5.prototype.getMinutes = function() {
    return this.minute;
  };
  Time5.prototype.getSeconds = function() {
    return this.second;
  };
  Time5.prototype.getMilliseconds = function() {
    return this.millisecond;
  };
  Time5.prototype.getTime = function() {
    return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
  };
  return Time5;
}();
var DateTime3 = function(_super) {
  __extends(DateTime4, _super);
  function DateTime4(year, month, day, hour, minute, second, millisecond) {
    var _this = _super.call(this, hour, minute, second, millisecond) || this;
    _this.year = year;
    _this.month = month;
    _this.day = day;
    return _this;
  }
  DateTime4.fromDate = function(date) {
    return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
  };
  DateTime4.prototype.getWeekday = function() {
    return dateutil.getWeekday(new Date(this.getTime()));
  };
  DateTime4.prototype.getTime = function() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
  };
  DateTime4.prototype.getDay = function() {
    return this.day;
  };
  DateTime4.prototype.getMonth = function() {
    return this.month;
  };
  DateTime4.prototype.getYear = function() {
    return this.year;
  };
  DateTime4.prototype.addYears = function(years) {
    this.year += years;
  };
  DateTime4.prototype.addMonths = function(months) {
    this.month += months;
    if (this.month > 12) {
      var yearDiv = Math.floor(this.month / 12);
      var monthMod = pymod(this.month, 12);
      this.month = monthMod;
      this.year += yearDiv;
      if (this.month === 0) {
        this.month = 12;
        --this.year;
      }
    }
  };
  DateTime4.prototype.addWeekly = function(days2, wkst) {
    if (wkst > this.getWeekday()) {
      this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days2 * 7;
    } else {
      this.day += -(this.getWeekday() - wkst) + days2 * 7;
    }
    this.fixDay();
  };
  DateTime4.prototype.addDaily = function(days2) {
    this.day += days2;
    this.fixDay();
  };
  DateTime4.prototype.addHours = function(hours, filtered, byhour) {
    if (filtered) {
      this.hour += Math.floor((23 - this.hour) / hours) * hours;
    }
    for (; ; ) {
      this.hour += hours;
      var _a3 = divmod(this.hour, 24), dayDiv = _a3.div, hourMod = _a3.mod;
      if (dayDiv) {
        this.hour = hourMod;
        this.addDaily(dayDiv);
      }
      if (empty(byhour) || includes(byhour, this.hour))
        break;
    }
  };
  DateTime4.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
    if (filtered) {
      this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
    }
    for (; ; ) {
      this.minute += minutes;
      var _a3 = divmod(this.minute, 60), hourDiv = _a3.div, minuteMod = _a3.mod;
      if (hourDiv) {
        this.minute = minuteMod;
        this.addHours(hourDiv, false, byhour);
      }
      if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
        break;
      }
    }
  };
  DateTime4.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
    if (filtered) {
      this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
    }
    for (; ; ) {
      this.second += seconds;
      var _a3 = divmod(this.second, 60), minuteDiv = _a3.div, secondMod = _a3.mod;
      if (minuteDiv) {
        this.second = secondMod;
        this.addMinutes(minuteDiv, false, byhour, byminute);
      }
      if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
        break;
      }
    }
  };
  DateTime4.prototype.fixDay = function() {
    if (this.day <= 28) {
      return;
    }
    var daysinmonth = dateutil.monthRange(this.year, this.month - 1)[1];
    if (this.day <= daysinmonth) {
      return;
    }
    while (this.day > daysinmonth) {
      this.day -= daysinmonth;
      ++this.month;
      if (this.month === 13) {
        this.month = 1;
        ++this.year;
        if (this.year > dateutil.MAXYEAR) {
          return;
        }
      }
      daysinmonth = dateutil.monthRange(this.year, this.month - 1)[1];
    }
  };
  DateTime4.prototype.add = function(options, filtered) {
    var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
    switch (freq) {
      case Frequency.YEARLY:
        return this.addYears(interval);
      case Frequency.MONTHLY:
        return this.addMonths(interval);
      case Frequency.WEEKLY:
        return this.addWeekly(interval, wkst);
      case Frequency.DAILY:
        return this.addDaily(interval);
      case Frequency.HOURLY:
        return this.addHours(interval, filtered, byhour);
      case Frequency.MINUTELY:
        return this.addMinutes(interval, filtered, byhour, byminute);
      case Frequency.SECONDLY:
        return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
    }
  };
  return DateTime4;
}(Time3);

// node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys2 = Object.keys(options);
  for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (dateutil_default.isDate(options[key]) && !dateutil_default.isValidDate(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options);
}
function parseOptions(options) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date(new Date().setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i3 = 0; i3 < opts.bysetpos.length; i3++) {
      var v = opts.bysetpos[i3];
      if (v === 0 || !(v >= -366 && v <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [dateutil_default.getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i3 = 0; i3 < opts.bymonthday.length; i3++) {
      var v = opts.bymonthday[i3];
      if (v > 0) {
        bymonthday.push(v);
      } else if (v < 0) {
        bynmonthday.push(v);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i3 = 0; i3 < opts.byweekday.length; i3++) {
      var wday = opts.byweekday[i3];
      if (isNumber(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time3(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// node_modules/rrule/dist/esm/parsestring.js
function parseString(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x2) {
    return x2 !== null;
  });
  return __assign(__assign({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = dateutil_default.untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr2) {
    var _a3 = attr2.split("="), key = _a3[0], value = _a3[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday(value);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = dateutil_default.untilStringToDate(value);
        break;
      case "BYEASTER":
        options.byeaster = Number(value);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value) {
  if (value.indexOf(",") !== -1) {
    var values = value.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value);
}
function parseIndividualNumber(value) {
  if (/^[+-]?\d+$/.test(value)) {
    return Number(value);
  }
  return value;
}
function parseWeekday(value) {
  var days2 = value.split(",");
  return days2.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n2 = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n2);
  });
}

// node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = function() {
  function DateWithZone2(date, tzid) {
    if (isNaN(date.getTime())) {
      throw new RangeError("Invalid date passed to DateWithZone");
    }
    this.date = date;
    this.tzid = tzid;
  }
  Object.defineProperty(DateWithZone2.prototype, "isUTC", {
    get: function() {
      return !this.tzid || this.tzid.toUpperCase() === "UTC";
    },
    enumerable: false,
    configurable: true
  });
  DateWithZone2.prototype.toString = function() {
    var datestr = dateutil_default.timeToUntilString(this.date.getTime(), this.isUTC);
    if (!this.isUTC) {
      return ";TZID=".concat(this.tzid, ":").concat(datestr);
    }
    return ":".concat(datestr);
  };
  DateWithZone2.prototype.getTime = function() {
    return this.date.getTime();
  };
  DateWithZone2.prototype.rezonedDate = function() {
    var _a3;
    if (this.isUTC) {
      return this.date;
    }
    var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    var dateInLocalTZ = new Date(this.date.toLocaleString(void 0, { timeZone: localTimeZone }));
    var dateInTargetTZ = new Date(this.date.toLocaleString(void 0, { timeZone: (_a3 = this.tzid) !== null && _a3 !== void 0 ? _a3 : "UTC" }));
    var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
    return new Date(this.date.getTime() - tzOffset);
  };
  return DateWithZone2;
}();

// node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys2 = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i3 = 0; i3 < keys2.length; i3++) {
    if (keys2[i3] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys2[i3]))
      continue;
    var key = keys2[i3].toUpperCase();
    var value = options[keys2[i3]];
    var outValue = "";
    if (!isPresent(value) || isArray(value) && !value.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber(value)) {
          outValue = new Weekday(value).toString();
        } else {
          outValue = value.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value, options.tzid);
        break;
      case "UNTIL":
        outValue = dateutil_default.timeToUntilString(value, !options.tzid);
        break;
      default:
        if (isArray(value)) {
          var strValues = [];
          for (var j = 0; j < value.length; j++) {
            strValues[j] = String(value[j]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a3) {
    var key2 = _a3[0], value2 = _a3[1];
    return "".concat(key2, "=").concat(value2.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x2) {
    return !!x2;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i3) {
      return date.getTime() === right[i3].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = function() {
  function Cache2() {
    this.all = false;
    this.before = [];
    this.after = [];
    this.between = [];
  }
  Cache2.prototype._cacheAdd = function(what, value, args) {
    if (value) {
      value = value instanceof Date ? dateutil_default.clone(value) : dateutil_default.cloneDates(value);
    }
    if (what === "all") {
      this.all = value;
    } else {
      args._value = value;
      this[what].push(args);
    }
  };
  Cache2.prototype._cacheGet = function(what, args) {
    var cached = false;
    var argsKeys = args ? Object.keys(args) : [];
    var findCacheDiff = function(item2) {
      for (var i4 = 0; i4 < argsKeys.length; i4++) {
        var key = argsKeys[i4];
        if (!argsMatch(args[key], item2[key])) {
          return true;
        }
      }
      return false;
    };
    var cachedObject = this[what];
    if (what === "all") {
      cached = this.all;
    } else if (isArray(cachedObject)) {
      for (var i3 = 0; i3 < cachedObject.length; i3++) {
        var item = cachedObject[i3];
        if (argsKeys.length && findCacheDiff(item))
          continue;
        cached = item._value;
        break;
      }
    }
    if (!cached && this.all) {
      var iterResult = new iterresult_default(what, args);
      for (var i3 = 0; i3 < this.all.length; i3++) {
        if (!iterResult.accept(this.all[i3]))
          break;
      }
      cached = iterResult.getValue();
      this._cacheAdd(what, cached, args);
    }
    return isArray(cached) ? dateutil_default.cloneDates(cached) : cached instanceof Date ? dateutil_default.clone(cached) : cached;
  };
  return Cache2;
}();

// node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i3 = 0; i3 < 55; i3++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = new Date(Date.UTC(year, 0, 1));
  var yearlen = dateutil_default.isLeapYear(year) ? 366 : 365;
  var nextyearlen = dateutil_default.isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = dateutil_default.toOrdinal(firstyday);
  var yearweekday = dateutil_default.getWeekday(firstyday);
  var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j = 0; j < options.byweekno.length; j++) {
    var n2 = options.byweekno[j];
    if (n2 < 0) {
      n2 += numweeks + 1;
    }
    if (!(n2 > 0 && n2 <= numweeks)) {
      continue;
    }
    var i3 = void 0;
    if (n2 > 1) {
      i3 = no1wkst + (n2 - 1) * 7;
      if (no1wkst !== firstwkst) {
        i3 -= 7 - firstwkst;
      }
    } else {
      i3 = no1wkst;
    }
    for (var k2 = 0; k2 < 7; k2++) {
      result.wnomask[i3] = 1;
      i3++;
      if (result.wdaymask[i3] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i3 = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i3 -= 7 - firstwkst;
    if (i3 < yearlen) {
      for (var j = 0; j < 7; j++) {
        result.wnomask[i3] = 1;
        i3 += 1;
        if (result.wdaymask[i3] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = dateutil_default.getWeekday(new Date(Date.UTC(year - 1, 0, 1)));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = dateutil_default.isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i3 = 0; i3 < no1wkst; i3++)
        result.wnomask[i3] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = dateutil_default.isLeapYear(year) ? 366 : 365;
  var firstyday = new Date(Date.UTC(year, 0, 1));
  var wday = dateutil_default.getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j = 0; j < options.bymonth.length; j++) {
        month = options.bymonth[j];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j = 0; j < ranges.length; j++) {
    var rang = ranges[j];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k2 = 0; k2 < options.bynweekday.length; k2++) {
      var i3 = void 0;
      var _a3 = options.bynweekday[k2], wday = _a3[0], n2 = _a3[1];
      if (n2 < 0) {
        i3 = last + (n2 + 1) * 7;
        i3 -= pymod(wdaymask[i3] - wday, 7);
      } else {
        i3 = first + (n2 - 1) * 7;
        i3 += pymod(7 - wdaymask[i3] + wday, 7);
      }
      if (first <= i3 && i3 <= last)
        result.nwdaymask[i3] = 1;
    }
  }
  return result;
}

// node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y3, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var a4 = y3 % 19;
  var b2 = Math.floor(y3 / 100);
  var c6 = y3 % 100;
  var d4 = Math.floor(b2 / 4);
  var e3 = b2 % 4;
  var f = Math.floor((b2 + 8) / 25);
  var g = Math.floor((b2 - f + 1) / 3);
  var h6 = Math.floor(19 * a4 + b2 - d4 - g + 15) % 30;
  var i3 = Math.floor(c6 / 4);
  var k2 = c6 % 4;
  var l2 = Math.floor(32 + 2 * e3 + 2 * i3 - h6 - k2) % 7;
  var m3 = Math.floor((a4 + 11 * h6 + 22 * l2) / 451);
  var month = Math.floor((h6 + l2 - 7 * m3 + 114) / 31);
  var day = (h6 + l2 - 7 * m3 + 114) % 31 + 1;
  var date = Date.UTC(y3, month - 1, day + offset);
  var yearStart = Date.UTC(y3, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = function() {
  function Iterinfo2(options) {
    this.options = options;
  }
  Iterinfo2.prototype.rebuild = function(year, month) {
    var options = this.options;
    if (year !== this.lastyear) {
      this.yearinfo = rebuildYear(year, options);
    }
    if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
      var _a3 = this.yearinfo, yearlen = _a3.yearlen, mrange = _a3.mrange, wdaymask = _a3.wdaymask;
      this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
    }
    if (isPresent(options.byeaster)) {
      this.eastermask = easter(year, options.byeaster);
    }
  };
  Object.defineProperty(Iterinfo2.prototype, "lastyear", {
    get: function() {
      return this.monthinfo ? this.monthinfo.lastyear : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
    get: function() {
      return this.monthinfo ? this.monthinfo.lastmonth : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "yearlen", {
    get: function() {
      return this.yearinfo.yearlen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
    get: function() {
      return this.yearinfo.yearordinal;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mrange", {
    get: function() {
      return this.yearinfo.mrange;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
    get: function() {
      return this.yearinfo.wdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mmask", {
    get: function() {
      return this.yearinfo.mmask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "wnomask", {
    get: function() {
      return this.yearinfo.wnomask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
    get: function() {
      return this.monthinfo ? this.monthinfo.nwdaymask : [];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
    get: function() {
      return this.yearinfo.nextyearlen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
    get: function() {
      return this.yearinfo.mdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
    get: function() {
      return this.yearinfo.nmdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Iterinfo2.prototype.ydayset = function() {
    return [range(this.yearlen), 0, this.yearlen];
  };
  Iterinfo2.prototype.mdayset = function(_, month) {
    var start = this.mrange[month - 1];
    var end = this.mrange[month];
    var set3 = repeat(null, this.yearlen);
    for (var i3 = start; i3 < end; i3++)
      set3[i3] = i3;
    return [set3, start, end];
  };
  Iterinfo2.prototype.wdayset = function(year, month, day) {
    var set3 = repeat(null, this.yearlen + 7);
    var i3 = dateutil_default.toOrdinal(new Date(Date.UTC(year, month - 1, day))) - this.yearordinal;
    var start = i3;
    for (var j = 0; j < 7; j++) {
      set3[i3] = i3;
      ++i3;
      if (this.wdaymask[i3] === this.options.wkst)
        break;
    }
    return [set3, start, i3];
  };
  Iterinfo2.prototype.ddayset = function(year, month, day) {
    var set3 = repeat(null, this.yearlen);
    var i3 = dateutil_default.toOrdinal(new Date(Date.UTC(year, month - 1, day))) - this.yearordinal;
    set3[i3] = i3;
    return [set3, i3, i3 + 1];
  };
  Iterinfo2.prototype.htimeset = function(hour, _, second, millisecond) {
    var _this = this;
    var set3 = [];
    this.options.byminute.forEach(function(minute) {
      set3 = set3.concat(_this.mtimeset(hour, minute, second, millisecond));
    });
    dateutil_default.sort(set3);
    return set3;
  };
  Iterinfo2.prototype.mtimeset = function(hour, minute, _, millisecond) {
    var set3 = this.options.bysecond.map(function(second) {
      return new Time3(hour, minute, second, millisecond);
    });
    dateutil_default.sort(set3);
    return set3;
  };
  Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
    return [new Time3(hour, minute, second, millisecond)];
  };
  Iterinfo2.prototype.getdayset = function(freq) {
    switch (freq) {
      case Frequency.YEARLY:
        return this.ydayset.bind(this);
      case Frequency.MONTHLY:
        return this.mdayset.bind(this);
      case Frequency.WEEKLY:
        return this.wdayset.bind(this);
      case Frequency.DAILY:
        return this.ddayset.bind(this);
      default:
        return this.ddayset.bind(this);
    }
  };
  Iterinfo2.prototype.gettimeset = function(freq) {
    switch (freq) {
      case Frequency.HOURLY:
        return this.htimeset.bind(this);
      case Frequency.MINUTELY:
        return this.mtimeset.bind(this);
      case Frequency.SECONDLY:
        return this.stimeset.bind(this);
    }
  };
  return Iterinfo2;
}();
var iterinfo_default = Iterinfo;

// node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j = 0; j < bysetpos.length; j++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k2 = start; k2 < end; k2++) {
      var val = dayset[k2];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i3 = void 0;
    if (daypos < 0) {
      i3 = tmp.slice(daypos)[0];
    } else {
      i3 = tmp[daypos];
    }
    var time2 = timeset[timepos];
    var date = dateutil_default.fromOrdinal(ii.yearordinal + i3);
    var res = dateutil_default.combine(date, time2);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  dateutil_default.sort(poslist);
  return poslist;
}

// node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime3.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a3 = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a3[0], start = _a3[1], end = _a3[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j = 0; j < poslist.length; j++) {
        var res = poslist[j];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j = start; j < end; j++) {
        var currentDay = dayset[j];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = dateutil_default.fromOrdinal(ii.yearordinal + currentDay);
        for (var k2 = 0; k2 < timeset.length; k2++) {
          var time2 = timeset[k2];
          var res = dateutil_default.combine(date, time2);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > dateutil_default.MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = function() {
  function RRule2(options, noCache) {
    if (options === void 0) {
      options = {};
    }
    if (noCache === void 0) {
      noCache = false;
    }
    this._cache = noCache ? null : new Cache();
    this.origOptions = initializeOptions(options);
    var parsedOptions = parseOptions(options).parsedOptions;
    this.options = parsedOptions;
  }
  RRule2.parseText = function(text2, language) {
    return parseText(text2, language);
  };
  RRule2.fromText = function(text2, language) {
    return fromText(text2, language);
  };
  RRule2.fromString = function(str) {
    return new RRule2(RRule2.parseString(str) || void 0);
  };
  RRule2.prototype._iter = function(iterResult) {
    return iter(iterResult, this.options);
  };
  RRule2.prototype._cacheGet = function(what, args) {
    if (!this._cache)
      return false;
    return this._cache._cacheGet(what, args);
  };
  RRule2.prototype._cacheAdd = function(what, value, args) {
    if (!this._cache)
      return;
    return this._cache._cacheAdd(what, value, args);
  };
  RRule2.prototype.all = function(iterator) {
    if (iterator) {
      return this._iter(new callbackiterresult_default("all", {}, iterator));
    }
    var result = this._cacheGet("all");
    if (result === false) {
      result = this._iter(new iterresult_default("all", {}));
      this._cacheAdd("all", result);
    }
    return result;
  };
  RRule2.prototype.between = function(after, before, inc, iterator) {
    if (inc === void 0) {
      inc = false;
    }
    if (!dateutil_default.isValidDate(after) || !dateutil_default.isValidDate(before)) {
      throw new Error("Invalid date passed in to RRule.between");
    }
    var args = {
      before,
      after,
      inc
    };
    if (iterator) {
      return this._iter(new callbackiterresult_default("between", args, iterator));
    }
    var result = this._cacheGet("between", args);
    if (result === false) {
      result = this._iter(new iterresult_default("between", args));
      this._cacheAdd("between", result, args);
    }
    return result;
  };
  RRule2.prototype.before = function(dt, inc) {
    if (inc === void 0) {
      inc = false;
    }
    if (!dateutil_default.isValidDate(dt)) {
      throw new Error("Invalid date passed in to RRule.before");
    }
    var args = { dt, inc };
    var result = this._cacheGet("before", args);
    if (result === false) {
      result = this._iter(new iterresult_default("before", args));
      this._cacheAdd("before", result, args);
    }
    return result;
  };
  RRule2.prototype.after = function(dt, inc) {
    if (inc === void 0) {
      inc = false;
    }
    if (!dateutil_default.isValidDate(dt)) {
      throw new Error("Invalid date passed in to RRule.after");
    }
    var args = { dt, inc };
    var result = this._cacheGet("after", args);
    if (result === false) {
      result = this._iter(new iterresult_default("after", args));
      this._cacheAdd("after", result, args);
    }
    return result;
  };
  RRule2.prototype.count = function() {
    return this.all().length;
  };
  RRule2.prototype.toString = function() {
    return optionsToString(this.origOptions);
  };
  RRule2.prototype.toText = function(gettext, language, dateFormatter) {
    return toText(this, gettext, language, dateFormatter);
  };
  RRule2.prototype.isFullyConvertibleToText = function() {
    return isFullyConvertible(this);
  };
  RRule2.prototype.clone = function() {
    return new RRule2(this.origOptions);
  };
  RRule2.FREQUENCIES = [
    "YEARLY",
    "MONTHLY",
    "WEEKLY",
    "DAILY",
    "HOURLY",
    "MINUTELY",
    "SECONDLY"
  ];
  RRule2.YEARLY = Frequency.YEARLY;
  RRule2.MONTHLY = Frequency.MONTHLY;
  RRule2.WEEKLY = Frequency.WEEKLY;
  RRule2.DAILY = Frequency.DAILY;
  RRule2.HOURLY = Frequency.HOURLY;
  RRule2.MINUTELY = Frequency.MINUTELY;
  RRule2.SECONDLY = Frequency.SECONDLY;
  RRule2.MO = Days.MO;
  RRule2.TU = Days.TU;
  RRule2.WE = Days.WE;
  RRule2.TH = Days.TH;
  RRule2.FR = Days.FR;
  RRule2.SA = Days.SA;
  RRule2.SU = Days.SU;
  RRule2.parseString = parseString;
  RRule2.optionsToString = optionsToString;
  return RRule2;
}();

// node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i3 = 0; i3 < _rdate.length; i3++) {
    var zonedDate = new DateWithZone(_rdate[i3], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  dateutil_default.sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s4, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s4);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s4, options.unfold);
  lines.forEach(function(line) {
    var _a3;
    if (!line)
      return;
    var _b2 = breakDownLine(line), name2 = _b2.name, parms = _b2.parms, value = _b2.value;
    switch (name2.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString(line));
        break;
      case "RDATE":
        var _c = (_a3 = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a3 !== void 0 ? _a3 : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString(value));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name2);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s4, options) {
  var _a3 = parseInput(s4, options), rrulevals = _a3.rrulevals, rdatevals = _a3.rdatevals, exrulevals = _a3.exrulevals, exdatevals = _a3.exdatevals, dtstart = _a3.dtstart, tzid = _a3.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s4, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s4, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys2 = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys2.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS2), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a3 = split(line, ":", 1), name2 = _a3[0], value = _a3[1];
  return {
    name: name2,
    value
  };
}
function breakDownLine(line) {
  var _a3 = extractName(line), name2 = _a3.name, value = _a3.value;
  var parms = name2.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value
  };
}
function splitIntoLines(s4, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s4 = s4 && s4.trim();
  if (!s4)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s4.split(/\s/);
  }
  var lines = s4.split("\n");
  var i3 = 0;
  while (i3 < lines.length) {
    var line = lines[i3] = lines[i3].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i3, 1);
    } else if (i3 > 0 && line[0] === " ") {
      lines[i3 - 1] += line.slice(1);
      lines.splice(i3, 1);
    } else {
      i3 += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return dateutil_default.untilStringToDate(datestr);
  });
}

// node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i3 = 0; i3 < _this._rrule.length; i3++) {
      var field_1 = _this._rrule[i3].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = function(_super) {
  __extends(RRuleSet2, _super);
  function RRuleSet2(noCache) {
    if (noCache === void 0) {
      noCache = false;
    }
    var _this = _super.call(this, {}, noCache) || this;
    _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
    _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
    _this._rrule = [];
    _this._rdate = [];
    _this._exrule = [];
    _this._exdate = [];
    return _this;
  }
  RRuleSet2.prototype._iter = function(iterResult) {
    return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
  };
  RRuleSet2.prototype.rrule = function(rrule) {
    _addRule(rrule, this._rrule);
  };
  RRuleSet2.prototype.exrule = function(rrule) {
    _addRule(rrule, this._exrule);
  };
  RRuleSet2.prototype.rdate = function(date) {
    _addDate(date, this._rdate);
  };
  RRuleSet2.prototype.exdate = function(date) {
    _addDate(date, this._exdate);
  };
  RRuleSet2.prototype.rrules = function() {
    return this._rrule.map(function(e3) {
      return rrulestr(e3.toString());
    });
  };
  RRuleSet2.prototype.exrules = function() {
    return this._exrule.map(function(e3) {
      return rrulestr(e3.toString());
    });
  };
  RRuleSet2.prototype.rdates = function() {
    return this._rdate.map(function(e3) {
      return new Date(e3.getTime());
    });
  };
  RRuleSet2.prototype.exdates = function() {
    return this._exdate.map(function(e3) {
      return new Date(e3.getTime());
    });
  };
  RRuleSet2.prototype.valueOf = function() {
    var result = [];
    if (!this._rrule.length && this._dtstart) {
      result = result.concat(optionsToString({ dtstart: this._dtstart }));
    }
    this._rrule.forEach(function(rrule) {
      result = result.concat(rrule.toString().split("\n"));
    });
    this._exrule.forEach(function(exrule) {
      result = result.concat(exrule.toString().split("\n").map(function(line) {
        return line.replace(/^RRULE:/, "EXRULE:");
      }).filter(function(line) {
        return !/^DTSTART/.test(line);
      }));
    });
    if (this._rdate.length) {
      result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
    }
    if (this._exdate.length) {
      result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
    }
    return result;
  };
  RRuleSet2.prototype.toString = function() {
    return this.valueOf().join("\n");
  };
  RRuleSet2.prototype.clone = function() {
    var rrs = new RRuleSet2(!!this._cache);
    this._rrule.forEach(function(rule) {
      return rrs.rrule(rule.clone());
    });
    this._exrule.forEach(function(rule) {
      return rrs.exrule(rule.clone());
    });
    this._rdate.forEach(function(date) {
      return rrs.rdate(new Date(date.getTime()));
    });
    this._exdate.forEach(function(date) {
      return rrs.exdate(new Date(date.getTime()));
    });
    return rrs;
  };
  return RRuleSet2;
}(RRule);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    dateutil_default.sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return dateutil_default.timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// src/model/format/splitter.ts
var MySymbol = class {
  constructor(primary, func) {
    this.primary = primary;
    this.func = func;
  }
  static ofChar(ch) {
    return new MySymbol(ch, (text2) => {
      return text2 === ch;
    });
  }
  static ofChars(ch) {
    if (ch.length === 0) {
      throw "empty symbol";
    }
    if (ch[0] == null) {
      throw "ch mustn't be null";
    }
    if (ch.length === 0) {
      return this.ofChar(ch[0]);
    }
    return new MySymbol(ch[0], (text2) => {
      return ch.filter((c6) => text2 === c6).length > 0;
    });
  }
  isMySymbol(text2) {
    return this.func(text2);
  }
};
var Tokens = class {
  constructor(tokens) {
    this.tokens = tokens;
  }
  setTokenText(symbol, text2, keepSpace = false, create = false, separateMySymbolAndText = false, insertAt) {
    let token = this.getToken(symbol);
    if (token === null) {
      if (!create) {
        return null;
      }
      if (symbol instanceof MySymbol) {
        token = { symbol: symbol.primary, text: text2 };
      } else {
        token = { symbol, text: text2 };
      }
      if (separateMySymbolAndText && token.symbol !== "" && !token.text.startsWith(" ")) {
        token.text = " " + token.text;
      }
      if (this.tokens.length > 0) {
        const lastToken = this.tokens[this.tokens.length - 1];
        if (!this.isTokenEndsWithSpace(lastToken)) {
          lastToken.text += " ";
        }
      }
      if (insertAt == null) {
        this.tokens.push(token);
      } else {
        let index2 = 0;
        let insertTokenIndex = -1;
        let tokenIndex = 0;
        for (const t3 of this.tokens) {
          const end = index2 + t3.symbol.length + t3.text.length;
          if (tokenIndex > 0) {
            if (end > insertAt) {
              insertTokenIndex = tokenIndex;
              break;
            }
          }
          index2 = end;
          tokenIndex++;
        }
        if (insertTokenIndex == -1) {
          this.tokens.push(token);
        } else {
          this.tokens.splice(insertTokenIndex, 0, token);
          if (insertTokenIndex < this.tokens.length - 1) {
            token.text = token.text + " ";
          }
        }
      }
      return token;
    }
    this.replaceTokenText(token, text2, keepSpace);
    return token;
  }
  length() {
    return this.tokens.length;
  }
  replaceTokenText(token, text2, keepSpace = false) {
    if (!keepSpace) {
      token.text = text2;
      return;
    }
    token.text = token.text.replace(/^(\s*).*?(\s*)$/, `$1${text2}$2`);
  }
  isTokenEndsWithSpace(token) {
    return token.text.match(/^.*\s$/);
  }
  getToken(symbol) {
    for (const token of this.tokens) {
      if (symbol instanceof MySymbol) {
        if (symbol.isMySymbol(token.symbol)) {
          return token;
        }
      } else {
        if (symbol === token.symbol) {
          return token;
        }
      }
    }
    return null;
  }
  getTokenText(symbol, removeSpace = false) {
    const token = this.getToken(symbol);
    if (token === null) {
      return null;
    }
    if (!removeSpace) {
      return token.text;
    }
    return token.text.replace(/^\s*(.*?)\s*$/, "$1");
  }
  removeToken(symbol) {
    this.tokens = this.tokens.filter((token) => !symbol.isMySymbol(token.symbol));
  }
  forEachTokens(consumer) {
    this.tokens.forEach(consumer);
  }
  rangeOfSymbol(symbol) {
    let index2 = 0;
    for (const token of this.tokens) {
      const end = index2 + token.symbol.length + token.text.length;
      if (symbol.isMySymbol(token.symbol)) {
        return {
          start: index2,
          end
        };
      }
      index2 = end;
    }
    return;
  }
  join() {
    return this.tokens.map((t3) => t3.symbol + t3.text).join("");
  }
};
function splitBySymbol(line, symbols) {
  const chars = [...line];
  let text2 = "";
  let currentToken = null;
  const splitted = [];
  const fillPreviousToken = () => {
    if (currentToken === null) {
      splitted.push({ symbol: "", text: text2 });
    } else {
      currentToken.text = text2;
    }
  };
  chars.forEach((c6) => {
    const isMySymbol = symbols.filter((s4) => s4.isMySymbol(c6)).length > 0;
    if (isMySymbol) {
      fillPreviousToken();
      currentToken = { symbol: c6, text: "" };
      splitted.push(currentToken);
      text2 = "";
    } else {
      text2 += c6;
    }
  });
  if (text2.length > 0) {
    fillPreviousToken();
  }
  return splitted;
}

// src/model/format/reminder-tasks-plugin.ts
function removeTags(text2) {
  return text2.replace(/#\w+/g, "");
}
var _TasksPluginReminderModel = class {
  constructor(useCustomEmoji, removeTags2, strictDateFormat, tokens) {
    this.useCustomEmoji = useCustomEmoji;
    this.removeTags = removeTags2;
    this.strictDateFormat = strictDateFormat;
    this.tokens = tokens;
  }
  static parse(line, useCustomEmoji, removeTags2, strictDateFormat) {
    return new _TasksPluginReminderModel(useCustomEmoji != null ? useCustomEmoji : false, removeTags2 != null ? removeTags2 : false, strictDateFormat != null ? strictDateFormat : true, new Tokens(splitBySymbol(line, this.allSymbols)));
  }
  getTitle() {
    let title = this.tokens.getTokenText("", true);
    if (title != null && this.removeTags) {
      title = removeTags(title);
    }
    return title;
  }
  getTime() {
    return this.getDate(this.getReminderSymbol());
  }
  setTime(time2, insertAt) {
    if (this.useCustomEmoji) {
      this.setDate(this.getReminderSymbol(), time2, 1);
    } else {
      this.setDate(this.getReminderSymbol(), time2, insertAt);
    }
  }
  getDueDate() {
    return this.getDate(_TasksPluginReminderModel.symbolDueDate);
  }
  setDueDate(time2) {
    this.setDate(_TasksPluginReminderModel.symbolDueDate, time2);
  }
  setRawTime(rawTime) {
    this.setDate(this.getReminderSymbol(), rawTime);
    return true;
  }
  getReminderSymbol() {
    if (this.useCustomEmoji) {
      return _TasksPluginReminderModel.symbolReminder;
    } else {
      return _TasksPluginReminderModel.symbolDueDate;
    }
  }
  getEndOfTimeTextIndex() {
    let timeSymbol = _TasksPluginReminderModel.symbolDueDate;
    if (this.useCustomEmoji) {
      timeSymbol = _TasksPluginReminderModel.symbolReminder;
    }
    const token = this.tokens.rangeOfSymbol(timeSymbol);
    if (token != null) {
      return token.end;
    }
    return this.toMarkdown().length;
  }
  toMarkdown() {
    return this.tokens.join();
  }
  setTitle(description) {
    this.tokens.setTokenText("", description, true, true);
  }
  getDoneDate() {
    return this.getDate(_TasksPluginReminderModel.symbolDoneDate);
  }
  setDoneDate(time2) {
    this.setDate(_TasksPluginReminderModel.symbolDoneDate, time2);
  }
  getRecurrence() {
    return this.tokens.getTokenText(_TasksPluginReminderModel.symbolRecurrence, true);
  }
  clone() {
    return _TasksPluginReminderModel.parse(this.toMarkdown(), this.useCustomEmoji, this.removeTags, this.strictDateFormat);
  }
  getDate(symbol) {
    const dateText = this.tokens.getTokenText(symbol, true);
    if (dateText === null) {
      return null;
    }
    if (symbol === _TasksPluginReminderModel.symbolReminder) {
      return DATE_TIME_FORMATTER.parse(dateText);
    } else {
      const date = (0, import_moment3.default)(dateText, _TasksPluginReminderModel.dateFormat, this.strictDateFormat);
      if (!date.isValid()) {
        return null;
      }
      return new DateTime(date, false);
    }
  }
  setDate(symbol, time2, insertAt) {
    if (time2 == null) {
      this.tokens.removeToken(symbol);
      return;
    }
    let timeStr;
    if (time2 instanceof DateTime) {
      if (symbol === _TasksPluginReminderModel.symbolReminder) {
        timeStr = DATE_TIME_FORMATTER.toString(time2);
      } else {
        timeStr = time2.format(_TasksPluginReminderModel.dateFormat);
      }
    } else {
      timeStr = time2;
    }
    this.tokens.setTokenText(symbol, timeStr, true, true, this.shouldSplitBetweenSymbolAndText(), insertAt);
  }
  shouldSplitBetweenSymbolAndText() {
    let withSpace = 0;
    let noSpace = 0;
    this.tokens.forEachTokens((token) => {
      if (token.symbol === "") {
        return;
      }
      if (token.text.match(/^\s.*$/)) {
        withSpace += 1;
      } else {
        noSpace++;
      }
    });
    if (withSpace > noSpace) {
      return true;
    } else if (withSpace < noSpace) {
      return false;
    } else {
      return true;
    }
  }
};
var TasksPluginReminderModel = _TasksPluginReminderModel;
TasksPluginReminderModel.dateFormat = "YYYY-MM-DD";
TasksPluginReminderModel.symbolDueDate = MySymbol.ofChars([..."\u{1F4C5}\u{1F4C6}\u{1F5D3}"]);
TasksPluginReminderModel.symbolDoneDate = MySymbol.ofChar("\u2705");
TasksPluginReminderModel.symbolRecurrence = MySymbol.ofChar("\u{1F501}");
TasksPluginReminderModel.symbolReminder = MySymbol.ofChar("\u23F0");
TasksPluginReminderModel.symbolScheduled = MySymbol.ofChar("\u23F3");
TasksPluginReminderModel.symbolStart = MySymbol.ofChar("\u{1F6EB}");
TasksPluginReminderModel.allSymbols = [
  _TasksPluginReminderModel.symbolDueDate,
  _TasksPluginReminderModel.symbolDoneDate,
  _TasksPluginReminderModel.symbolRecurrence,
  _TasksPluginReminderModel.symbolReminder,
  _TasksPluginReminderModel.symbolStart,
  _TasksPluginReminderModel.symbolScheduled
];
var _TasksPluginFormat = class extends TodoBasedReminderFormat {
  parseReminder(todo) {
    const parsed = TasksPluginReminderModel.parse(todo.body, this.useCustomEmoji(), this.removeTagsEnabled(), this.isStrictDateFormat());
    if (this.useCustomEmoji() && parsed.getDueDate() == null) {
      return null;
    }
    return parsed;
  }
  removeTagsEnabled() {
    return this.config.getParameter(ReminderFormatParameterKey.removeTagsForTasksPlugin);
  }
  useCustomEmoji() {
    return this.config.getParameter(ReminderFormatParameterKey.useCustomEmojiForTasksPlugin);
  }
  modifyReminder(doc2, todo, parsed, edit) {
    if (!super.modifyReminder(doc2, todo, parsed, edit)) {
      return false;
    }
    if (edit.checked !== void 0) {
      if (edit.checked) {
        const recurrence = parsed.getRecurrence();
        if (recurrence !== null) {
          const nextReminderTodo = todo.clone();
          const nextReminder = parsed.clone();
          const dueDate = parsed.getDueDate();
          if (dueDate == null) {
            return false;
          }
          if (this.useCustomEmoji()) {
            const time2 = parsed.getTime();
            if (time2 == null) {
              return false;
            }
            const nextTime = this.nextDate(recurrence, time2.moment());
            const nextDueDate = this.nextDate(recurrence, dueDate.moment());
            if (nextTime == null || nextDueDate == null) {
              return false;
            }
            nextReminder.setTime(new DateTime((0, import_moment3.default)(nextTime), true));
            nextReminder.setDueDate(new DateTime((0, import_moment3.default)(nextDueDate), true));
          } else {
            const next = this.nextDate(recurrence, dueDate.moment());
            if (next == null) {
              return false;
            }
            const nextDueDate = new DateTime((0, import_moment3.default)(next), true);
            nextReminder.setTime(nextDueDate);
          }
          nextReminderTodo.body = nextReminder.toMarkdown();
          nextReminderTodo.setChecked(false);
          doc2.insertTodo(todo.lineIndex, nextReminderTodo);
        }
        parsed.setDoneDate(this.config.getParameter(ReminderFormatParameterKey.now));
      } else {
        parsed.setDoneDate(void 0);
      }
    }
    return true;
  }
  nextDate(recurrence, dtStart) {
    const rruleOptions = RRule.parseText(recurrence);
    if (!rruleOptions) {
      return void 0;
    }
    const today = this.config.getParameter(ReminderFormatParameterKey.now).moment();
    today.set("hour", dtStart.get("hour"));
    today.set("minute", dtStart.get("minute"));
    today.set("second", dtStart.get("second"));
    today.set("millisecond", dtStart.get("millisecond"));
    if (today.isAfter(dtStart)) {
      dtStart = today;
    }
    const base3 = dtStart.clone();
    rruleOptions.dtstart = dtStart.utc(true).toDate();
    const rrule = new RRule(rruleOptions);
    const rdate = rrule.after(dtStart.toDate(), false);
    const diff = rdate.getTime() - rruleOptions.dtstart.getTime();
    base3.add(diff, "millisecond");
    return base3.toDate();
  }
  newReminder(title, time2, insertAt) {
    const parsed = TasksPluginReminderModel.parse(title, this.useCustomEmoji(), this.removeTagsEnabled(), this.isStrictDateFormat());
    parsed.setTime(time2, insertAt);
    if (this.useCustomEmoji() && parsed.getDueDate() == null) {
      parsed.setDueDate(time2);
    }
    parsed.setTitle(title);
    return parsed;
  }
};
var TasksPluginFormat = _TasksPluginFormat;
TasksPluginFormat.instance = new _TasksPluginFormat();

// src/model/format/index.ts
var REMINDER_FORMAT = new CompositeReminderFormat();
REMINDER_FORMAT.resetFormat([DefaultReminderFormat.instance]);
var ReminderFormatType = class {
  constructor(name2, description, example, format2, defaultEnabled) {
    this.name = name2;
    this.description = description;
    this.example = example;
    this.format = format2;
    this.defaultEnabled = defaultEnabled;
  }
};
function parseReminder(doc2) {
  return REMINDER_FORMAT.parse(doc2);
}
async function modifyReminder(doc2, reminder, edit) {
  return REMINDER_FORMAT.modify(doc2, reminder, edit);
}
function changeReminderFormat(formatTypes) {
  if (formatTypes.length === 0) {
    REMINDER_FORMAT.resetFormat([DefaultReminderFormat.instance]);
  } else {
    REMINDER_FORMAT.resetFormat(formatTypes.map((f) => f.format));
  }
}
function setReminderFormatConfig(config) {
  REMINDER_FORMAT.setConfig(config);
}
var reminderPluginReminderFormat = new ReminderFormatType("ReminderPluginReminderFormat", "Reminder plugin format", "(@2021-09-08)", DefaultReminderFormat.instance, true);
var tasksPluginReminderFormat = new ReminderFormatType("TasksPluginReminderFormat", "Tasks plugin format", "\u{1F4C5} 2021-09-08", TasksPluginFormat.instance, false);
var kanbanPluginReminderFormat = new ReminderFormatType("KanbanPluginReminderFormat", "Kanban plugin format", "@{2021-09-08}", KanbanReminderFormat.instance, false);
var ReminderFormatTypes = [
  reminderPluginReminderFormat,
  tasksPluginReminderFormat,
  kanbanPluginReminderFormat
];

// src/model/content.ts
var Content = class {
  constructor(file, content) {
    this.doc = new MarkdownDocument(file, content);
  }
  getReminders(doneOnly = true) {
    const reminders = parseReminder(this.doc);
    if (!doneOnly) {
      return reminders;
    }
    return reminders.filter((reminder) => !reminder.done);
  }
  getTodos() {
    return this.doc.getTodos();
  }
  async modifyReminderLines(modifyFunc) {
    for (const reminder of this.getReminders(false)) {
      const edit = modifyFunc(reminder);
      if (edit === null) {
        return;
      }
      await this.modifyReminderLine(reminder, edit);
    }
  }
  async updateReminder(reminder, edit) {
    await this.modifyReminderLine(reminder, edit);
  }
  async modifyReminderLine(reminder, edit) {
    const modified = await modifyReminder(this.doc, reminder, edit);
    if (modified) {
      logger_default.info("Reminder was updated: reminder=%o", reminder);
    } else {
      logger_default.warn("Cannot modify reminder because it's not a reminder todo: reminder=%o", reminder);
    }
    return modified;
  }
  getContent() {
    return this.doc.toMarkdown();
  }
};

// src/controller.ts
var RemindersController = class {
  constructor(vault, reminders) {
    this.vault = vault;
    this.reminders = reminders;
  }
  async openReminder(reminder, leaf) {
    logger_default.log("Open reminder: ", reminder);
    const file = this.vault.getAbstractFileByPath(reminder.file);
    if (!(file instanceof import_obsidian2.TFile)) {
      logger_default.error("Cannot open file because it isn't a TFile: %o", file);
      return;
    }
    await leaf.openFile(file);
    if (!(leaf.view instanceof import_obsidian2.MarkdownView)) {
      return;
    }
    const line = leaf.view.editor.getLine(reminder.rowNumber);
    leaf.view.editor.setSelection({
      line: reminder.rowNumber,
      ch: 0
    }, {
      line: reminder.rowNumber,
      ch: line.length
    });
  }
  async updateReminder(reminder, checked) {
    const file = this.vault.getAbstractFileByPath(reminder.file);
    if (!(file instanceof import_obsidian2.TFile)) {
      logger_default.error("file is not instance of TFile: %o", file);
      return;
    }
    const content = new Content(file.path, await this.vault.read(file));
    await content.updateReminder(reminder, {
      checked,
      time: reminder.time
    });
    await this.vault.modify(file, content.getContent());
  }
  async reloadAllFiles() {
    logger_default.debug("Reload all files and collect reminders");
    this.reminders.clear();
    for (const file of this.vault.getMarkdownFiles()) {
      await this.reloadFile(file, false);
    }
  }
  async removeFile(path) {
    logger_default.debug("Remove file: path=%s", path);
    const result = this.reminders.removeFile(path);
    return result;
  }
  async reloadFile(file, reloadUI = false) {
    logger_default.debug("Reload file and collect reminders: file=%s, forceReloadUI=%s", file.path, reloadUI);
    if (!(file instanceof import_obsidian2.TFile)) {
      logger_default.debug("Cannot read file other than TFile: file=%o", file);
      return false;
    }
    if (!this.isMarkdownFile(file)) {
      logger_default.debug("Not a markdown file: file=%o", file);
      return false;
    }
    const content = new Content(file.path, await this.vault.cachedRead(file));
    const reminders = content.getReminders();
    if (reminders.length > 0) {
      if (!this.reminders.replaceFile(file.path, reminders)) {
        return false;
      }
    } else {
      if (!this.reminders.removeFile(file.path)) {
        return false;
      }
    }
    return true;
  }
  isMarkdownFile(file) {
    return file.extension.toLowerCase() === "md";
  }
};

// src/model/settings.ts
var import_obsidian3 = require("obsidian");
var SettingRegistry = class {
  constructor() {
    this.settingContexts = [];
  }
  register(settingContext) {
    this.settingContexts.push(settingContext);
  }
  findByKey(key) {
    return this.settingContexts.find((c6) => c6.key === key);
  }
  forEach(consumer) {
    this.settingContexts.forEach(consumer);
  }
};
var SettingContext = class {
  constructor(_settingRegistry) {
    this._settingRegistry = _settingRegistry;
    this.tags = [];
  }
  init(settingModel, setting, containerEl) {
    this.settingModel = settingModel;
    this._setting = setting;
    this.validationEl = containerEl.createDiv("validation", (el) => {
      el.style.color = "var(--text-error)";
      el.style.marginBottom = "1rem";
      el.style.fontSize = "14px";
      el.style.display = "none";
    });
    this.infoEl = containerEl.createDiv("info", (el) => {
      el.style.color = "var(--text-faint)";
      el.style.marginBottom = "1rem";
      el.style.fontSize = "14px";
      el.style.display = "none";
    });
  }
  setValidationError(error) {
    this.setText(this.validationEl, error);
  }
  setInfo(info) {
    this.setText(this.infoEl, info);
  }
  setText(el, text2) {
    if (!el) {
      logger_default.error("element not created");
      return;
    }
    if (text2 === null) {
      el.style.display = "none";
    } else {
      el.style.display = "block";
      el.innerHTML = text2;
    }
  }
  get setting() {
    return this._setting;
  }
  get registry() {
    return this._settingRegistry;
  }
  hasTag(tag) {
    return this.tags.filter((t3) => t3 === tag).length > 0;
  }
  update() {
    if (!this.anyValueChanged) {
      return;
    }
    this.anyValueChanged(this);
  }
  setEnabled(enable) {
    this.setting.setDisabled(!enable);
  }
  findContextByKey(key) {
    return this._settingRegistry.findByKey(key);
  }
  booleanValue() {
    return this.settingModel.value;
  }
  isInitialized() {
    return this.settingModel && this.validationEl && this.setting;
  }
};
var SettingModelBuilder = class {
  constructor(registry2) {
    this.registry = registry2;
    this.context = new SettingContext(this.registry);
    this.registry.register(this.context);
  }
  key(key) {
    this.context.key = key;
    return this;
  }
  name(name2) {
    this.context.name = name2;
    return this;
  }
  desc(desc) {
    this.context.desc = desc;
    return this;
  }
  tag(tag) {
    this.context.tags.push(tag);
    return this;
  }
  text(initValue) {
    return new TextSettingModelBuilder(this.context, false, initValue);
  }
  textArea(initValue) {
    return new TextSettingModelBuilder(this.context, true, initValue);
  }
  number(initValue) {
    return new NumberSettingModelBuilder(this.context, initValue);
  }
  toggle(initValue) {
    return new ToggleSettingModelBuilder(this.context, initValue);
  }
  dropdown(initValue) {
    return new DropdownSettingModelBuilder(this.context, initValue);
  }
};
var AbstractSettingModelBuilder = class {
  constructor(context, initValue) {
    this.context = context;
    this.initValue = initValue;
  }
  onAnyValueChanged(anyValueChanged) {
    this.context.anyValueChanged = anyValueChanged;
    return this;
  }
  onValueChange() {
    this.context.registry.forEach((c6) => {
      c6.update();
    });
  }
  buildSettingModel(serde, initializer) {
    return new SettingModelImpl(this.context, serde, this.initValue, initializer);
  }
};
var TextSettingModelBuilder = class extends AbstractSettingModelBuilder {
  constructor(context, longText, initValue) {
    super(context, initValue);
    this.longText = longText;
  }
  placeHolder(placeHolder) {
    this._placeHolder = placeHolder;
    return this;
  }
  build(serde) {
    return this.buildSettingModel(serde, ({ setting, rawValue, context }) => {
      const initText = (text2) => {
        var _a3;
        text2.setPlaceholder((_a3 = this._placeHolder) != null ? _a3 : "").setValue(rawValue.value).onChange(async (value) => {
          try {
            serde.unmarshal(value);
            rawValue.value = value;
            context.setValidationError(null);
            this.onValueChange();
          } catch (e3) {
            if (e3 instanceof Error) {
              context.setValidationError(e3.message);
            } else if (typeof e3 === "string") {
              context.setValidationError(e3);
            }
          }
        });
      };
      if (this.longText) {
        setting.addTextArea((textarea) => {
          initText(textarea);
        });
      } else {
        setting.addText((text2) => {
          initText(text2);
        });
      }
    });
  }
};
var NumberSettingModelBuilder = class extends AbstractSettingModelBuilder {
  constructor(context, initValue) {
    super(context, initValue);
  }
  placeHolder(placeHolder) {
    this._placeHolder = placeHolder;
    return this;
  }
  build(serde) {
    return this.buildSettingModel(serde, ({ setting, rawValue, context }) => {
      const initText = (text2) => {
        var _a3;
        text2.setPlaceholder((_a3 = this._placeHolder) != null ? _a3 : "").setValue(rawValue.value.toString()).onChange(async (value) => {
          try {
            const n2 = parseInt(value);
            rawValue.value = n2;
            context.setValidationError(null);
            this.onValueChange();
          } catch (e3) {
            if (e3 instanceof Error) {
              context.setValidationError(e3.message);
            } else if (typeof e3 === "string") {
              context.setValidationError(e3);
            }
          }
        });
      };
      setting.addText((textarea) => {
        initText(textarea);
      });
    });
  }
};
var ToggleSettingModelBuilder = class extends AbstractSettingModelBuilder {
  build(serde) {
    return new SettingModelImpl(this.context, serde, this.initValue, ({ setting, rawValue }) => {
      setting.addToggle((toggle) => toggle.setValue(rawValue.value).onChange(async (value) => {
        rawValue.value = value;
        this.onValueChange();
      }));
    });
  }
};
var DropdownOption = class {
  constructor(label, value) {
    this.label = label;
    this.value = value;
  }
};
var DropdownSettingModelBuilder = class extends AbstractSettingModelBuilder {
  constructor() {
    super(...arguments);
    this.options = [];
  }
  addOption(label, value) {
    this.options.push(new DropdownOption(label, value));
    return this;
  }
  build(serde) {
    return new SettingModelImpl(this.context, serde, this.initValue, ({ setting, rawValue }) => {
      setting.addDropdown((d4) => {
        this.options.forEach((option) => {
          d4.addOption(option.value, option.label);
        });
        d4.setValue(rawValue.value);
        d4.onChange(async (value) => {
          rawValue.value = value;
          this.onValueChange();
        });
      });
    });
  }
};
var SettingModelImpl = class {
  constructor(context, serde, initRawValue, settingInitializer) {
    this.context = context;
    this.serde = serde;
    this.settingInitializer = settingInitializer;
    this.rawValue = new Reference(initRawValue);
    if (context.key == null) {
      throw new Error("key is required.");
    }
  }
  createSetting(containerEl) {
    var _a3, _b2;
    const setting = new import_obsidian3.Setting(containerEl).setName((_a3 = this.context.name) != null ? _a3 : "").setDesc((_b2 = this.context.desc) != null ? _b2 : "");
    this.context.init(this, setting, containerEl);
    this.settingInitializer({
      setting,
      rawValue: this.rawValue,
      context: this.context
    });
    return setting;
  }
  get value() {
    return this.serde.unmarshal(this.rawValue.value);
  }
  get key() {
    return this.context.key;
  }
  load(settings) {
    if (settings === void 0) {
      return;
    }
    const newValue = settings[this.key];
    if (newValue !== void 0) {
      this.rawValue.value = newValue;
    }
  }
  store(settings) {
    settings[this.key] = this.rawValue.value;
  }
  hasTag(tag) {
    return this.context.hasTag(tag);
  }
};
var SettingGroup = class {
  constructor(name2) {
    this.name = name2;
    this.settings = [];
  }
  addSettings(...settingModels) {
    this.settings.push(...settingModels);
  }
};
var SettingTabModel = class {
  constructor() {
    this.groups = [];
    this.registry = new SettingRegistry();
  }
  newSettingBuilder() {
    return new SettingModelBuilder(this.registry);
  }
  newGroup(name2) {
    const group = new SettingGroup(name2);
    this.groups.push(group);
    return group;
  }
  displayOn(el) {
    el.empty();
    this.groups.forEach((group) => {
      el.createEl("h3", { text: group.name });
      group.settings.forEach((settings) => {
        settings.createSetting(el);
      });
    });
    this.registry.forEach((context) => context.update());
  }
  forEach(consumer) {
    this.groups.forEach((group) => {
      group.settings.forEach((setting) => {
        consumer(setting);
      });
    });
  }
};
var TimeSerde = class {
  unmarshal(rawValue) {
    return Time.parse(rawValue);
  }
  marshal(value) {
    return value.toString();
  }
};
var RawSerde = class {
  unmarshal(rawValue) {
    return rawValue;
  }
  marshal(value) {
    return value;
  }
};
var LatersSerde = class {
  unmarshal(rawValue) {
    return parseLaters(rawValue);
  }
  marshal(value) {
    return value.map((v) => v.label).join("\n");
  }
};
var ReminderFormatTypeSerde = class {
  unmarshal(rawValue) {
    const format2 = ReminderFormatTypes.find((format3) => format3.name === rawValue);
    return format2;
  }
  marshal(value) {
    return value.name;
  }
};

// src/settings.ts
var import_obsidian4 = require("obsidian");
var import_obsidian_daily_notes_interface = __toESM(require_main());

// node_modules/cursor-effects/dist/esm.js
function e(e3) {
  let t3, i3, n2, o2, s4 = e3 && e3.emoji || "\u{1F92A}", h6 = e3 && e3.element, c6 = h6 || document.body, l2 = window.innerWidth, d4 = window.innerHeight, a4 = { x: l2 / 2, y: l2 / 2 }, r = [];
  const A2 = window.matchMedia("(prefers-reduced-motion: reduce)");
  function u2() {
    if (A2.matches)
      return console.log("This browser has prefers reduced motion turned on, so the cursor did not init"), false;
    t3 = document.createElement("canvas"), i3 = t3.getContext("2d"), t3.style.top = "0px", t3.style.left = "0px", t3.style.pointerEvents = "none", h6 ? (t3.style.position = "absolute", c6.appendChild(t3), t3.width = c6.clientWidth, t3.height = c6.clientHeight) : (t3.style.position = "fixed", document.body.appendChild(t3), t3.width = l2, t3.height = d4), i3.font = "16px serif", i3.textBaseline = "middle", i3.textAlign = "center";
    let e4 = i3.measureText(s4), n3 = document.createElement("canvas"), a5 = n3.getContext("2d");
    n3.width = e4.width, n3.height = 2 * e4.actualBoundingBoxAscent, a5.textAlign = "center", a5.font = "16px serif", a5.textBaseline = "middle", a5.fillText(s4, n3.width / 2, e4.actualBoundingBoxAscent), o2 = n3;
    let u3 = 0;
    for (u3 = 0; u3 < 7; u3++)
      r[u3] = new x2(o2);
    c6.addEventListener("mousemove", p2), c6.addEventListener("touchmove", g, { passive: true }), c6.addEventListener("touchstart", g, { passive: true }), window.addEventListener("resize", m3), f();
  }
  function m3(e4) {
    l2 = window.innerWidth, d4 = window.innerHeight, h6 ? (t3.width = c6.clientWidth, t3.height = c6.clientHeight) : (t3.width = l2, t3.height = d4);
  }
  function g(e4) {
    if (e4.touches.length > 0)
      if (h6) {
        const t4 = c6.getBoundingClientRect();
        a4.x = e4.touches[0].clientX - t4.left, a4.y = e4.touches[0].clientY - t4.top;
      } else
        a4.x = e4.touches[0].clientX, a4.y = e4.touches[0].clientY;
  }
  function p2(e4) {
    if (h6) {
      const t4 = c6.getBoundingClientRect();
      a4.x = e4.clientX - t4.left, a4.y = e4.clientY - t4.top;
    } else
      a4.x = e4.clientX, a4.y = e4.clientY;
  }
  function f() {
    !function() {
      t3.width = t3.width, r[0].position.x = a4.x, r[0].position.y = a4.y;
      for (let e4 = 1; e4 < 7; e4++) {
        let n3 = new v(0, 0);
        e4 > 0 && w3(e4 - 1, e4, n3), e4 < 6 && w3(e4 + 1, e4, n3);
        let o3, s5, h7 = new v(10 * -r[e4].velocity.x, 10 * -r[e4].velocity.y), c7 = new v((n3.X + h7.X) / 1, (n3.Y + h7.Y) / 1 + 50);
        r[e4].velocity.x += 0.01 * c7.X, r[e4].velocity.y += 0.01 * c7.Y, Math.abs(r[e4].velocity.x) < 0.1 && Math.abs(r[e4].velocity.y) < 0.1 && Math.abs(c7.X) < 0.1 && Math.abs(c7.Y) < 0.1 && (r[e4].velocity.x = 0, r[e4].velocity.y = 0), r[e4].position.x += r[e4].velocity.x, r[e4].position.y += r[e4].velocity.y, o3 = t3.clientHeight, s5 = t3.clientWidth, r[e4].position.y >= o3 - 11 - 1 && (r[e4].velocity.y > 0 && (r[e4].velocity.y = 0.7 * -r[e4].velocity.y), r[e4].position.y = o3 - 11 - 1), r[e4].position.x >= s5 - 11 && (r[e4].velocity.x > 0 && (r[e4].velocity.x = 0.7 * -r[e4].velocity.x), r[e4].position.x = s5 - 11 - 1), r[e4].position.x < 0 && (r[e4].velocity.x < 0 && (r[e4].velocity.x = 0.7 * -r[e4].velocity.x), r[e4].position.x = 0), r[e4].draw(i3);
      }
    }(), n2 = requestAnimationFrame(f);
  }
  function y3() {
    t3.remove(), cancelAnimationFrame(n2), c6.removeEventListener("mousemove", p2), c6.removeEventListener("touchmove", g), c6.removeEventListener("touchstart", g), window.addEventListener("resize", m3);
  }
  function v(e4, t4) {
    this.X = e4, this.Y = t4;
  }
  function w3(e4, t4, i4) {
    let n3 = r[e4].position.x - r[t4].position.x, o3 = r[e4].position.y - r[t4].position.y, s5 = Math.sqrt(n3 * n3 + o3 * o3);
    if (s5 > 10) {
      let e5 = 10 * (s5 - 10);
      i4.X += n3 / s5 * e5, i4.Y += o3 / s5 * e5;
    }
  }
  function x2(e4) {
    this.position = { x: a4.x, y: a4.y }, this.velocity = { x: 0, y: 0 }, this.canv = e4, this.draw = function(e5) {
      e5.drawImage(this.canv, this.position.x - this.canv.width / 2, this.position.y - this.canv.height / 2, this.canv.width, this.canv.height);
    };
  }
  return A2.onchange = () => {
    A2.matches ? y3() : u2();
  }, u2(), { destroy: y3 };
}
function t(e3) {
  let t3 = e3 && e3.colors || ["#D61C59", "#E7D84B", "#1B8798"], i3 = e3 && e3.element, n2 = i3 || document.body, o2 = window.innerWidth, s4 = window.innerHeight;
  const h6 = { x: o2 / 2, y: o2 / 2 }, c6 = { x: o2 / 2, y: o2 / 2 }, l2 = [], d4 = [];
  let a4, r, A2;
  const u2 = window.matchMedia("(prefers-reduced-motion: reduce)");
  function m3() {
    if (u2.matches)
      return console.log("This browser has prefers reduced motion turned on, so the cursor did not init"), false;
    a4 = document.createElement("canvas"), r = a4.getContext("2d"), a4.style.top = "0px", a4.style.left = "0px", a4.style.pointerEvents = "none", i3 ? (a4.style.position = "absolute", n2.appendChild(a4), a4.width = n2.clientWidth, a4.height = n2.clientHeight) : (a4.style.position = "fixed", n2.appendChild(a4), a4.width = o2, a4.height = s4), r.font = "21px serif", r.textBaseline = "middle", r.textAlign = "center", t3.forEach((e4) => {
      let t4 = r.measureText("*"), i4 = document.createElement("canvas"), n3 = i4.getContext("2d");
      i4.width = t4.width, i4.height = t4.actualBoundingBoxAscent + t4.actualBoundingBoxDescent, n3.fillStyle = e4, n3.textAlign = "center", n3.font = "21px serif", n3.textBaseline = "middle", n3.fillText("*", i4.width / 2, t4.actualBoundingBoxAscent), d4.push(i4);
    }), n2.addEventListener("mousemove", f), n2.addEventListener("touchmove", p2, { passive: true }), n2.addEventListener("touchstart", p2, { passive: true }), window.addEventListener("resize", g), v();
  }
  function g(e4) {
    o2 = window.innerWidth, s4 = window.innerHeight, i3 ? (a4.width = n2.clientWidth, a4.height = n2.clientHeight) : (a4.width = o2, a4.height = s4);
  }
  function p2(e4) {
    if (e4.touches.length > 0)
      for (let t4 = 0; t4 < e4.touches.length; t4++)
        y3(e4.touches[t4].clientX, e4.touches[t4].clientY, d4[Math.floor(Math.random() * d4.length)]);
  }
  function f(e4) {
    window.requestAnimationFrame(() => {
      if (i3) {
        const t4 = n2.getBoundingClientRect();
        h6.x = e4.clientX - t4.left, h6.y = e4.clientY - t4.top;
      } else
        h6.x = e4.clientX, h6.y = e4.clientY;
      Math.hypot(h6.x - c6.x, h6.y - c6.y) > 1.5 && (y3(h6.x, h6.y, d4[Math.floor(Math.random() * t3.length)]), c6.x = h6.x, c6.y = h6.y);
    });
  }
  function y3(e4, t4, i4) {
    l2.push(new x2(e4, t4, i4));
  }
  function v() {
    !function() {
      r.clearRect(0, 0, o2, s4);
      for (let e4 = 0; e4 < l2.length; e4++)
        l2[e4].update(r);
      for (let e4 = l2.length - 1; e4 >= 0; e4--)
        l2[e4].lifeSpan < 0 && l2.splice(e4, 1);
    }(), A2 = requestAnimationFrame(v);
  }
  function w3() {
    a4.remove(), cancelAnimationFrame(A2), n2.removeEventListener("mousemove", f), n2.removeEventListener("touchmove", p2), n2.removeEventListener("touchstart", p2), window.addEventListener("resize", g);
  }
  function x2(e4, t4, i4) {
    const n3 = Math.floor(30 * Math.random() + 60);
    this.initialLifeSpan = n3, this.lifeSpan = n3, this.velocity = { x: (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 2), y: 0.7 * Math.random() + 0.9 }, this.position = { x: e4, y: t4 }, this.canv = i4, this.update = function(e5) {
      this.position.x += this.velocity.x, this.position.y += this.velocity.y, this.lifeSpan--, this.velocity.y += 0.02;
      const t5 = Math.max(this.lifeSpan / this.initialLifeSpan, 0);
      e5.drawImage(this.canv, this.position.x - this.canv.width / 2 * t5, this.position.y - this.canv.height / 2, this.canv.width * t5, this.canv.height * t5);
    };
  }
  return u2.onchange = () => {
    u2.matches ? w3() : m3();
  }, m3(), { destroy: w3 };
}
function i(e3) {
  let t3, i3, n2, o2 = e3 && e3.element, s4 = o2 || document.body, h6 = ["\u2744\uFE0F"], c6 = window.innerWidth, l2 = window.innerHeight, d4 = { x: c6 / 2, y: c6 / 2 }, a4 = [], r = [];
  const A2 = window.matchMedia("(prefers-reduced-motion: reduce)");
  function u2() {
    if (A2.matches)
      return console.log("This browser has prefers reduced motion turned on, so the cursor did not init"), false;
    t3 = document.createElement("canvas"), i3 = t3.getContext("2d"), t3.style.top = "0px", t3.style.left = "0px", t3.style.pointerEvents = "none", o2 ? (t3.style.position = "absolute", s4.appendChild(t3), t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.style.position = "fixed", document.body.appendChild(t3), t3.width = c6, t3.height = l2), i3.font = "12px serif", i3.textBaseline = "middle", i3.textAlign = "center", h6.forEach((e4) => {
      let t4 = i3.measureText(e4), n3 = document.createElement("canvas"), o3 = n3.getContext("2d");
      n3.width = t4.width, n3.height = 2 * t4.actualBoundingBoxAscent, o3.textAlign = "center", o3.font = "12px serif", o3.textBaseline = "middle", o3.fillText(e4, n3.width / 2, t4.actualBoundingBoxAscent), r.push(n3);
    }), s4.addEventListener("mousemove", p2), s4.addEventListener("touchmove", g, { passive: true }), s4.addEventListener("touchstart", g, { passive: true }), window.addEventListener("resize", m3), y3();
  }
  function m3(e4) {
    c6 = window.innerWidth, l2 = window.innerHeight, o2 ? (t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.width = c6, t3.height = l2);
  }
  function g(e4) {
    if (e4.touches.length > 0)
      for (let t4 = 0; t4 < e4.touches.length; t4++)
        f(e4.touches[t4].clientX, e4.touches[t4].clientY, r[Math.floor(Math.random() * r.length)]);
  }
  function p2(e4) {
    if (o2) {
      const t4 = s4.getBoundingClientRect();
      d4.x = e4.clientX - t4.left, d4.y = e4.clientY - t4.top;
    } else
      d4.x = e4.clientX, d4.y = e4.clientY;
    f(d4.x, d4.y, r[Math.floor(Math.random() * h6.length)]);
  }
  function f(e4, t4, i4) {
    a4.push(new w3(e4, t4, i4));
  }
  function y3() {
    !function() {
      i3.clearRect(0, 0, c6, l2);
      for (let e4 = 0; e4 < a4.length; e4++)
        a4[e4].update(i3);
      for (let e4 = a4.length - 1; e4 >= 0; e4--)
        a4[e4].lifeSpan < 0 && a4.splice(e4, 1);
    }(), n2 = requestAnimationFrame(y3);
  }
  function v() {
    t3.remove(), cancelAnimationFrame(n2), s4.removeEventListener("mousemove", p2), s4.removeEventListener("touchmove", g), s4.removeEventListener("touchstart", g), window.addEventListener("resize", m3);
  }
  function w3(e4, t4, i4) {
    const n3 = Math.floor(60 * Math.random() + 80);
    this.initialLifeSpan = n3, this.lifeSpan = n3, this.velocity = { x: (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 2), y: 1 + Math.random() }, this.position = { x: e4, y: t4 }, this.canv = i4, this.update = function(e5) {
      this.position.x += this.velocity.x, this.position.y += this.velocity.y, this.lifeSpan--, this.velocity.x += 2 * (Math.random() < 0.5 ? -1 : 1) / 75, this.velocity.y -= Math.random() / 300;
      const t5 = Math.max(this.lifeSpan / this.initialLifeSpan, 0), i5 = 0.0174533 * (2 * this.lifeSpan);
      e5.translate(this.position.x, this.position.y), e5.rotate(i5), e5.drawImage(this.canv, -this.canv.width / 2 * t5, -this.canv.height / 2, this.canv.width * t5, this.canv.height * t5), e5.rotate(-i5), e5.translate(-this.position.x, -this.position.y);
    };
  }
  return A2.onchange = () => {
    A2.matches ? v() : u2();
  }, u2(), { destroy: v };
}
function n(e3) {
  let t3, i3, n2, o2 = e3 && e3.element, s4 = o2 || document.body, h6 = window.innerWidth, c6 = window.innerHeight, l2 = { x: h6 / 2, y: h6 / 2 }, d4 = [];
  const a4 = (e3 == null ? void 0 : e3.particles) || 15;
  let r = false, A2 = new Image();
  A2.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAATCAYAAACk9eypAAAAAXNSR0IArs4c6QAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASAAAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAADKADAAQAAAABAAAAEwAAAAAChpcNAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpMwidZAAABqElEQVQoFY3SPUvDQBgH8BREpRHExYiDgmLFl6WC+AYmWeyLg4i7buJX8DMpOujgyxGvUYeCgzhUQUSKKLUS0+ZyptXh8Z5Ti621ekPyJHl+uftfomhaf9Ei5JyxXKfynyEA6EYcLHpwyflT958GAQ7DTABNHd8EbtDbEH2BD5QEQmi2mM8P/Iq+A0SzszEg+3sPjDnDdVEtQKQbMUidHD3xVzf6A9UDEmEm+8h9KTqTVUjT+vB53aHrCbAPiceYq1dQI1Aqv4EhMll0jzv+Y0yiRgCnLRSYyDQHVoqUXe4uKL9l+L7GXC4vkMhE6eW/AOJs9k583ORDUyXMZ8F5SVHVVnllmPNKSFagAJ5DofaqGXw/gHBYg51dIldkmknY3tguv3jOtHR4+MqAzaraJXbEhqHhcQlwGSOi5pytVQHZLN5s0WNe8HPrLYlFsO20RPHkImxsbmHdLJFI76th7Z4SeuF53hTeFLvhRCJRCTKZKxgdnRDbW+iozFJbBMw14/ElwGYc0egMBMFzT21f5Rog33Z7dX02GBm7WV5ZfT5Nn5bE3zuCDe9UxdTpNvK+5AAAAABJRU5ErkJggg==";
  const u2 = window.matchMedia("(prefers-reduced-motion: reduce)");
  function m3() {
    if (u2.matches)
      return console.log("This browser has prefers reduced motion turned on, so the cursor did not init"), false;
    t3 = document.createElement("canvas"), i3 = t3.getContext("2d"), t3.style.top = "0px", t3.style.left = "0px", t3.style.pointerEvents = "none", o2 ? (t3.style.position = "absolute", s4.appendChild(t3), t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.style.position = "fixed", document.body.appendChild(t3), t3.width = h6, t3.height = c6), s4.addEventListener("mousemove", p2), window.addEventListener("resize", g), f();
  }
  function g(e4) {
    h6 = window.innerWidth, c6 = window.innerHeight, o2 ? (t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.width = h6, t3.height = c6);
  }
  function p2(e4) {
    if (o2) {
      const t5 = s4.getBoundingClientRect();
      l2.x = e4.clientX - t5.left, l2.y = e4.clientY - t5.top;
    } else
      l2.x = e4.clientX, l2.y = e4.clientY;
    if (r === false) {
      r = true;
      for (let e5 = 0; e5 < a4; e5++)
        t4 = l2.x, i4 = l2.y, n3 = A2, d4.push(new v(t4, i4, n3));
    }
    var t4, i4, n3;
  }
  function f() {
    !function() {
      i3.clearRect(0, 0, h6, c6);
      let e4 = l2.x, t4 = l2.y;
      d4.forEach(function(n3, o3, s5) {
        let h7 = s5[o3 + 1] || s5[0];
        n3.position.x = e4, n3.position.y = t4, n3.move(i3), e4 += 0.4 * (h7.position.x - n3.position.x), t4 += 0.4 * (h7.position.y - n3.position.y);
      });
    }(), n2 = requestAnimationFrame(f);
  }
  function y3() {
    t3.remove(), cancelAnimationFrame(n2), s4.removeEventListener("mousemove", p2), window.addEventListener("resize", g);
  }
  function v(e4, t4, i4) {
    this.position = { x: e4, y: t4 }, this.image = i4, this.move = function(e5) {
      e5.drawImage(this.image, this.position.x, this.position.y);
    };
  }
  return u2.onchange = () => {
    u2.matches ? y3() : m3();
  }, m3(), { destroy: y3 };
}
function o(e3) {
  let t3, i3, n2 = e3 && e3.element, o2 = n2 || document.body, s4 = window.innerWidth, h6 = window.innerHeight, c6 = { x: s4 / 2, y: s4 / 2 }, l2 = new function(e4, t4, i4, n3) {
    this.position = { x: e4, y: t4 }, this.width = i4, this.lag = n3, this.moveTowards = function(e5, t5, i5) {
      this.position.x += (e5 - this.position.x) / this.lag, this.position.y += (t5 - this.position.y) / this.lag, i5.fillStyle = d4, i5.beginPath(), i5.arc(this.position.x, this.position.y, this.width, 0, 2 * Math.PI), i5.fill(), i5.closePath();
    };
  }(s4 / 2, h6 / 2, 10, 10), d4 = (e3 == null ? void 0 : e3.color) || "#323232a6";
  const a4 = window.matchMedia("(prefers-reduced-motion: reduce)");
  function r() {
    if (a4.matches)
      return console.log("This browser has prefers reduced motion turned on, so the cursor did not init"), false;
    t3 = document.createElement("canvas"), i3 = t3.getContext("2d"), t3.style.top = "0px", t3.style.left = "0px", t3.style.pointerEvents = "none", n2 ? (t3.style.position = "absolute", o2.appendChild(t3), t3.width = o2.clientWidth, t3.height = o2.clientHeight) : (t3.style.position = "fixed", document.body.appendChild(t3), t3.width = s4, t3.height = h6), o2.addEventListener("mousemove", u2), window.addEventListener("resize", A2), m3();
  }
  function A2(e4) {
    s4 = window.innerWidth, h6 = window.innerHeight, n2 ? (t3.width = o2.clientWidth, t3.height = o2.clientHeight) : (t3.width = s4, t3.height = h6);
  }
  function u2(e4) {
    if (n2) {
      const t4 = o2.getBoundingClientRect();
      c6.x = e4.clientX - t4.left, c6.y = e4.clientY - t4.top;
    } else
      c6.x = e4.clientX, c6.y = e4.clientY;
  }
  function m3() {
    i3.clearRect(0, 0, s4, h6), l2.moveTowards(c6.x, c6.y, i3), requestAnimationFrame(m3);
  }
  function g() {
    t3.remove(), cancelAnimationFrame(m3), o2.removeEventListener("mousemove", u2), window.addEventListener("resize", A2);
  }
  return a4.onchange = () => {
    a4.matches ? g() : r();
  }, r(), { destroy: g };
}
function s(e3) {
  let t3, i3, n2, o2 = e3 && e3.element, s4 = o2 || document.body, h6 = window.innerWidth, c6 = window.innerHeight, l2 = { x: h6 / 2, y: h6 / 2 }, d4 = [], a4 = [];
  const r = window.matchMedia("(prefers-reduced-motion: reduce)");
  function A2() {
    if (r.matches)
      return console.log("This browser has prefers reduced motion turned on, so the cursor did not init"), false;
    t3 = document.createElement("canvas"), i3 = t3.getContext("2d"), t3.style.top = "0px", t3.style.left = "0px", t3.style.pointerEvents = "none", o2 ? (t3.style.position = "absolute", s4.appendChild(t3), t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.style.position = "fixed", document.body.appendChild(t3), t3.width = h6, t3.height = c6), s4.addEventListener("mousemove", g), s4.addEventListener("touchmove", m3, { passive: true }), s4.addEventListener("touchstart", m3, { passive: true }), window.addEventListener("resize", u2), f();
  }
  function u2(e4) {
    h6 = window.innerWidth, c6 = window.innerHeight, o2 ? (t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.width = h6, t3.height = c6);
  }
  function m3(e4) {
    if (e4.touches.length > 0)
      for (let t4 = 0; t4 < e4.touches.length; t4++)
        p2(e4.touches[t4].clientX, e4.touches[t4].clientY, a4[Math.floor(Math.random() * a4.length)]);
  }
  function g(e4) {
    if (o2) {
      const t4 = s4.getBoundingClientRect();
      l2.x = e4.clientX - t4.left, l2.y = e4.clientY - t4.top;
    } else
      l2.x = e4.clientX, l2.y = e4.clientY;
    p2(l2.x, l2.y);
  }
  function p2(e4, t4, i4) {
    d4.push(new v(e4, t4, i4));
  }
  function f() {
    !function() {
      i3.clearRect(0, 0, h6, c6);
      for (let e4 = 0; e4 < d4.length; e4++)
        d4[e4].update(i3);
      for (let e4 = d4.length - 1; e4 >= 0; e4--)
        d4[e4].lifeSpan < 0 && d4.splice(e4, 1);
    }(), n2 = requestAnimationFrame(f);
  }
  function y3() {
    t3.remove(), cancelAnimationFrame(n2), s4.removeEventListener("mousemove", g), s4.removeEventListener("touchmove", m3), s4.removeEventListener("touchstart", m3), window.addEventListener("resize", u2);
  }
  function v(e4, t4, i4) {
    const n3 = Math.floor(60 * Math.random() + 60);
    this.initialLifeSpan = n3, this.lifeSpan = n3, this.velocity = { x: (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 10), y: -1 * Math.random() - 0.4 }, this.position = { x: e4, y: t4 }, this.canv = i4, this.baseDimension = 4, this.update = function(e5) {
      this.position.x += this.velocity.x, this.position.y += this.velocity.y, this.velocity.x += 2 * (Math.random() < 0.5 ? -1 : 1) / 75, this.velocity.y -= Math.random() / 600, this.lifeSpan--;
      const t5 = 0.2 + (this.initialLifeSpan - this.lifeSpan) / this.initialLifeSpan;
      e5.fillStyle = "#e6f1f7", e5.strokeStyle = "#3a92c5", e5.beginPath(), e5.arc(this.position.x - this.baseDimension / 2 * t5, this.position.y - this.baseDimension / 2, this.baseDimension * t5, 0, 2 * Math.PI), e5.stroke(), e5.fill(), e5.closePath();
    };
  }
  return r.onchange = () => {
    r.matches ? y3() : A2();
  }, A2(), { destroy: y3 };
}
function h(e3) {
  const t3 = e3 && e3.emoji || ["\u{1F600}", "\u{1F602}", "\u{1F606}", "\u{1F60A}"];
  let i3 = e3 && e3.element, n2 = i3 || document.body, o2 = window.innerWidth, s4 = window.innerHeight;
  const h6 = { x: o2 / 2, y: o2 / 2 }, c6 = { x: o2 / 2, y: o2 / 2 };
  let l2 = 0;
  const d4 = [], a4 = [];
  let r, A2, u2;
  const m3 = window.matchMedia("(prefers-reduced-motion: reduce)");
  function g() {
    if (m3.matches)
      return console.log("This browser has prefers reduced motion turned on, so the cursor did not init"), false;
    r = document.createElement("canvas"), A2 = r.getContext("2d"), r.style.top = "0px", r.style.left = "0px", r.style.pointerEvents = "none", i3 ? (r.style.position = "absolute", n2.appendChild(r), r.width = n2.clientWidth, r.height = n2.clientHeight) : (r.style.position = "fixed", document.body.appendChild(r), r.width = o2, r.height = s4), A2.font = "21px serif", A2.textBaseline = "middle", A2.textAlign = "center", t3.forEach((e4) => {
      let t4 = A2.measureText(e4), i4 = document.createElement("canvas"), n3 = i4.getContext("2d");
      i4.width = t4.width, i4.height = 2 * t4.actualBoundingBoxAscent, n3.textAlign = "center", n3.font = "21px serif", n3.textBaseline = "middle", n3.fillText(e4, i4.width / 2, t4.actualBoundingBoxAscent), a4.push(i4);
    }), n2.addEventListener("mousemove", y3, { passive: true }), n2.addEventListener("touchmove", f, { passive: true }), n2.addEventListener("touchstart", f, { passive: true }), window.addEventListener("resize", p2), w3();
  }
  function p2(e4) {
    o2 = window.innerWidth, s4 = window.innerHeight, i3 ? (r.width = n2.clientWidth, r.height = n2.clientHeight) : (r.width = o2, r.height = s4);
  }
  function f(e4) {
    if (e4.touches.length > 0)
      for (let t4 = 0; t4 < e4.touches.length; t4++)
        v(e4.touches[t4].clientX, e4.touches[t4].clientY, a4[Math.floor(Math.random() * a4.length)]);
  }
  function y3(e4) {
    e4.timeStamp - l2 < 16 || window.requestAnimationFrame(() => {
      if (i3) {
        const t4 = n2.getBoundingClientRect();
        h6.x = e4.clientX - t4.left, h6.y = e4.clientY - t4.top;
      } else
        h6.x = e4.clientX, h6.y = e4.clientY;
      Math.hypot(h6.x - c6.x, h6.y - c6.y) > 1 && (v(h6.x, h6.y, a4[Math.floor(Math.random() * t3.length)]), c6.x = h6.x, c6.y = h6.y, l2 = e4.timeStamp);
    });
  }
  function v(e4, t4, i4) {
    d4.push(new E2(e4, t4, i4));
  }
  function w3() {
    !function() {
      A2.clearRect(0, 0, o2, s4);
      for (let e4 = 0; e4 < d4.length; e4++)
        d4[e4].update(A2);
      for (let e4 = d4.length - 1; e4 >= 0; e4--)
        d4[e4].lifeSpan < 0 && d4.splice(e4, 1);
    }(), u2 = requestAnimationFrame(w3);
  }
  function x2() {
    r.remove(), cancelAnimationFrame(u2), n2.removeEventListener("mousemove", y3), n2.removeEventListener("touchmove", f), n2.removeEventListener("touchstart", f), window.addEventListener("resize", p2);
  }
  function E2(e4, t4, i4) {
    const n3 = Math.floor(60 * Math.random() + 80);
    this.initialLifeSpan = n3, this.lifeSpan = n3, this.velocity = { x: (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 2), y: 0.4 * Math.random() + 0.8 }, this.position = { x: e4, y: t4 }, this.canv = i4, this.update = function(e5) {
      this.position.x += this.velocity.x, this.position.y += this.velocity.y, this.lifeSpan--, this.velocity.y += 0.05;
      const t5 = Math.max(this.lifeSpan / this.initialLifeSpan, 0);
      e5.drawImage(this.canv, this.position.x - this.canv.width / 2 * t5, this.position.y - this.canv.height / 2, this.canv.width * t5, this.canv.height * t5);
    };
  }
  return m3.onchange = () => {
    m3.matches ? x2() : g();
  }, g(), { destroy: x2 };
}
function c(e3) {
  let t3, i3, n2, o2 = e3 && e3.element, s4 = o2 || document.body, h6 = window.innerWidth, c6 = window.innerHeight, l2 = { x: h6 / 2, y: h6 / 2 }, d4 = [], a4 = new Image();
  a4.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAATCAYAAACk9eypAAAAAXNSR0IArs4c6QAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASAAAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAADKADAAQAAAABAAAAEwAAAAAChpcNAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpMwidZAAABqElEQVQoFY3SPUvDQBgH8BREpRHExYiDgmLFl6WC+AYmWeyLg4i7buJX8DMpOujgyxGvUYeCgzhUQUSKKLUS0+ZyptXh8Z5Ti621ekPyJHl+uftfomhaf9Ei5JyxXKfynyEA6EYcLHpwyflT958GAQ7DTABNHd8EbtDbEH2BD5QEQmi2mM8P/Iq+A0SzszEg+3sPjDnDdVEtQKQbMUidHD3xVzf6A9UDEmEm+8h9KTqTVUjT+vB53aHrCbAPiceYq1dQI1Aqv4EhMll0jzv+Y0yiRgCnLRSYyDQHVoqUXe4uKL9l+L7GXC4vkMhE6eW/AOJs9k583ORDUyXMZ8F5SVHVVnllmPNKSFagAJ5DofaqGXw/gHBYg51dIldkmknY3tguv3jOtHR4+MqAzaraJXbEhqHhcQlwGSOi5pytVQHZLN5s0WNe8HPrLYlFsO20RPHkImxsbmHdLJFI76th7Z4SeuF53hTeFLvhRCJRCTKZKxgdnRDbW+iozFJbBMw14/ElwGYc0egMBMFzT21f5Rog33Z7dX02GBm7WV5ZfT5Nn5bE3zuCDe9UxdTpNvK+5AAAAABJRU5ErkJggg==";
  const r = window.matchMedia("(prefers-reduced-motion: reduce)");
  function A2() {
    if (r.matches)
      return console.log("This browser has prefers reduced motion turned on, so the cursor did not init"), false;
    t3 = document.createElement("canvas"), i3 = t3.getContext("2d"), t3.style.top = "0px", t3.style.left = "0px", t3.style.pointerEvents = "none", o2 ? (t3.style.position = "absolute", s4.appendChild(t3), t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.style.position = "fixed", document.body.appendChild(t3), t3.width = h6, t3.height = c6), s4.addEventListener("mousemove", g), s4.addEventListener("touchmove", m3, { passive: true }), s4.addEventListener("touchstart", m3, { passive: true }), window.addEventListener("resize", u2), f();
  }
  function u2(e4) {
    h6 = window.innerWidth, c6 = window.innerHeight, o2 ? (t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.width = h6, t3.height = c6);
  }
  function m3(e4) {
    if (e4.touches.length > 0)
      for (let t4 = 0; t4 < e4.touches.length; t4++)
        p2(e4.touches[t4].clientX, e4.touches[t4].clientY, a4);
  }
  function g(e4) {
    if (o2) {
      const t4 = s4.getBoundingClientRect();
      l2.x = e4.clientX - t4.left, l2.y = e4.clientY - t4.top;
    } else
      l2.x = e4.clientX, l2.y = e4.clientY;
    p2(l2.x, l2.y, a4);
  }
  function p2(e4, t4, i4) {
    d4.push(new v(e4, t4, i4));
  }
  function f() {
    !function() {
      i3.clearRect(0, 0, h6, c6);
      for (let e4 = 0; e4 < d4.length; e4++)
        d4[e4].update(i3);
      for (let e4 = d4.length - 1; e4 >= 0; e4--)
        d4[e4].lifeSpan < 0 && d4.splice(e4, 1);
    }(), n2 = requestAnimationFrame(f);
  }
  function y3() {
    t3.remove(), cancelAnimationFrame(n2), s4.removeEventListener("mousemove", g), s4.removeEventListener("touchmove", m3), s4.removeEventListener("touchstart", m3), window.addEventListener("resize", u2);
  }
  function v(e4, t4, i4) {
    this.initialLifeSpan = 40, this.lifeSpan = 40, this.position = { x: e4, y: t4 }, this.image = i4, this.update = function(e5) {
      this.lifeSpan--;
      const t5 = Math.max(this.lifeSpan / this.initialLifeSpan, 0);
      e5.globalAlpha = t5, e5.drawImage(this.image, this.position.x, this.position.y);
    };
  }
  return r.onchange = () => {
    r.matches ? y3() : A2();
  }, A2(), { destroy: y3 };
}
function l(e3) {
  let t3, i3, n2, o2 = e3 && e3.element, s4 = o2 || document.body, h6 = window.innerWidth, c6 = window.innerHeight, l2 = { x: h6 / 2, y: h6 / 2 }, d4 = [];
  const a4 = (e3 == null ? void 0 : e3.length) || 20, r = (e3 == null ? void 0 : e3.colors) || ["#FE0000", "#FD8C00", "#FFE500", "#119F0B", "#0644B3", "#C22EDC"], A2 = (e3 == null ? void 0 : e3.size) || 3;
  let u2 = false;
  const m3 = window.matchMedia("(prefers-reduced-motion: reduce)");
  function g() {
    if (m3.matches)
      return console.log("This browser has prefers reduced motion turned on, so the cursor did not init"), false;
    t3 = document.createElement("canvas"), i3 = t3.getContext("2d"), t3.style.top = "0px", t3.style.left = "0px", t3.style.pointerEvents = "none", o2 ? (t3.style.position = "absolute", s4.appendChild(t3), t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.style.position = "fixed", document.body.appendChild(t3), t3.width = h6, t3.height = c6), s4.addEventListener("mousemove", f), window.addEventListener("resize", p2), y3();
  }
  function p2(e4) {
    h6 = window.innerWidth, c6 = window.innerHeight, o2 ? (t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.width = h6, t3.height = c6);
  }
  function f(e4) {
    if (o2) {
      const t5 = s4.getBoundingClientRect();
      l2.x = e4.clientX - t5.left, l2.y = e4.clientY - t5.top;
    } else
      l2.x = e4.clientX, l2.y = e4.clientY;
    if (u2 === false) {
      u2 = true;
      for (let e5 = 0; e5 < a4; e5++)
        t4 = l2.x, i4 = l2.y, void 0, d4.push(new w3(t4, i4));
    }
    var t4, i4;
  }
  function y3() {
    !function() {
      i3.clearRect(0, 0, h6, c6), i3.lineJoin = "round";
      let e4 = [], t4 = l2.x, n3 = l2.y;
      d4.forEach(function(i4, o3, s5) {
        let h7 = s5[o3 + 1] || s5[0];
        i4.position.x = t4, i4.position.y = n3, e4.push({ x: t4, y: n3 }), t4 += 0.4 * (h7.position.x - i4.position.x), n3 += 0.4 * (h7.position.y - i4.position.y);
      }), r.forEach((t5, n4) => {
        i3.beginPath(), i3.strokeStyle = t5, e4.length && i3.moveTo(e4[0].x, e4[0].y + n4 * (A2 - 1)), e4.forEach((e5, t6) => {
          t6 !== 0 && i3.lineTo(e5.x, e5.y + n4 * A2);
        }), i3.lineWidth = A2, i3.lineCap = "round", i3.stroke();
      });
    }(), n2 = requestAnimationFrame(y3);
  }
  function v() {
    t3.remove(), cancelAnimationFrame(n2), s4.removeEventListener("mousemove", f), window.addEventListener("resize", p2);
  }
  function w3(e4, t4) {
    this.position = { x: e4, y: t4 };
  }
  return m3.onchange = () => {
    m3.matches ? v() : g();
  }, g(), { destroy: v };
}
function d(e3) {
  let t3, i3, n2, o2 = e3 && e3.element, s4 = o2 || document.body, h6 = window.innerWidth, c6 = window.innerHeight, l2 = { x: h6 / 2, y: h6 / 2 };
  const d4 = e3 && e3.dateColor || "blue", a4 = e3 && e3.faceColor || "black", r = e3 && e3.secondsColor || "red", A2 = e3 && e3.minutesColor || "black", u2 = e3 && e3.hoursColor || "black", m3 = 0.4;
  let g = new Date(), p2 = g.getDate(), f = g.getYear() + 1900;
  const y3 = (" " + ["SUNDAY", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY"][g.getDay()] + " " + p2 + " " + ["JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE", "JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER"][g.getMonth()] + " " + f).split(""), v = ["3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "1", "2"], w3 = v.length, x2 = ["\u2022", "\u2022", "\u2022"], E2 = ["\u2022", "\u2022", "\u2022", "\u2022"], M3 = ["\u2022", "\u2022", "\u2022", "\u2022", "\u2022"], L2 = 360 / w3, C = 360 / y3.length, B2 = 45 / 6.5, Y2 = [], b2 = [], R2 = [], S3 = [], W = [], H3 = [], I2 = [], X2 = [], T3 = [];
  var D2 = parseInt(y3.length + w3 + x2.length + E2.length + M3.length) + 1;
  const F = window.matchMedia("(prefers-reduced-motion: reduce)");
  function z2() {
    if (F.matches)
      return console.log("This browser has prefers reduced motion turned on, so the cursor did not init"), false;
    t3 = document.createElement("canvas"), i3 = t3.getContext("2d"), t3.style.top = "0px", t3.style.left = "0px", t3.style.pointerEvents = "none", o2 ? (t3.style.position = "absolute", s4.appendChild(t3), t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.style.position = "fixed", document.body.appendChild(t3), t3.width = h6, t3.height = c6), i3.font = "10px sans-serif", i3.textAlign = "center", i3.textBaseline = "middle";
    for (let e4 = 0; e4 < D2; e4++)
      Y2[e4] = 0, b2[e4] = 0, R2[e4] = 0, S3[e4] = 0;
    for (let e4 = 0; e4 < y3.length; e4++)
      T3[e4] = { color: d4, value: y3[e4] };
    for (let e4 = 0; e4 < v.length; e4++)
      X2[e4] = { color: a4, value: v[e4] };
    for (let e4 = 0; e4 < x2.length; e4++)
      I2[e4] = { color: u2, value: x2[e4] };
    for (let e4 = 0; e4 < E2.length; e4++)
      H3[e4] = { color: A2, value: E2[e4] };
    for (let e4 = 0; e4 < M3.length; e4++)
      W[e4] = { color: r, value: M3[e4] };
    s4.addEventListener("mousemove", U), s4.addEventListener("touchmove", J, { passive: true }), s4.addEventListener("touchstart", J, { passive: true }), window.addEventListener("resize", P), Q2();
  }
  function P(e4) {
    h6 = window.innerWidth, c6 = window.innerHeight, o2 ? (t3.width = s4.clientWidth, t3.height = s4.clientHeight) : (t3.width = h6, t3.height = c6);
  }
  function J(e4) {
    if (e4.touches.length > 0)
      if (o2) {
        const t4 = s4.getBoundingClientRect();
        l2.x = e4.touches[0].clientX - t4.left, l2.y = e4.touches[0].clientY - t4.top;
      } else
        l2.x = e4.touches[0].clientX, l2.y = e4.touches[0].clientY;
  }
  function U(e4) {
    if (o2) {
      const t4 = s4.getBoundingClientRect();
      l2.x = e4.clientX - t4.left, l2.y = e4.clientY - t4.top;
    } else
      l2.x = e4.clientX, l2.y = e4.clientY;
  }
  function Q2() {
    !function() {
      R2[0] = Math.round(Y2[0] += (l2.y - Y2[0]) * m3), S3[0] = Math.round(b2[0] += (l2.x - b2[0]) * m3);
      for (let e4 = 1; e4 < D2; e4++)
        R2[e4] = Math.round(Y2[e4] += (R2[e4 - 1] - Y2[e4]) * m3), S3[e4] = Math.round(b2[e4] += (S3[e4 - 1] - b2[e4]) * m3), Y2[e4 - 1] >= c6 - 80 && (Y2[e4 - 1] = c6 - 80), b2[e4 - 1] >= h6 - 80 && (b2[e4 - 1] = h6 - 80);
    }(), function() {
      i3.clearRect(0, 0, h6, c6);
      const e4 = new Date(), t4 = e4.getSeconds(), n3 = Math.PI * (t4 - 15) / 30, o3 = e4.getMinutes(), s5 = Math.PI * (o3 - 15) / 30, l3 = e4.getHours(), d5 = Math.PI * (l3 - 3) / 6 + Math.PI * parseInt(e4.getMinutes()) / 360;
      for (let e5 = 0; e5 < T3.length; e5++)
        T3[e5].y = Y2[e5] + 67.5 * Math.sin(-n3 + e5 * C * Math.PI / 180), T3[e5].x = b2[e5] + 67.5 * Math.cos(-n3 + e5 * C * Math.PI / 180), i3.fillStyle = T3[e5].color, i3.fillText(T3[e5].value, T3[e5].x, T3[e5].y);
      for (let e5 = 0; e5 < X2.length; e5++)
        X2[e5].y = Y2[T3.length + e5] + 45 * Math.sin(e5 * L2 * Math.PI / 180), X2[e5].x = b2[T3.length + e5] + 45 * Math.cos(e5 * L2 * Math.PI / 180), i3.fillStyle = X2[e5].color, i3.fillText(X2[e5].value, X2[e5].x, X2[e5].y);
      for (let e5 = 0; e5 < I2.length; e5++)
        I2[e5].y = Y2[T3.length + w3 + e5] + 0 + e5 * B2 * Math.sin(d5), I2[e5].x = b2[T3.length + w3 + e5] + 0 + e5 * B2 * Math.cos(d5), i3.fillStyle = I2[e5].color, i3.fillText(I2[e5].value, I2[e5].x, I2[e5].y);
      for (let e5 = 0; e5 < H3.length; e5++)
        H3[e5].y = Y2[T3.length + w3 + I2.length + e5] + 0 + e5 * B2 * Math.sin(s5), H3[e5].x = b2[T3.length + w3 + I2.length + e5] + 0 + e5 * B2 * Math.cos(s5), i3.fillStyle = H3[e5].color, i3.fillText(H3[e5].value, H3[e5].x, H3[e5].y);
      for (let e5 = 0; e5 < W.length; e5++)
        W[e5].y = Y2[T3.length + w3 + I2.length + H3.length + e5] + 0 + e5 * B2 * Math.sin(n3), W[e5].x = b2[T3.length + w3 + I2.length + H3.length + e5] + 0 + e5 * B2 * Math.cos(n3), i3.fillStyle = W[e5].color, i3.fillText(W[e5].value, W[e5].x, W[e5].y);
    }(), n2 = requestAnimationFrame(Q2);
  }
  function Z() {
    t3.remove(), cancelAnimationFrame(n2), s4.removeEventListener("mousemove", U), s4.removeEventListener("touchmove", J), s4.removeEventListener("touchstart", J), window.addEventListener("resize", P);
  }
  return F.onchange = () => {
    F.matches ? Z() : z2();
  }, z2(), { destroy: Z };
}
function a(e3) {
  let t3, i3, n2, o2 = e3 || {}, s4 = e3 && e3.element, h6 = s4 || document.body, c6 = o2.text ? " " + e3.text : " Your Text Here", l2 = o2.font || "monospace", d4 = o2.textSize || 12, a4 = d4 + "px " + l2, r = o2.gap || d4 + 2, A2 = 0, u2 = [], m3 = window.innerWidth, g = window.innerHeight, p2 = { x: m3 / 2, y: m3 / 2 };
  for (let e4 = 0; e4 < c6.length; e4++)
    u2[e4] = { letter: c6.charAt(e4), x: m3 / 2, y: m3 / 2 };
  e3 == null ? void 0 : e3.size;
  const f = window.matchMedia("(prefers-reduced-motion: reduce)");
  function y3() {
    if (f.matches)
      return console.log("This browser has prefers reduced motion turned on, so the cursor did not init"), false;
    t3 = document.createElement("canvas"), i3 = t3.getContext("2d"), t3.style.top = "0px", t3.style.left = "0px", t3.style.pointerEvents = "none", s4 ? (t3.style.position = "absolute", h6.appendChild(t3), t3.width = h6.clientWidth, t3.height = h6.clientHeight) : (t3.style.position = "fixed", document.body.appendChild(t3), t3.width = m3, t3.height = g), h6.addEventListener("mousemove", w3), window.addEventListener("resize", v), x2();
  }
  function v(e4) {
    m3 = window.innerWidth, g = window.innerHeight, s4 ? (t3.width = h6.clientWidth, t3.height = h6.clientHeight) : (t3.width = m3, t3.height = g);
  }
  function w3(e4) {
    if (s4) {
      const t4 = h6.getBoundingClientRect();
      p2.x = e4.clientX - t4.left, p2.y = e4.clientY - t4.top;
    } else
      p2.x = e4.clientX, p2.y = e4.clientY;
  }
  function x2() {
    !function() {
      i3.clearRect(0, 0, m3, g), A2 += 0.15;
      let e4 = 2 * Math.cos(A2), t4 = 5 * Math.sin(A2);
      for (let e5 = u2.length - 1; e5 > 0; e5--)
        u2[e5].x = u2[e5 - 1].x + r, u2[e5].y = u2[e5 - 1].y, i3.font = a4, i3.fillText(u2[e5].letter, u2[e5].x, u2[e5].y);
      let n3 = u2[0].x, o3 = u2[0].y;
      n3 += (p2.x - n3) / 5 + e4 + 2, o3 += (p2.y - o3) / 5 + t4, u2[0].x = n3, u2[0].y = o3;
    }(), n2 = requestAnimationFrame(x2);
  }
  function E2() {
    t3.remove(), cancelAnimationFrame(n2), h6.removeEventListener("mousemove", w3), window.addEventListener("resize", v);
  }
  return f.onchange = () => {
    f.matches ? E2() : y3();
  }, y3(), { destroy: E2 };
}

// src/render/CursorEffects.ts
var cursorEffects = [];
function enableCursorEffect(effectName) {
  let emo;
  switch (effectName) {
    case "bubbleCursor":
      emo = new s();
      break;
    case "clockCursor":
      emo = new d();
      break;
    case "emojiCursor":
      emo = new h({ emoji: ["\u{1F525}", "\u{1F42C}", "\u{1F986}"] });
      break;
    case "fairyDustCursor":
      emo = new t();
      break;
    case "followingDotCursor":
      emo = new o();
      break;
    case "ghostCursor":
      emo = new c();
      break;
    case "rainbowCursor":
      emo = new l();
      break;
    case "snowflakeCursor":
      emo = new i();
      break;
    case "springyEmojiCursor":
      emo = new e();
      break;
    case "textFlag":
      emo = new a();
      break;
    case "trailingCursor":
      emo = new n();
      break;
    default:
      break;
  }
  cursorEffects.push(emo);
}
function toggleCursorEffects(target) {
  if (target != "none") {
    disableCursorEffect();
    enableCursorEffect(target);
  } else {
    disableCursorEffect();
  }
}
function disableCursorEffect() {
  cursorEffects.forEach((emo) => emo.destroy());
}

// src/render/Blast.ts
var import_party_js = __toESM(require_lib());

// src/locale/en.ts
var en_default = {
  menu: {
    setBannerForCurrent: "Set Random Banner For Current File",
    setBannerForTheFolder: "Set random banner for this path",
    planPomodoro: "Plan a pomodoro",
    defaultTask: "Default task: ",
    showPomodoroHistory: "Show pomodoro history"
  },
  command: {
    "awesome-brain-manager-check-in": "Habit Check In",
    "awesome-brain-manager-remove-check-in": "Remove Habit Check In",
    "awesome-brain-manager-rollover": "Rollover Todos Now",
    "awesome-brain-manager-undo": "Undo last rollover"
  },
  setting: {
    cursorEffect: {
      name: "Cursor Effect",
      desc: "Select a mouse effect"
    },
    powerMode: {
      name: "Power Mode",
      desc: "Enable power mode effects?"
    },
    shakeMode: {
      name: "Shake Mode",
      desc: "Enable editor shake mode effects?"
    },
    expectedTime: {
      name: "Expected Time",
      desc: "How many minutes do you want to set for a pomodoro?"
    },
    title: {
      effects: "Beautiful Effects",
      pomodoro: "Pomodoro(beta feature)",
      warning: "!!!The following features are experimental!!! If you really need, recommend  you use uphy's obsidian-reminder and lumoe's obsidian-rollover-daily-todos plugin."
    }
  },
  info: {
    effects: {
      none: "No Effect",
      bubbleCursor: "Bubble",
      clockCursor: "Clock",
      emojiCursor: "Emoji",
      fairyDustCursor: "Fairy Dust",
      followingDotCursor: "Following Dot",
      ghostCursor: "Ghost",
      rainbowCursor: "Rainbow",
      snowflakeCursor: "Snowflake",
      springyEmojiCursor: "Springy Emoji",
      textFlag: "Text Flag",
      trailingCursor: "Trailing"
    },
    powerMode: {
      "0": "No Effect",
      "1": "Square Particle",
      "2": "Circle Particle",
      "3": "Party",
      "4": "HeartBeat"
    },
    Pomodoro: "Pomodoro",
    "Awesome Brain Manager": "Awesome Brain Manager",
    unknown: "unknown",
    ltr: "LTR",
    trl: "RTL",
    done: "Done: ",
    noDoingTask: "No task to focus on",
    haveABreak: "Have a break",
    noTag: "No Tags",
    taskType: "Task type",
    planNum: "Plan task number",
    finishNum: "Finish task number",
    todayNum: "Today task",
    totalNum: "Total task",
    todayTime: "Today time",
    totalTime: "Total time",
    noTimeLine: "No timeline content",
    startTask: "\u25B6\uFE0F Start",
    stopTask: "\u23F8\uFE0F Stop",
    finishTask: "\u2705 Finish",
    cancelTask: "\u{1F534} Cancel",
    deleteTask: "\u2757 Delete",
    handleThisFirst: "Please handle this unfinished task: "
  }
};

// src/locale/zh-cn.ts
var zh_cn_default = {
  menu: {
    setBannerForCurrent: "\u5207\u6362\u5F53\u524D\u6587\u4EF6banner\u56FE",
    setBannerForTheFolder: "\u5207\u6362\u5F53\u524D\u8DEF\u5F84\u4E0B\u6587\u4EF6\u7684banner\u56FE",
    planPomodoro: "\u89C4\u5212\u4E00\u4E2A\u756A\u8304\u949F",
    defaultTask: "\u9ED8\u8BA4\u4EFB\u52A1\uFF1A"
  },
  command: {
    "awesome-brain-manager-check-in": "\u4E60\u60EF\u6253\u5361",
    "awesome-brain-manager-remove-check-in": "\u79FB\u9664\u4E60\u60EF\u6253\u5361",
    "awesome-brain-manager-rollover": "\u5C06\u672A\u5B8C\u6210\u4EFB\u52A1\u8BB0\u5F55\u5230\u4ECA\u5929",
    "awesome-brain-manager-undo": '\u64A4\u9500"\u5C06\u672A\u5B8C\u6210\u4EFB\u52A1\u8BB0\u5F55\u5230\u4ECA\u5929"\u7684\u64CD\u4F5C'
  },
  setting: {
    cursorEffect: {
      name: "\u9F20\u6807\u7279\u6548",
      desc: "\u9009\u62E9\u4E00\u4E2A\u9F20\u6807\u7279\u6548"
    },
    powerMode: {
      name: "\u6309\u952E\u7279\u6548",
      desc: "\u9009\u62E9\u4E00\u4E2A\u6309\u952E\u7279\u6548"
    },
    shakeMode: {
      name: "\u7A97\u53E3\u6296\u52A8",
      desc: "\u662F\u5426\u5F00\u542F\u7A97\u53E3\u6296\u52A8\u7279\u6548\uFF1F"
    },
    expectedTime: {
      name: "\u756A\u8304\u949F\u65F6\u95F4",
      desc: "\u4F60\u671F\u671B\u4E00\u4E2A\u756A\u8304\u949F\u591A\u5C11\u5206\u949F\uFF1F"
    },
    title: {
      effects: "\u9F20\u6807\u3001\u6309\u952E\u7279\u6548",
      pomodoro: "\u756A\u8304\u949F(beta version)",
      warning: "!!!\u4EE5\u4E0B\u529F\u80FD\u5728\u5B9E\u9A8C\u9636\u6BB5!!! \u5982\u679C\u4F60\u786E\u5B9E\u9700\u8981\uFF0C\u63A8\u8350\u4F7F\u7528 obsidian-reminder \u548C obsidian-rollover-daily-todos\u63D2\u4EF6."
    }
  },
  info: {
    effects: {
      none: "\u65E0\u7279\u6548",
      bubbleCursor: "\u6C14\u6CE1",
      clockCursor: "\u65F6\u949F",
      emojiCursor: "\u8868\u60C5",
      fairyDustCursor: "\u4ED9\u5C18",
      followingDotCursor: "\u8DDF\u968F\u70B9",
      ghostCursor: "\u91CD\u5F71",
      rainbowCursor: "\u5F69\u8679",
      snowflakeCursor: "\u96EA\u82B1",
      springyEmojiCursor: "\u5F39\u6027\u8868\u60C5",
      textFlag: "\u6587\u672C\u6807\u5FD7",
      trailingCursor: "Trailing"
    },
    powerMode: {
      "0": "\u65E0\u7279\u6548",
      "1": "\u65B9\u5757\u7C92\u5B50",
      "2": "\u5706\u5F62\u7C92\u5B50",
      "3": "\u6D3E\u5BF9",
      "4": "\u5FC3\u8DF3"
    },
    Pomodoro: "\u756A\u8304\u949F",
    "Awesome Brain Manager": "Awesome Brain Manager",
    unknown: "unknown",
    ltr: "LTR",
    trl: "RTL",
    done: "\u5B8C\u6210\uFF1A",
    noDoingTask: "\u5F53\u524D\u65E0\u4E13\u6CE8\u4EFB\u52A1",
    haveABreak: "\u4F11\u606F\u4E00\u4E0B",
    noTag: "\u65E0\u6807\u7B7E",
    taskType: "\u4EFB\u52A1\u7C7B\u578B",
    planNum: "\u4E13\u6CE8\u6B21\u6570",
    finishNum: "\u5B8C\u6210\u6B21\u6570",
    todayNum: "\u4ECA\u65E5\u756A\u8304",
    totalNum: "\u603B\u756A\u8304",
    todayTime: "\u4ECA\u65E5\u4E13\u6CE8\u65F6\u957F",
    totalTime: "\u603B\u4E13\u6CE8\u65F6\u957F",
    noTimeLine: "\u65E0\u65F6\u95F4\u7EBF\u5185\u5BB9",
    startTask: "\u25B6\uFE0F \u5F00\u59CB",
    stopTask: "\u23F8\uFE0F \u6682\u505C",
    finishTask: "\u2705 \u5B8C\u6210",
    cancelTask: "\u{1F534} \u53D6\u6D88",
    deleteTask: "\u2757 \u5220\u9664",
    handleThisFirst: "\u8BF7\u5148\u5904\u7406\u672A\u5B8C\u6210\u4EFB\u52A1\uFF1A"
  }
};

// src/i18n.ts
var T = class {
  constructor() {
    this.all = {
      en: en_default,
      zh: zh_cn_default
    };
    this.lang = localStorage.getItem("language") || "en";
  }
  get texts() {
    return this.all[this.lang];
  }
};
var i18n_default2 = new T().texts;

// src/render/Blast.ts
var shakeTime = 0;
var shakeTimeMax = 0;
var lastTime = 0;
var particlePointer = 0;
var effect;
var isActive = false;
var enableShake;
var cmNode;
var titleBarHeight = 40;
var canvas;
var ctx;
var _a, _b;
if (window.app.isMobile) {
  titleBarHeight = ((_a = document.getElementsByClassName("view-header")[5]) == null ? void 0 : _a.innerHeight) || 40;
} else {
  titleBarHeight = ((_b = document.getElementsByClassName("titlebar")[0]) == null ? void 0 : _b.innerHeight) || 40;
}
var shakeIntensity = 5;
var particles = [];
var MAX_PARTICLES = 500;
var PARTICLE_NUM_RANGE = { min: 5, max: 10 };
var PARTICLE_GRAVITY = 0.08;
var PARTICLE_ALPHA_FADEOUT = 0.96;
var PARTICLE_VELOCITY_RANGE = {
  x: [-1, 1],
  y: [-3.5, -1.5]
};
var w = window.innerWidth;
var h2 = window.innerHeight - titleBarHeight;
var throttledShake = throttle(shake, 100);
var throttledSpawnParticles = throttle(spawnParticles, 100);
var throttledPartyMe = throttle(partyMe, 100);
function heartBeat(node) {
  const heartPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  heartPath.setAttribute("d", "M316.722,29.761c66.852,0,121.053,54.202,121.053,121.041c0,110.478-218.893,257.212-218.893,257.212S0,266.569,0,150.801 C0,67.584,54.202,29.761,121.041,29.761c40.262,0,75.827,19.745,97.841,49.976C240.899,49.506,276.47,29.761,316.722,29.761z");
  const heartShape = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  heartShape.setAttribute("viewBox", "0 0 512 512");
  heartShape.setAttribute("height", "20");
  heartShape.setAttribute("width", "20");
  heartShape.appendChild(heartPath);
  import_party_js.default.scene.current.createEmitter({
    emitterOptions: {
      loops: 1,
      useGravity: false,
      modules: [
        new import_party_js.default.ModuleBuilder().drive("size").by((t3) => 0.5 + 0.3 * (Math.cos(t3 * 10) + 1)).build(),
        new import_party_js.default.ModuleBuilder().drive("rotation").by((t3) => new import_party_js.default.Vector(0, 0, 100).scale(t3)).relative().build()
      ]
    },
    emissionOptions: {
      rate: 0,
      bursts: [{ time: 0, count: import_party_js.default.variation.skew(20, 10) }],
      sourceSampler: import_party_js.default.sources.dynamicSource(node),
      angle: import_party_js.default.variation.range(0, 360),
      initialSpeed: 400,
      initialColor: import_party_js.default.variation.gradientSample(import_party_js.default.Gradient.simple(import_party_js.default.Color.fromHex("#ffa68d"), import_party_js.default.Color.fromHex("#fd3a84")))
    },
    rendererOptions: {
      shapeFactory: heartShape,
      applyLighting: void 0
    }
  });
}
function partyMe(cm) {
  const cursorPos = cm.getCursor();
  const pos = cm.coordsAtPos(cursorPos);
  const node = document.elementFromPoint(pos.left, pos.top);
  if (effect == "3") {
    import_party_js.default.confetti(node, {
      count: import_party_js.default.variation.range(20, 40)
    });
  } else if (effect == "4") {
    heartBeat(node);
  }
}
function getRGBComponents(node) {
  var _a3;
  const color2 = getComputedStyle(node).color;
  if (color2) {
    try {
      return (_a3 = color2.match(/(\d+), (\d+), (\d+)/)) == null ? void 0 : _a3.slice(1);
    } catch (e3) {
      return [255, 255, 255];
    }
  } else {
    return [255, 255, 255];
  }
}
function spawnParticles(cm) {
  const cursorPos = cm.getCursor();
  const pos = cm.coordsAtPos(cursorPos);
  const node = document.elementFromPoint(pos.left, pos.top);
  const numParticles = random(PARTICLE_NUM_RANGE.min, PARTICLE_NUM_RANGE.max);
  const color2 = getRGBComponents(node);
  for (let i3 = numParticles; i3--; ) {
    particles[particlePointer] = createParticle(pos.left + 10, pos.top - titleBarHeight, color2);
    particlePointer = (particlePointer + 1) % MAX_PARTICLES;
  }
}
function createParticle(x2, y3, color2) {
  const p2 = {
    x: x2,
    y: y3 + 10,
    alpha: 1,
    color: color2,
    size: 0,
    vx: 0,
    vy: 0,
    drag: 0,
    wander: 0,
    theta: 0
  };
  if (effect === "1") {
    p2.size = random(2, 4);
    p2.vx = PARTICLE_VELOCITY_RANGE.x[0] + Math.random() * (PARTICLE_VELOCITY_RANGE.x[1] - PARTICLE_VELOCITY_RANGE.x[0]);
    p2.vy = PARTICLE_VELOCITY_RANGE.y[0] + Math.random() * (PARTICLE_VELOCITY_RANGE.y[1] - PARTICLE_VELOCITY_RANGE.y[0]);
  } else if (effect === "2") {
    p2.size = random(2, 8);
    p2.drag = 0.92;
    p2.vx = random(-3, 3);
    p2.vy = random(-3, 3);
    p2.wander = 0.15;
    p2.theta = random(0, 360) * Math.PI / 180;
  }
  return p2;
}
function effect1(particle) {
  particle.vy += PARTICLE_GRAVITY;
  particle.x += particle.vx;
  particle.y += particle.vy;
  particle.alpha *= PARTICLE_ALPHA_FADEOUT;
  ctx.fillStyle = "rgba(" + particle.color[0] + "," + particle.color[1] + "," + particle.color[2] + "," + particle.alpha + ")";
  ctx.fillRect(Math.round(particle.x - 1), Math.round(particle.y - 1), particle.size, particle.size);
}
function effect2(particle) {
  particle.x += particle.vx;
  particle.y += particle.vy;
  particle.vx *= particle.drag;
  particle.vy *= particle.drag;
  particle.theta += random(-0.5, 0.5);
  particle.vx += Math.sin(particle.theta) * 0.1;
  particle.vy += Math.cos(particle.theta) * 0.1;
  particle.size *= 0.96;
  ctx.fillStyle = "rgba(" + particle.color[0] + "," + particle.color[1] + "," + particle.color[2] + "," + particle.alpha + ")";
  ctx.beginPath();
  ctx.arc(Math.round(particle.x - 1), Math.round(particle.y - 1), particle.size, 0, 2 * Math.PI);
  ctx.fill();
}
function drawParticles() {
  let particle;
  for (let i3 = particles.length; i3--; ) {
    particle = particles[i3];
    if (!particle || particle.alpha < 0.01 || particle.size <= 0.5) {
      continue;
    }
    if (effect === "1") {
      effect1(particle);
    } else if (effect === "2") {
      effect2(particle);
    }
  }
}
function shake(editor, time2) {
  cmNode = editor.containerEl;
  shakeTime = shakeTimeMax = time2;
}
function random(min, max) {
  if (!max) {
    max = min;
    min = 0;
  }
  return min + ~~(Math.random() * (max - min + 1));
}
function throttle(callback2, limit) {
  let wait = false;
  return function() {
    if (!wait) {
      callback2.apply(this, arguments);
      wait = true;
      setTimeout(function() {
        wait = false;
      }, limit);
    }
  };
}
function loop() {
  if (!isActive) {
    return;
  }
  ctx.clearRect(0, 0, w, h2);
  const current_time = new Date().getTime();
  if (!lastTime)
    lastTime = current_time;
  const dt = (current_time - lastTime) / 1e3;
  lastTime = current_time;
  if (enableShake && enableShake.value && shakeTime > 0) {
    shakeTime -= dt;
    const magnitude = shakeTime / shakeTimeMax * shakeIntensity;
    const shakeX = random(-magnitude, magnitude);
    const shakeY = random(-magnitude, magnitude);
    cmNode.style.transform = "translate(" + shakeX + "px," + shakeY + "px)";
  }
  drawParticles();
  requestAnimationFrame(loop);
}
function onCodeMirrorChange(editor) {
  throttledShake(editor, 0.3);
  throttledSpawnParticles(editor);
  throttledPartyMe(editor);
}
function toggleShake(targetVal) {
  enableShake = targetVal;
}
function toggleBlast(targetEffect) {
  if (Object.keys(i18n_default2.info.powerMode).contains(targetEffect)) {
    effect = targetEffect;
    isActive = true;
    if (!canvas) {
      canvas = document.createElement("canvas");
      ctx = canvas.getContext("2d"), canvas.id = "code-blast-canvas";
      canvas.style.position = "absolute";
      canvas.style.top = `${titleBarHeight}px`;
      canvas.style.left = 0;
      canvas.style.zIndex = 1;
      canvas.style.pointerEvents = "none";
      canvas.width = w;
      canvas.height = h2;
      document.body.appendChild(canvas);
      loop();
    }
  } else {
    isActive = false;
    if (canvas) {
      canvas.remove();
      canvas = null;
    }
    return;
  }
}

// src/settings.ts
var TAG_RESCAN = "re-scan";
var Settings = class {
  constructor() {
    this.settings = new SettingTabModel();
    const reminderFormatSettings = new ReminderFormatSettings(this.settings);
    this.cursorEffectBuilder = this.settings.newSettingBuilder().key("cursorEffect").name(i18n_default2.setting.cursorEffect.name).desc(i18n_default2.setting.cursorEffect.desc).dropdown("none");
    Object.keys(i18n_default2.info.effects).forEach((f) => this.cursorEffectBuilder.addOption(`${i18n_default2.info.effects[f]}`, f));
    this.cursorEffect = this.cursorEffectBuilder.onAnyValueChanged((context) => {
      toggleCursorEffects(SETTINGS.cursorEffect.value);
    }).build(new RawSerde());
    this.powerModeBuilder = this.settings.newSettingBuilder().key("powerMode").name(i18n_default2.setting.powerMode.name).desc(i18n_default2.setting.powerMode.desc).dropdown("0");
    Object.keys(i18n_default2.info.powerMode).forEach((f) => {
      this.powerModeBuilder.addOption(i18n_default2.info.powerMode[f], f);
    });
    this.powerMode = this.powerModeBuilder.onAnyValueChanged((context) => {
      toggleBlast(SETTINGS.powerMode.value);
    }).build(new RawSerde());
    this.shakeMode = this.settings.newSettingBuilder().key("shakeMode").name(i18n_default2.setting.shakeMode.name).desc(i18n_default2.setting.shakeMode.desc).toggle(false).build(new RawSerde());
    this.expectedTime = this.settings.newSettingBuilder().key("expectedTime").name(i18n_default2.setting.expectedTime.name).desc(i18n_default2.setting.expectedTime.desc).number(25).build(new RawSerde());
    this.reminderTime = this.settings.newSettingBuilder().key("reminderTime").name("Reminder Time").desc("Time when a reminder with no time part will show").tag(TAG_RESCAN).text("09:00").placeHolder("Time (hh:mm)").build(new TimeSerde());
    this.useSystemNotification = this.settings.newSettingBuilder().key("useSystemNotification").name("Use system notification").desc("Use system notification for reminder notifications").toggle(false).build(new RawSerde());
    this.laters = this.settings.newSettingBuilder().key("laters").name("Remind me later").desc("Line-separated list of remind me later items").textArea("In 30 minutes\nIn 1 hour\nIn 3 hours\nTomorrow\nNext week").placeHolder("In 30 minutes\nIn 1 hour\nIn 3 hours\nTomorrow\nNext week").build(new LatersSerde());
    this.dateFormat = this.settings.newSettingBuilder().key("dateFormat").name("Date format").desc("moment style date format: https://momentjs.com/docs/#/displaying/format/").tag(TAG_RESCAN).text("YYYY-MM-DD").placeHolder("YYYY-MM-DD").onAnyValueChanged((context) => {
      context.setEnabled(reminderFormatSettings.enableReminderPluginReminderFormat.value);
    }).build(new RawSerde());
    this.strictDateFormat = this.settings.newSettingBuilder().key("strictDateFormat").name("Strict Date format").desc("Strictly parse the date and time").tag(TAG_RESCAN).toggle(false).build(new RawSerde());
    this.dateTimeFormat = this.settings.newSettingBuilder().key("dateTimeFormat").name("Date and time format").desc("moment() style date time format: https://momentjs.com/docs/#/displaying/format/").tag(TAG_RESCAN).text("YYYY-MM-DD HH:mm").placeHolder("YYYY-MM-DD HH:mm").onAnyValueChanged((context) => {
      context.setEnabled(reminderFormatSettings.enableReminderPluginReminderFormat.value);
    }).build(new RawSerde());
    this.linkDatesToDailyNotes = this.settings.newSettingBuilder().key("linkDatesToDailyNotes").name("Link dates to daily notes").desc("When toggled, Dates link to daily notes.").tag(TAG_RESCAN).toggle(false).onAnyValueChanged((context) => {
      context.setEnabled(reminderFormatSettings.enableReminderPluginReminderFormat.value);
    }).build(new RawSerde());
    this.autoCompleteTrigger = this.settings.newSettingBuilder().key("autoCompleteTrigger").name("Calendar popup trigger").desc("Trigger text to show calendar popup").text("(@").placeHolder("(@").onAnyValueChanged((context) => {
      const value = this.autoCompleteTrigger.value;
      context.setInfo(`Popup is ${value.length === 0 ? "disabled" : "enabled"}`);
    }).build(new RawSerde());
    const primaryFormatBuilder = this.settings.newSettingBuilder().key("primaryReminderFormat").name("Primary reminder format").desc("Reminder format for generated reminder by calendar popup").dropdown(ReminderFormatTypes[0].name);
    ReminderFormatTypes.forEach((f) => primaryFormatBuilder.addOption(`${f.description} - ${f.example}`, f.name));
    this.primaryFormat = primaryFormatBuilder.build(new ReminderFormatTypeSerde());
    this.useCustomEmojiForTasksPlugin = this.settings.newSettingBuilder().key("useCustomEmojiForTasksPlugin").name("Distinguish between reminder date and due date").desc("Use custom emoji \u23F0 instead of \u{1F4C5} and distinguish between reminder date/time and Tasks Plugin's due date.").tag(TAG_RESCAN).toggle(false).onAnyValueChanged((context) => {
      context.setEnabled(reminderFormatSettings.enableTasksPluginReminderFormat.value);
    }).build(new RawSerde());
    this.removeTagsForTasksPlugin = this.settings.newSettingBuilder().key("removeTagsForTasksPlugin").name("Remove tags from reminder title").desc("If checked, tags(#xxx) are removed from the reminder list view and notification.").tag(TAG_RESCAN).toggle(false).onAnyValueChanged((context) => {
      context.setEnabled(reminderFormatSettings.enableTasksPluginReminderFormat.value);
    }).build(new RawSerde());
    this.editDetectionSec = this.settings.newSettingBuilder().key("editDetectionSec").name("Edit Detection Time").desc("The minimum amount of time (in seconds) after a key is typed that it will be identified as notifiable.").number(10).build(new RawSerde());
    this.reminderCheckIntervalSec = this.settings.newSettingBuilder().key("reminderCheckIntervalSec").name("Reminder check interval").desc("Interval(in seconds) to periodically check whether or not you should be notified of reminders.  You will need to restart Obsidian for this setting to take effect.").number(5).build(new RawSerde());
    this.rolloverTemplateHeadingBuilder = this.settings.newSettingBuilder().key("templateHeading").name("Template heading").desc("Which heading from your template should the todos go under").dropdown("none");
    this.templateHeading = this.rolloverTemplateHeadingBuilder.build(new RawSerde());
    this.deleteOnComplete = this.settings.newSettingBuilder().key("deleteOnComplete").name("Delete todos from previous day").desc("Once todos are found, they are added to Today's Daily Note. If successful, they are deleted from Yesterday's Daily note. Enabling this is destructive and may result in lost data. Keeping this disabled will simply duplicate them from yesterday's note and place them in the appropriate section. Note that currently, duplicate todos will be deleted regardless of what heading they are in, and which heading you choose from above.").toggle(false).build(new RawSerde());
    this.removeEmptyTodos = this.settings.newSettingBuilder().key("removeEmptyTodos").name("Remove empty todos in rollover").desc("If you have empty todos, they will not be rolled over to the next day.").toggle(true).build(new RawSerde());
    this.debugEnable = this.settings.newSettingBuilder().key("debugEnable").name("Enable debug").desc("If you set this value as true, your will see debug info in console.").toggle(false).build(new RawSerde());
    this.settings.newGroup(i18n_default2.setting.title.effects).addSettings(this.cursorEffect, this.powerMode, this.shakeMode);
    this.settings.newGroup(i18n_default2.setting.title.pomodoro).addSettings(this.expectedTime);
    this.settings.newGroup(i18n_default2.setting.title.warning);
    this.settings.newGroup("Rollover TODOs").addSettings(this.templateHeading, this.deleteOnComplete, this.removeEmptyTodos);
    this.settings.newGroup("Notification Settings").addSettings(this.reminderTime, this.laters, this.useSystemNotification);
    this.settings.newGroup("Editor").addSettings(this.autoCompleteTrigger, this.primaryFormat);
    this.settings.newGroup("Reminder Format - Reminder Plugin").addSettings(reminderFormatSettings.enableReminderPluginReminderFormat, this.dateFormat, this.dateTimeFormat, this.strictDateFormat, this.linkDatesToDailyNotes);
    this.settings.newGroup("Reminder Format - Tasks Plugin").addSettings(reminderFormatSettings.enableTasksPluginReminderFormat, this.useCustomEmojiForTasksPlugin, this.removeTagsForTasksPlugin);
    this.settings.newGroup("Reminder Format - Kanban Plugin").addSettings(reminderFormatSettings.enableKanbanPluginReminderFormat);
    this.settings.newGroup("Advanced").addSettings(this.editDetectionSec, this.reminderCheckIntervalSec, this.debugEnable);
    const config = new ReminderFormatConfig();
    config.setParameterFunc(ReminderFormatParameterKey.now, () => DateTime.now());
    config.setParameter(ReminderFormatParameterKey.useCustomEmojiForTasksPlugin, this.useCustomEmojiForTasksPlugin);
    config.setParameter(ReminderFormatParameterKey.linkDatesToDailyNotes, this.linkDatesToDailyNotes);
    config.setParameter(ReminderFormatParameterKey.removeTagsForTasksPlugin, this.removeTagsForTasksPlugin);
    setReminderFormatConfig(config);
  }
  setRolloverTemplateHeadingOptions(val) {
    if (this.setRolloverTemplateHeadingOptionsHasBeenSet) {
      return;
    }
    val.forEach((f) => this.rolloverTemplateHeadingBuilder.addOption(`${f}`, f));
    this.setRolloverTemplateHeadingOptionsHasBeenSet = true;
  }
  forEach(consumer) {
    this.settings.forEach(consumer);
  }
};
var ReminderFormatSettings = class {
  constructor(settings) {
    this.settings = settings;
    this.settingKeyToFormatName = /* @__PURE__ */ new Map();
    this.reminderFormatSettings = [];
    this.enableReminderPluginReminderFormat = this.createUseReminderFormatSetting(reminderPluginReminderFormat);
    this.enableTasksPluginReminderFormat = this.createUseReminderFormatSetting(tasksPluginReminderFormat);
    this.enableKanbanPluginReminderFormat = this.createUseReminderFormatSetting(kanbanPluginReminderFormat);
  }
  createUseReminderFormatSetting(format2) {
    const key = `enable${format2.name}`;
    const setting = this.settings.newSettingBuilder().key(key).name(`Enable ${format2.description}`).desc(`Enable ${format2.description}`).tag(TAG_RESCAN).toggle(format2.defaultEnabled).onAnyValueChanged((context) => {
      var _a3;
      context.setInfo(`Example: ${(_a3 = format2.format.appendReminder("- [ ] Task 1", DateTime.now())) == null ? void 0 : _a3.insertedLine}`);
    }).build(new RawSerde());
    this.settingKeyToFormatName.set(key, format2);
    this.reminderFormatSettings.push(setting);
    setting.rawValue.onChanged(() => {
      this.updateReminderFormat(setting);
    });
    return setting;
  }
  updateReminderFormat(setting) {
    const selectedFormats = this.reminderFormatSettings.filter((s4) => s4.value).map((s4) => this.settingKeyToFormatName.get(s4.key)).filter((s4) => s4 !== void 0);
    changeReminderFormat(selectedFormats);
  }
};
var SETTINGS = new Settings();
var ReminderSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app2, plugin3, pluginData) {
    super(app2, plugin3);
    this.pluginData = pluginData;
  }
  async getTemplateHeadings() {
    const { template } = (0, import_obsidian_daily_notes_interface.getDailyNoteSettings)();
    if (!template)
      return [];
    let file = this.app.vault.getAbstractFileByPath(template);
    if (file == null) {
      file = this.app.vault.getAbstractFileByPath(template + ".md");
    }
    const templateContents = await this.app.vault.read(file);
    const allHeadings = Array.from(templateContents.matchAll(/#{1,} .*/g)).map(([heading]) => heading);
    return allHeadings;
  }
  async display() {
    const { containerEl } = this;
    const templateHeadings = await this.getTemplateHeadings();
    SETTINGS.setRolloverTemplateHeadingOptions(templateHeadings);
    SETTINGS.settings.displayOn(containerEl);
  }
  hide() {
    this.pluginData.save();
  }
};

// src/data.ts
var PluginDataIO = class {
  constructor(plugin3, reminders) {
    this.plugin = plugin3;
    this.reminders = reminders;
    this.restoring = true;
    this.changed = false;
    this.scanned = new Reference(false);
    SETTINGS.forEach((setting) => {
      setting.rawValue.onChanged(() => {
        if (this.restoring) {
          return;
        }
        if (setting.hasTag(TAG_RESCAN)) {
          this.scanned.value = false;
        }
        this.changed = true;
      });
    });
  }
  async load() {
    const data = await this.plugin.loadData();
    if (!data) {
      this.scanned.value = false;
      return;
    }
    this.scanned.value = data.scanned;
    const loadedSettings = data.settings;
    SETTINGS.forEach((setting) => {
      setting.load(loadedSettings);
    });
    if (data.reminders) {
      Object.keys(data.reminders).forEach((filePath) => {
        const remindersInFile = data.reminders[filePath];
        if (!remindersInFile) {
          return;
        }
        this.reminders.replaceFile(filePath, remindersInFile.map((d4) => new Reminder(filePath, d4.title, DateTime.parse(d4.time), d4.rowNumber, false)));
      });
    }
    this.changed = false;
    if (this.restoring) {
      this.restoring = false;
    }
  }
  async save(force = false) {
    if (!force && !this.changed) {
      return;
    }
    logger_default.debug("Save reminder plugin data: force=%s, changed=%s", force, this.changed);
    const remindersData = {};
    this.reminders.fileToReminders.forEach((r, filePath) => {
      remindersData[filePath] = r.map((rr) => ({
        title: rr.title,
        time: rr.time.toString(),
        rowNumber: rr.rowNumber
      }));
    });
    const settings = {};
    SETTINGS.forEach((setting) => {
      setting.store(settings);
    });
    await this.plugin.saveData({
      scanned: this.scanned.value,
      reminders: remindersData,
      settings
    });
    this.changed = false;
  }
};

// src/obsidian-hack/obsidian-debug-mobile.ts
var import_obsidian5 = require("obsidian");
function monkeyPatchConsole(plugin3) {
  if (!import_obsidian5.Platform.isMobile) {
    return;
  }
  const logFile = `${plugin3.manifest.dir}/logs.txt`;
  const logs = [];
  const logMessages = (prefix3) => (...messages) => {
    logs.push(`
[${prefix3}]`);
    for (const message of messages) {
      logs.push(String(message));
    }
    plugin3.app.vault.adapter.write(logFile, logs.join(" "));
  };
  console.debug = logMessages("debug");
  console.error = logMessages("error");
  console.info = logMessages("info");
  console.log = logMessages("log");
  console.warn = logMessages("warn");
}

// src/ui/modal/customModals.ts
var import_obsidian6 = require("obsidian");
var ALL_IMAGE_ORIGIN = [
  { title: "pixabay", origin: "pixabay" },
  { title: "pexels", origin: "pexels" },
  { title: "dummyimage", origin: "dummyimage" }
];
var ImageOriginModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app2, plugin3, path) {
    super(app2);
    this.plugin = plugin3;
    this.selectedPath = path;
  }
  getItems() {
    return ALL_IMAGE_ORIGIN;
  }
  getItemText(imageOrigin) {
    return imageOrigin.title;
  }
  onChooseItem(imageOrigin, evt) {
    new import_obsidian6.Notice(`Selected ${imageOrigin.origin}`);
    this.plugin.setRandomBanner(this.selectedPath, imageOrigin.origin);
  }
};
var PomodoroReminderModal = class extends import_obsidian6.Modal {
  constructor(app2, pomodoro) {
    super(app2);
    this.pomodoro = pomodoro;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: i18n_default2.info.done + this.pomodoro.task });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/view/PomodoroHistoryView.ts
var import_obsidian8 = require("obsidian");

// node_modules/@vue/shared/dist/shared.esm-bundler.js
function makeMap(str, expectsLowerCase) {
  const map4 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i3 = 0; i3 < list.length; i3++) {
    map4[list[i3]] = true;
  }
  return expectsLowerCase ? (val) => !!map4[val.toLowerCase()] : (val) => !!map4[val];
}
function normalizeStyle(value) {
  if (isArray2(value)) {
    const res = {};
    for (let i3 = 0; i3 < value.length; i3++) {
      const item = value[i3];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
var listDelimiterRE = /;(?![^(]*\))/g;
var propertyDelimiterRE = /:([^]+)/;
var styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray2(value)) {
    for (let i3 = 0; i3 < value.length; i3++) {
      const normalized = normalizeClass(value[i3]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name2 in value) {
      if (value[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
var isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
var toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray2(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
var replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray2(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
var EMPTY_OBJ = false ? Object.freeze({}) : {};
var EMPTY_ARR = false ? Object.freeze([]) : [];
var NOOP = () => {
};
var NO = () => false;
var onRE = /^on[^a-z]/;
var isOn = (key) => onRE.test(key);
var isModelListener = (key) => key.startsWith("onUpdate:");
var extend = Object.assign;
var remove = (arr, el) => {
  const i3 = arr.indexOf(el);
  if (i3 > -1) {
    arr.splice(i3, 1);
  }
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty.call(val, key);
var isArray2 = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isSet = (val) => toTypeString(val) === "[object Set]";
var isFunction = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject = (val) => val !== null && typeof val === "object";
var isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isPlainObject = (val) => toTypeString(val) === "[object Object]";
var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
var cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c6) => c6 ? c6.toUpperCase() : "");
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
var invokeArrayFns = (fns, arg) => {
  for (let i3 = 0; i3 < fns.length; i3++) {
    fns[i3](arg);
  }
};
var def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
var toNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
var _globalThis;
var getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};

// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
var activeEffectScope;
var EffectScope = class {
  constructor(detached = false) {
    this.detached = detached;
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (false) {
      warn(`cannot run an inactive effect scope.`);
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i3, l2;
      for (i3 = 0, l2 = this.effects.length; i3 < l2; i3++) {
        this.effects[i3].stop();
      }
      for (i3 = 0, l2 = this.cleanups.length; i3 < l2; i3++) {
        this.cleanups[i3]();
      }
      if (this.scopes) {
        for (i3 = 0, l2 = this.scopes.length; i3 < l2; i3++) {
          this.scopes[i3].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this.active = false;
    }
  }
};
function recordEffectScope(effect4, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect4);
  }
}
var createDep = (effects2) => {
  const dep = new Set(effects2);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
var wasTracked = (dep) => (dep.w & trackOpBit) > 0;
var newTracked = (dep) => (dep.n & trackOpBit) > 0;
var initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i3 = 0; i3 < deps.length; i3++) {
      deps[i3].w |= trackOpBit;
    }
  }
};
var finalizeDepMarkers = (effect4) => {
  const { deps } = effect4;
  if (deps.length) {
    let ptr = 0;
    for (let i3 = 0; i3 < deps.length; i3++) {
      const dep = deps[i3];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect4);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
var targetMap = /* @__PURE__ */ new WeakMap();
var effectTrackDepth = 0;
var trackOpBit = 1;
var maxMarkerBits = 30;
var activeEffect;
var ITERATE_KEY = Symbol(false ? "iterate" : "");
var MAP_KEY_ITERATE_KEY = Symbol(false ? "Map key iterate" : "");
var ReactiveEffect = class {
  constructor(fn, scheduler2 = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler2;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
};
function cleanupEffect(effect4) {
  const { deps } = effect4;
  if (deps.length) {
    for (let i3 = 0; i3 < deps.length; i3++) {
      deps[i3].delete(effect4);
    }
    deps.length = 0;
  }
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = false ? { effect: activeEffect, target, type, key } : void 0;
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (false) {
      activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray2(target)) {
    const newLength = toNumber(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = false ? { target, type, key, newValue, oldValue, oldTarget } : void 0;
  if (deps.length === 1) {
    if (deps[0]) {
      if (false) {
        triggerEffects(deps[0], eventInfo);
      } else {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects2 = [];
    for (const dep of deps) {
      if (dep) {
        effects2.push(...dep);
      }
    }
    if (false) {
      triggerEffects(createDep(effects2), eventInfo);
    } else {
      triggerEffects(createDep(effects2));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects2 = isArray2(dep) ? dep : [...dep];
  for (const effect4 of effects2) {
    if (effect4.computed) {
      triggerEffect(effect4, debuggerEventExtraInfo);
    }
  }
  for (const effect4 of effects2) {
    if (!effect4.computed) {
      triggerEffect(effect4, debuggerEventExtraInfo);
    }
  }
}
function triggerEffect(effect4, debuggerEventExtraInfo) {
  if (effect4 !== activeEffect || effect4.allowRecurse) {
    if (false) {
      effect4.onTrigger(extend({ effect: effect4 }, debuggerEventExtraInfo));
    }
    if (effect4.scheduler) {
      effect4.scheduler();
    } else {
      effect4.run();
    }
  }
}
var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol));
var get = /* @__PURE__ */ createGetter();
var shallowGet = /* @__PURE__ */ createGetter(false, true);
var readonlyGet = /* @__PURE__ */ createGetter(true);
var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i3 = 0, l2 = this.length; i3 < l2; i3++) {
        track(arr, "get", i3 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get3(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray2(target);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
var set = /* @__PURE__ */ createSetter();
var shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set3(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray2(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray2(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
var mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
};
var readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    if (false) {
      warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    if (false) {
      warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
var shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
var toShallow = (value) => value;
var getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add2(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get3.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get3 ? get3.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = false ? isMap(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach2(callback2, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback2.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (false) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add: add2,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add: add2,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
var mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
var shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
var readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    if (false) {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
var toReactive = (value) => isObject(value) ? reactive(value) : value;
var toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    if (false) {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    } else {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    if (false) {
      triggerEffects(ref2.dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    } else {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
var RefImpl = class {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
};
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
var shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  if (false) {
    console.warn(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = isArray2(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
var ObjectRefImpl = class {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
};
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
var _a2;
var ComputedRefImpl = class {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a2] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self79 = toRaw(this);
    trackRefValue(self79);
    if (self79._dirty || !self79._cacheable) {
      self79._dirty = false;
      self79._value = self79.effect.run();
    }
    return self79._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
};
_a2 = "__v_isReadonly";
function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = false ? () => {
      console.warn("Write operation failed: computed value is readonly");
    } : NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (false) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
var _a$1;
_a$1 = "__v_isReadonly";

// node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
var stack = [];
function warn(msg2, ...args) {
  if (true)
    return;
  pauseTracking();
  const instance4 = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance4 && instance4.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance4, 11, [
      msg2 + args.join(""),
      instance4 && instance4.proxy,
      trace.map(({ vnode }) => `at <${formatComponentName(instance4, vnode.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg2}`, ...args];
    if (trace.length && true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i3) => {
    logs.push(...i3 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys2 = Object.keys(props);
  keys2.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys2.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance4, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance4, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance4, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance4, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance4, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i3 = 0; i3 < fn.length; i3++) {
    values.push(callWithAsyncErrorHandling(fn[i3], instance4, type, args));
  }
  return values;
}
function handleError(err, instance4, type, throwInDev = true) {
  const contextVNode = instance4 ? instance4.vnode : null;
  if (instance4) {
    let cur = instance4.parent;
    const exposedInstance = instance4.proxy;
    const errorInfo = false ? ErrorTypeStrings[type] : type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i3 = 0; i3 < errorCapturedHooks.length; i3++) {
          if (errorCapturedHooks[i3](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance4.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  if (false) {
    const info = ErrorTypeStrings[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {
    console.error(err);
  }
}
var isFlushing = false;
var isFlushPending = false;
var queue = [];
var flushIndex = 0;
var pendingPostFlushCbs = [];
var activePostFlushCbs = null;
var postFlushIndex = 0;
var resolvedPromise = /* @__PURE__ */ Promise.resolve();
var currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i3 = queue.indexOf(job);
  if (i3 > flushIndex) {
    queue.splice(i3, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray2(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i3 = isFlushing ? flushIndex + 1 : 0) {
  if (false) {
    seen = seen || /* @__PURE__ */ new Map();
  }
  for (; i3 < queue.length; i3++) {
    const cb = queue[i3];
    if (cb && cb.pre) {
      if (false) {
        continue;
      }
      queue.splice(i3, 1);
      i3--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (false) {
      seen = seen || /* @__PURE__ */ new Map();
    }
    activePostFlushCbs.sort((a4, b2) => getId(a4) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (false) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
var getId = (job) => job.id == null ? Infinity : job.id;
var comparator = (a4, b2) => {
  const diff = getId(a4) - getId(b2);
  if (diff === 0) {
    if (a4.pre && !b2.pre)
      return -1;
    if (b2.pre && !a4.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  if (false) {
    seen = seen || /* @__PURE__ */ new Map();
  }
  queue.sort(comparator);
  const check = false ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
if (false) {
  getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
function emit$1(instance4, event, ...rawArgs) {
  if (instance4.isUnmounted)
    return;
  const props = instance4.vnode.props || EMPTY_OBJ;
  if (false) {
    const { emitsOptions, propsOptions: [propsOptions] } = instance4;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
          warn(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`);
        }
      } else {
        const validator = emitsOptions[event];
        if (isFunction(validator)) {
          const isValid2 = validator(...rawArgs);
          if (!isValid2) {
            warn(`Invalid event arguments: event validation failed for event "${event}".`);
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a4) => isString(a4) ? a4.trim() : a4);
    }
    if (number) {
      args = rawArgs.map(toNumber);
    }
  }
  if (false) {
    devtoolsComponentEmit(instance4, event, args);
  }
  if (false) {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
      warn(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance4, instance4.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance4, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance4.emitted) {
      instance4.emitted = {};
    } else if (instance4.emitted[handlerName]) {
      return;
    }
    instance4.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance4, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray2(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
var currentRenderingInstance = null;
var currentScopeId = null;
function setCurrentRenderingInstance(instance4) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance4;
  currentScopeId = instance4 && instance4.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx3 = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx3)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx3);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (false) {
      devtoolsComponentUpdated(ctx3);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function renderComponentRoot(instance4) {
  const { type: Component2, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render: render14, renderCache, data, setupState, ctx: ctx3, inheritAttrs } = instance4;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance4);
  if (false) {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render14.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx3));
      fallthroughAttrs = attrs;
    } else {
      const render15 = Component2;
      if (false) {
        markAttrsAccessed();
      }
      result = normalizeVNode(render15.length > 1 ? render15(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit
      } : { attrs, slots, emit }) : render15(props, null));
      fallthroughAttrs = Component2.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance4, 1);
    result = createVNode(Comment);
  }
  let root2 = result;
  let setRoot = void 0;
  if (false) {
    [root2, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      } else if (false) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i3 = 0, l2 = allAttrs.length; i3 < l2; i3++) {
          const key = allAttrs[i3];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
        }
        if (eventAttrs.length) {
          warn(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
        }
      }
    }
  }
  if (vnode.dirs) {
    if (false) {
      warn(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
    }
    root2 = cloneVNode(root2);
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (false) {
      warn(`Component inside <Transition> renders non-element root node that cannot be animated.`);
    }
    root2.transition = vnode.transition;
  }
  if (false) {
    setRoot(root2);
  } else {
    result = root2;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
var getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
var filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (false) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i3 = 0; i3 < dynamicProps.length; i3++) {
        const key = dynamicProps[i3];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i3 = 0; i3 < nextKeys.length; i3++) {
    const key = nextKeys[i3];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
var isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray2(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key, value) {
  if (!currentInstance) {
    if (false) {
      warn(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance4 = currentInstance || currentRenderingInstance;
  if (instance4) {
    const provides = instance4.parent == null ? instance4.vnode.appContext && instance4.vnode.appContext.provides : instance4.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance4.proxy) : defaultValue;
    } else if (false) {
      warn(`injection "${String(key)}" not found.`);
    }
  } else if (false) {
    warn(`inject() can only be used inside setup() or functional components.`);
  }
}
function watchEffect(effect4, options) {
  return doWatch(effect4, null, options);
}
var INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (false) {
    warn(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush: flush2, onTrack, onTrigger } = EMPTY_OBJ) {
  if (false) {
    if (immediate !== void 0) {
      warn(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    if (deep !== void 0) {
      warn(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
  }
  const warnInvalidSource = (s4) => {
    warn(`Invalid watch source: `, s4, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
  };
  const instance4 = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s4) => isReactive(s4) || isShallow(s4));
    getter = () => source.map((s4) => {
      if (isRef(s4)) {
        return s4.value;
      } else if (isReactive(s4)) {
        return traverse(s4);
      } else if (isFunction(s4)) {
        return callWithErrorHandling(s4, instance4, 2);
      } else {
      }
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance4, 2);
    } else {
      getter = () => {
        if (instance4 && instance4.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance4, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect4.onStop = () => {
      callWithErrorHandling(fn, instance4, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance4, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush2 === "sync") {
      const ctx3 = useSSRContext();
      ssrCleanup = ctx3.__watcherHandles || (ctx3.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect4.active) {
      return;
    }
    if (cb) {
      const newValue = effect4.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i3) => hasChanged(v, oldValue[i3])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance4, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect4.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler2;
  if (flush2 === "sync") {
    scheduler2 = job;
  } else if (flush2 === "post") {
    scheduler2 = () => queuePostRenderEffect(job, instance4 && instance4.suspense);
  } else {
    job.pre = true;
    if (instance4)
      job.id = instance4.uid;
    scheduler2 = () => queueJob(job);
  }
  const effect4 = new ReactiveEffect(getter, scheduler2);
  if (false) {
    effect4.onTrack = onTrack;
    effect4.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect4.run();
    }
  } else if (flush2 === "post") {
    queuePostRenderEffect(effect4.run.bind(effect4), instance4 && instance4.suspense);
  } else {
    effect4.run();
  }
  const unwatch = () => {
    effect4.stop();
    if (instance4 && instance4.scope) {
      remove(instance4.scope.effects, effect4);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx3, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx3;
    for (let i3 = 0; i3 < segments.length && cur; i3++) {
      cur = cur[segments[i3]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray2(value)) {
    for (let i3 = 0; i3 < value.length; i3++) {
      traverse(value[i3], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
var TransitionHookValidator = [Function, Array];
var BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance4 = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children2 = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children2 || !children2.length) {
        return;
      }
      let child = children2[0];
      if (children2.length > 1) {
        let hasFound = false;
        for (const c6 of children2) {
          if (c6.type !== Comment) {
            if (false) {
              warn("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
              break;
            }
            child = c6;
            hasFound = true;
            if (true)
              break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (false) {
        warn(`invalid <transition> mode: ${mode}`);
      }
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance4);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance4.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance4);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance4.update.active !== false) {
              instance4.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
var BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance4) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook3 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance4, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook3(hook, args);
    if (isArray2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook3(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook3(cancelHook, [el]);
        } else {
          callHook3(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook3(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook3(onLeaveCancelled, [el]);
        } else {
          callHook3(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance4);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children2, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i3 = 0; i3 < children2.length; i3++) {
    let child = children2[i3];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i3);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i3 = 0; i3 < ret.length; i3++) {
      ret[i3].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction(options) ? { setup: options, name: options.name } : options;
}
var isAsyncWrapper = (i3) => !!i3.type.__asyncLoader;
var isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (false) {
    const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
    warn(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
var createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);
var onBeforeMount = createHook("bm");
var onMounted = createHook("m");
var onBeforeUpdate = createHook("bu");
var onUpdated = createHook("u");
var onBeforeUnmount = createHook("bum");
var onUnmounted = createHook("um");
var onServerPrefetch = createHook("sp");
var onRenderTriggered = createHook("rtg");
var onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance4 = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i3 = 0; i3 < directives.length; i3++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i3];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance: instance4,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance4, name2) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i3 = 0; i3 < bindings.length; i3++) {
    const binding = bindings[i3];
    if (oldBindings) {
      binding.oldValue = oldBindings[i3].value;
    }
    let hook = binding.dir[name2];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance4, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
var NULL_DYNAMIC_COMPONENT = Symbol();
function renderList(source, renderItem, cache2, index2) {
  let ret;
  const cached = cache2 && cache2[index2];
  if (isArray2(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i3 = 0, l2 = source.length; i3 < l2; i3++) {
      ret[i3] = renderItem(source[i3], i3, void 0, cached && cached[i3]);
    }
  } else if (typeof source === "number") {
    if (false) {
      warn(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i3 = 0; i3 < source; i3++) {
      ret[i3] = renderItem(i3 + 1, i3, void 0, cached && cached[i3]);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i3) => renderItem(item, i3, void 0, cached && cached[i3]));
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i3 = 0, l2 = keys2.length; i3 < l2; i3++) {
        const key = keys2[i3];
        ret[i3] = renderItem(source[key], key, i3, cached && cached[i3]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index2] = ret;
  }
  return ret;
}
function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name2 !== "default")
      props.name = name2;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name2];
  if (false) {
    warn(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
    slot = () => [];
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, {
    key: props.key || validSlotContent && validSlotContent.key || `_${name2}`
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
var getPublicInstance = (i3) => {
  if (!i3)
    return null;
  if (isStatefulComponent(i3))
    return getExposeProxy(i3) || i3.proxy;
  return getPublicInstance(i3.parent);
};
var publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
  $: (i3) => i3,
  $el: (i3) => i3.vnode.el,
  $data: (i3) => i3.data,
  $props: (i3) => false ? shallowReadonly(i3.props) : i3.props,
  $attrs: (i3) => false ? shallowReadonly(i3.attrs) : i3.attrs,
  $slots: (i3) => false ? shallowReadonly(i3.slots) : i3.slots,
  $refs: (i3) => false ? shallowReadonly(i3.refs) : i3.refs,
  $parent: (i3) => getPublicInstance(i3.parent),
  $root: (i3) => getPublicInstance(i3.root),
  $emit: (i3) => i3.emit,
  $options: (i3) => true ? resolveMergedOptions(i3) : i3.type,
  $forceUpdate: (i3) => i3.f || (i3.f = () => queueJob(i3.update)),
  $nextTick: (i3) => i3.n || (i3.n = nextTick.bind(i3.proxy)),
  $watch: (i3) => true ? instanceWatch.bind(i3) : NOOP
});
var hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
var PublicInstanceProxyHandlers = {
  get({ _: instance4 }, key) {
    const { ctx: ctx3, setupState, data, props, accessCache, type, appContext } = instance4;
    if (false) {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx3[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance4.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx3 !== EMPTY_OBJ && hasOwn(ctx3, key)) {
        accessCache[key] = 4;
        return ctx3[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance4, "get", key);
      }
      return publicGetter(instance4);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx3 !== EMPTY_OBJ && hasOwn(ctx3, key)) {
      accessCache[key] = 4;
      return ctx3[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if (false) {
      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
        warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
      } else if (instance4 === currentRenderingInstance) {
        warn(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
      }
    }
  },
  set({ _: instance4 }, key, value) {
    const { data, setupState, ctx: ctx3 } = instance4;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (false) {
      warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance4.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance4) {
      return false;
    } else {
      if (false) {
        Object.defineProperty(ctx3, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx3[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx: ctx3, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx3, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (false) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
  };
}
var shouldCacheAccess = true;
function applyOptions(instance4) {
  const options = resolveMergedOptions(instance4);
  const publicThis = instance4.proxy;
  const ctx3 = instance4.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance4, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate: beforeUpdate2,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render14,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = false ? createDuplicateChecker() : null;
  if (false) {
    const [propsOptions] = instance4.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx3, checkDuplicateProperties, instance4.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        if (false) {
          Object.defineProperty(ctx3, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          ctx3[key] = methodHandler.bind(publicThis);
        }
        if (false) {
          checkDuplicateProperties("Methods", key);
        }
      } else if (false) {
        warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
      }
    }
  }
  if (dataOptions) {
    if (false) {
      warn(`The data option must be a function. Plain object usage is no longer supported.`);
    }
    const data = dataOptions.call(publicThis, publicThis);
    if (false) {
      warn(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
    }
    if (!isObject(data)) {
    } else {
      instance4.data = reactive(data);
      if (false) {
        for (const key in data) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx3, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get3 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (false) {
        warn(`Computed property "${key}" has no getter.`);
      }
      const set3 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : false ? () => {
        warn(`Write operation failed: computed property "${key}" is readonly.`);
      } : NOOP;
      const c6 = computed2({
        get: get3,
        set: set3
      });
      Object.defineProperty(ctx3, key, {
        enumerable: true,
        configurable: true,
        get: () => c6.value,
        set: (v) => c6.value = v
      });
      if (false) {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx3, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance4, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray2(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate2);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray2(expose)) {
    if (expose.length) {
      const exposed = instance4.exposed || (instance4.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance4.exposed) {
      instance4.exposed = {};
    }
  }
  if (render14 && instance4.render === NOOP) {
    instance4.render = render14;
  }
  if (inheritAttrs != null) {
    instance4.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance4.components = components;
  if (directives)
    instance4.directives = directives;
}
function resolveInjections(injectOptions, ctx3, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx3, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        if (false) {
          warn(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
        }
        ctx3[key] = injected;
      }
    } else {
      ctx3[key] = injected;
    }
    if (false) {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook(hook, instance4, type) {
  callWithAsyncErrorHandling(isArray2(hook) ? hook.map((h6) => h6.bind(instance4.proxy)) : hook.bind(instance4.proxy), instance4, type);
}
function createWatcher(raw, ctx3, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx3[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    } else if (false) {
      warn(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray2(raw)) {
      raw.forEach((r) => createWatcher(r, ctx3, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx3[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      } else if (false) {
        warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else if (false) {
    warn(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance4) {
  const base3 = instance4.type;
  const { mixins, extends: extendsOptions } = base3;
  const { mixins: globalMixins, optionsCache: cache2, config: { optionMergeStrategies } } = instance4.appContext;
  const cached = cache2.get(base3);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base3;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m3) => mergeOptions(resolved, m3, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base3, optionMergeStrategies);
  }
  if (isObject(base3)) {
    cache2.set(base3, resolved);
  }
  return resolved;
}
function mergeOptions(to2, from2, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from2;
  if (extendsOptions) {
    mergeOptions(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m3) => mergeOptions(to2, m3, strats, true));
  }
  for (const key in from2) {
    if (asMixin && key === "expose") {
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from2[key]) : from2[key];
    }
  }
  return to2;
}
var internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from2) {
  if (!from2) {
    return to2;
  }
  if (!to2) {
    return from2;
  }
  return function mergedDataFn() {
    return extend(isFunction(to2) ? to2.call(this, this) : to2, isFunction(from2) ? from2.call(this, this) : from2);
  };
}
function mergeInject(to2, from2) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from2));
}
function normalizeInject(raw) {
  if (isArray2(raw)) {
    const res = {};
    for (let i3 = 0; i3 < raw.length; i3++) {
      res[raw[i3]] = raw[i3];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to2, from2) {
  return to2 ? [...new Set([].concat(to2, from2))] : from2;
}
function mergeObjectOptions(to2, from2) {
  return to2 ? extend(extend(/* @__PURE__ */ Object.create(null), to2), from2) : from2;
}
function mergeWatchOptions(to2, from2) {
  if (!to2)
    return from2;
  if (!from2)
    return to2;
  const merged = extend(/* @__PURE__ */ Object.create(null), to2);
  for (const key in from2) {
    merged[key] = mergeAsArray(to2[key], from2[key]);
  }
  return merged;
}
function initProps(instance4, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance4.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance4, rawProps, props, attrs);
  for (const key in instance4.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (false) {
    validateProps(rawProps || {}, props, instance4);
  }
  if (isStateful) {
    instance4.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance4.type.props) {
      instance4.props = attrs;
    } else {
      instance4.props = props;
    }
  }
  instance4.attrs = attrs;
}
function updateProps(instance4, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance4;
  const rawCurrentProps = toRaw(props);
  const [options] = instance4.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance4.vnode.dynamicProps;
      for (let i3 = 0; i3 < propsToUpdate.length; i3++) {
        let key = propsToUpdate[i3];
        if (isEmitListener(instance4.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance4, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance4, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance4, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance4, "set", "$attrs");
  }
  if (false) {
    validateProps(rawProps || {}, props, instance4);
  }
}
function setFullProps(instance4, rawProps, props, attrs) {
  const [options, needCastKeys] = instance4.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance4.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i3 = 0; i3 < needCastKeys.length; i3++) {
      const key = needCastKeys[i3];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance4, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance4, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction(defaultValue)) {
        const { propsDefaults } = instance4;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance4);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray2(raw)) {
    for (let i3 = 0; i3 < raw.length; i3++) {
      if (false) {
        warn(`props must be strings when using array syntax.`, raw[i3]);
      }
      const normalizedKey = camelize(raw[i3]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (false) {
      warn(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray2(opt) || isFunction(opt) ? { type: opt } : Object.assign({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else if (false) {
    warn(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  const match3 = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match3 ? match3[1] : ctor === null ? "null" : "";
}
function isSameType(a4, b2) {
  return getType(a4) === getType(b2);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray2(expectedTypes)) {
    return expectedTypes.findIndex((t3) => isSameType(t3, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
var isInternalKey = (key) => key[0] === "_" || key === "$stable";
var normalizeSlotValue = (value) => isArray2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
var normalizeSlot = (key, rawSlot, ctx3) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) {
      warn(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx3);
  normalized._c = false;
  return normalized;
};
var normalizeObjectSlots = (rawSlots, slots, instance4) => {
  const ctx3 = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx3);
    } else if (value != null) {
      if (false) {
        warn(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
var normalizeVNodeSlots = (instance4, children2) => {
  if (false) {
    warn(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
  }
  const normalized = normalizeSlotValue(children2);
  instance4.slots.default = () => normalized;
};
var initSlots = (instance4, children2) => {
  if (instance4.vnode.shapeFlag & 32) {
    const type = children2._;
    if (type) {
      instance4.slots = toRaw(children2);
      def(children2, "_", type);
    } else {
      normalizeObjectSlots(children2, instance4.slots = {});
    }
  } else {
    instance4.slots = {};
    if (children2) {
      normalizeVNodeSlots(instance4, children2);
    }
  }
  def(instance4.slots, InternalObjectKey, 1);
};
var updateSlots = (instance4, children2, optimized) => {
  const { vnode, slots } = instance4;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children2._;
    if (type) {
      if (false) {
        extend(slots, children2);
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children2);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children2.$stable;
      normalizeObjectSlots(children2, slots);
    }
    deletionComparisonTarget = children2;
  } else if (children2) {
    normalizeVNodeSlots(instance4, children2);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
var uid = 0;
function createAppAPI(render14, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted2 = false;
    const app2 = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        if (false) {
          warn(`app.config cannot be replaced. Modify individual options instead.`);
        }
      },
      use(plugin3, ...options) {
        if (installedPlugins.has(plugin3)) {
        } else if (plugin3 && isFunction(plugin3.install)) {
          installedPlugins.add(plugin3);
          plugin3.install(app2, ...options);
        } else if (isFunction(plugin3)) {
          installedPlugins.add(plugin3);
          plugin3(app2, ...options);
        } else if (false) {
          warn(`A plugin must either be a function or an object with an "install" function.`);
        }
        return app2;
      },
      mixin(mixin) {
        if (true) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (false) {
            warn("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
          }
        } else if (false) {
          warn("Mixins are only available in builds supporting Options API");
        }
        return app2;
      },
      component(name2, component) {
        if (false) {
          validateComponentName(name2, context.config);
        }
        if (!component) {
          return context.components[name2];
        }
        if (false) {
          warn(`Component "${name2}" has already been registered in target app.`);
        }
        context.components[name2] = component;
        return app2;
      },
      directive(name2, directive) {
        if (false) {
          validateDirectiveName(name2);
        }
        if (!directive) {
          return context.directives[name2];
        }
        if (false) {
          warn(`Directive "${name2}" has already been registered in target app.`);
        }
        context.directives[name2] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG2) {
        if (!isMounted2) {
          if (false) {
            warn(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
          }
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (false) {
            context.reload = () => {
              render14(cloneVNode(vnode), rootContainer, isSVG2);
            };
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render14(vnode, rootContainer, isSVG2);
          }
          isMounted2 = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          if (false) {
            app2._instance = vnode.component;
            devtoolsInitApp(app2, version);
          }
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else if (false) {
          warn(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
        }
      },
      unmount() {
        if (isMounted2) {
          render14(null, app2._container);
          if (false) {
            app2._instance = null;
            devtoolsUnmountApp(app2);
          }
          delete app2._container.__vue_app__;
        } else if (false) {
          warn(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if (false) {
          warn(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
        }
        context.provides[key] = value;
        return app2;
      }
    };
    return app2;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray2(rawRef)) {
    rawRef.forEach((r, i3) => setRef(r, oldRawRef && (isArray2(oldRawRef) ? oldRawRef[i3] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  if (false) {
    warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray2(existing) && remove(existing, refValue);
          } else {
            if (!isArray2(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else if (false) {
          warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (false) {
      warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
    }
  }
}
function initFeatureFlags() {
  const needWarn = [];
  if (false) {
    getGlobalThis().__VUE_OPTIONS_API__ = true;
  }
  if (false) {
    getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
  }
  if (false) {
    const multi = needWarn.length > 1;
    console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
var queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = getGlobalThis();
  target.__VUE__ = true;
  if (false) {
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n12, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG2 = false, slotScopeIds = null, optimized = false ? false : !!n2.dynamicChildren) => {
    if (n12 === n2) {
      return;
    }
    if (n12 && !isSameVNodeType(n12, n2)) {
      anchor = getNextHostNode(n12);
      unmount2(n12, parentComponent, parentSuspense, true);
      n12 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n12, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n12, n2, container, anchor);
        break;
      case Static:
        if (n12 == null) {
          mountStaticNode(n2, container, anchor, isSVG2);
        } else if (false) {
          patchStaticNode(n12, n2, container, isSVG2);
        }
        break;
      case Fragment:
        processFragment(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, internals);
        } else if (false) {
          warn("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n12 && n12.ref, parentSuspense, n2 || n12, !n2);
    }
  };
  const processText = (n12, n2, container, anchor) => {
    if (n12 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n12.el;
      if (n2.children !== n12.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n12, n2, container, anchor) => {
    if (n12 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n12.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG2) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG2, n2.el, n2.anchor);
  };
  const patchStaticNode = (n12, n2, container, isSVG2) => {
    if (n2.children !== n12.children) {
      const anchor = hostNextSibling(n12.anchor);
      removeStaticNode(n12);
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG2);
    } else {
      n2.el = n12.el;
      n2.anchor = n12.anchor;
    }
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
    isSVG2 = isSVG2 || n2.type === "svg";
    if (n12 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
    } else {
      patchElement(n12, n2, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG2, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG2 && type !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], isSVG2, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (false) {
      Object.defineProperty(el, "__vnode", {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, "__vueParentComponent", {
        value: parentComponent,
        enumerable: false
      });
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i3 = 0; i3 < slotScopeIds.length; i3++) {
        hostSetScopeId(el, slotScopeIds[i3]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (false) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, start = 0) => {
    for (let i3 = start; i3 < children2.length; i3++) {
      const child = children2[i3] = optimized ? cloneIfMounted(children2[i3]) : normalizeVNode(children2[i3]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
    }
  };
  const patchElement = (n12, n2, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
    const el = n2.el = n12.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n12.patchFlag & 16;
    const oldProps = n12.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n12, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (false) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    const areChildrenSVG = isSVG2 && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n12.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
      if (false) {
        traverseStaticChildren(n12, n2);
      }
    } else if (!optimized) {
      patchChildren(n12, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG2);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG2);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG2);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i3 = 0; i3 < propsToUpdate.length; i3++) {
            const key = propsToUpdate[i3];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG2, n12.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n12.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG2);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
        dirs && invokeDirectiveHook(n2, n12, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG2, slotScopeIds) => {
    for (let i3 = 0; i3 < newChildren.length; i3++) {
      const oldVNode = oldChildren[i3];
      const newVNode = newChildren[i3];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG2, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG2) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG2, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG2, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n12 ? n12.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n12 ? n12.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (false) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n12 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n12.dynamicChildren) {
        patchBlockChildren(n12.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG2, slotScopeIds);
        if (false) {
          traverseStaticChildren(n12, n2);
        } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n12, n2, true);
        }
      } else {
        patchChildren(n12, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n12 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG2, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG2, optimized);
      }
    } else {
      updateComponent(n12, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG2, optimized) => {
    const instance4 = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (false) {
      registerHMR(instance4);
    }
    if (false) {
      pushWarningContext(initialVNode);
      startMeasure(instance4, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance4.ctx.renderer = internals;
    }
    {
      if (false) {
        startMeasure(instance4, `init`);
      }
      setupComponent(instance4);
      if (false) {
        endMeasure(instance4, `init`);
      }
    }
    if (instance4.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance4, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance4.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance4, initialVNode, container, anchor, parentSuspense, isSVG2, optimized);
    if (false) {
      popWarningContext();
      endMeasure(instance4, `mount`);
    }
  };
  const updateComponent = (n12, n2, optimized) => {
    const instance4 = n2.component = n12.component;
    if (shouldUpdateComponent(n12, n2, optimized)) {
      if (instance4.asyncDep && !instance4.asyncResolved) {
        if (false) {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance4, n2, optimized);
        if (false) {
          popWarningContext();
        }
        return;
      } else {
        instance4.next = n2;
        invalidateJob(instance4.update);
        instance4.update();
      }
    } else {
      n2.el = n12.el;
      instance4.vnode = n2;
    }
  };
  const setupRenderEffect = (instance4, initialVNode, container, anchor, parentSuspense, isSVG2, optimized) => {
    const componentUpdateFn = () => {
      if (!instance4.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m3, parent } = instance4;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance4, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance4, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (false) {
              startMeasure(instance4, `render`);
            }
            instance4.subTree = renderComponentRoot(instance4);
            if (false) {
              endMeasure(instance4, `render`);
            }
            if (false) {
              startMeasure(instance4, `hydrate`);
            }
            hydrateNode(el, instance4.subTree, instance4, parentSuspense, null);
            if (false) {
              endMeasure(instance4, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(() => !instance4.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          if (false) {
            startMeasure(instance4, `render`);
          }
          const subTree = instance4.subTree = renderComponentRoot(instance4);
          if (false) {
            endMeasure(instance4, `render`);
          }
          if (false) {
            startMeasure(instance4, `patch`);
          }
          patch(null, subTree, container, anchor, instance4, parentSuspense, isSVG2);
          if (false) {
            endMeasure(instance4, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m3) {
          queuePostRenderEffect(m3, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance4.a && queuePostRenderEffect(instance4.a, parentSuspense);
        }
        instance4.isMounted = true;
        if (false) {
          devtoolsComponentAdded(instance4);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance4;
        let originNext = next;
        let vnodeHook;
        if (false) {
          pushWarningContext(next || instance4.vnode);
        }
        toggleRecurse(instance4, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance4, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance4, true);
        if (false) {
          startMeasure(instance4, `render`);
        }
        const nextTree = renderComponentRoot(instance4);
        if (false) {
          endMeasure(instance4, `render`);
        }
        const prevTree = instance4.subTree;
        instance4.subTree = nextTree;
        if (false) {
          startMeasure(instance4, `patch`);
        }
        patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance4, parentSuspense, isSVG2);
        if (false) {
          endMeasure(instance4, `patch`);
        }
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance4, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
        if (false) {
          devtoolsComponentUpdated(instance4);
        }
        if (false) {
          popWarningContext();
        }
      }
    };
    const effect4 = instance4.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update2), instance4.scope);
    const update2 = instance4.update = () => effect4.run();
    update2.id = instance4.uid;
    toggleRecurse(instance4, true);
    if (false) {
      effect4.onTrack = instance4.rtc ? (e3) => invokeArrayFns(instance4.rtc, e3) : void 0;
      effect4.onTrigger = instance4.rtg ? (e3) => invokeArrayFns(instance4.rtg, e3) : void 0;
      update2.ownerInstance = instance4;
    }
    update2();
  };
  const updateComponentPreRender = (instance4, nextVNode, optimized) => {
    nextVNode.component = instance4;
    const prevProps = instance4.vnode.props;
    instance4.vnode = nextVNode;
    instance4.next = null;
    updateProps(instance4, nextVNode.props, prevProps, optimized);
    updateSlots(instance4, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized = false) => {
    const c1 = n12 && n12.children;
    const prevShapeFlag = n12 ? n12.shapeFlag : 0;
    const c22 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c22, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c22, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c22 !== c1) {
        hostSetElementText(container, c22);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c22, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c22, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c22, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c22 = c22 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c22.length;
    const commonLength = Math.min(oldLength, newLength);
    let i3;
    for (i3 = 0; i3 < commonLength; i3++) {
      const nextChild = c22[i3] = optimized ? cloneIfMounted(c22[i3]) : normalizeVNode(c22[i3]);
      patch(c1[i3], nextChild, container, null, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c22, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c22, container, parentAnchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
    let i3 = 0;
    const l2 = c22.length;
    let e1 = c1.length - 1;
    let e22 = l2 - 1;
    while (i3 <= e1 && i3 <= e22) {
      const n12 = c1[i3];
      const n2 = c22[i3] = optimized ? cloneIfMounted(c22[i3]) : normalizeVNode(c22[i3]);
      if (isSameVNodeType(n12, n2)) {
        patch(n12, n2, container, null, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
      } else {
        break;
      }
      i3++;
    }
    while (i3 <= e1 && i3 <= e22) {
      const n12 = c1[e1];
      const n2 = c22[e22] = optimized ? cloneIfMounted(c22[e22]) : normalizeVNode(c22[e22]);
      if (isSameVNodeType(n12, n2)) {
        patch(n12, n2, container, null, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e22--;
    }
    if (i3 > e1) {
      if (i3 <= e22) {
        const nextPos = e22 + 1;
        const anchor = nextPos < l2 ? c22[nextPos].el : parentAnchor;
        while (i3 <= e22) {
          patch(null, c22[i3] = optimized ? cloneIfMounted(c22[i3]) : normalizeVNode(c22[i3]), container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
          i3++;
        }
      }
    } else if (i3 > e22) {
      while (i3 <= e1) {
        unmount2(c1[i3], parentComponent, parentSuspense, true);
        i3++;
      }
    } else {
      const s1 = i3;
      const s22 = i3;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i3 = s22; i3 <= e22; i3++) {
        const nextChild = c22[i3] = optimized ? cloneIfMounted(c22[i3]) : normalizeVNode(c22[i3]);
        if (nextChild.key != null) {
          if (false) {
            warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
          }
          keyToNewIndexMap.set(nextChild.key, i3);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e22 - s22 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i3 = 0; i3 < toBePatched; i3++)
        newIndexToOldIndexMap[i3] = 0;
      for (i3 = s1; i3 <= e1; i3++) {
        const prevChild = c1[i3];
        if (patched >= toBePatched) {
          unmount2(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s22; j <= e22; j++) {
            if (newIndexToOldIndexMap[j - s22] === 0 && isSameVNodeType(prevChild, c22[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount2(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s22] = i3 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c22[newIndex], container, null, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i3 = toBePatched - 1; i3 >= 0; i3--) {
        const nextIndex = s22 + i3;
        const nextChild = c22[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c22[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i3] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i3 !== increasingNewIndexSequence[j]) {
            move2(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move2 = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children: children2, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move2(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i3 = 0; i3 < children2.length; i3++) {
        move2(children2[i3], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount2 = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children: children2, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children2, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if (false) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove2(child);
          }
        });
      } else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance4, parentSuspense, doRemove) => {
    if (false) {
      unregisterHMR(instance4);
    }
    const { bum, scope, update: update2, subTree, um } = instance4;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update2) {
      update2.active = false;
      unmount2(subTree, instance4, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance4.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance4.asyncDep && !instance4.asyncResolved && instance4.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (false) {
      devtoolsComponentRemoved(instance4);
    }
  };
  const unmountChildren = (children2, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i3 = start; i3 < children2.length; i3++) {
      unmount2(children2[i3], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render14 = (vnode, container, isSVG2) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount2(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG2);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount2,
    m: move2,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render14,
    hydrate,
    createApp: createAppAPI(render14, hydrate)
  };
}
function toggleRecurse({ effect: effect4, update: update2 }, allowed) {
  effect4.allowRecurse = update2.allowRecurse = allowed;
}
function traverseStaticChildren(n12, n2, shallow = false) {
  const ch1 = n12.children;
  const ch2 = n2.children;
  if (isArray2(ch1) && isArray2(ch2)) {
    for (let i3 = 0; i3 < ch1.length; i3++) {
      const c1 = ch1[i3];
      let c22 = ch2[i3];
      if (c22.shapeFlag & 1 && !c22.dynamicChildren) {
        if (c22.patchFlag <= 0 || c22.patchFlag === 32) {
          c22 = ch2[i3] = cloneIfMounted(ch2[i3]);
          c22.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c22);
      }
      if (c22.type === Text) {
        c22.el = c1.el;
      }
      if (false) {
        c22.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i3, j, u2, v, c6;
  const len = arr.length;
  for (i3 = 0; i3 < len; i3++) {
    const arrI = arr[i3];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i3] = j;
        result.push(i3);
        continue;
      }
      u2 = 0;
      v = result.length - 1;
      while (u2 < v) {
        c6 = u2 + v >> 1;
        if (arr[result[c6]] < arrI) {
          u2 = c6 + 1;
        } else {
          v = c6;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i3] = result[u2 - 1];
        }
        result[u2] = i3;
      }
    }
  }
  u2 = result.length;
  v = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v;
    v = p2[v];
  }
  return result;
}
var isTeleport = (type) => type.__isTeleport;
var isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
var isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
var resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      if (!target) {
      }
      return target;
    }
  } else {
    if (false) {
      warn(`Invalid Teleport target: ${targetSelector}`);
    }
    return targetSelector;
  }
};
var TeleportImpl = {
  __isTeleport: true,
  process(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert: insert2, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children: children2, dynamicChildren } = n2;
    if (false) {
      optimized = false;
      dynamicChildren = null;
    }
    if (n12 == null) {
      const placeholder = n2.el = false ? createComment("teleport start") : createText("");
      const mainAnchor = n2.anchor = false ? createComment("teleport end") : createText("");
      insert2(placeholder, container, anchor);
      insert2(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert2(targetAnchor, target);
        isSVG2 = isSVG2 || isTargetSVG(target);
      } else if (false) {
        warn("Invalid Teleport target on mount:", target, `(${typeof target})`);
      }
      const mount2 = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children2, container2, anchor2, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount2(container, mainAnchor);
      } else if (target) {
        mount2(target, targetAnchor);
      }
    } else {
      n2.el = n12.el;
      const mainAnchor = n2.anchor = n12.anchor;
      const target = n2.target = n12.target;
      const targetAnchor = n2.targetAnchor = n12.targetAnchor;
      const wasDisabled = isTeleportDisabled(n12.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG2 = isSVG2 || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n12.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG2, slotScopeIds);
        traverseStaticChildren(n12, n2, true);
      } else if (!optimized) {
        patchChildren(n12, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n12.props && n12.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          } else if (false) {
            warn("Invalid Teleport target on update:", target, `(${typeof target})`);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount2, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children: children2, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i3 = 0; i3 < children2.length; i3++) {
          const child = children2[i3];
          unmount2(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert: insert2 }, m: move2 }, moveType = 2) {
  if (moveType === 0) {
    insert2(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children: children2, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert2(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i3 = 0; i3 < children2.length; i3++) {
        move2(children2[i3], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert2(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
var Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx3 = vnode.ctx;
  if (ctx3 && ctx3.ut) {
    let node = vnode.children[0].el;
    while (node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx3.uid);
      node = node.nextSibling;
    }
    ctx3.ut();
  }
}
var Fragment = Symbol(false ? "Fragment" : void 0);
var Text = Symbol(false ? "Text" : void 0);
var Comment = Symbol(false ? "Comment" : void 0);
var Static = Symbol(false ? "Static" : void 0);
var blockStack = [];
var currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
var isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children2, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children2, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children2, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children2, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n12, n2) {
  if (false) {
    n12.shapeFlag &= ~256;
    n2.shapeFlag &= ~512;
    return false;
  }
  return n12.type === n2.type && n12.key === n2.key;
}
var InternalObjectKey = `__vInternal`;
var normalizeKey = ({ key }) => key != null ? key : null;
var normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children: children2,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children2);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children2) {
    vnode.shapeFlag |= isString(children2) ? 8 : 16;
  }
  if (false) {
    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
var createVNode = false ? createVNodeWithArgsTransform : _createVNode;
function _createVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (false) {
      warn(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children2) {
      normalizeChildren(cloned, children2);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style2)) {
      if (isProxy(style2) && !isArray2(style2)) {
        style2 = extend({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  if (false) {
    type = toRaw(type);
    warn(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
  }
  return createBaseVNode(type, props, children2, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children: children2 } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: false ? children2.map(deepCloneVNode) : children2,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx
  };
  return cloned;
}
function createTextVNode(text2 = " ", flag = 0) {
  return createVNode(Text, null, text2, flag);
}
function createCommentVNode(text2 = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text2)) : createVNode(Comment, null, text2);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray2(child)) {
    return createVNode(Fragment, null, child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children2) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children2 == null) {
    children2 = null;
  } else if (isArray2(children2)) {
    type = 16;
  } else if (typeof children2 === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children2.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children2._;
      if (!slotFlag && !(InternalObjectKey in children2)) {
        children2._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children2._ = 1;
        } else {
          children2._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children2)) {
    children2 = { default: children2, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children2 = String(children2);
    if (shapeFlag & 64) {
      type = 16;
      children2 = [createTextVNode(children2)];
    } else {
      type = 8;
    }
  }
  vnode.children = children2;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i3 = 0; i3 < args.length; i3++) {
    const toMerge = args[i3];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance4, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance4, 7, [
    vnode,
    prevVNode
  ]);
}
var emptyAppContext = createAppContext();
var uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance4 = {
    uid: uid$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (false) {
    instance4.ctx = createDevRenderContext(instance4);
  } else {
    instance4.ctx = { _: instance4 };
  }
  instance4.root = parent ? parent.root : instance4;
  instance4.emit = emit$1.bind(null, instance4);
  if (vnode.ce) {
    vnode.ce(instance4);
  }
  return instance4;
}
var currentInstance = null;
var getCurrentInstance = () => currentInstance || currentRenderingInstance;
var setCurrentInstance = (instance4) => {
  currentInstance = instance4;
  instance4.scope.on();
};
var unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance4) {
  return instance4.vnode.shapeFlag & 4;
}
var isInSSRComponentSetup = false;
function setupComponent(instance4, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children: children2 } = instance4.vnode;
  const isStateful = isStatefulComponent(instance4);
  initProps(instance4, props, isStateful, isSSR);
  initSlots(instance4, children2);
  const setupResult = isStateful ? setupStatefulComponent(instance4, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance4, isSSR) {
  var _a3;
  const Component2 = instance4.type;
  if (false) {
    if (Component2.name) {
      validateComponentName(Component2.name, instance4.appContext.config);
    }
    if (Component2.components) {
      const names2 = Object.keys(Component2.components);
      for (let i3 = 0; i3 < names2.length; i3++) {
        validateComponentName(names2[i3], instance4.appContext.config);
      }
    }
    if (Component2.directives) {
      const names2 = Object.keys(Component2.directives);
      for (let i3 = 0; i3 < names2.length; i3++) {
        validateDirectiveName(names2[i3]);
      }
    }
    if (Component2.compilerOptions && isRuntimeOnly()) {
      warn(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    }
  }
  instance4.accessCache = /* @__PURE__ */ Object.create(null);
  instance4.proxy = markRaw(new Proxy(instance4.ctx, PublicInstanceProxyHandlers));
  if (false) {
    exposePropsOnRenderContext(instance4);
  }
  const { setup } = Component2;
  if (setup) {
    const setupContext = instance4.setupContext = setup.length > 1 ? createSetupContext(instance4) : null;
    setCurrentInstance(instance4);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance4, 0, [false ? shallowReadonly(instance4.props) : instance4.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance4, resolvedResult, isSSR);
        }).catch((e3) => {
          handleError(e3, instance4, 0);
        });
      } else {
        instance4.asyncDep = setupResult;
        if (false) {
          const name2 = (_a3 = Component2.name) !== null && _a3 !== void 0 ? _a3 : "Anonymous";
          warn(`Component <${name2}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
        }
      }
    } else {
      handleSetupResult(instance4, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance4, isSSR);
  }
}
function handleSetupResult(instance4, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance4.type.__ssrInlineRender) {
      instance4.ssrRender = setupResult;
    } else {
      instance4.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    if (false) {
      warn(`setup() should not return VNodes directly - return a render function instead.`);
    }
    if (false) {
      instance4.devtoolsRawSetupState = setupResult;
    }
    instance4.setupState = proxyRefs(setupResult);
    if (false) {
      exposeSetupStateOnRenderContext(instance4);
    }
  } else if (false) {
    warn(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
  }
  finishComponentSetup(instance4, isSSR);
}
var compile;
var installWithProxy;
function finishComponentSetup(instance4, isSSR, skipOptions) {
  const Component2 = instance4.type;
  if (!instance4.render) {
    if (!isSSR && compile && !Component2.render) {
      const template = Component2.template || resolveMergedOptions(instance4).template;
      if (template) {
        if (false) {
          startMeasure(instance4, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance4.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component2;
        const finalCompilerOptions = extend(extend({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component2.render = compile(template, finalCompilerOptions);
        if (false) {
          endMeasure(instance4, `compile`);
        }
      }
    }
    instance4.render = Component2.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance4);
    }
  }
  if (true) {
    setCurrentInstance(instance4);
    pauseTracking();
    applyOptions(instance4);
    resetTracking();
    unsetCurrentInstance();
  }
  if (false) {
    if (!compile && Component2.template) {
      warn(`Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
    } else {
      warn(`Component is missing template or render function.`);
    }
  }
}
function createAttrsProxy(instance4) {
  return new Proxy(instance4.attrs, false ? {
    get(target, key) {
      markAttrsAccessed();
      track(instance4, "get", "$attrs");
      return target[key];
    },
    set() {
      warn(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn(`setupContext.attrs is readonly.`);
      return false;
    }
  } : {
    get(target, key) {
      track(instance4, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance4) {
  const expose = (exposed) => {
    if (false) {
      warn(`expose() should be called only once per setup().`);
    }
    instance4.exposed = exposed || {};
  };
  let attrs;
  if (false) {
    return Object.freeze({
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance4));
      },
      get slots() {
        return shallowReadonly(instance4.slots);
      },
      get emit() {
        return (event, ...args) => instance4.emit(event, ...args);
      },
      expose
    });
  } else {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance4));
      },
      slots: instance4.slots,
      emit: instance4.emit,
      expose
    };
  }
}
function getExposeProxy(instance4) {
  if (instance4.exposed) {
    return instance4.exposeProxy || (instance4.exposeProxy = new Proxy(proxyRefs(markRaw(instance4.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance4);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
var classifyRE = /(?:^|[-_])(\w)/g;
var classify = (str) => str.replace(classifyRE, (c6) => c6.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component2, includeInferred = true) {
  return isFunction(Component2) ? Component2.displayName || Component2.name : Component2.name || includeInferred && Component2.__name;
}
function formatComponentName(instance4, Component2, isRoot = false) {
  let name2 = getComponentName(Component2);
  if (!name2 && Component2.__file) {
    const match3 = Component2.__file.match(/([^/\\]+)\.\w+$/);
    if (match3) {
      name2 = match3[1];
    }
  }
  if (!name2 && instance4 && instance4.parent) {
    const inferFromRegistry = (registry2) => {
      for (const key in registry2) {
        if (registry2[key] === Component2) {
          return key;
        }
      }
    };
    name2 = inferFromRegistry(instance4.components || instance4.parent.type.components) || inferFromRegistry(instance4.appContext.components);
  }
  return name2 ? classify(name2) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
var computed2 = (getterOrOptions, debugOptions) => {
  return computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h3(type, propsOrChildren, children2) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject(propsOrChildren) && !isArray2(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children2 = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children2)) {
      children2 = [children2];
    }
    return createVNode(type, propsOrChildren, children2);
  }
}
var ssrContextKey = Symbol(false ? `ssrContext` : ``);
var useSSRContext = () => {
  {
    const ctx3 = inject(ssrContextKey);
    if (!ctx3) {
    }
    return ctx3;
  }
};
var version = "3.2.45";

// node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
var svgNS = "http://www.w3.org/2000/svg";
var doc = typeof document !== "undefined" ? document : null;
var templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
var nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG2, is, props) => {
    const el = isSVG2 ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text2) => doc.createTextNode(text2),
  createComment: (text2) => doc.createComment(text2),
  setText: (node, text2) => {
    node.nodeValue = text2;
  },
  setElementText: (el, text2) => {
    el.textContent = text2;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  insertStaticContent(content, parent, anchor, isSVG2, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG2 ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG2) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG2) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG2) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style2.display = currentDisplay;
    }
  }
}
var importantRE = /\s*!important$/;
function setStyle(style2, name2, val) {
  if (isArray2(val)) {
    val.forEach((v) => setStyle(style2, name2, v));
  } else {
    if (val == null)
      val = "";
    if (false) {
      if (semicolonRE.test(val)) {
        warn(`Unexpected semicolon at the end of '${name2}' style value: '${val}'`);
      }
    }
    if (name2.startsWith("--")) {
      style2.setProperty(name2, val);
    } else {
      const prefixed = autoPrefix(style2, name2);
      if (importantRE.test(val)) {
        style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
var prefixes = ["Webkit", "Moz", "ms"];
var prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name2 = camelize(rawName);
  if (name2 !== "filter" && name2 in style2) {
    return prefixCache[rawName] = name2;
  }
  name2 = capitalize(name2);
  for (let i3 = 0; i3 < prefixes.length; i3++) {
    const prefixed = prefixes[i3] + name2;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
var xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG2, instance4) {
  if (isSVG2 && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e3) {
    if (false) {
      warn(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: value ${value} is invalid.`, e3);
    }
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener2(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance4 = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name2, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance4);
      addEventListener2(el, name2, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name2, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
var optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name2) {
  let options;
  if (optionsModifierRE.test(name2)) {
    options = {};
    let m3;
    while (m3 = name2.match(optionsModifierRE)) {
      name2 = name2.slice(0, name2.length - m3[0].length);
      options[m3[0].toLowerCase()] = true;
    }
  }
  const event = name2[2] === ":" ? name2.slice(3) : hyphenate(name2.slice(2));
  return [event, options];
}
var cachedNow = 0;
var p = /* @__PURE__ */ Promise.resolve();
var getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance4) {
  const invoker = (e3) => {
    if (!e3._vts) {
      e3._vts = Date.now();
    } else if (e3._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(patchStopImmediatePropagation(e3, invoker.value), instance4, 5, [e3]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e3, value) {
  if (isArray2(value)) {
    const originalStop = e3.stopImmediatePropagation;
    e3.stopImmediatePropagation = () => {
      originalStop.call(e3);
      e3._stopped = true;
    };
    return value.map((fn) => (e4) => !e4._stopped && fn && fn(e4));
  } else {
    return value;
  }
}
var nativeOnRE = /^on[a-z]/;
var patchProp = (el, key, prevValue, nextValue, isSVG2 = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG2);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG2)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG2);
  }
};
function shouldSetAsProp(el, key, value, isSVG2) {
  if (isSVG2) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
var TRANSITION = "transition";
var ANIMATION = "animation";
var Transition = (props, { slots }) => h3(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
var DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
var TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend({}, BaseTransition.props, DOMTransitionPropsValidators);
var callHook2 = (hook, args = []) => {
  if (isArray2(hook)) {
    hook.forEach((h6) => h6(...args));
  } else if (hook) {
    hook(...args);
  }
};
var hasExplicitCallback = (hook) => {
  return hook ? isArray2(hook) ? hook.some((h6) => h6.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name: name2 = "v", type, duration, enterFromClass = `${name2}-enter-from`, enterActiveClass = `${name2}-enter-active`, enterToClass = `${name2}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name2}-leave-from`, leaveActiveClass = `${name2}-leave-active`, leaveToClass = `${name2}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook2(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook2(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook2(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook2(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook2(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook2(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook2(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n2 = NumberOf(duration);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  if (false)
    validateDuration(res);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c6) => c6 && el.classList.add(c6));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c6) => c6 && el.classList.remove(c6));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
var endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e3) => {
    if (e3.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d4, i3) => toMs(d4) + toMs(delays[i3])));
}
function toMs(s4) {
  return Number(s4.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
var positionMap = /* @__PURE__ */ new WeakMap();
var newPositionMap = /* @__PURE__ */ new WeakMap();
var TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance4 = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children2;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance4.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c6) => {
        const el = c6.el;
        const style2 = el.style;
        addTransitionClass(el, moveClass);
        style2.transform = style2.webkitTransform = style2.transitionDuration = "";
        const cb = el._moveCb = (e3) => {
          if (e3 && e3.target !== el) {
            return;
          }
          if (!e3 || /transform$/.test(e3.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children2;
      children2 = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i3 = 0; i3 < children2.length; i3++) {
        const child = children2[i3];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance4));
        } else if (false) {
          warn(`<TransitionGroup> children must be keyed.`);
        }
      }
      if (prevChildren) {
        for (let i3 = 0; i3 < prevChildren.length; i3++) {
          const child = prevChildren[i3];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance4));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children2);
    };
  }
};
var TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c6) {
  const el = c6.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c6) {
  newPositionMap.set(c6, c6.el.getBoundingClientRect());
}
function applyTranslation(c6) {
  const oldPos = positionMap.get(c6);
  const newPos = newPositionMap.get(c6);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s4 = c6.el.style;
    s4.transform = s4.webkitTransform = `translate(${dx}px,${dy}px)`;
    s4.transitionDuration = "0s";
    return c6;
  }
}
function hasCSSTransform(el, root2, moveClass) {
  const clone3 = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c6) => c6 && clone3.classList.remove(c6));
    });
  }
  moveClass.split(/\s+/).forEach((c6) => c6 && clone3.classList.add(c6));
  clone3.style.display = "none";
  const container = root2.nodeType === 1 ? root2 : root2.parentNode;
  container.appendChild(clone3);
  const { hasTransform } = getTransitionInfo(clone3);
  container.removeChild(clone3);
  return hasTransform;
}
var vShow = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
var rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
var renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
var createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  if (false) {
    injectNativeTagCheck(app2);
    injectCompilerOptionsCheck(app2);
  }
  const { mount: mount2 } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount2(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    if (false) {
      warn(`Failed to mount app: mount target selector "${container}" returned null.`);
    }
    return res;
  }
  if (false) {
    warn(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
  }
  return container;
}

// node_modules/vue/dist/vue.runtime.esm-bundler.js
if (false) {
  initDev();
}

// node_modules/seemly/es/animation/next-frame-once.js
var onceCbs = [];
var paramsMap = /* @__PURE__ */ new WeakMap();
function flushOnceCallbacks() {
  onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));
  onceCbs = [];
}
function beforeNextFrameOnce(cb, ...params) {
  paramsMap.set(cb, params);
  if (onceCbs.includes(cb))
    return;
  onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
}

// node_modules/seemly/es/dom/happens-in.js
function happensIn(e3, dataSetPropName) {
  let { target } = e3;
  while (target) {
    if (target.dataset) {
      if (target.dataset[dataSetPropName] !== void 0)
        return true;
    }
    target = target.parentElement;
  }
  return false;
}

// node_modules/seemly/es/dom/get-precise-event-target.js
function getPreciseEventTarget(event) {
  return event.composedPath()[0] || null;
}

// node_modules/seemly/es/css/responsive.js
function parseResponsiveProp(reponsiveProp) {
  if (typeof reponsiveProp === "number") {
    return {
      "": reponsiveProp.toString()
    };
  }
  const params = {};
  reponsiveProp.split(/ +/).forEach((pairLiteral) => {
    if (pairLiteral === "")
      return;
    const [prefix3, value] = pairLiteral.split(":");
    if (value === void 0) {
      params[""] = prefix3;
    } else {
      params[prefix3] = value;
    }
  });
  return params;
}
function parseResponsivePropValue(reponsiveProp, activeKeyOrSize) {
  var _a3;
  if (reponsiveProp === void 0 || reponsiveProp === null)
    return void 0;
  const classObj = parseResponsiveProp(reponsiveProp);
  if (activeKeyOrSize === void 0)
    return classObj[""];
  if (typeof activeKeyOrSize === "string") {
    return (_a3 = classObj[activeKeyOrSize]) !== null && _a3 !== void 0 ? _a3 : classObj[""];
  } else if (Array.isArray(activeKeyOrSize)) {
    for (let i3 = activeKeyOrSize.length - 1; i3 >= 0; --i3) {
      const key = activeKeyOrSize[i3];
      if (key in classObj)
        return classObj[key];
    }
    return classObj[""];
  } else {
    let activeValue = void 0;
    let activeKey = -1;
    Object.keys(classObj).forEach((key) => {
      const keyAsNum = Number(key);
      if (!Number.isNaN(keyAsNum) && activeKeyOrSize >= keyAsNum && keyAsNum >= activeKey) {
        activeKey = keyAsNum;
        activeValue = classObj[key];
      }
    });
    return activeValue;
  }
}

// node_modules/seemly/es/css/index.js
function depx(value) {
  if (typeof value === "string") {
    if (value.endsWith("px")) {
      return Number(value.slice(0, value.length - 2));
    }
    return Number(value);
  }
  return value;
}
function pxfy(value) {
  if (value === void 0 || value === null)
    return void 0;
  if (typeof value === "number")
    return `${value}px`;
  if (value.endsWith("px"))
    return value;
  return `${value}px`;
}
function getMargin(value, position) {
  const parts = value.trim().split(/\s+/g);
  const margin = {
    top: parts[0]
  };
  switch (parts.length) {
    case 1:
      margin.right = parts[0];
      margin.bottom = parts[0];
      margin.left = parts[0];
      break;
    case 2:
      margin.right = parts[1];
      margin.left = parts[1];
      margin.bottom = parts[0];
      break;
    case 3:
      margin.right = parts[1];
      margin.bottom = parts[2];
      margin.left = parts[1];
      break;
    case 4:
      margin.right = parts[1];
      margin.bottom = parts[2];
      margin.left = parts[3];
      break;
    default:
      throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
  }
  if (position === void 0)
    return margin;
  return margin[position];
}
function getGap(value, orient) {
  const [rowGap, colGap] = value.split(" ");
  if (!orient)
    return {
      row: rowGap,
      col: colGap || rowGap
    };
  return orient === "row" ? rowGap : colGap;
}

// node_modules/seemly/es/color/colors.js
var colors_default = {
  black: "#000",
  silver: "#C0C0C0",
  gray: "#808080",
  white: "#FFF",
  maroon: "#800000",
  red: "#F00",
  purple: "#800080",
  fuchsia: "#F0F",
  green: "#008000",
  lime: "#0F0",
  olive: "#808000",
  yellow: "#FF0",
  navy: "#000080",
  blue: "#00F",
  teal: "#008080",
  aqua: "#0FF",
  transparent: "#0000"
};

// node_modules/seemly/es/color/index.js
var prefix = "^\\s*";
var suffix = "\\s*$";
var percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
var float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
var hex = "([0-9A-Fa-f])";
var dhex = "([0-9A-Fa-f]{2})";
var hslRegex = new RegExp(`${prefix}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
var hsvRegex = new RegExp(`${prefix}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
var hslaRegex = new RegExp(`${prefix}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
var hsvaRegex = new RegExp(`${prefix}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
var rgbRegex = new RegExp(`${prefix}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
var rgbaRegex = new RegExp(`${prefix}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
var sHexRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${suffix}`);
var hexRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${suffix}`);
var sHexaRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${hex}${suffix}`);
var hexaRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
function parseHex(value) {
  return parseInt(value, 16);
}
function rgba(color2) {
  try {
    let i3;
    if (i3 = hexRegex.exec(color2)) {
      return [parseHex(i3[1]), parseHex(i3[2]), parseHex(i3[3]), 1];
    } else if (i3 = rgbRegex.exec(color2)) {
      return [roundChannel(i3[1]), roundChannel(i3[5]), roundChannel(i3[9]), 1];
    } else if (i3 = rgbaRegex.exec(color2)) {
      return [
        roundChannel(i3[1]),
        roundChannel(i3[5]),
        roundChannel(i3[9]),
        roundAlpha(i3[13])
      ];
    } else if (i3 = sHexRegex.exec(color2)) {
      return [
        parseHex(i3[1] + i3[1]),
        parseHex(i3[2] + i3[2]),
        parseHex(i3[3] + i3[3]),
        1
      ];
    } else if (i3 = hexaRegex.exec(color2)) {
      return [
        parseHex(i3[1]),
        parseHex(i3[2]),
        parseHex(i3[3]),
        roundAlpha(parseHex(i3[4]) / 255)
      ];
    } else if (i3 = sHexaRegex.exec(color2)) {
      return [
        parseHex(i3[1] + i3[1]),
        parseHex(i3[2] + i3[2]),
        parseHex(i3[3] + i3[3]),
        roundAlpha(parseHex(i3[4] + i3[4]) / 255)
      ];
    } else if (color2 in colors_default) {
      return rgba(colors_default[color2]);
    }
    throw new Error(`[seemly/rgba]: Invalid color value ${color2}.`);
  } catch (e3) {
    throw e3;
  }
}
function normalizeAlpha(alphaValue) {
  return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
}
function stringifyRgba(r, g, b2, a4) {
  return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b2)}, ${normalizeAlpha(a4)})`;
}
function compositeChannel(v1, a1, v2, a22, a4) {
  return roundChannel((v1 * a1 * (1 - a22) + v2 * a22) / a4);
}
function composite(background, overlay3) {
  if (!Array.isArray(background))
    background = rgba(background);
  if (!Array.isArray(overlay3))
    overlay3 = rgba(overlay3);
  const a1 = background[3];
  const a22 = overlay3[3];
  const alpha2 = roundAlpha(a1 + a22 - a1 * a22);
  return stringifyRgba(compositeChannel(background[0], a1, overlay3[0], a22, alpha2), compositeChannel(background[1], a1, overlay3[1], a22, alpha2), compositeChannel(background[2], a1, overlay3[2], a22, alpha2), alpha2);
}
function changeColor(base3, options) {
  const [r, g, b2, a4 = 1] = Array.isArray(base3) ? base3 : rgba(base3);
  if (options.alpha) {
    return stringifyRgba(r, g, b2, options.alpha);
  }
  return stringifyRgba(r, g, b2, a4);
}
function scaleColor(base3, options) {
  const [r, g, b2, a4 = 1] = Array.isArray(base3) ? base3 : rgba(base3);
  const { lightness = 1, alpha: alpha2 = 1 } = options;
  return toRgbaString([r * lightness, g * lightness, b2 * lightness, a4 * alpha2]);
}
function roundAlpha(value) {
  const v = Math.round(Number(value) * 100) / 100;
  if (v > 1)
    return 1;
  if (v < 0)
    return 0;
  return v;
}
function roundChannel(value) {
  const v = Math.round(Number(value));
  if (v > 255)
    return 255;
  if (v < 0)
    return 0;
  return v;
}
function toRgbaString(base3) {
  const [r, g, b2] = base3;
  if (3 in base3) {
    return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b2)}, ${roundAlpha(base3[3])})`;
  }
  return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b2)}, 1)`;
}

// node_modules/seemly/es/misc/index.js
function createId(length = 8) {
  return Math.random().toString(16).slice(2, 2 + length);
}

// node_modules/naive-ui/es/_utils/vue/get-slot.js
function getSlot(instance4, slotName = "default", fallback = []) {
  const slots = instance4.$slots;
  const slot = slots[slotName];
  if (slot === void 0)
    return fallback;
  return slot();
}

// node_modules/naive-ui/es/_utils/vue/keep.js
function keep(object, keys2 = [], rest) {
  const keepedObject = {};
  keys2.forEach((key) => {
    keepedObject[key] = object[key];
  });
  return Object.assign(keepedObject, rest);
}

// node_modules/naive-ui/es/_utils/vue/omit.js
function omit(object, keys2 = [], rest) {
  const omitedObject = {};
  const originalKeys = Object.getOwnPropertyNames(object);
  originalKeys.forEach((originalKey) => {
    if (!keys2.includes(originalKey)) {
      omitedObject[originalKey] = object[originalKey];
    }
  });
  return Object.assign(omitedObject, rest);
}

// node_modules/naive-ui/es/_utils/vue/flatten.js
function flatten(vNodes, filterCommentNode = true, result = []) {
  vNodes.forEach((vNode) => {
    if (vNode === null)
      return;
    if (typeof vNode !== "object") {
      if (typeof vNode === "string" || typeof vNode === "number") {
        result.push(createTextVNode(String(vNode)));
      }
      return;
    }
    if (Array.isArray(vNode)) {
      flatten(vNode, filterCommentNode, result);
      return;
    }
    if (vNode.type === Fragment) {
      if (vNode.children === null)
        return;
      if (Array.isArray(vNode.children)) {
        flatten(vNode.children, filterCommentNode, result);
      }
    } else if (vNode.type !== Comment) {
      result.push(vNode);
    }
  });
  return result;
}

// node_modules/naive-ui/es/_utils/vue/call.js
function call(funcs, ...args) {
  if (Array.isArray(funcs)) {
    funcs.forEach((func) => call(func, ...args));
  } else
    return funcs(...args);
}

// node_modules/naive-ui/es/_utils/vue/keysOf.js
function keysOf(obj) {
  return Object.keys(obj);
}

// node_modules/naive-ui/es/_utils/vue/render.js
var render = (r, ...args) => {
  if (typeof r === "function") {
    return r(...args);
  } else if (typeof r === "string") {
    return createTextVNode(r);
  } else if (typeof r === "number") {
    return createTextVNode(String(r));
  } else {
    return null;
  }
};

// node_modules/naive-ui/es/_utils/naive/warn.js
function warn2(location, message) {
  console.error(`[naive/${location}]: ${message}`);
}
function throwError(location, message) {
  throw new Error(`[naive/${location}]: ${message}`);
}

// node_modules/naive-ui/es/_utils/vue/get-first-slot-vnode.js
function getFirstSlotVNode(slots, slotName = "default", props = void 0) {
  const slot = slots[slotName];
  if (!slot) {
    warn2("getFirstSlotVNode", `slot[${slotName}] is empty`);
    return null;
  }
  const slotContent = flatten(slot(props));
  if (slotContent.length === 1) {
    return slotContent[0];
  } else {
    warn2("getFirstSlotVNode", `slot[${slotName}] should have exactly one child`);
    return null;
  }
}

// node_modules/naive-ui/es/_utils/vue/create-ref-setter.js
function createRefSetter(ref2) {
  return (inst) => {
    if (inst) {
      ref2.value = inst.$el;
    } else {
      ref2.value = null;
    }
  };
}

// node_modules/naive-ui/es/_utils/vue/create-injection-key.js
function createInjectionKey(key) {
  return key;
}

// node_modules/naive-ui/es/_utils/vue/resolve-slot.js
function ensureValidVNode2(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) {
      return true;
    }
    if (child.type === Comment) {
      return false;
    }
    if (child.type === Fragment && !ensureValidVNode2(child.children)) {
      return false;
    }
    return true;
  }) ? vnodes : null;
}
function resolveSlot(slot, fallback) {
  return slot && ensureValidVNode2(slot()) || fallback();
}
function resolveSlotWithProps(slot, props, fallback) {
  return slot && ensureValidVNode2(slot(props)) || fallback(props);
}
function resolveWrappedSlot(slot, wrapper) {
  const children2 = slot && ensureValidVNode2(slot());
  return wrapper(children2 || null);
}
function isSlotEmpty(slot) {
  return !(slot && ensureValidVNode2(slot()));
}

// node_modules/naive-ui/es/_utils/vue/is-node-v-show-false.js
function isNodeVShowFalse(vNode) {
  var _a3;
  const showDir = (_a3 = vNode.dirs) === null || _a3 === void 0 ? void 0 : _a3.find(({ dir }) => dir === vShow);
  return !!(showDir && showDir.value === false);
}

// node_modules/naive-ui/es/_utils/vue/wrapper.js
var Wrapper = defineComponent({
  render() {
    var _a3, _b2;
    return (_b2 = (_a3 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a3);
  }
});

// node_modules/naive-ui/es/_utils/css/format-length.js
var pureNumberRegex = /^(\d|\.)+$/;
var numberRegex = /(\d|\.)+/;
function formatLength(length, { c: c6 = 1, offset = 0, attachPx = true } = {}) {
  if (typeof length === "number") {
    const result = (length + offset) * c6;
    if (result === 0)
      return "0";
    return `${result}px`;
  } else if (typeof length === "string") {
    if (pureNumberRegex.test(length)) {
      const result = (Number(length) + offset) * c6;
      if (attachPx) {
        if (result === 0)
          return "0";
        return `${result}px`;
      } else {
        return `${result}`;
      }
    } else {
      const result = numberRegex.exec(length);
      if (!result)
        return length;
      return length.replace(numberRegex, String((Number(result[0]) + offset) * c6));
    }
  }
  return length;
}

// node_modules/naive-ui/es/_utils/css/color-to-class.js
function color2Class(color2) {
  return color2.replace(/#|\(|\)|,|\s/g, "_");
}

// node_modules/css-render/esm/parse.js
function ampCount(selector) {
  let cnt = 0;
  for (let i3 = 0; i3 < selector.length; ++i3) {
    if (selector[i3] === "&")
      ++cnt;
  }
  return cnt;
}
var separatorRegex = /\s*,(?![^(]*\))\s*/g;
var extraSpaceRegex = /\s+/g;
function resolveSelectorWithAmp(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    let round2 = ampCount(partialSelector);
    if (!round2) {
      amp.forEach((partialAmp) => {
        nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
      });
      return;
    } else if (round2 === 1) {
      amp.forEach((partialAmp) => {
        nextAmp.push(partialSelector.replace("&", partialAmp));
      });
      return;
    }
    let partialNextAmp = [
      partialSelector
    ];
    while (round2--) {
      const nextPartialNextAmp = [];
      partialNextAmp.forEach((selectorItr) => {
        amp.forEach((partialAmp) => {
          nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
        });
      });
      partialNextAmp = nextPartialNextAmp;
    }
    partialNextAmp.forEach((part) => nextAmp.push(part));
  });
  return nextAmp;
}
function resolveSelector(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    amp.forEach((partialAmp) => {
      nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
    });
  });
  return nextAmp;
}
function parseSelectorPath(selectorPaths) {
  let amp = [""];
  selectorPaths.forEach((selector) => {
    selector = selector && selector.trim();
    if (!selector) {
      return;
    }
    if (selector.includes("&")) {
      amp = resolveSelectorWithAmp(amp, selector);
    } else {
      amp = resolveSelector(amp, selector);
    }
  });
  return amp.join(", ").replace(extraSpaceRegex, " ");
}

// node_modules/css-render/esm/utils.js
function removeElement(el) {
  if (!el)
    return;
  const parentElement = el.parentElement;
  if (parentElement)
    parentElement.removeChild(el);
}
function queryElement(id) {
  return document.querySelector(`style[cssr-id="${id}"]`);
}
function createElement(id) {
  const el = document.createElement("style");
  el.setAttribute("cssr-id", id);
  return el;
}
function isMediaOrSupports(selector) {
  if (!selector)
    return false;
  return /^\s*@(s|m)/.test(selector);
}

// node_modules/css-render/esm/render.js
var kebabRegex = /[A-Z]/g;
function kebabCase(pattern) {
  return pattern.replace(kebabRegex, (match3) => "-" + match3.toLowerCase());
}
function unwrapProperty(prop, indent = "  ") {
  if (typeof prop === "object" && prop !== null) {
    return " {\n" + Object.entries(prop).map((v) => {
      return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
    }).join("\n") + "\n" + indent + "}";
  }
  return `: ${prop};`;
}
function unwrapProperties(props, instance4, params) {
  if (typeof props === "function") {
    return props({
      context: instance4.context,
      props: params
    });
  }
  return props;
}
function createStyle(selector, props, instance4, params) {
  if (!props)
    return "";
  const unwrappedProps = unwrapProperties(props, instance4, params);
  if (!unwrappedProps)
    return "";
  if (typeof unwrappedProps === "string") {
    return `${selector} {
${unwrappedProps}
}`;
  }
  const propertyNames = Object.keys(unwrappedProps);
  if (propertyNames.length === 0) {
    if (instance4.config.keepEmptyBlock)
      return selector + " {\n}";
    return "";
  }
  const statements = selector ? [
    selector + " {"
  ] : [];
  propertyNames.forEach((propertyName) => {
    const property2 = unwrappedProps[propertyName];
    if (propertyName === "raw") {
      statements.push("\n" + property2 + "\n");
      return;
    }
    propertyName = kebabCase(propertyName);
    if (property2 !== null && property2 !== void 0) {
      statements.push(`  ${propertyName}${unwrapProperty(property2)}`);
    }
  });
  if (selector) {
    statements.push("}");
  }
  return statements.join("\n");
}
function loopCNodeListWithCallback(children2, options, callback2) {
  if (!children2)
    return;
  children2.forEach((child) => {
    if (Array.isArray(child)) {
      loopCNodeListWithCallback(child, options, callback2);
    } else if (typeof child === "function") {
      const grandChildren = child(options);
      if (Array.isArray(grandChildren)) {
        loopCNodeListWithCallback(grandChildren, options, callback2);
      } else if (grandChildren) {
        callback2(grandChildren);
      }
    } else if (child) {
      callback2(child);
    }
  });
}
function traverseCNode(node, selectorPaths, styles, instance4, params, styleSheet) {
  const $ = node.$;
  let blockSelector = "";
  if (!$ || typeof $ === "string") {
    if (isMediaOrSupports($)) {
      blockSelector = $;
    } else {
      selectorPaths.push($);
    }
  } else if (typeof $ === "function") {
    const selector2 = $({
      context: instance4.context,
      props: params
    });
    if (isMediaOrSupports(selector2)) {
      blockSelector = selector2;
    } else {
      selectorPaths.push(selector2);
    }
  } else {
    if ($.before)
      $.before(instance4.context);
    if (!$.$ || typeof $.$ === "string") {
      if (isMediaOrSupports($.$)) {
        blockSelector = $.$;
      } else {
        selectorPaths.push($.$);
      }
    } else if ($.$) {
      const selector2 = $.$({
        context: instance4.context,
        props: params
      });
      if (isMediaOrSupports(selector2)) {
        blockSelector = selector2;
      } else {
        selectorPaths.push(selector2);
      }
    }
  }
  const selector = parseSelectorPath(selectorPaths);
  const style2 = createStyle(selector, node.props, instance4, params);
  if (blockSelector) {
    styles.push(`${blockSelector} {`);
    if (styleSheet && style2) {
      styleSheet.insertRule(`${blockSelector} {
${style2}
}
`);
    }
  } else {
    if (styleSheet && style2) {
      styleSheet.insertRule(style2);
    }
    if (!styleSheet && style2.length)
      styles.push(style2);
  }
  if (node.children) {
    loopCNodeListWithCallback(node.children, {
      context: instance4.context,
      props: params
    }, (childNode) => {
      if (typeof childNode === "string") {
        const style3 = createStyle(selector, { raw: childNode }, instance4, params);
        if (styleSheet) {
          styleSheet.insertRule(style3);
        } else {
          styles.push(style3);
        }
      } else {
        traverseCNode(childNode, selectorPaths, styles, instance4, params, styleSheet);
      }
    });
  }
  selectorPaths.pop();
  if (blockSelector) {
    styles.push("}");
  }
  if ($ && $.after)
    $.after(instance4.context);
}
function render2(node, instance4, props, insertRule = false) {
  const styles = [];
  traverseCNode(node, [], styles, instance4, props, insertRule ? node.instance.__styleSheet : void 0);
  if (insertRule)
    return "";
  return styles.join("\n\n");
}

// node_modules/@emotion/hash/dist/hash.browser.esm.js
function murmur2(str) {
  var h6 = 0;
  var k2, i3 = 0, len = str.length;
  for (; len >= 4; ++i3, len -= 4) {
    k2 = str.charCodeAt(i3) & 255 | (str.charCodeAt(++i3) & 255) << 8 | (str.charCodeAt(++i3) & 255) << 16 | (str.charCodeAt(++i3) & 255) << 24;
    k2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= k2 >>> 24;
    h6 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ (h6 & 65535) * 1540483477 + ((h6 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h6 ^= (str.charCodeAt(i3 + 2) & 255) << 16;
    case 2:
      h6 ^= (str.charCodeAt(i3 + 1) & 255) << 8;
    case 1:
      h6 ^= str.charCodeAt(i3) & 255;
      h6 = (h6 & 65535) * 1540483477 + ((h6 >>> 16) * 59797 << 16);
  }
  h6 ^= h6 >>> 13;
  h6 = (h6 & 65535) * 1540483477 + ((h6 >>> 16) * 59797 << 16);
  return ((h6 ^ h6 >>> 15) >>> 0).toString(36);
}
var hash_browser_esm_default = murmur2;

// node_modules/css-render/esm/mount.js
if (typeof window !== "undefined") {
  window.__cssrContext = {};
}
function unmount(intance, node, id) {
  const { els } = node;
  if (id === void 0) {
    els.forEach(removeElement);
    node.els = [];
  } else {
    const target = queryElement(id);
    if (target && els.includes(target)) {
      removeElement(target);
      node.els = els.filter((el) => el !== target);
    }
  }
}
function addElementToList(els, target) {
  els.push(target);
}
function mount(instance4, node, id, props, head, silent, force, anchorMetaName, ssrAdapter2) {
  if (silent && !ssrAdapter2) {
    if (id === void 0) {
      console.error("[css-render/mount]: `id` is required in `silent` mode.");
      return;
    }
    const cssrContext = window.__cssrContext;
    if (!cssrContext[id]) {
      cssrContext[id] = true;
      render2(node, instance4, props, silent);
    }
    return;
  }
  let style2;
  if (id === void 0) {
    style2 = node.render(props);
    id = hash_browser_esm_default(style2);
  }
  if (ssrAdapter2) {
    ssrAdapter2.adapter(id, style2 !== null && style2 !== void 0 ? style2 : node.render(props));
    return;
  }
  const queriedTarget = queryElement(id);
  if (queriedTarget !== null && !force) {
    return queriedTarget;
  }
  const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
  if (style2 === void 0)
    style2 = node.render(props);
  target.textContent = style2;
  if (queriedTarget !== null)
    return queriedTarget;
  if (anchorMetaName) {
    const anchorMetaEl = document.head.querySelector(`meta[name="${anchorMetaName}"]`);
    if (anchorMetaEl) {
      document.head.insertBefore(target, anchorMetaEl);
      addElementToList(node.els, target);
      return target;
    }
  }
  if (head) {
    document.head.insertBefore(target, document.head.querySelector("style, link"));
  } else {
    document.head.appendChild(target);
  }
  addElementToList(node.els, target);
  return target;
}

// node_modules/css-render/esm/c.js
function wrappedRender(props) {
  return render2(this, this.instance, props);
}
function wrappedMount(options = {}) {
  const { id, ssr, props, head = false, silent = false, force = false, anchorMetaName } = options;
  const targetElement = mount(this.instance, this, id, props, head, silent, force, anchorMetaName, ssr);
  return targetElement;
}
function wrappedUnmount(options = {}) {
  const { id } = options;
  unmount(this.instance, this, id);
}
var createCNode = function(instance4, $, props, children2) {
  return {
    instance: instance4,
    $,
    props,
    children: children2,
    els: [],
    render: wrappedRender,
    mount: wrappedMount,
    unmount: wrappedUnmount
  };
};
var c2 = function(instance4, $, props, children2) {
  if (Array.isArray($)) {
    return createCNode(instance4, { $: null }, null, $);
  } else if (Array.isArray(props)) {
    return createCNode(instance4, $, null, props);
  } else if (Array.isArray(children2)) {
    return createCNode(instance4, $, props, children2);
  } else {
    return createCNode(instance4, $, props, null);
  }
};

// node_modules/css-render/esm/CssRender.js
function CssRender(config = {}) {
  let styleSheet = null;
  const cssr2 = {
    c: (...args) => c2(cssr2, ...args),
    use: (plugin3, ...args) => plugin3.install(cssr2, ...args),
    find: queryElement,
    context: {},
    config,
    get __styleSheet() {
      if (!styleSheet) {
        const style2 = document.createElement("style");
        document.head.appendChild(style2);
        styleSheet = document.styleSheets[document.styleSheets.length - 1];
        return styleSheet;
      }
      return styleSheet;
    }
  };
  return cssr2;
}

// node_modules/css-render/esm/exists.js
function exists(id, ssr) {
  if (id === void 0)
    return false;
  if (ssr) {
    const { context: { ids } } = ssr;
    return ids.has(id);
  }
  return queryElement(id) !== null;
}

// node_modules/@css-render/plugin-bem/esm/index.js
function plugin(options) {
  let _bPrefix = ".";
  let _ePrefix = "__";
  let _mPrefix = "--";
  let c6;
  if (options) {
    let t3 = options.blockPrefix;
    if (t3) {
      _bPrefix = t3;
    }
    t3 = options.elementPrefix;
    if (t3) {
      _ePrefix = t3;
    }
    t3 = options.modifierPrefix;
    if (t3) {
      _mPrefix = t3;
    }
  }
  const _plugin = {
    install(instance4) {
      c6 = instance4.c;
      const ctx3 = instance4.context;
      ctx3.bem = {};
      ctx3.bem.b = null;
      ctx3.bem.els = null;
    }
  };
  function b2(arg) {
    let memorizedB;
    let memorizedE;
    return {
      before(ctx3) {
        memorizedB = ctx3.bem.b;
        memorizedE = ctx3.bem.els;
        ctx3.bem.els = null;
      },
      after(ctx3) {
        ctx3.bem.b = memorizedB;
        ctx3.bem.els = memorizedE;
      },
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        context.bem.b = arg;
        return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
      }
    };
  }
  function e3(arg) {
    let memorizedE;
    return {
      before(ctx3) {
        memorizedE = ctx3.bem.els;
      },
      after(ctx3) {
        ctx3.bem.els = memorizedE;
      },
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        context.bem.els = arg.split(",").map((v) => v.trim());
        return context.bem.els.map((el) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el}`).join(", ");
      }
    };
  }
  function m3(arg) {
    return {
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        const modifiers = arg.split(",").map((v) => v.trim());
        function elementToSelector(el) {
          return modifiers.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== void 0 ? `${_ePrefix}${el}` : ""}${_mPrefix}${modifier}`).join(", ");
        }
        const els = context.bem.els;
        if (els !== null) {
          if (false) {
            throw Error(`[css-render/plugin-bem]: m(${arg}) is invalid, using modifier inside multiple elements is not allowed`);
          }
          return elementToSelector(els[0]);
        } else {
          return elementToSelector();
        }
      }
    };
  }
  function notM(arg) {
    return {
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        const els = context.bem.els;
        if (false) {
          throw Error(`[css-render/plugin-bem]: notM(${arg}) is invalid, using modifier inside multiple elements is not allowed`);
        }
        return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
      }
    };
  }
  const cB2 = (...args) => c6(b2(args[0]), args[1], args[2]);
  const cE2 = (...args) => c6(e3(args[0]), args[1], args[2]);
  const cM2 = (...args) => c6(m3(args[0]), args[1], args[2]);
  const cNotM2 = (...args) => c6(notM(args[0]), args[1], args[2]);
  Object.assign(_plugin, {
    cB: cB2,
    cE: cE2,
    cM: cM2,
    cNotM: cNotM2
  });
  return _plugin;
}

// node_modules/naive-ui/es/_utils/cssr/create-key.js
function createKey(prefix3, suffix2) {
  return prefix3 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
}
createKey("abc", "def");

// node_modules/naive-ui/es/_utils/cssr/index.js
var namespace = "n";
var prefix2 = `.${namespace}-`;
var elementPrefix = "__";
var modifierPrefix = "--";
var cssr = CssRender();
var plugin2 = plugin({
  blockPrefix: prefix2,
  elementPrefix,
  modifierPrefix
});
cssr.use(plugin2);
var { c: c3, find } = cssr;
var { cB, cE, cM, cNotM } = plugin2;
function insideModal(style2) {
  return c3(({ props: { bPrefix } }) => `${bPrefix || prefix2}modal, ${bPrefix || prefix2}drawer`, [style2]);
}
function insidePopover(style2) {
  return c3(({ props: { bPrefix } }) => `${bPrefix || prefix2}popover`, [style2]);
}
function asModal(style2) {
  return c3(({ props: { bPrefix } }) => `&${bPrefix || prefix2}modal`, style2);
}
var cCB = (...args) => {
  return c3(">", [cB(...args)]);
};

// node_modules/naive-ui/es/_utils/env/is-jsdom.js
var _isJsdom;
function isJsdom() {
  if (_isJsdom === void 0) {
    _isJsdom = navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
  }
  return _isJsdom;
}

// node_modules/naive-ui/es/_utils/env/is-browser.js
var isBrowser = typeof document !== "undefined" && typeof window !== "undefined";

// node_modules/naive-ui/es/_utils/composable/use-deferred-true.js
function useDeferredTrue(valueRef, delay, shouldDelayRef) {
  if (!delay)
    return valueRef;
  const delayedRef = ref(valueRef.value);
  let timerId = null;
  watch(valueRef, (value) => {
    if (timerId !== null)
      window.clearTimeout(timerId);
    if (value === true) {
      if (shouldDelayRef && !shouldDelayRef.value) {
        delayedRef.value = true;
      } else {
        timerId = window.setTimeout(() => {
          delayedRef.value = true;
        }, delay);
      }
    } else {
      delayedRef.value = false;
    }
  });
  return delayedRef;
}

// node_modules/vooks/es/use-false-until-truthy.js
function useFalseUntilTruthy(originalRef) {
  const currentRef = ref(!!originalRef.value);
  if (currentRef.value)
    return readonly(currentRef);
  const stop2 = watch(originalRef, (value) => {
    if (value) {
      currentRef.value = true;
      stop2();
    }
  });
  return readonly(currentRef);
}

// node_modules/vooks/es/use-memo.js
function useMemo(getterOrOptions) {
  const computedValueRef = computed2(getterOrOptions);
  const valueRef = ref(computedValueRef.value);
  watch(computedValueRef, (value) => {
    valueRef.value = value;
  });
  if (typeof getterOrOptions === "function") {
    return valueRef;
  } else {
    return {
      __v_isRef: true,
      get value() {
        return valueRef.value;
      },
      set value(v) {
        getterOrOptions.set(v);
      }
    };
  }
}
var use_memo_default = useMemo;

// node_modules/vooks/es/utils.js
function hasInstance() {
  return getCurrentInstance() !== null;
}
var isBrowser2 = typeof window !== "undefined";

// node_modules/vooks/es/on-fonts-ready.js
var fontsReady;
var isFontReady;
var init = () => {
  var _a3, _b2;
  fontsReady = isBrowser2 ? (_b2 = (_a3 = document) === null || _a3 === void 0 ? void 0 : _a3.fonts) === null || _b2 === void 0 ? void 0 : _b2.ready : void 0;
  isFontReady = false;
  if (fontsReady !== void 0) {
    void fontsReady.then(() => {
      isFontReady = true;
    });
  } else {
    isFontReady = true;
  }
};
init();
function onFontsReady(cb) {
  if (isFontReady)
    return;
  let deactivated = false;
  onMounted(() => {
    if (!isFontReady) {
      fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
        if (deactivated)
          return;
        cb();
      });
    }
  });
  onBeforeUnmount(() => {
    deactivated = true;
  });
}

// node_modules/evtd/es/utils.js
function getEventTarget(e3) {
  const path = e3.composedPath();
  return path[0];
}

// node_modules/evtd/es/traps.js
var traps = {
  mousemoveoutside: /* @__PURE__ */ new WeakMap(),
  clickoutside: /* @__PURE__ */ new WeakMap()
};
function createTrapHandler(name2, el, originalHandler) {
  if (name2 === "mousemoveoutside") {
    const moveHandler = (e3) => {
      if (el.contains(getEventTarget(e3)))
        return;
      originalHandler(e3);
    };
    return {
      mousemove: moveHandler,
      touchstart: moveHandler
    };
  } else if (name2 === "clickoutside") {
    let mouseDownOutside = false;
    const downHandler = (e3) => {
      mouseDownOutside = !el.contains(getEventTarget(e3));
    };
    const upHanlder = (e3) => {
      if (!mouseDownOutside)
        return;
      if (el.contains(getEventTarget(e3)))
        return;
      originalHandler(e3);
    };
    return {
      mousedown: downHandler,
      mouseup: upHanlder,
      touchstart: downHandler,
      touchend: upHanlder
    };
  }
  console.error(`[evtd/create-trap-handler]: name \`${name2}\` is invalid. This could be a bug of evtd.`);
  return {};
}
function ensureTrapHandlers(name2, el, handler) {
  const handlers = traps[name2];
  let elHandlers = handlers.get(el);
  if (elHandlers === void 0) {
    handlers.set(el, elHandlers = /* @__PURE__ */ new WeakMap());
  }
  let trapHandler = elHandlers.get(handler);
  if (trapHandler === void 0) {
    elHandlers.set(handler, trapHandler = createTrapHandler(name2, el, handler));
  }
  return trapHandler;
}
function trapOn(name2, el, handler, options) {
  if (name2 === "mousemoveoutside" || name2 === "clickoutside") {
    const trapHandlers = ensureTrapHandlers(name2, el, handler);
    Object.keys(trapHandlers).forEach((key) => {
      on(key, document, trapHandlers[key], options);
    });
    return true;
  }
  return false;
}
function trapOff(name2, el, handler, options) {
  if (name2 === "mousemoveoutside" || name2 === "clickoutside") {
    const trapHandlers = ensureTrapHandlers(name2, el, handler);
    Object.keys(trapHandlers).forEach((key) => {
      off(key, document, trapHandlers[key], options);
    });
    return true;
  }
  return false;
}

// node_modules/evtd/es/delegate.js
function createDelegate() {
  if (typeof window === "undefined") {
    return {
      on: () => {
      },
      off: () => {
      }
    };
  }
  const propagationStopped = /* @__PURE__ */ new WeakMap();
  const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
  function trackPropagation() {
    propagationStopped.set(this, true);
  }
  function trackImmediate() {
    propagationStopped.set(this, true);
    immediatePropagationStopped.set(this, true);
  }
  function spy(event, propName, fn) {
    const source = event[propName];
    event[propName] = function() {
      fn.apply(event, arguments);
      return source.apply(event, arguments);
    };
    return event;
  }
  function unspy(event, propName) {
    event[propName] = Event.prototype[propName];
  }
  const currentTargets = /* @__PURE__ */ new WeakMap();
  const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
  function getCurrentTarget() {
    var _a3;
    return (_a3 = currentTargets.get(this)) !== null && _a3 !== void 0 ? _a3 : null;
  }
  function defineCurrentTarget(event, getter) {
    if (currentTargetDescriptor === void 0)
      return;
    Object.defineProperty(event, "currentTarget", {
      configurable: true,
      enumerable: true,
      get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
    });
  }
  const phaseToTypeToElToHandlers = {
    bubble: {},
    capture: {}
  };
  const typeToWindowEventHandlers = {};
  function createUnifiedHandler() {
    const delegeteHandler = function(e3) {
      const { type, eventPhase, bubbles } = e3;
      const target = getEventTarget(e3);
      if (eventPhase === 2)
        return;
      const phase = eventPhase === 1 ? "capture" : "bubble";
      let cursor = target;
      const path = [];
      while (true) {
        if (cursor === null)
          cursor = window;
        path.push(cursor);
        if (cursor === window) {
          break;
        }
        cursor = cursor.parentNode || null;
      }
      const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
      const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
      spy(e3, "stopPropagation", trackPropagation);
      spy(e3, "stopImmediatePropagation", trackImmediate);
      defineCurrentTarget(e3, getCurrentTarget);
      if (phase === "capture") {
        if (captureElToHandlers === void 0)
          return;
        for (let i3 = path.length - 1; i3 >= 0; --i3) {
          if (propagationStopped.has(e3))
            break;
          const target2 = path[i3];
          const handlers = captureElToHandlers.get(target2);
          if (handlers !== void 0) {
            currentTargets.set(e3, target2);
            for (const handler of handlers) {
              if (immediatePropagationStopped.has(e3))
                break;
              handler(e3);
            }
          }
          if (i3 === 0 && !bubbles && bubbleElToHandlers !== void 0) {
            const bubbleHandlers = bubbleElToHandlers.get(target2);
            if (bubbleHandlers !== void 0) {
              for (const handler of bubbleHandlers) {
                if (immediatePropagationStopped.has(e3))
                  break;
                handler(e3);
              }
            }
          }
        }
      } else if (phase === "bubble") {
        if (bubbleElToHandlers === void 0)
          return;
        for (let i3 = 0; i3 < path.length; ++i3) {
          if (propagationStopped.has(e3))
            break;
          const target2 = path[i3];
          const handlers = bubbleElToHandlers.get(target2);
          if (handlers !== void 0) {
            currentTargets.set(e3, target2);
            for (const handler of handlers) {
              if (immediatePropagationStopped.has(e3))
                break;
              handler(e3);
            }
          }
        }
      }
      unspy(e3, "stopPropagation");
      unspy(e3, "stopImmediatePropagation");
      defineCurrentTarget(e3);
    };
    delegeteHandler.displayName = "evtdUnifiedHandler";
    return delegeteHandler;
  }
  function createUnifiedWindowEventHandler() {
    const delegateHandler = function(e3) {
      const { type, eventPhase } = e3;
      if (eventPhase !== 2)
        return;
      const handlers = typeToWindowEventHandlers[type];
      if (handlers === void 0)
        return;
      handlers.forEach((handler) => handler(e3));
    };
    delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
    return delegateHandler;
  }
  const unifiedHandler = createUnifiedHandler();
  const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
  function ensureElToHandlers(phase, type) {
    const phaseHandlers = phaseToTypeToElToHandlers[phase];
    if (phaseHandlers[type] === void 0) {
      phaseHandlers[type] = /* @__PURE__ */ new Map();
      window.addEventListener(type, unifiedHandler, phase === "capture");
    }
    return phaseHandlers[type];
  }
  function ensureWindowEventHandlers(type) {
    const windowEventHandlers = typeToWindowEventHandlers[type];
    if (windowEventHandlers === void 0) {
      typeToWindowEventHandlers[type] = /* @__PURE__ */ new Set();
      window.addEventListener(type, unfiendWindowEventHandler);
    }
    return typeToWindowEventHandlers[type];
  }
  function ensureHandlers(elToHandlers, el) {
    let elHandlers = elToHandlers.get(el);
    if (elHandlers === void 0) {
      elToHandlers.set(el, elHandlers = /* @__PURE__ */ new Set());
    }
    return elHandlers;
  }
  function handlerExist(el, phase, type, handler) {
    const elToHandlers = phaseToTypeToElToHandlers[phase][type];
    if (elToHandlers !== void 0) {
      const handlers = elToHandlers.get(el);
      if (handlers !== void 0) {
        if (handlers.has(handler))
          return true;
      }
    }
    return false;
  }
  function windowEventHandlerExist(type, handler) {
    const handlers = typeToWindowEventHandlers[type];
    if (handlers !== void 0) {
      if (handlers.has(handler)) {
        return true;
      }
    }
    return false;
  }
  function on2(type, el, handler, options) {
    let mergedHandler;
    if (typeof options === "object" && options.once === true) {
      mergedHandler = (e3) => {
        off2(type, el, mergedHandler, options);
        handler(e3);
      };
    } else {
      mergedHandler = handler;
    }
    const trapped = trapOn(type, el, mergedHandler, options);
    if (trapped)
      return;
    const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
    const elToHandlers = ensureElToHandlers(phase, type);
    const handlers = ensureHandlers(elToHandlers, el);
    if (!handlers.has(mergedHandler))
      handlers.add(mergedHandler);
    if (el === window) {
      const windowEventHandlers = ensureWindowEventHandlers(type);
      if (!windowEventHandlers.has(mergedHandler)) {
        windowEventHandlers.add(mergedHandler);
      }
    }
  }
  function off2(type, el, handler, options) {
    const trapped = trapOff(type, el, handler, options);
    if (trapped)
      return;
    const capture = options === true || typeof options === "object" && options.capture === true;
    const phase = capture ? "capture" : "bubble";
    const elToHandlers = ensureElToHandlers(phase, type);
    const handlers = ensureHandlers(elToHandlers, el);
    if (el === window) {
      const mirrorPhase = capture ? "bubble" : "capture";
      if (!handlerExist(el, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {
        const windowEventHandlers = typeToWindowEventHandlers[type];
        windowEventHandlers.delete(handler);
        if (windowEventHandlers.size === 0) {
          window.removeEventListener(type, unfiendWindowEventHandler);
          typeToWindowEventHandlers[type] = void 0;
        }
      }
    }
    if (handlers.has(handler))
      handlers.delete(handler);
    if (handlers.size === 0) {
      elToHandlers.delete(el);
    }
    if (elToHandlers.size === 0) {
      window.removeEventListener(type, unifiedHandler, phase === "capture");
      phaseToTypeToElToHandlers[phase][type] = void 0;
    }
  }
  return {
    on: on2,
    off: off2
  };
}
var { on, off } = createDelegate();

// node_modules/vooks/es/use-merged-state.js
function useMergedState(controlledStateRef, uncontrolledStateRef) {
  watch(controlledStateRef, (value) => {
    if (value !== void 0) {
      uncontrolledStateRef.value = value;
    }
  });
  return computed2(() => {
    if (controlledStateRef.value === void 0) {
      return uncontrolledStateRef.value;
    }
    return controlledStateRef.value;
  });
}

// node_modules/vooks/es/life-cycle/use-is-mounted.js
function isMounted() {
  const isMounted2 = ref(false);
  onMounted(() => {
    isMounted2.value = true;
  });
  return readonly(isMounted2);
}

// node_modules/vooks/es/use-compitable.js
function useCompitable(reactive2, keys2) {
  return computed2(() => {
    for (const key of keys2) {
      if (reactive2[key] !== void 0)
        return reactive2[key];
    }
    return reactive2[keys2[keys2.length - 1]];
  });
}

// node_modules/vooks/es/use-is-ios.js
var isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && !window.MSStream;
function useIsIos() {
  return isIos;
}

// node_modules/vooks/es/use-breakpoints.js
var defaultBreakpointOptions = {
  xs: 0,
  s: 640,
  m: 1024,
  l: 1280,
  xl: 1536,
  "2xl": 1920
};
function createMediaQuery(screenWidth) {
  return `(min-width: ${screenWidth}px)`;
}
var mqlMap = {};
function useBreakpoints(screens = defaultBreakpointOptions) {
  if (!isBrowser2)
    return computed2(() => []);
  if (typeof window.matchMedia !== "function")
    return computed2(() => []);
  const breakpointStatusRef = ref({});
  const breakpoints = Object.keys(screens);
  const updateBreakpoints = (e3, breakpointName) => {
    if (e3.matches)
      breakpointStatusRef.value[breakpointName] = true;
    else
      breakpointStatusRef.value[breakpointName] = false;
  };
  breakpoints.forEach((key) => {
    const breakpointValue = screens[key];
    let mql;
    let cbs;
    if (mqlMap[breakpointValue] === void 0) {
      mql = window.matchMedia(createMediaQuery(breakpointValue));
      if (mql.addEventListener) {
        mql.addEventListener("change", (e3) => {
          cbs.forEach((cb) => {
            cb(e3, key);
          });
        });
      } else if (mql.addListener) {
        mql.addListener((e3) => {
          cbs.forEach((cb) => {
            cb(e3, key);
          });
        });
      }
      cbs = /* @__PURE__ */ new Set();
      mqlMap[breakpointValue] = {
        mql,
        cbs
      };
    } else {
      mql = mqlMap[breakpointValue].mql;
      cbs = mqlMap[breakpointValue].cbs;
    }
    cbs.add(updateBreakpoints);
    if (mql.matches) {
      cbs.forEach((cb) => {
        cb(mql, key);
      });
    }
  });
  onBeforeUnmount(() => {
    breakpoints.forEach((breakpoint) => {
      const { cbs } = mqlMap[screens[breakpoint]];
      if (cbs.has(updateBreakpoints)) {
        cbs.delete(updateBreakpoints);
      }
    });
  });
  return computed2(() => {
    const { value } = breakpointStatusRef;
    return breakpoints.filter((key) => value[key]);
  });
}
var use_breakpoints_default = useBreakpoints;

// node_modules/vooks/es/use-keyboard.js
function useKeyboard(options = {}, enabledRef) {
  const state = reactive({
    ctrl: false,
    command: false,
    win: false,
    shift: false,
    tab: false
  });
  const { keydown, keyup } = options;
  const keydownHandler = (e3) => {
    switch (e3.key) {
      case "Control":
        state.ctrl = true;
        break;
      case "Meta":
        state.command = true;
        state.win = true;
        break;
      case "Shift":
        state.shift = true;
        break;
      case "Tab":
        state.tab = true;
        break;
    }
    if (keydown !== void 0) {
      Object.keys(keydown).forEach((key) => {
        if (key !== e3.key)
          return;
        const handler = keydown[key];
        if (typeof handler === "function") {
          handler(e3);
        } else {
          const { stop: stop2 = false, prevent = false } = handler;
          if (stop2)
            e3.stopPropagation();
          if (prevent)
            e3.preventDefault();
          handler.handler(e3);
        }
      });
    }
  };
  const keyupHandler = (e3) => {
    switch (e3.key) {
      case "Control":
        state.ctrl = false;
        break;
      case "Meta":
        state.command = false;
        state.win = false;
        break;
      case "Shift":
        state.shift = false;
        break;
      case "Tab":
        state.tab = false;
        break;
    }
    if (keyup !== void 0) {
      Object.keys(keyup).forEach((key) => {
        if (key !== e3.key)
          return;
        const handler = keyup[key];
        if (typeof handler === "function") {
          handler(e3);
        } else {
          const { stop: stop2 = false, prevent = false } = handler;
          if (stop2)
            e3.stopPropagation();
          if (prevent)
            e3.preventDefault();
          handler.handler(e3);
        }
      });
    }
  };
  const setup = () => {
    if (enabledRef === void 0 || enabledRef.value) {
      on("keydown", document, keydownHandler);
      on("keyup", document, keyupHandler);
    }
    if (enabledRef !== void 0) {
      watch(enabledRef, (value) => {
        if (value) {
          on("keydown", document, keydownHandler);
          on("keyup", document, keyupHandler);
        } else {
          off("keydown", document, keydownHandler);
          off("keyup", document, keyupHandler);
        }
      });
    }
  };
  if (hasInstance()) {
    onBeforeMount(setup);
    onBeforeUnmount(() => {
      if (enabledRef === void 0 || enabledRef.value) {
        off("keydown", document, keydownHandler);
        off("keyup", document, keyupHandler);
      }
    });
  } else {
    setup();
  }
  return readonly(state);
}

// node_modules/naive-ui/es/_internal/select-menu/src/interface.js
var internalSelectionMenuInjectionKey = createInjectionKey("n-internal-select-menu");
var internalSelectionMenuBodyInjectionKey = createInjectionKey("n-internal-select-menu-body");

// node_modules/naive-ui/es/modal/src/interface.js
var modalBodyInjectionKey = createInjectionKey("n-modal-body");
var modalInjectionKey = createInjectionKey("n-modal");

// node_modules/naive-ui/es/drawer/src/interface.js
var drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
var drawerInjectionKey = createInjectionKey("n-drawer");

// node_modules/naive-ui/es/popover/src/interface.js
var popoverBodyInjectionKey = createInjectionKey("n-popover-body");

// node_modules/naive-ui/es/_utils/composable/use-adjusted-to.js
var teleportDisabled = "__disabled__";
function useAdjustedTo(props) {
  const modal = inject(modalBodyInjectionKey, null);
  const drawer = inject(drawerBodyInjectionKey, null);
  const popover = inject(popoverBodyInjectionKey, null);
  const selectMenu = inject(internalSelectionMenuBodyInjectionKey, null);
  const fullscreenElementRef = ref();
  if (typeof document !== "undefined") {
    fullscreenElementRef.value = document.fullscreenElement;
    const handleFullscreenChange = () => {
      fullscreenElementRef.value = document.fullscreenElement;
    };
    onMounted(() => {
      on("fullscreenchange", document, handleFullscreenChange);
    });
    onBeforeUnmount(() => {
      off("fullscreenchange", document, handleFullscreenChange);
    });
  }
  return use_memo_default(() => {
    var _a3;
    const { to: to2 } = props;
    if (to2 !== void 0) {
      if (to2 === false)
        return teleportDisabled;
      if (to2 === true)
        return fullscreenElementRef.value || "body";
      return to2;
    }
    if (modal === null || modal === void 0 ? void 0 : modal.value) {
      return (_a3 = modal.value.$el) !== null && _a3 !== void 0 ? _a3 : modal.value;
    }
    if (drawer === null || drawer === void 0 ? void 0 : drawer.value)
      return drawer.value;
    if (popover === null || popover === void 0 ? void 0 : popover.value)
      return popover.value;
    if (selectMenu === null || selectMenu === void 0 ? void 0 : selectMenu.value)
      return selectMenu.value;
    return to2 !== null && to2 !== void 0 ? to2 : fullscreenElementRef.value || "body";
  });
}
useAdjustedTo.tdkey = teleportDisabled;
useAdjustedTo.propTo = {
  type: [String, Object, Boolean],
  default: void 0
};

// node_modules/naive-ui/es/_utils/composable/use-houdini.js
var houdiniRegistered = false;
function useHoudini() {
  if (!isBrowser)
    return;
  if (!window.CSS)
    return;
  if (!houdiniRegistered) {
    houdiniRegistered = true;
    if ("registerProperty" in (window === null || window === void 0 ? void 0 : window.CSS)) {
      try {
        ;
        CSS.registerProperty({
          name: "--n-color-start",
          syntax: "<color>",
          inherits: false,
          initialValue: "#0000"
        });
        CSS.registerProperty({
          name: "--n-color-end",
          syntax: "<color>",
          inherits: false,
          initialValue: "#0000"
        });
      } catch (e3) {
      }
    }
  }
}

// node_modules/vueuc/es/shared/v-node.js
function getSlot2(scope, slots, slotName = "default") {
  const slot = slots[slotName];
  if (slot === void 0) {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
  }
  return slot();
}
function flatten2(vNodes, filterCommentNode = true, result = []) {
  vNodes.forEach((vNode) => {
    if (vNode === null)
      return;
    if (typeof vNode !== "object") {
      if (typeof vNode === "string" || typeof vNode === "number") {
        result.push(createTextVNode(String(vNode)));
      }
      return;
    }
    if (Array.isArray(vNode)) {
      flatten2(vNode, filterCommentNode, result);
      return;
    }
    if (vNode.type === Fragment) {
      if (vNode.children === null)
        return;
      if (Array.isArray(vNode.children)) {
        flatten2(vNode.children, filterCommentNode, result);
      }
    } else if (vNode.type !== Comment) {
      result.push(vNode);
    }
  });
  return result;
}
function getFirstVNode(scope, slots, slotName = "default") {
  const slot = slots[slotName];
  if (slot === void 0) {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
  }
  const content = flatten2(slot());
  if (content.length === 1) {
    return content[0];
  } else {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);
  }
}

// node_modules/vueuc/es/binder/src/utils.js
var viewMeasurer = null;
function ensureViewBoundingRect() {
  if (viewMeasurer === null) {
    viewMeasurer = document.getElementById("v-binder-view-measurer");
    if (viewMeasurer === null) {
      viewMeasurer = document.createElement("div");
      viewMeasurer.id = "v-binder-view-measurer";
      const { style: style2 } = viewMeasurer;
      style2.position = "fixed";
      style2.left = "0";
      style2.right = "0";
      style2.top = "0";
      style2.bottom = "0";
      style2.pointerEvents = "none";
      style2.visibility = "hidden";
      document.body.appendChild(viewMeasurer);
    }
  }
  return viewMeasurer.getBoundingClientRect();
}
function getPointRect(x2, y3) {
  const viewRect = ensureViewBoundingRect();
  return {
    top: y3,
    left: x2,
    height: 0,
    width: 0,
    right: viewRect.width - x2,
    bottom: viewRect.height - y3
  };
}
function getRect(el) {
  const elRect = el.getBoundingClientRect();
  const viewRect = ensureViewBoundingRect();
  return {
    left: elRect.left - viewRect.left,
    top: elRect.top - viewRect.top,
    bottom: viewRect.height + viewRect.top - elRect.bottom,
    right: viewRect.width + viewRect.left - elRect.right,
    width: elRect.width,
    height: elRect.height
  };
}
function getParentNode(node) {
  if (node.nodeType === 9) {
    return null;
  }
  return node.parentNode;
}
function getScrollParent(node) {
  if (node === null)
    return null;
  const parentNode = getParentNode(node);
  if (parentNode === null) {
    return null;
  }
  if (parentNode.nodeType === 9) {
    return document;
  }
  if (parentNode.nodeType === 1) {
    const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return parentNode;
    }
  }
  return getScrollParent(parentNode);
}

// node_modules/vueuc/es/binder/src/Binder.js
var Binder = defineComponent({
  name: "Binder",
  props: {
    syncTargetWithParent: Boolean,
    syncTarget: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    var _a3;
    provide("VBinder", (_a3 = getCurrentInstance()) === null || _a3 === void 0 ? void 0 : _a3.proxy);
    const VBinder = inject("VBinder", null);
    const targetRef = ref(null);
    const setTargetRef = (el) => {
      targetRef.value = el;
      if (VBinder && props.syncTargetWithParent) {
        VBinder.setTargetRef(el);
      }
    };
    let scrollableNodes = [];
    const ensureScrollListener = () => {
      let cursor = targetRef.value;
      while (true) {
        cursor = getScrollParent(cursor);
        if (cursor === null)
          break;
        scrollableNodes.push(cursor);
      }
      for (const el of scrollableNodes) {
        on("scroll", el, onScroll, true);
      }
    };
    const removeScrollListeners = () => {
      for (const el of scrollableNodes) {
        off("scroll", el, onScroll, true);
      }
      scrollableNodes = [];
    };
    const followerScrollListeners = /* @__PURE__ */ new Set();
    const addScrollListener = (listener) => {
      if (followerScrollListeners.size === 0) {
        ensureScrollListener();
      }
      if (!followerScrollListeners.has(listener)) {
        followerScrollListeners.add(listener);
      }
    };
    const removeScrollListener = (listener) => {
      if (followerScrollListeners.has(listener)) {
        followerScrollListeners.delete(listener);
      }
      if (followerScrollListeners.size === 0) {
        removeScrollListeners();
      }
    };
    const onScroll = () => {
      beforeNextFrameOnce(onScrollRaf);
    };
    const onScrollRaf = () => {
      followerScrollListeners.forEach((listener) => listener());
    };
    const followerResizeListeners = /* @__PURE__ */ new Set();
    const addResizeListener = (listener) => {
      if (followerResizeListeners.size === 0) {
        on("resize", window, onResize);
      }
      if (!followerResizeListeners.has(listener)) {
        followerResizeListeners.add(listener);
      }
    };
    const removeResizeListener = (listener) => {
      if (followerResizeListeners.has(listener)) {
        followerResizeListeners.delete(listener);
      }
      if (followerResizeListeners.size === 0) {
        off("resize", window, onResize);
      }
    };
    const onResize = () => {
      followerResizeListeners.forEach((listener) => listener());
    };
    onBeforeUnmount(() => {
      off("resize", window, onResize);
      removeScrollListeners();
    });
    return {
      targetRef,
      setTargetRef,
      addScrollListener,
      removeScrollListener,
      addResizeListener,
      removeResizeListener
    };
  },
  render() {
    return getSlot2("binder", this.$slots);
  }
});
var Binder_default = Binder;

// node_modules/vueuc/es/binder/src/Target.js
var Target_default = defineComponent({
  name: "Target",
  setup() {
    const { setTargetRef, syncTarget } = inject("VBinder");
    const setTargetDirective = {
      mounted: setTargetRef,
      updated: setTargetRef
    };
    return {
      syncTarget,
      setTargetDirective
    };
  },
  render() {
    const { syncTarget, setTargetDirective } = this;
    if (syncTarget) {
      return withDirectives(getFirstVNode("follower", this.$slots), [
        [setTargetDirective]
      ]);
    }
    return getFirstVNode("follower", this.$slots);
  }
});

// node_modules/vdirs/es/mousemoveoutside.js
var ctxKey = "@@mmoContext";
var mousemoveoutside = {
  mounted(el, { value }) {
    el[ctxKey] = {
      handler: void 0
    };
    if (typeof value === "function") {
      el[ctxKey].handler = value;
      on("mousemoveoutside", el, value);
    }
  },
  updated(el, { value }) {
    const ctx3 = el[ctxKey];
    if (typeof value === "function") {
      if (ctx3.handler) {
        if (ctx3.handler !== value) {
          off("mousemoveoutside", el, ctx3.handler);
          ctx3.handler = value;
          on("mousemoveoutside", el, value);
        }
      } else {
        el[ctxKey].handler = value;
        on("mousemoveoutside", el, value);
      }
    } else {
      if (ctx3.handler) {
        off("mousemoveoutside", el, ctx3.handler);
        ctx3.handler = void 0;
      }
    }
  },
  unmounted(el) {
    const { handler } = el[ctxKey];
    if (handler) {
      off("mousemoveoutside", el, handler);
    }
    el[ctxKey].handler = void 0;
  }
};
var mousemoveoutside_default = mousemoveoutside;

// node_modules/vdirs/es/clickoutside.js
var ctxKey2 = "@@coContext";
var clickoutside = {
  mounted(el, { value, modifiers }) {
    el[ctxKey2] = {
      handler: void 0
    };
    if (typeof value === "function") {
      el[ctxKey2].handler = value;
      on("clickoutside", el, value, {
        capture: modifiers.capture
      });
    }
  },
  updated(el, { value, modifiers }) {
    const ctx3 = el[ctxKey2];
    if (typeof value === "function") {
      if (ctx3.handler) {
        if (ctx3.handler !== value) {
          off("clickoutside", el, ctx3.handler, {
            capture: modifiers.capture
          });
          ctx3.handler = value;
          on("clickoutside", el, value, {
            capture: modifiers.capture
          });
        }
      } else {
        el[ctxKey2].handler = value;
        on("clickoutside", el, value, {
          capture: modifiers.capture
        });
      }
    } else {
      if (ctx3.handler) {
        off("clickoutside", el, ctx3.handler, {
          capture: modifiers.capture
        });
        ctx3.handler = void 0;
      }
    }
  },
  unmounted(el, { modifiers }) {
    const { handler } = el[ctxKey2];
    if (handler) {
      off("clickoutside", el, handler, {
        capture: modifiers.capture
      });
    }
    el[ctxKey2].handler = void 0;
  }
};
var clickoutside_default = clickoutside;

// node_modules/vdirs/es/utils.js
function warn3(location, message) {
  console.error(`[vdirs/${location}]: ${message}`);
}

// node_modules/vdirs/es/zindexable/z-index-manager.js
var ZIndexManager = class {
  constructor() {
    this.elementZIndex = /* @__PURE__ */ new Map();
    this.nextZIndex = 2e3;
  }
  get elementCount() {
    return this.elementZIndex.size;
  }
  ensureZIndex(el, zIndex) {
    const { elementZIndex } = this;
    if (zIndex !== void 0) {
      el.style.zIndex = `${zIndex}`;
      elementZIndex.delete(el);
      return;
    }
    const { nextZIndex } = this;
    if (elementZIndex.has(el)) {
      const currentZIndex = elementZIndex.get(el);
      if (currentZIndex + 1 === this.nextZIndex)
        return;
    }
    el.style.zIndex = `${nextZIndex}`;
    elementZIndex.set(el, nextZIndex);
    this.nextZIndex = nextZIndex + 1;
    this.squashState();
  }
  unregister(el, zIndex) {
    const { elementZIndex } = this;
    if (elementZIndex.has(el)) {
      elementZIndex.delete(el);
    } else if (zIndex === void 0) {
      warn3("z-index-manager/unregister-element", "Element not found when unregistering.");
    }
    this.squashState();
  }
  squashState() {
    const { elementCount } = this;
    if (!elementCount) {
      this.nextZIndex = 2e3;
    }
    if (this.nextZIndex - elementCount > 2500)
      this.rearrange();
  }
  rearrange() {
    const elementZIndexPair = Array.from(this.elementZIndex.entries());
    elementZIndexPair.sort((pair1, pair2) => {
      return pair1[1] - pair2[1];
    });
    this.nextZIndex = 2e3;
    elementZIndexPair.forEach((pair) => {
      const el = pair[0];
      const zIndex = this.nextZIndex++;
      if (`${zIndex}` !== el.style.zIndex)
        el.style.zIndex = `${zIndex}`;
    });
  }
};
var z_index_manager_default = new ZIndexManager();

// node_modules/vdirs/es/zindexable/index.js
var ctx2 = "@@ziContext";
var zindexable = {
  mounted(el, bindings) {
    const { value = {} } = bindings;
    const { zIndex, enabled } = value;
    el[ctx2] = {
      enabled: !!enabled,
      initialized: false
    };
    if (enabled) {
      z_index_manager_default.ensureZIndex(el, zIndex);
      el[ctx2].initialized = true;
    }
  },
  updated(el, bindings) {
    const { value = {} } = bindings;
    const { zIndex, enabled } = value;
    const cachedEnabled = el[ctx2].enabled;
    if (enabled && !cachedEnabled) {
      z_index_manager_default.ensureZIndex(el, zIndex);
      el[ctx2].initialized = true;
    }
    el[ctx2].enabled = !!enabled;
  },
  unmounted(el, bindings) {
    if (!el[ctx2].initialized)
      return;
    const { value = {} } = bindings;
    const { zIndex } = value;
    z_index_manager_default.unregister(el, zIndex);
  }
};
var zindexable_default = zindexable;

// node_modules/@css-render/vue3-ssr/esm/index.js
var ssrContextKey2 = Symbol("@css-render/vue3-ssr");
function createStyleString(id, style2) {
  return `<style cssr-id="${id}">
${style2}
</style>`;
}
function ssrAdapter(id, style2) {
  const ssrContext = inject(ssrContextKey2, null);
  if (ssrContext === null) {
    console.error("[css-render/vue3-ssr]: no ssr context found.");
    return;
  }
  const { styles, ids } = ssrContext;
  if (ids.has(id))
    return;
  if (styles !== null) {
    ids.add(id);
    styles.push(createStyleString(id, style2));
  }
}
var isBrowser3 = typeof document !== "undefined";
function useSsrAdapter() {
  if (isBrowser3)
    return void 0;
  const context = inject(ssrContextKey2, null);
  if (context === null)
    return void 0;
  return {
    adapter: ssrAdapter,
    context
  };
}

// node_modules/vueuc/es/shared/warn.js
function warn4(location, message) {
  console.error(`[vueuc/${location}]: ${message}`);
}

// node_modules/vueuc/es/shared/cssr.js
var { c: c4 } = CssRender();
var cssrAnchorMetaName = "vueuc-style";

// node_modules/vueuc/es/shared/resolve-to.js
function resolveTo(selector) {
  if (typeof selector === "string") {
    return document.querySelector(selector);
  }
  return selector();
}

// node_modules/vueuc/es/lazy-teleport/src/index.js
var src_default = defineComponent({
  name: "LazyTeleport",
  props: {
    to: {
      type: [String, Object],
      default: void 0
    },
    disabled: Boolean,
    show: {
      type: Boolean,
      required: true
    }
  },
  setup(props) {
    return {
      showTeleport: useFalseUntilTruthy(toRef(props, "show")),
      mergedTo: computed2(() => {
        const { to: to2 } = props;
        return to2 !== null && to2 !== void 0 ? to2 : "body";
      })
    };
  },
  render() {
    return this.showTeleport ? this.disabled ? getSlot2("lazy-teleport", this.$slots) : h3(Teleport, {
      disabled: this.disabled,
      to: this.mergedTo
    }, getSlot2("lazy-teleport", this.$slots)) : null;
  }
});

// node_modules/vueuc/es/binder/src/get-placement-style.js
var oppositionPositions = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
var oppositeAligns = {
  start: "end",
  center: "center",
  end: "start"
};
var propToCompare = {
  top: "height",
  bottom: "height",
  left: "width",
  right: "width"
};
var transformOrigins = {
  "bottom-start": "top left",
  bottom: "top center",
  "bottom-end": "top right",
  "top-start": "bottom left",
  top: "bottom center",
  "top-end": "bottom right",
  "right-start": "top left",
  right: "center left",
  "right-end": "bottom left",
  "left-start": "top right",
  left: "center right",
  "left-end": "bottom right"
};
var overlapTransformOrigin = {
  "bottom-start": "bottom left",
  bottom: "bottom center",
  "bottom-end": "bottom right",
  "top-start": "top left",
  top: "top center",
  "top-end": "top right",
  "right-start": "top right",
  right: "center right",
  "right-end": "bottom right",
  "left-start": "top left",
  left: "center left",
  "left-end": "bottom left"
};
var oppositeAlignCssPositionProps = {
  "bottom-start": "right",
  "bottom-end": "left",
  "top-start": "right",
  "top-end": "left",
  "right-start": "bottom",
  "right-end": "top",
  "left-start": "bottom",
  "left-end": "top"
};
var keepOffsetDirection = {
  top: true,
  bottom: false,
  left: true,
  right: false
};
var cssPositionToOppositeAlign = {
  top: "end",
  bottom: "start",
  left: "end",
  right: "start"
};
function getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, shift, flip, overlap) {
  if (!flip || overlap) {
    return { placement, top: 0, left: 0 };
  }
  const [position, align] = placement.split("-");
  let properAlign = align !== null && align !== void 0 ? align : "center";
  let properOffset = {
    top: 0,
    left: 0
  };
  const deriveOffset = (oppositeAlignCssSizeProp, alignCssPositionProp, offsetVertically2) => {
    let left = 0;
    let top = 0;
    const diff = followerRect[oppositeAlignCssSizeProp] - targetRect[alignCssPositionProp] - targetRect[oppositeAlignCssSizeProp];
    if (diff > 0 && shift) {
      if (offsetVertically2) {
        top = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
      } else {
        left = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
      }
    }
    return {
      left,
      top
    };
  };
  const offsetVertically = position === "left" || position === "right";
  if (properAlign !== "center") {
    const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
    const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
    const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp];
    if (followerRect[oppositeAlignCssSizeProp] > targetRect[oppositeAlignCssSizeProp]) {
      if (targetRect[oppositeAlignCssPositionProp] + targetRect[oppositeAlignCssSizeProp] < followerRect[oppositeAlignCssSizeProp]) {
        const followerOverTargetSize = (followerRect[oppositeAlignCssSizeProp] - targetRect[oppositeAlignCssSizeProp]) / 2;
        if (targetRect[oppositeAlignCssPositionProp] < followerOverTargetSize || targetRect[currentAlignCssPositionProp] < followerOverTargetSize) {
          if (targetRect[oppositeAlignCssPositionProp] < targetRect[currentAlignCssPositionProp]) {
            properAlign = oppositeAligns[align];
            properOffset = deriveOffset(oppositeAlignCssSizeProp, currentAlignCssPositionProp, offsetVertically);
          } else {
            properOffset = deriveOffset(oppositeAlignCssSizeProp, oppositeAlignCssPositionProp, offsetVertically);
          }
        } else {
          properAlign = "center";
        }
      }
    } else if (followerRect[oppositeAlignCssSizeProp] < targetRect[oppositeAlignCssSizeProp]) {
      if (targetRect[currentAlignCssPositionProp] < 0 && targetRect[oppositeAlignCssPositionProp] > targetRect[currentAlignCssPositionProp]) {
        properAlign = oppositeAligns[align];
      }
    }
  } else {
    const possibleAlternativeAlignCssPositionProp1 = position === "bottom" || position === "top" ? "left" : "top";
    const possibleAlternativeAlignCssPositionProp2 = oppositionPositions[possibleAlternativeAlignCssPositionProp1];
    const alternativeAlignCssSizeProp = propToCompare[possibleAlternativeAlignCssPositionProp1];
    const followerOverTargetSize = (followerRect[alternativeAlignCssSizeProp] - targetRect[alternativeAlignCssSizeProp]) / 2;
    if (targetRect[possibleAlternativeAlignCssPositionProp1] < followerOverTargetSize || targetRect[possibleAlternativeAlignCssPositionProp2] < followerOverTargetSize) {
      if (targetRect[possibleAlternativeAlignCssPositionProp1] > targetRect[possibleAlternativeAlignCssPositionProp2]) {
        properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp1];
        properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp1, offsetVertically);
      } else {
        properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp2];
        properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp2, offsetVertically);
      }
    }
  }
  let properPosition = position;
  if (targetRect[position] < followerRect[propToCompare[position]] && targetRect[position] < targetRect[oppositionPositions[position]]) {
    properPosition = oppositionPositions[position];
  }
  return {
    placement: properAlign !== "center" ? `${properPosition}-${properAlign}` : properPosition,
    left: properOffset.left,
    top: properOffset.top
  };
}
function getProperTransformOrigin(placement, overlap) {
  if (overlap)
    return overlapTransformOrigin[placement];
  return transformOrigins[placement];
}
function getOffset(placement, offsetRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap) {
  if (overlap) {
    switch (placement) {
      case "bottom-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-100%)"
        };
      case "bottom-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "top-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: ""
        };
      case "top-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%)"
        };
      case "right-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%)"
        };
      case "right-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "left-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: ""
        };
      case "left-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-100%)"
        };
      case "top":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
          transform: "translateX(-50%)"
        };
      case "right":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-50%)"
        };
      case "left":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-50%)"
        };
      case "bottom":
      default:
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
          transform: "translateX(-50%) translateY(-100%)"
        };
    }
  }
  switch (placement) {
    case "bottom-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: ""
      };
    case "bottom-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%)"
      };
    case "top-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%)"
      };
    case "top-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%) translateY(-100%)"
      };
    case "right-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: ""
      };
    case "right-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%)"
      };
    case "left-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%)"
      };
    case "left-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%) translateY(-100%)"
      };
    case "top":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%) translateX(-50%)"
      };
    case "right":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-50%)"
      };
    case "left":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-50%) translateX(-100%)"
      };
    case "bottom":
    default:
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-50%)"
      };
  }
}

// node_modules/vueuc/es/binder/src/Follower.js
var style = c4([
  c4(".v-binder-follower-container", {
    position: "absolute",
    left: "0",
    right: "0",
    top: "0",
    height: "0",
    pointerEvents: "none",
    zIndex: "auto"
  }),
  c4(".v-binder-follower-content", {
    position: "absolute",
    zIndex: "auto"
  }, [
    c4("> *", {
      pointerEvents: "all"
    })
  ])
]);
var Follower_default = defineComponent({
  name: "Follower",
  inheritAttrs: false,
  props: {
    show: Boolean,
    enabled: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String,
      default: "bottom"
    },
    syncTrigger: {
      type: Array,
      default: ["resize", "scroll"]
    },
    to: [String, Object],
    flip: {
      type: Boolean,
      default: true
    },
    internalShift: Boolean,
    x: Number,
    y: Number,
    width: String,
    minWidth: String,
    containerClass: String,
    teleportDisabled: Boolean,
    zindexable: {
      type: Boolean,
      default: true
    },
    zIndex: Number,
    overlap: Boolean
  },
  setup(props) {
    const VBinder = inject("VBinder");
    const mergedEnabledRef = use_memo_default(() => {
      return props.enabled !== void 0 ? props.enabled : props.show;
    });
    const followerRef = ref(null);
    const offsetContainerRef = ref(null);
    const ensureListeners = () => {
      const { syncTrigger } = props;
      if (syncTrigger.includes("scroll")) {
        VBinder.addScrollListener(syncPosition);
      }
      if (syncTrigger.includes("resize")) {
        VBinder.addResizeListener(syncPosition);
      }
    };
    const removeListeners = () => {
      VBinder.removeScrollListener(syncPosition);
      VBinder.removeResizeListener(syncPosition);
    };
    onMounted(() => {
      if (mergedEnabledRef.value) {
        syncPosition();
        ensureListeners();
      }
    });
    const ssrAdapter2 = useSsrAdapter();
    style.mount({
      id: "vueuc/binder",
      head: true,
      anchorMetaName: cssrAnchorMetaName,
      ssr: ssrAdapter2
    });
    onBeforeUnmount(() => {
      removeListeners();
    });
    onFontsReady(() => {
      if (mergedEnabledRef.value) {
        syncPosition();
      }
    });
    const syncPosition = () => {
      if (!mergedEnabledRef.value) {
        return;
      }
      const follower = followerRef.value;
      if (follower === null)
        return;
      const target = VBinder.targetRef;
      const { x: x2, y: y3, overlap } = props;
      const targetRect = x2 !== void 0 && y3 !== void 0 ? getPointRect(x2, y3) : getRect(target);
      follower.style.setProperty("--v-target-width", `${Math.round(targetRect.width)}px`);
      follower.style.setProperty("--v-target-height", `${Math.round(targetRect.height)}px`);
      const { width, minWidth, placement, internalShift, flip } = props;
      follower.setAttribute("v-placement", placement);
      if (overlap) {
        follower.setAttribute("v-overlap", "");
      } else {
        follower.removeAttribute("v-overlap");
      }
      const { style: style2 } = follower;
      if (width === "target") {
        style2.width = `${targetRect.width}px`;
      } else if (width !== void 0) {
        style2.width = width;
      } else {
        style2.width = "";
      }
      if (minWidth === "target") {
        style2.minWidth = `${targetRect.width}px`;
      } else if (minWidth !== void 0) {
        style2.minWidth = minWidth;
      } else {
        style2.minWidth = "";
      }
      const followerRect = getRect(follower);
      const offsetContainerRect = getRect(offsetContainerRef.value);
      const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);
      const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
      const { left, top, transform } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);
      follower.setAttribute("v-placement", properPlacement);
      follower.style.setProperty("--v-offset-left", `${Math.round(offsetLeftToStandardPlacement)}px`);
      follower.style.setProperty("--v-offset-top", `${Math.round(offsetTopToStandardPlacement)}px`);
      follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;
      follower.style.setProperty("--v-transform-origin", properTransformOrigin);
      follower.style.transformOrigin = properTransformOrigin;
    };
    watch(mergedEnabledRef, (value) => {
      if (value) {
        ensureListeners();
        syncOnNextTick();
      } else {
        removeListeners();
      }
    });
    const syncOnNextTick = () => {
      nextTick().then(syncPosition).catch((e3) => console.error(e3));
    };
    [
      "placement",
      "x",
      "y",
      "internalShift",
      "flip",
      "width",
      "overlap",
      "minWidth"
    ].forEach((prop) => {
      watch(toRef(props, prop), syncPosition);
    });
    ["teleportDisabled"].forEach((prop) => {
      watch(toRef(props, prop), syncOnNextTick);
    });
    watch(toRef(props, "syncTrigger"), (value) => {
      if (!value.includes("resize")) {
        VBinder.removeResizeListener(syncPosition);
      } else {
        VBinder.addResizeListener(syncPosition);
      }
      if (!value.includes("scroll")) {
        VBinder.removeScrollListener(syncPosition);
      } else {
        VBinder.addScrollListener(syncPosition);
      }
    });
    const isMountedRef = isMounted();
    const mergedToRef = use_memo_default(() => {
      const { to: to2 } = props;
      if (to2 !== void 0)
        return to2;
      if (isMountedRef.value) {
        return void 0;
      }
      return void 0;
    });
    return {
      VBinder,
      mergedEnabled: mergedEnabledRef,
      offsetContainerRef,
      followerRef,
      mergedTo: mergedToRef,
      syncPosition
    };
  },
  render() {
    return h3(src_default, {
      show: this.show,
      to: this.mergedTo,
      disabled: this.teleportDisabled
    }, {
      default: () => {
        var _a3, _b2;
        const vNode = h3("div", {
          class: ["v-binder-follower-container", this.containerClass],
          ref: "offsetContainerRef"
        }, [
          h3("div", {
            class: "v-binder-follower-content",
            ref: "followerRef"
          }, (_b2 = (_a3 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a3))
        ]);
        if (this.zindexable) {
          return withDirectives(vNode, [
            [
              zindexable_default,
              {
                enabled: this.mergedEnabled,
                zIndex: this.zIndex
              }
            ]
          ]);
        }
        return vNode;
      }
    });
  }
});

// node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers = [];

// node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

// node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze = function(obj) {
  return Object.freeze(obj);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize = function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
}();

// node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x2, y3, width, height) {
    this.x = x2;
    this.y = y3;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a3 = this, x2 = _a3.x, y3 = _a3.y, top = _a3.top, right = _a3.right, bottom = _a3.bottom, left = _a3.left, width = _a3.width, height = _a3.height;
    return { x: x2, y: y3, top, right, bottom, left, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
}();

// node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a3 = target.getBBox(), width = _a3.width, height = _a3.height;
    return !width && !height;
  }
  var _b2 = target, offsetWidth = _b2.offsetWidth, offsetHeight = _b2.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
  var _a3;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a3 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a3 === void 0 ? void 0 : _a3.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};

// node_modules/@juggle/resize-observer/lib/utils/global.js
var global2 = typeof window !== "undefined" ? window : {};

// node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global2.navigator && global2.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size2 = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size2(),
  borderBoxSize: size2(),
  contentBoxSize: size2(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size2(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size2(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size2(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a3 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a3.borderBoxSize, contentBoxSize = _a3.contentBoxSize, devicePixelContentBoxSize = _a3.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}();

// node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode = function(node) {
  if (isHidden(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback2 = callbacks_1[_i];
    callback2();
  }
  return shallowestDepth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};

// node_modules/@juggle/resize-observer/lib/utils/process.js
var process2 = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};

// node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger2;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback2) {
  if (!trigger2) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger2 = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback2);
  trigger2();
};

// node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver3() {
    requestAnimationFrame(cb);
  });
};

// node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process2();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global2.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name2) {
        return global2.addEventListener(name2, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name2) {
        return global2.removeEventListener(name2, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function(n2) {
  !watching && n2 > 0 && scheduler.start();
  watching += n2;
  !watching && scheduler.stop();
};

// node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size3 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size3;
    }
    if (this.lastReportedSize.inlineSize !== size3.inlineSize || this.lastReportedSize.blockSize !== size3.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail = function() {
  function ResizeObserverDetail2(resizeObserver, callback2) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback2;
  }
  return ResizeObserverDetail2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i3 = 0; i3 < observationTargets.length; i3 += 1) {
    if (observationTargets[i3].target === target) {
      return i3;
    }
  }
  return -1;
};
var ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback2) {
    var detail = new ResizeObserverDetail(resizeObserver, callback2);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index2 = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index2 >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index2, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver2 = function() {
  function ResizeObserver3(callback2) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback2 !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback2);
  }
  ResizeObserver3.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver3.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver3.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver3.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver3;
}();

// node_modules/vueuc/es/resize-observer/src/delegate.js
var ResizeObserverDelegate = class {
  constructor() {
    this.handleResize = this.handleResize.bind(this);
    this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver2)(this.handleResize);
    this.elHandlersMap = /* @__PURE__ */ new Map();
  }
  handleResize(entries) {
    for (const entry of entries) {
      const handler = this.elHandlersMap.get(entry.target);
      if (handler !== void 0) {
        handler(entry);
      }
    }
  }
  registerHandler(el, handler) {
    this.elHandlersMap.set(el, handler);
    this.observer.observe(el);
  }
  unregisterHandler(el) {
    if (!this.elHandlersMap.has(el)) {
      return;
    }
    this.elHandlersMap.delete(el);
    this.observer.unobserve(el);
  }
};
var delegate_default = new ResizeObserverDelegate();

// node_modules/vueuc/es/resize-observer/src/VResizeObserver.js
var VResizeObserver_default = defineComponent({
  name: "ResizeObserver",
  props: {
    onResize: Function
  },
  setup(props) {
    let registered = false;
    const proxy = getCurrentInstance().proxy;
    function handleResize(entry) {
      const { onResize } = props;
      if (onResize !== void 0)
        onResize(entry);
    }
    onMounted(() => {
      const el = proxy.$el;
      if (el === void 0) {
        warn4("resize-observer", "$el does not exist.");
        return;
      }
      if (el.nextElementSibling !== el.nextSibling) {
        if (el.nodeType === 3 && el.nodeValue !== "") {
          warn4("resize-observer", "$el can not be observed (it may be a text node).");
          return;
        }
      }
      if (el.nextElementSibling !== null) {
        delegate_default.registerHandler(el.nextElementSibling, handleResize);
        registered = true;
      }
    });
    onBeforeUnmount(() => {
      if (registered) {
        delegate_default.unregisterHandler(proxy.$el.nextElementSibling);
      }
    });
  },
  render() {
    return renderSlot(this.$slots, "default");
  }
});

// node_modules/vueuc/es/focus-trap/src/utils.js
function isHTMLElement(node) {
  return node instanceof HTMLElement;
}
function focusFirstDescendant(node) {
  for (let i3 = 0; i3 < node.childNodes.length; i3++) {
    const child = node.childNodes[i3];
    if (isHTMLElement(child)) {
      if (attemptFocus(child) || focusFirstDescendant(child)) {
        return true;
      }
    }
  }
  return false;
}
function focusLastDescendant(element2) {
  for (let i3 = element2.childNodes.length - 1; i3 >= 0; i3--) {
    const child = element2.childNodes[i3];
    if (isHTMLElement(child)) {
      if (attemptFocus(child) || focusLastDescendant(child)) {
        return true;
      }
    }
  }
  return false;
}
function attemptFocus(element2) {
  if (!isFocusable(element2)) {
    return false;
  }
  try {
    element2.focus({ preventScroll: true });
  } catch (e3) {
  }
  return document.activeElement === element2;
}
function isFocusable(element2) {
  if (element2.tabIndex > 0 || element2.tabIndex === 0 && element2.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (element2.getAttribute("disabled")) {
    return false;
  }
  switch (element2.nodeName) {
    case "A":
      return !!element2.href && element2.rel !== "ignore";
    case "INPUT":
      return element2.type !== "hidden" && element2.type !== "file";
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
      return true;
    default:
      return false;
  }
}

// node_modules/vueuc/es/focus-trap/src/index.js
var stack2 = [];
var FocusTrap = defineComponent({
  name: "FocusTrap",
  props: {
    disabled: Boolean,
    active: Boolean,
    autoFocus: {
      type: Boolean,
      default: true
    },
    onEsc: Function,
    initialFocusTo: String,
    finalFocusTo: String,
    returnFocusOnDeactivated: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const id = createId();
    const focusableStartRef = ref(null);
    const focusableEndRef = ref(null);
    let activated = false;
    let ignoreInternalFocusChange = false;
    const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
    function isCurrentActive() {
      const currentActiveId = stack2[stack2.length - 1];
      return currentActiveId === id;
    }
    function handleDocumentKeydown(e3) {
      var _a3;
      if (e3.code === "Escape") {
        if (isCurrentActive()) {
          (_a3 = props.onEsc) === null || _a3 === void 0 ? void 0 : _a3.call(props, e3);
        }
      }
    }
    onMounted(() => {
      watch(() => props.active, (value) => {
        if (value) {
          activate();
          on("keydown", document, handleDocumentKeydown);
        } else {
          off("keydown", document, handleDocumentKeydown);
          if (activated) {
            deactivate();
          }
        }
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(() => {
      off("keydown", document, handleDocumentKeydown);
      if (activated)
        deactivate();
    });
    function handleDocumentFocus(e3) {
      if (ignoreInternalFocusChange)
        return;
      if (isCurrentActive()) {
        const mainEl = getMainEl();
        if (mainEl === null)
          return;
        if (mainEl.contains(getPreciseEventTarget(e3)))
          return;
        resetFocusTo("first");
      }
    }
    function getMainEl() {
      const focusableStartEl = focusableStartRef.value;
      if (focusableStartEl === null)
        return null;
      let mainEl = focusableStartEl;
      while (true) {
        mainEl = mainEl.nextSibling;
        if (mainEl === null)
          break;
        if (mainEl instanceof Element && mainEl.tagName === "DIV") {
          break;
        }
      }
      return mainEl;
    }
    function activate() {
      var _a3;
      if (props.disabled)
        return;
      stack2.push(id);
      if (props.autoFocus) {
        const { initialFocusTo } = props;
        if (initialFocusTo === void 0) {
          resetFocusTo("first");
        } else {
          (_a3 = resolveTo(initialFocusTo)) === null || _a3 === void 0 ? void 0 : _a3.focus({ preventScroll: true });
        }
      }
      activated = true;
      document.addEventListener("focus", handleDocumentFocus, true);
    }
    function deactivate() {
      var _a3;
      if (props.disabled)
        return;
      document.removeEventListener("focus", handleDocumentFocus, true);
      stack2 = stack2.filter((idInStack) => idInStack !== id);
      if (isCurrentActive())
        return;
      const { finalFocusTo } = props;
      if (finalFocusTo !== void 0) {
        (_a3 = resolveTo(finalFocusTo)) === null || _a3 === void 0 ? void 0 : _a3.focus({ preventScroll: true });
      } else if (props.returnFocusOnDeactivated) {
        if (lastFocusedElement instanceof HTMLElement) {
          ignoreInternalFocusChange = true;
          lastFocusedElement.focus({ preventScroll: true });
          ignoreInternalFocusChange = false;
        }
      }
    }
    function resetFocusTo(target) {
      if (!isCurrentActive())
        return;
      if (props.active) {
        const focusableStartEl = focusableStartRef.value;
        const focusableEndEl = focusableEndRef.value;
        if (focusableStartEl !== null && focusableEndEl !== null) {
          const mainEl = getMainEl();
          if (mainEl == null || mainEl === focusableEndEl) {
            ignoreInternalFocusChange = true;
            focusableStartEl.focus({ preventScroll: true });
            ignoreInternalFocusChange = false;
            return;
          }
          ignoreInternalFocusChange = true;
          const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
          ignoreInternalFocusChange = false;
          if (!focused) {
            ignoreInternalFocusChange = true;
            focusableStartEl.focus({ preventScroll: true });
            ignoreInternalFocusChange = false;
          }
        }
      }
    }
    function handleStartFocus(e3) {
      if (ignoreInternalFocusChange)
        return;
      const mainEl = getMainEl();
      if (mainEl === null)
        return;
      if (e3.relatedTarget !== null && mainEl.contains(e3.relatedTarget)) {
        resetFocusTo("last");
      } else {
        resetFocusTo("first");
      }
    }
    function handleEndFocus(e3) {
      if (ignoreInternalFocusChange)
        return;
      if (e3.relatedTarget !== null && e3.relatedTarget === focusableStartRef.value) {
        resetFocusTo("last");
      } else {
        resetFocusTo("first");
      }
    }
    return {
      focusableStartRef,
      focusableEndRef,
      focusableStyle: "position: absolute; height: 0; width: 0;",
      handleStartFocus,
      handleEndFocus
    };
  },
  render() {
    const { default: defaultSlot } = this.$slots;
    if (defaultSlot === void 0)
      return null;
    if (this.disabled)
      return defaultSlot();
    const { active, focusableStyle } = this;
    return h3(Fragment, null, [
      h3("div", {
        "aria-hidden": "true",
        tabindex: active ? "0" : "-1",
        ref: "focusableStartRef",
        style: focusableStyle,
        onFocus: this.handleStartFocus
      }),
      defaultSlot(),
      h3("div", {
        "aria-hidden": "true",
        style: focusableStyle,
        ref: "focusableEndRef",
        tabindex: active ? "0" : "-1",
        onFocus: this.handleEndFocus
      })
    ]);
  }
});

// node_modules/naive-ui/es/_utils/composable/use-reactivated.js
function useReactivated(callback2) {
  const isDeactivatedRef = { isDeactivated: false };
  let activateStateInitialized = false;
  onActivated(() => {
    isDeactivatedRef.isDeactivated = false;
    if (!activateStateInitialized) {
      activateStateInitialized = true;
      return;
    }
    callback2();
  });
  onDeactivated(() => {
    isDeactivatedRef.isDeactivated = true;
    if (!activateStateInitialized) {
      activateStateInitialized = true;
    }
  });
  return isDeactivatedRef;
}

// node_modules/naive-ui/es/_mixins/use-form-item.js
var formItemInjectionKey = createInjectionKey("n-form-item");
function useFormItem(props, { defaultSize = "medium", mergedSize, mergedDisabled } = {}) {
  const NFormItem = inject(formItemInjectionKey, null);
  provide(formItemInjectionKey, null);
  const mergedSizeRef = computed2(mergedSize ? () => mergedSize(NFormItem) : () => {
    const { size: size3 } = props;
    if (size3)
      return size3;
    if (NFormItem) {
      const { mergedSize: mergedSize2 } = NFormItem;
      if (mergedSize2.value !== void 0) {
        return mergedSize2.value;
      }
    }
    return defaultSize;
  });
  const mergedDisabledRef = computed2(mergedDisabled ? () => mergedDisabled(NFormItem) : () => {
    const { disabled } = props;
    if (disabled !== void 0) {
      return disabled;
    }
    if (NFormItem) {
      return NFormItem.disabled.value;
    }
    return false;
  });
  const mergedStatusRef = computed2(() => {
    const { status } = props;
    if (status)
      return status;
    return NFormItem === null || NFormItem === void 0 ? void 0 : NFormItem.mergedValidationStatus.value;
  });
  onBeforeUnmount(() => {
    if (NFormItem) {
      NFormItem.restoreValidation();
    }
  });
  return {
    mergedSizeRef,
    mergedDisabledRef,
    mergedStatusRef,
    nTriggerFormBlur() {
      if (NFormItem) {
        NFormItem.handleContentBlur();
      }
    },
    nTriggerFormChange() {
      if (NFormItem) {
        NFormItem.handleContentChange();
      }
    },
    nTriggerFormFocus() {
      if (NFormItem) {
        NFormItem.handleContentFocus();
      }
    },
    nTriggerFormInput() {
      if (NFormItem) {
        NFormItem.handleContentInput();
      }
    }
  };
}

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty2 = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString2(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString2;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol2(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol2;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray3 = Array.isArray;
var isArray_default = isArray3;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/isObject.js
function isObject2(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject2;

// node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction2(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction2;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid3 = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid3 ? "Symbol(src)_1." + uid3 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty3 = objectProto3.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString2.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e3) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto4 = Object.prototype;
var hasOwnProperty4 = objectProto4.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty4.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform(array);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index2, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index2, object.length) : type == "string" && index2 in object) {
    return eq_default(object[index2], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/_isPrototype.js
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto6 = Object.prototype;
var hasOwnProperty5 = objectProto6.hasOwnProperty;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty5.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e3) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty6 = objectProto7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty6.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty7 = objectProto8.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty7.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto9 = Object.prototype;
var hasOwnProperty8 = objectProto9.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty8.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto10 = Object.prototype;
var hasOwnProperty9 = objectProto10.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty9.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto11 = Object.prototype;
var hasOwnProperty10 = objectProto11.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty10.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map4, key) {
  var data = map4.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size3 = data.size;
  data.set(key, value);
  this.size += data.size == size3 ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match3, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match3);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey_default(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get2(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get2;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values) {
  var index2 = -1, length = values.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values[index2];
  }
  return array;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto12 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty11 = objectProto12.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject2(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty11.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject2;

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array, start, end) {
  var index2 = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array[index2 + start];
  }
  return result;
}
var baseSlice_default = baseSlice;

// node_modules/lodash-es/_castSlice.js
function castSlice(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice_default(array, start, end);
}
var castSlice_default = castSlice;

// node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var hasUnicode_default = hasUnicode;

// node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string) {
  return string.split("");
}
var asciiToArray_default = asciiToArray;

// node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// node_modules/lodash-es/_stringToArray.js
function stringToArray(string) {
  return hasUnicode_default(string) ? unicodeToArray_default(string) : asciiToArray_default(string);
}
var stringToArray_default = stringToArray;

// node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string) {
    string = toString_default(string);
    var strSymbols = hasUnicode_default(string) ? stringToArray_default(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default = createCaseFirst;

// node_modules/lodash-es/upperFirst.js
var upperFirst = createCaseFirst_default("toUpperCase");
var upperFirst_default = upperFirst;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer3 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto13 = Object.prototype;
var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_DataView.js
var DataView = getNative_default(root_default, "DataView");
var DataView_default = DataView;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache_default();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack3) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack3.get(array);
  var othStacked = stack3.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack3.set(array, other);
  stack3.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack3) : customizer(arrValue, othValue, index2, array, other, stack3);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack3))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack3))) {
      result = false;
      break;
    }
  }
  stack3["delete"](array);
  stack3["delete"](other);
  return result;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map4) {
  var index2 = -1, result = Array(map4.size);
  map4.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack3) {
  switch (tag) {
    case dataViewTag3:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag2:
    case dateTag2:
    case numberTag2:
      return eq_default(+object, +other);
    case errorTag2:
      return object.name == other.name && object.message == other.message;
    case regexpTag2:
    case stringTag2:
      return object == other + "";
    case mapTag3:
      var convert = mapToArray_default;
    case setTag3:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack3.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack3.set(object, other);
      var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack3);
      stack3["delete"](object);
      return result;
    case symbolTag2:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto14 = Object.prototype;
var hasOwnProperty12 = objectProto14.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack3) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty12.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack3.get(object);
  var othStacked = stack3.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack3.set(object, other);
  stack3.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack3) : customizer(objValue, othValue, key, object, other, stack3);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack3) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack3["delete"](object);
  stack3["delete"](other);
  return result;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag4 = "[object Object]";
var objectProto15 = Object.prototype;
var hasOwnProperty13 = objectProto15.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack3) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object), othTag = othIsArr ? arrayTag2 : getTag_default(other);
  objTag = objTag == argsTag3 ? objectTag4 : objTag;
  othTag = othTag == argsTag3 ? objectTag4 : othTag;
  var objIsObj = objTag == objectTag4, othIsObj = othTag == objectTag4, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack3 || (stack3 = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack3) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack3);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty13.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty13.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack3 || (stack3 = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack3);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack3 || (stack3 = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack3);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack3) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack3);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack3 = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack3);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack3) : result)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result = keys_default(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey_default(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function(object) {
    return baseGet_default(object, path);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
var property_default = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack3) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack3.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack3) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack3.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack3);
    stack3["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack3) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack3 || (stack3 = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack3);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack3) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var baseMap_default = baseMap;

// node_modules/lodash-es/map.js
function map(collection, iteratee) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee, 3));
}
var map_default = map;

// node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge;

// node_modules/naive-ui/es/_styles/common/_common.js
var common_default = {
  fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
  fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
  fontWeight: "400",
  fontWeightStrong: "500",
  cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
  cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
  cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
  borderRadius: "3px",
  borderRadiusSmall: "2px",
  fontSize: "14px",
  fontSizeMini: "12px",
  fontSizeTiny: "12px",
  fontSizeSmall: "14px",
  fontSizeMedium: "14px",
  fontSizeLarge: "15px",
  fontSizeHuge: "16px",
  lineHeight: "1.6",
  heightMini: "16px",
  heightTiny: "22px",
  heightSmall: "28px",
  heightMedium: "34px",
  heightLarge: "40px",
  heightHuge: "46px"
};

// node_modules/naive-ui/es/_styles/global/index.cssr.js
var {
  fontSize,
  fontFamily,
  lineHeight
} = common_default;
var index_cssr_default = c3("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c3("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);

// node_modules/naive-ui/es/config-provider/src/context.js
var configProviderInjectionKey = createInjectionKey("n-config-provider");

// node_modules/naive-ui/es/_mixins/common.js
var cssrAnchorMetaName2 = "naive-ui-style";

// node_modules/naive-ui/es/_mixins/use-theme.js
function createTheme(theme) {
  return theme;
}
function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
  const ssrAdapter2 = useSsrAdapter();
  const NConfigProvider = inject(configProviderInjectionKey, null);
  if (style2) {
    const mountStyle = () => {
      const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
      style2.mount({
        id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
        head: true,
        props: {
          bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
        },
        anchorMetaName: cssrAnchorMetaName2,
        ssr: ssrAdapter2
      });
      if (!(NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled)) {
        index_cssr_default.mount({
          id: "n-global",
          head: true,
          anchorMetaName: cssrAnchorMetaName2,
          ssr: ssrAdapter2
        });
      }
    };
    if (ssrAdapter2) {
      mountStyle();
    } else {
      onBeforeMount(mountStyle);
    }
  }
  const mergedThemeRef = computed2(() => {
    var _a3;
    const { theme: { common: selfCommon, self: self79, peers = {} } = {}, themeOverrides: selfOverrides = {}, builtinThemeOverrides: builtinOverrides = {} } = props;
    const { common: selfCommonOverrides, peers: peersOverrides } = selfOverrides;
    const { common: globalCommon = void 0, [resolveId]: { common: globalSelfCommon = void 0, self: globalSelf = void 0, peers: globalPeers = {} } = {} } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value) || {};
    const { common: globalCommonOverrides = void 0, [resolveId]: globalSelfOverrides = {} } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value) || {};
    const { common: globalSelfCommonOverrides, peers: globalPeersOverrides = {} } = globalSelfOverrides;
    const mergedCommon = merge_default({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
    const mergedSelf = merge_default((_a3 = self79 || globalSelf || defaultTheme.self) === null || _a3 === void 0 ? void 0 : _a3(mergedCommon), builtinOverrides, globalSelfOverrides, selfOverrides);
    return {
      common: mergedCommon,
      self: mergedSelf,
      peers: merge_default({}, defaultTheme.peers, globalPeers, peers),
      peerOverrides: merge_default({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
    };
  });
  return mergedThemeRef;
}
useTheme.props = {
  theme: Object,
  themeOverrides: Object,
  builtinThemeOverrides: Object
};
var use_theme_default = useTheme;

// node_modules/naive-ui/es/_mixins/use-config.js
var defaultClsPrefix = "n";
function useConfig(props = {}, options = {
  defaultBordered: true
}) {
  const NConfigProvider = inject(configProviderInjectionKey, null);
  return {
    inlineThemeDisabled: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.inlineThemeDisabled,
    mergedRtlRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef,
    mergedComponentPropsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef,
    mergedBreakpointsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBreakpointsRef,
    mergedBorderedRef: computed2(() => {
      var _a3, _b2;
      const { bordered } = props;
      if (bordered !== void 0)
        return bordered;
      return (_b2 = (_a3 = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value) !== null && _a3 !== void 0 ? _a3 : options.defaultBordered) !== null && _b2 !== void 0 ? _b2 : true;
    }),
    mergedClsPrefixRef: computed2(() => {
      const clsPrefix = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedClsPrefixRef.value;
      return clsPrefix || defaultClsPrefix;
    }),
    namespaceRef: computed2(() => NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value)
  };
}

// node_modules/naive-ui/es/locales/common/zhCN.js
var zhCN = {
  name: "zh-CN",
  global: {
    undo: "\u64A4\u9500",
    redo: "\u91CD\u505A",
    confirm: "\u786E\u8BA4",
    clear: "\u6E05\u9664"
  },
  Popconfirm: {
    positiveText: "\u786E\u8BA4",
    negativeText: "\u53D6\u6D88"
  },
  Cascader: {
    placeholder: "\u8BF7\u9009\u62E9",
    loading: "\u52A0\u8F7D\u4E2D",
    loadingRequiredMessage: (label) => `\u52A0\u8F7D\u5168\u90E8 ${label} \u7684\u5B50\u8282\u70B9\u540E\u624D\u53EF\u9009\u4E2D`
  },
  Time: {
    dateFormat: "yyyy-MM-dd",
    dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
  },
  DatePicker: {
    yearFormat: "yyyy\u5E74",
    monthFormat: "MMM",
    dayFormat: "eeeeee",
    yearTypeFormat: "yyyy",
    monthTypeFormat: "yyyy-MM",
    dateFormat: "yyyy-MM-dd",
    dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
    quarterFormat: "yyyy-qqq",
    clear: "\u6E05\u9664",
    now: "\u6B64\u523B",
    confirm: "\u786E\u8BA4",
    selectTime: "\u9009\u62E9\u65F6\u95F4",
    selectDate: "\u9009\u62E9\u65E5\u671F",
    datePlaceholder: "\u9009\u62E9\u65E5\u671F",
    datetimePlaceholder: "\u9009\u62E9\u65E5\u671F\u65F6\u95F4",
    monthPlaceholder: "\u9009\u62E9\u6708\u4EFD",
    yearPlaceholder: "\u9009\u62E9\u5E74\u4EFD",
    quarterPlaceholder: "\u9009\u62E9\u5B63\u5EA6",
    startDatePlaceholder: "\u5F00\u59CB\u65E5\u671F",
    endDatePlaceholder: "\u7ED3\u675F\u65E5\u671F",
    startDatetimePlaceholder: "\u5F00\u59CB\u65E5\u671F\u65F6\u95F4",
    endDatetimePlaceholder: "\u7ED3\u675F\u65E5\u671F\u65F6\u95F4",
    startMonthPlaceholder: "\u5F00\u59CB\u6708\u4EFD",
    endMonthPlaceholder: "\u7ED3\u675F\u6708\u4EFD",
    monthBeforeYear: false,
    firstDayOfWeek: 0,
    today: "\u4ECA\u5929"
  },
  DataTable: {
    checkTableAll: "\u9009\u62E9\u5168\u90E8\u8868\u683C\u6570\u636E",
    uncheckTableAll: "\u53D6\u6D88\u9009\u62E9\u5168\u90E8\u8868\u683C\u6570\u636E",
    confirm: "\u786E\u8BA4",
    clear: "\u91CD\u7F6E"
  },
  LegacyTransfer: {
    sourceTitle: "\u6E90\u9879",
    targetTitle: "\u76EE\u6807\u9879"
  },
  Transfer: {
    selectAll: "\u5168\u9009",
    clearAll: "\u6E05\u9664",
    unselectAll: "\u53D6\u6D88\u5168\u9009",
    total: (num) => `\u5171 ${num} \u9879`,
    selected: (num) => `\u5DF2\u9009 ${num} \u9879`
  },
  Empty: {
    description: "\u65E0\u6570\u636E"
  },
  Select: {
    placeholder: "\u8BF7\u9009\u62E9"
  },
  TimePicker: {
    placeholder: "\u8BF7\u9009\u62E9\u65F6\u95F4",
    positiveText: "\u786E\u8BA4",
    negativeText: "\u53D6\u6D88",
    now: "\u6B64\u523B"
  },
  Pagination: {
    goto: "\u8DF3\u81F3",
    selectionSuffix: "\u9875"
  },
  DynamicTags: {
    add: "\u6DFB\u52A0"
  },
  Log: {
    loading: "\u52A0\u8F7D\u4E2D"
  },
  Input: {
    placeholder: "\u8BF7\u8F93\u5165"
  },
  InputNumber: {
    placeholder: "\u8BF7\u8F93\u5165"
  },
  DynamicInput: {
    create: "\u6DFB\u52A0"
  },
  ThemeEditor: {
    title: "\u4E3B\u9898\u7F16\u8F91\u5668",
    clearAllVars: "\u6E05\u9664\u5168\u90E8\u53D8\u91CF",
    clearSearch: "\u6E05\u9664\u641C\u7D22",
    filterCompName: "\u8FC7\u6EE4\u7EC4\u4EF6\u540D",
    filterVarName: "\u8FC7\u6EE4\u53D8\u91CF\u540D",
    import: "\u5BFC\u5165",
    export: "\u5BFC\u51FA",
    restore: "\u6062\u590D\u9ED8\u8BA4"
  },
  Image: {
    tipPrevious: "\u4E0A\u4E00\u5F20\uFF08\u2190\uFF09",
    tipNext: "\u4E0B\u4E00\u5F20\uFF08\u2192\uFF09",
    tipCounterclockwise: "\u5411\u5DE6\u65CB\u8F6C",
    tipClockwise: "\u5411\u53F3\u65CB\u8F6C",
    tipZoomOut: "\u7F29\u5C0F",
    tipZoomIn: "\u653E\u5927",
    tipClose: "\u5173\u95ED\uFF08Esc\uFF09",
    tipOriginalSize: "\u7F29\u653E\u5230\u539F\u59CB\u5C3A\u5BF8"
  }
};
var zhCN_default = zhCN;

// node_modules/naive-ui/es/locales/common/enUS.js
var enUS = {
  name: "en-US",
  global: {
    undo: "Undo",
    redo: "Redo",
    confirm: "Confirm",
    clear: "Clear"
  },
  Popconfirm: {
    positiveText: "Confirm",
    negativeText: "Cancel"
  },
  Cascader: {
    placeholder: "Please Select",
    loading: "Loading",
    loadingRequiredMessage: (label) => `Please load all ${label}'s descendants before checking it.`
  },
  Time: {
    dateFormat: "yyyy-MM-dd",
    dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
  },
  DatePicker: {
    yearFormat: "yyyy",
    monthFormat: "MMM",
    dayFormat: "eeeeee",
    yearTypeFormat: "yyyy",
    monthTypeFormat: "yyyy-MM",
    dateFormat: "yyyy-MM-dd",
    dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
    quarterFormat: "yyyy-qqq",
    clear: "Clear",
    now: "Now",
    confirm: "Confirm",
    selectTime: "Select Time",
    selectDate: "Select Date",
    datePlaceholder: "Select Date",
    datetimePlaceholder: "Select Date and Time",
    monthPlaceholder: "Select Month",
    yearPlaceholder: "Select Year",
    quarterPlaceholder: "Select Quarter",
    startDatePlaceholder: "Start Date",
    endDatePlaceholder: "End Date",
    startDatetimePlaceholder: "Start Date and Time",
    endDatetimePlaceholder: "End Date and Time",
    startMonthPlaceholder: "Start Month",
    endMonthPlaceholder: "End Month",
    monthBeforeYear: true,
    firstDayOfWeek: 6,
    today: "Today"
  },
  DataTable: {
    checkTableAll: "Select all in the table",
    uncheckTableAll: "Unselect all in the table",
    confirm: "Confirm",
    clear: "Clear"
  },
  LegacyTransfer: {
    sourceTitle: "Source",
    targetTitle: "Target"
  },
  Transfer: {
    selectAll: "Select all",
    unselectAll: "Unselect all",
    clearAll: "Clear",
    total: (num) => `Total ${num} items`,
    selected: (num) => `${num} items selected`
  },
  Empty: {
    description: "No Data"
  },
  Select: {
    placeholder: "Please Select"
  },
  TimePicker: {
    placeholder: "Select Time",
    positiveText: "OK",
    negativeText: "Cancel",
    now: "Now"
  },
  Pagination: {
    goto: "Goto",
    selectionSuffix: "page"
  },
  DynamicTags: {
    add: "Add"
  },
  Log: {
    loading: "Loading"
  },
  Input: {
    placeholder: "Please Input"
  },
  InputNumber: {
    placeholder: "Please Input"
  },
  DynamicInput: {
    create: "Create"
  },
  ThemeEditor: {
    title: "Theme Editor",
    clearAllVars: "Clear All Variables",
    clearSearch: "Clear Search",
    filterCompName: "Filter Component Name",
    filterVarName: "Filter Variable Name",
    import: "Import",
    export: "Export",
    restore: "Reset to Default"
  },
  Image: {
    tipPrevious: "Previous picture (\u2190)",
    tipNext: "Next picture (\u2192)",
    tipCounterclockwise: "Counterclockwise",
    tipClockwise: "Clockwise",
    tipZoomOut: "Zoom out",
    tipZoomIn: "Zoom in",
    tipClose: "Close (Esc)",
    tipOriginalSize: "Zoom to original size"
  }
};
var enUS_default = enUS;

// node_modules/date-fns/esm/locale/zh-CN/_lib/formatDistance/index.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "\u4E0D\u5230 1 \u79D2",
    other: "\u4E0D\u5230 {{count}} \u79D2"
  },
  xSeconds: {
    one: "1 \u79D2",
    other: "{{count}} \u79D2"
  },
  halfAMinute: "\u534A\u5206\u949F",
  lessThanXMinutes: {
    one: "\u4E0D\u5230 1 \u5206\u949F",
    other: "\u4E0D\u5230 {{count}} \u5206\u949F"
  },
  xMinutes: {
    one: "1 \u5206\u949F",
    other: "{{count}} \u5206\u949F"
  },
  xHours: {
    one: "1 \u5C0F\u65F6",
    other: "{{count}} \u5C0F\u65F6"
  },
  aboutXHours: {
    one: "\u5927\u7EA6 1 \u5C0F\u65F6",
    other: "\u5927\u7EA6 {{count}} \u5C0F\u65F6"
  },
  xDays: {
    one: "1 \u5929",
    other: "{{count}} \u5929"
  },
  aboutXWeeks: {
    one: "\u5927\u7EA6 1 \u4E2A\u661F\u671F",
    other: "\u5927\u7EA6 {{count}} \u4E2A\u661F\u671F"
  },
  xWeeks: {
    one: "1 \u4E2A\u661F\u671F",
    other: "{{count}} \u4E2A\u661F\u671F"
  },
  aboutXMonths: {
    one: "\u5927\u7EA6 1 \u4E2A\u6708",
    other: "\u5927\u7EA6 {{count}} \u4E2A\u6708"
  },
  xMonths: {
    one: "1 \u4E2A\u6708",
    other: "{{count}} \u4E2A\u6708"
  },
  aboutXYears: {
    one: "\u5927\u7EA6 1 \u5E74",
    other: "\u5927\u7EA6 {{count}} \u5E74"
  },
  xYears: {
    one: "1 \u5E74",
    other: "{{count}} \u5E74"
  },
  overXYears: {
    one: "\u8D85\u8FC7 1 \u5E74",
    other: "\u8D85\u8FC7 {{count}} \u5E74"
  },
  almostXYears: {
    one: "\u5C06\u8FD1 1 \u5E74",
    other: "\u5C06\u8FD1 {{count}} \u5E74"
  }
};
var formatDistance = function formatDistance2(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "\u5185";
    } else {
      return result + "\u524D";
    }
  }
  return result;
};
var formatDistance_default = formatDistance;

// node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/date-fns/esm/locale/zh-CN/_lib/formatLong/index.js
var dateFormats = {
  full: "y'\u5E74'M'\u6708'd'\u65E5' EEEE",
  long: "y'\u5E74'M'\u6708'd'\u65E5'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
var timeFormats = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
var dateTimeFormats = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong_default = formatLong;

// node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}

// node_modules/date-fns/esm/toDate/index.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof3(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof3(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

// node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

// node_modules/date-fns/esm/_lib/defaultOptions/index.js
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

// node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/isSameUTCWeek/index.js
function isSameUTCWeek(dirtyDateLeft, dirtyDateRight, options) {
  requiredArgs(2, arguments);
  var dateLeftStartOfWeek = startOfUTCWeek(dirtyDateLeft, options);
  var dateRightStartOfWeek = startOfUTCWeek(dirtyDateRight, options);
  return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
}

// node_modules/date-fns/esm/locale/zh-CN/_lib/formatRelative/index.js
function checkWeek(date, baseDate, options) {
  var baseFormat = "eeee p";
  if (isSameUTCWeek(date, baseDate, options)) {
    return baseFormat;
  } else if (date.getTime() > baseDate.getTime()) {
    return "'\u4E0B\u4E2A'" + baseFormat;
  }
  return "'\u4E0A\u4E2A'" + baseFormat;
}
var formatRelativeLocale = {
  lastWeek: checkWeek,
  yesterday: "'\u6628\u5929' p",
  today: "'\u4ECA\u5929' p",
  tomorrow: "'\u660E\u5929' p",
  nextWeek: checkWeek,
  other: "PP p"
};
var formatRelative = function formatRelative2(token, date, baseDate, options) {
  var format2 = formatRelativeLocale[token];
  if (typeof format2 === "function") {
    return format2(date, baseDate, options);
  }
  return format2;
};
var formatRelative_default = formatRelative;

// node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}

// node_modules/date-fns/esm/locale/zh-CN/_lib/localize/index.js
var eraValues = {
  narrow: ["\u524D", "\u516C\u5143"],
  abbreviated: ["\u524D", "\u516C\u5143"],
  wide: ["\u516C\u5143\u524D", "\u516C\u5143"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["\u7B2C\u4E00\u5B63", "\u7B2C\u4E8C\u5B63", "\u7B2C\u4E09\u5B63", "\u7B2C\u56DB\u5B63"],
  wide: ["\u7B2C\u4E00\u5B63\u5EA6", "\u7B2C\u4E8C\u5B63\u5EA6", "\u7B2C\u4E09\u5B63\u5EA6", "\u7B2C\u56DB\u5B63\u5EA6"]
};
var monthValues = {
  narrow: ["\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D", "\u5341", "\u5341\u4E00", "\u5341\u4E8C"],
  abbreviated: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"],
  wide: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"]
};
var dayValues = {
  narrow: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
  short: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
  abbreviated: ["\u5468\u65E5", "\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D"],
  wide: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"]
};
var dayPeriodValues = {
  narrow: {
    am: "\u4E0A",
    pm: "\u4E0B",
    midnight: "\u51CC\u6668",
    noon: "\u5348",
    morning: "\u65E9",
    afternoon: "\u4E0B\u5348",
    evening: "\u665A",
    night: "\u591C"
  },
  abbreviated: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  },
  wide: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "\u4E0A",
    pm: "\u4E0B",
    midnight: "\u51CC\u6668",
    noon: "\u5348",
    morning: "\u65E9",
    afternoon: "\u4E0B\u5348",
    evening: "\u665A",
    night: "\u591C"
  },
  abbreviated: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  },
  wide: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, options) {
  var number = Number(dirtyNumber);
  switch (options === null || options === void 0 ? void 0 : options.unit) {
    case "date":
      return number.toString() + "\u65E5";
    case "hour":
      return number.toString() + "\u65F6";
    case "minute":
      return number.toString() + "\u5206";
    case "second":
      return number.toString() + "\u79D2";
    default:
      return "\u7B2C " + number.toString();
  }
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize_default = localize;

// node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}

// node_modules/date-fns/esm/locale/zh-CN/_lib/match/index.js
var matchOrdinalNumberPattern = /^(第\s*)?\d+(日|时|分|秒)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(前)/i,
  abbreviated: /^(前)/i,
  wide: /^(公元前|公元)/i
};
var parseEraPatterns = {
  any: [/^(前)/i, /^(公元)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^第[一二三四]刻/i,
  wide: /^第[一二三四]刻钟/i
};
var parseQuarterPatterns = {
  any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
};
var matchMonthPatterns = {
  narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
  abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
  wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
};
var parseMonthPatterns = {
  narrow: [/^一/i, /^二/i, /^三/i, /^四/i, /^五/i, /^六/i, /^七/i, /^八/i, /^九/i, /^十(?!(一|二))/i, /^十一/i, /^十二/i],
  any: [/^一|1/i, /^二|2/i, /^三|3/i, /^四|4/i, /^五|5/i, /^六|6/i, /^七|7/i, /^八|8/i, /^九|9/i, /^十(?!(一|二))|10/i, /^十一|11/i, /^十二|12/i]
};
var matchDayPatterns = {
  narrow: /^[一二三四五六日]/i,
  short: /^[一二三四五六日]/i,
  abbreviated: /^周[一二三四五六日]/i,
  wide: /^星期[一二三四五六日]/i
};
var parseDayPatterns = {
  any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
};
var matchDayPeriodPatterns = {
  any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨|)/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^上午?/i,
    pm: /^下午?/i,
    midnight: /^午夜/i,
    noon: /^[中正]午/i,
    morning: /^早上/i,
    afternoon: /^下午/i,
    evening: /^晚上?/i,
    night: /^凌晨/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match_default = match;

// node_modules/date-fns/esm/locale/zh-CN/index.js
var locale = {
  code: "zh-CN",
  formatDistance: formatDistance_default,
  formatLong: formatLong_default,
  formatRelative: formatRelative_default,
  localize: localize_default,
  match: match_default,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
var zh_CN_default = locale;

// node_modules/naive-ui/es/locales/date/zhCN.js
var dateZhCN = {
  name: "zh-CN",
  locale: zh_CN_default
};
var zhCN_default2 = dateZhCN;

// node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
var formatDistanceLocale2 = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance3 = function formatDistance4(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale2[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance_default2 = formatDistance3;

// node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js
var dateFormats2 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats2 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats2 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong2 = {
  date: buildFormatLongFn({
    formats: dateFormats2,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats2,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats2,
    defaultWidth: "full"
  })
};
var formatLong_default2 = formatLong2;

// node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
var formatRelativeLocale2 = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative3 = function formatRelative4(token, _date, _baseDate, _options) {
  return formatRelativeLocale2[token];
};
var formatRelative_default2 = formatRelative3;

// node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js
var eraValues2 = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues2 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues2 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues2 = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues2 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues2 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber3 = function ordinalNumber4(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize2 = {
  ordinalNumber: ordinalNumber3,
  era: buildLocalizeFn({
    values: eraValues2,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues2,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback2(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues2,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues2,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues2,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues2,
    defaultFormattingWidth: "wide"
  })
};
var localize_default2 = localize2;

// node_modules/date-fns/esm/locale/en-US/_lib/match/index.js
var matchOrdinalNumberPattern2 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern2 = /\d+/i;
var matchEraPatterns2 = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns2 = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns2 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns2 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns2 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns2 = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns2 = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns2 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns2 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns2 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern2,
    parsePattern: parseOrdinalNumberPattern2,
    valueCallback: function valueCallback3(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns2,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns2,
    defaultParseWidth: "any",
    valueCallback: function valueCallback4(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns2,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns2,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns2,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns2,
    defaultParseWidth: "any"
  })
};
var match_default2 = match2;

// node_modules/date-fns/esm/locale/en-US/index.js
var locale2 = {
  code: "en-US",
  formatDistance: formatDistance_default2,
  formatLong: formatLong_default2,
  formatRelative: formatRelative_default2,
  localize: localize_default2,
  match: match_default2,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var en_US_default = locale2;

// node_modules/naive-ui/es/locales/date/enUS.js
var dateEnUs = {
  name: "en-US",
  locale: en_US_default
};
var enUS_default2 = dateEnUs;

// node_modules/date-fns/esm/addDays/index.js
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}

// node_modules/date-fns/esm/addMonths/index.js
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}

// node_modules/date-fns/esm/addMilliseconds/index.js
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

// node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

// node_modules/date-fns/esm/startOfDay/index.js
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/isSameDay/index.js
function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

// node_modules/date-fns/esm/isDate/index.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function _typeof3(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function _typeof3(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof2(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/esm/isValid/index.js
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

// node_modules/date-fns/esm/startOfQuarter/index.js
function startOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3;
  date.setMonth(month, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/startOfMonth/index.js
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/subMilliseconds/index.js
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

// node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

// node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeek/index.js
var MILLISECONDS_IN_WEEK2 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
}

// node_modules/date-fns/esm/_lib/addLeadingZeros/index.js
function addLeadingZeros(number, targetLength) {
  var sign2 = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign2 + output;
}

// node_modules/date-fns/esm/_lib/format/lightFormatters/index.js
var formatters = {
  y: function y(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function d2(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  a: function a2(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function h4(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  s: function s2(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var lightFormatters_default = formatters;

// node_modules/date-fns/esm/_lib/format/formatters/index.js
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters2 = {
  G: function G(date, token, localize3) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize3.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize3.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize3.era(era, {
          width: "wide"
        });
    }
  },
  y: function y2(date, token, localize3) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize3.ordinalNumber(year, {
        unit: "year"
      });
    }
    return lightFormatters_default.y(date, token);
  },
  Y: function Y(date, token, localize3, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize3.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  Q: function Q(date, token, localize3) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize3.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize3.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize3.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize3.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function q(date, token, localize3) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize3.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize3.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize3.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize3.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function M2(date, token, localize3) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters_default.M(date, token);
      case "Mo":
        return localize3.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize3.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize3.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize3.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function L(date, token, localize3) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize3.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize3.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize3.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize3.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function w2(date, token, localize3, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize3.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  I: function I(date, token, localize3) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize3.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  d: function d3(date, token, localize3) {
    if (token === "do") {
      return localize3.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return lightFormatters_default.d(date, token);
  },
  D: function D(date, token, localize3) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize3.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  E: function E(date, token, localize3) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize3.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize3.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize3.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize3.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function e2(date, token, localize3, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize3.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize3.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize3.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize3.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize3.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function c5(date, token, localize3, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize3.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize3.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize3.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize3.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize3.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function i2(date, token, localize3) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize3.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize3.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize3.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize3.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize3.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function a3(date, token, localize3) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize3.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize3.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize3.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize3.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function b(date, token, localize3) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize3.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize3.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize3.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize3.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function B(date, token, localize3) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize3.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize3.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize3.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function h5(date, token, localize3) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize3.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return lightFormatters_default.h(date, token);
  },
  H: function H2(date, token, localize3) {
    if (token === "Ho") {
      return localize3.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return lightFormatters_default.H(date, token);
  },
  K: function K(date, token, localize3) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize3.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  k: function k(date, token, localize3) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize3.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  m: function m2(date, token, localize3) {
    if (token === "mo") {
      return localize3.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return lightFormatters_default.m(date, token);
  },
  s: function s3(date, token, localize3) {
    if (token === "so") {
      return localize3.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return lightFormatters_default.s(date, token);
  },
  S: function S2(date, token) {
    return lightFormatters_default.S(date, token);
  },
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function t2(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  T: function T2(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign2 = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign2 + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign2 + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign2 = offset > 0 ? "-" : "+";
    return sign2 + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign2 = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign2 + hours + delimiter + minutes;
}
var formatters_default = formatters2;

// node_modules/date-fns/esm/_lib/format/longFormatters/index.js
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong3) {
  switch (pattern) {
    case "P":
      return formatLong3.date({
        width: "short"
      });
    case "PP":
      return formatLong3.date({
        width: "medium"
      });
    case "PPP":
      return formatLong3.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong3.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong3) {
  switch (pattern) {
    case "p":
      return formatLong3.time({
        width: "short"
      });
    case "pp":
      return formatLong3.time({
        width: "medium"
      });
    case "ppp":
      return formatLong3.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong3.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong3) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong3);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong3.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong3.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong3.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong3.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong3)).replace("{{time}}", timeLongFormatter(timePattern, formatLong3));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters_default = longFormatters;

// node_modules/date-fns/esm/_lib/protectedTokens/index.js
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

// node_modules/date-fns/esm/_lib/defaultLocale/index.js
var defaultLocale_default = en_US_default;

// node_modules/date-fns/esm/format/index.js
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale3 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale3.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale3.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale3,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale3.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters_default[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale3.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}

// node_modules/date-fns/esm/getDate/index.js
function getDate(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var dayOfMonth = date.getDate();
  return dayOfMonth;
}

// node_modules/date-fns/esm/getDay/index.js
function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}

// node_modules/date-fns/esm/getMonth/index.js
function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  return month;
}

// node_modules/date-fns/esm/getTime/index.js
function getTime(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  return timestamp;
}

// node_modules/date-fns/esm/getYear/index.js
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}

// node_modules/date-fns/esm/isSameMonth/index.js
function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}

// node_modules/date-fns/esm/isSameQuarter/index.js
function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
  var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
  return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
}

// node_modules/date-fns/esm/isSameYear/index.js
function isSameYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}

// node_modules/naive-ui/es/_mixins/use-locale.js
function useLocale(ns) {
  const { mergedLocaleRef, mergedDateLocaleRef } = inject(configProviderInjectionKey, null) || {};
  const localeRef = computed2(() => {
    var _a3, _b2;
    return (_b2 = (_a3 = mergedLocaleRef === null || mergedLocaleRef === void 0 ? void 0 : mergedLocaleRef.value) === null || _a3 === void 0 ? void 0 : _a3[ns]) !== null && _b2 !== void 0 ? _b2 : enUS_default[ns];
  });
  const dateLocaleRef = computed2(() => {
    var _a3;
    return (_a3 = mergedDateLocaleRef === null || mergedDateLocaleRef === void 0 ? void 0 : mergedDateLocaleRef.value) !== null && _a3 !== void 0 ? _a3 : enUS_default2;
  });
  return {
    dateLocaleRef,
    localeRef
  };
}

// node_modules/naive-ui/es/_mixins/use-style.js
function useStyle(mountId, style2, clsPrefixRef) {
  if (!style2) {
    if (false)
      throwError("use-style", "No style is specified.");
    return;
  }
  const ssrAdapter2 = useSsrAdapter();
  const NConfigProvider = inject(configProviderInjectionKey, null);
  const mountStyle = () => {
    const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
    style2.mount({
      id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
      head: true,
      anchorMetaName: cssrAnchorMetaName2,
      props: {
        bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
      },
      ssr: ssrAdapter2
    });
    if (!(NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled)) {
      index_cssr_default.mount({
        id: "n-global",
        head: true,
        anchorMetaName: cssrAnchorMetaName2,
        ssr: ssrAdapter2
      });
    }
  };
  if (ssrAdapter2) {
    mountStyle();
  } else {
    onBeforeMount(mountStyle);
  }
}

// node_modules/naive-ui/es/_mixins/use-css-vars-class.js
function useThemeClass(componentName, hashRef, cssVarsRef, props) {
  var _a3;
  if (!cssVarsRef)
    throwError("useThemeClass", "cssVarsRef is not passed");
  const mergedThemeHashRef = (_a3 = inject(configProviderInjectionKey, null)) === null || _a3 === void 0 ? void 0 : _a3.mergedThemeHashRef;
  const themeClassRef = ref("");
  const ssrAdapter2 = useSsrAdapter();
  let renderCallback;
  const hashClassPrefix = `__${componentName}`;
  const mountStyle = () => {
    let finalThemeHash = hashClassPrefix;
    const hashValue = hashRef ? hashRef.value : void 0;
    const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
    if (themeHash)
      finalThemeHash += "-" + themeHash;
    if (hashValue)
      finalThemeHash += "-" + hashValue;
    const { themeOverrides, builtinThemeOverrides } = props;
    if (themeOverrides) {
      finalThemeHash += "-" + hash_browser_esm_default(JSON.stringify(themeOverrides));
    }
    if (builtinThemeOverrides) {
      finalThemeHash += "-" + hash_browser_esm_default(JSON.stringify(builtinThemeOverrides));
    }
    themeClassRef.value = finalThemeHash;
    renderCallback = () => {
      const cssVars = cssVarsRef.value;
      let style2 = "";
      for (const key in cssVars) {
        style2 += `${key}: ${cssVars[key]};`;
      }
      c3(`.${finalThemeHash}`, style2).mount({
        id: finalThemeHash,
        ssr: ssrAdapter2
      });
      renderCallback = void 0;
    };
  };
  watchEffect(() => {
    mountStyle();
  });
  return {
    themeClass: themeClassRef,
    onRender: () => {
      renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
    }
  };
}

// node_modules/naive-ui/es/_mixins/use-rtl.js
function useRtl(mountId, rtlStateRef, clsPrefixRef) {
  if (!rtlStateRef)
    return void 0;
  const ssrAdapter2 = useSsrAdapter();
  const componentRtlStateRef = computed2(() => {
    const { value: rtlState } = rtlStateRef;
    if (!rtlState) {
      return void 0;
    }
    const componentRtlState = rtlState[mountId];
    if (!componentRtlState) {
      return void 0;
    }
    return componentRtlState;
  });
  const mountStyle = () => {
    watchEffect(() => {
      const { value: clsPrefix } = clsPrefixRef;
      const id = `${clsPrefix}${mountId}Rtl`;
      if (exists(id, ssrAdapter2))
        return;
      const { value: componentRtlState } = componentRtlStateRef;
      if (!componentRtlState)
        return;
      componentRtlState.style.mount({
        id,
        head: true,
        anchorMetaName: cssrAnchorMetaName2,
        props: {
          bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
        },
        ssr: ssrAdapter2
      });
    });
  };
  if (ssrAdapter2) {
    mountStyle();
  } else {
    onBeforeMount(mountStyle);
  }
  return componentRtlStateRef;
}

// node_modules/naive-ui/es/_internal/icons/replaceable.js
function replaceable(name2, icon) {
  return defineComponent({
    name: upperFirst_default(name2),
    setup() {
      var _a3;
      const mergedIconsRef = (_a3 = inject(configProviderInjectionKey, null)) === null || _a3 === void 0 ? void 0 : _a3.mergedIconsRef;
      return () => {
        var _a4;
        const iconOverride = (_a4 = mergedIconsRef === null || mergedIconsRef === void 0 ? void 0 : mergedIconsRef.value) === null || _a4 === void 0 ? void 0 : _a4[name2];
        return iconOverride ? iconOverride() : icon;
      };
    }
  });
}

// node_modules/naive-ui/es/_internal/icons/ChevronLeft.js
var ChevronLeft_default = defineComponent({
  name: "ChevronLeft",
  render() {
    return h3("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h3("path", { d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z", fill: "currentColor" }));
  }
});

// node_modules/naive-ui/es/_internal/icons/ChevronRight.js
var ChevronRight_default = defineComponent({
  name: "ChevronRight",
  render() {
    return h3("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h3("path", { d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z", fill: "currentColor" }));
  }
});

// node_modules/naive-ui/es/_internal/icons/Close.js
var Close_default = replaceable("close", h3("svg", { viewBox: "0 0 12 12", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": true }, h3("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, h3("g", { fill: "currentColor", "fill-rule": "nonzero" }, h3("path", { d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z" })))));

// node_modules/naive-ui/es/_internal/icons/Empty.js
var Empty_default = defineComponent({
  name: "Empty",
  render() {
    return h3("svg", { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h3("path", { d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z", fill: "currentColor" }), h3("path", { d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z", fill: "currentColor" }));
  }
});

// node_modules/naive-ui/es/_internal/icons/Error.js
var Error_default = replaceable("error", h3("svg", { viewBox: "0 0 48 48", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, h3("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" }, h3("g", { "fill-rule": "nonzero" }, h3("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M17.8838835,16.1161165 L17.7823881,16.0249942 C17.3266086,15.6583353 16.6733914,15.6583353 16.2176119,16.0249942 L16.1161165,16.1161165 L16.0249942,16.2176119 C15.6583353,16.6733914 15.6583353,17.3266086 16.0249942,17.7823881 L16.1161165,17.8838835 L22.233,24 L16.1161165,30.1161165 L16.0249942,30.2176119 C15.6583353,30.6733914 15.6583353,31.3266086 16.0249942,31.7823881 L16.1161165,31.8838835 L16.2176119,31.9750058 C16.6733914,32.3416647 17.3266086,32.3416647 17.7823881,31.9750058 L17.8838835,31.8838835 L24,25.767 L30.1161165,31.8838835 L30.2176119,31.9750058 C30.6733914,32.3416647 31.3266086,32.3416647 31.7823881,31.9750058 L31.8838835,31.8838835 L31.9750058,31.7823881 C32.3416647,31.3266086 32.3416647,30.6733914 31.9750058,30.2176119 L31.8838835,30.1161165 L25.767,24 L31.8838835,17.8838835 L31.9750058,17.7823881 C32.3416647,17.3266086 32.3416647,16.6733914 31.9750058,16.2176119 L31.8838835,16.1161165 L31.7823881,16.0249942 C31.3266086,15.6583353 30.6733914,15.6583353 30.2176119,16.0249942 L30.1161165,16.1161165 L24,22.233 L17.8838835,16.1161165 L17.7823881,16.0249942 L17.8838835,16.1161165 Z" })))));

// node_modules/naive-ui/es/_internal/icons/Info.js
var Info_default = replaceable("info", h3("svg", { viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, h3("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" }, h3("g", { "fill-rule": "nonzero" }, h3("path", { d: "M14,2 C20.6274,2 26,7.37258 26,14 C26,20.6274 20.6274,26 14,26 C7.37258,26 2,20.6274 2,14 C2,7.37258 7.37258,2 14,2 Z M14,11 C13.4477,11 13,11.4477 13,12 L13,12 L13,20 C13,20.5523 13.4477,21 14,21 C14.5523,21 15,20.5523 15,20 L15,20 L15,12 C15,11.4477 14.5523,11 14,11 Z M14,6.75 C13.3096,6.75 12.75,7.30964 12.75,8 C12.75,8.69036 13.3096,9.25 14,9.25 C14.6904,9.25 15.25,8.69036 15.25,8 C15.25,7.30964 14.6904,6.75 14,6.75 Z" })))));

// node_modules/naive-ui/es/_internal/icons/Success.js
var Success_default = replaceable("success", h3("svg", { viewBox: "0 0 48 48", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, h3("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" }, h3("g", { "fill-rule": "nonzero" }, h3("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M32.6338835,17.6161165 C32.1782718,17.1605048 31.4584514,17.1301307 30.9676119,17.5249942 L30.8661165,17.6161165 L20.75,27.732233 L17.1338835,24.1161165 C16.6457281,23.6279612 15.8542719,23.6279612 15.3661165,24.1161165 C14.9105048,24.5717282 14.8801307,25.2915486 15.2749942,25.7823881 L15.3661165,25.8838835 L19.8661165,30.3838835 C20.3217282,30.8394952 21.0415486,30.8698693 21.5323881,30.4750058 L21.6338835,30.3838835 L32.6338835,19.3838835 C33.1220388,18.8957281 33.1220388,18.1042719 32.6338835,17.6161165 Z" })))));

// node_modules/naive-ui/es/_internal/icons/Warning.js
var Warning_default = replaceable("warning", h3("svg", { viewBox: "0 0 24 24", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, h3("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" }, h3("g", { "fill-rule": "nonzero" }, h3("path", { d: "M12,2 C17.523,2 22,6.478 22,12 C22,17.522 17.523,22 12,22 C6.477,22 2,17.522 2,12 C2,6.478 6.477,2 12,2 Z M12.0018002,15.0037242 C11.450254,15.0037242 11.0031376,15.4508407 11.0031376,16.0023869 C11.0031376,16.553933 11.450254,17.0010495 12.0018002,17.0010495 C12.5533463,17.0010495 13.0004628,16.553933 13.0004628,16.0023869 C13.0004628,15.4508407 12.5533463,15.0037242 12.0018002,15.0037242 Z M11.99964,7 C11.4868042,7.00018474 11.0642719,7.38637706 11.0066858,7.8837365 L11,8.00036004 L11.0018003,13.0012393 L11.00857,13.117858 C11.0665141,13.6151758 11.4893244,14.0010638 12.0021602,14.0008793 C12.514996,14.0006946 12.9375283,13.6145023 12.9951144,13.1171428 L13.0018002,13.0005193 L13,7.99964009 L12.9932303,7.8830214 C12.9352861,7.38570354 12.5124758,6.99981552 11.99964,7 Z" })))));

// node_modules/naive-ui/es/_internal/icon-switch-transition/src/IconSwitchTransition.js
var IconSwitchTransition_default = defineComponent({
  name: "BaseIconSwitchTransition",
  setup(_, { slots }) {
    const isMountedRef = isMounted();
    return () => h3(Transition, { name: "icon-switch-transition", appear: isMountedRef.value }, slots);
  }
});

// node_modules/naive-ui/es/_internal/fade-in-expand-transition/src/FadeInExpandTransition.js
var FadeInExpandTransition_default = defineComponent({
  name: "FadeInExpandTransition",
  props: {
    appear: Boolean,
    group: Boolean,
    mode: String,
    onLeave: Function,
    onAfterLeave: Function,
    onAfterEnter: Function,
    width: Boolean,
    reverse: Boolean
  },
  setup(props, { slots }) {
    function handleBeforeLeave(el) {
      if (props.width) {
        el.style.maxWidth = `${el.offsetWidth}px`;
      } else {
        el.style.maxHeight = `${el.offsetHeight}px`;
      }
      void el.offsetWidth;
    }
    function handleLeave(el) {
      if (props.width) {
        el.style.maxWidth = "0";
      } else {
        el.style.maxHeight = "0";
      }
      void el.offsetWidth;
      const { onLeave } = props;
      if (onLeave)
        onLeave();
    }
    function handleAfterLeave(el) {
      if (props.width) {
        el.style.maxWidth = "";
      } else {
        el.style.maxHeight = "";
      }
      const { onAfterLeave } = props;
      if (onAfterLeave)
        onAfterLeave();
    }
    function handleEnter(el) {
      el.style.transition = "none";
      if (props.width) {
        const memorizedWidth = el.offsetWidth;
        el.style.maxWidth = "0";
        void el.offsetWidth;
        el.style.transition = "";
        el.style.maxWidth = `${memorizedWidth}px`;
      } else {
        if (props.reverse) {
          el.style.maxHeight = `${el.offsetHeight}px`;
          void el.offsetHeight;
          el.style.transition = "";
          el.style.maxHeight = "0";
        } else {
          const memorizedHeight = el.offsetHeight;
          el.style.maxHeight = "0";
          void el.offsetWidth;
          el.style.transition = "";
          el.style.maxHeight = `${memorizedHeight}px`;
        }
      }
      void el.offsetWidth;
    }
    function handleAfterEnter(el) {
      var _a3;
      if (props.width) {
        el.style.maxWidth = "";
      } else {
        if (!props.reverse) {
          el.style.maxHeight = "";
        }
      }
      (_a3 = props.onAfterEnter) === null || _a3 === void 0 ? void 0 : _a3.call(props);
    }
    return () => {
      const type = props.group ? TransitionGroup : Transition;
      return h3(type, {
        name: props.width ? "fade-in-width-expand-transition" : "fade-in-height-expand-transition",
        mode: props.mode,
        appear: props.appear,
        onEnter: handleEnter,
        onAfterEnter: handleAfterEnter,
        onBeforeLeave: handleBeforeLeave,
        onLeave: handleLeave,
        onAfterLeave: handleAfterLeave
      }, slots);
    };
  }
});

// node_modules/naive-ui/es/_internal/icon/src/styles/index.cssr.js
var index_cssr_default2 = cB("base-icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [c3("svg", `
 height: 1em;
 width: 1em;
 `)]);

// node_modules/naive-ui/es/_internal/icon/src/Icon.js
var Icon_default = defineComponent({
  name: "BaseIcon",
  props: {
    role: String,
    ariaLabel: String,
    ariaDisabled: {
      type: Boolean,
      default: void 0
    },
    ariaHidden: {
      type: Boolean,
      default: void 0
    },
    clsPrefix: {
      type: String,
      required: true
    },
    onClick: Function,
    onMousedown: Function,
    onMouseup: Function
  },
  setup(props) {
    useStyle("-base-icon", index_cssr_default2, toRef(props, "clsPrefix"));
  },
  render() {
    return h3("i", { class: `${this.clsPrefix}-base-icon`, onClick: this.onClick, onMousedown: this.onMousedown, onMouseup: this.onMouseup, role: this.role, "aria-label": this.ariaLabel, "aria-hidden": this.ariaHidden, "aria-disabled": this.ariaDisabled }, this.$slots);
  }
});

// node_modules/naive-ui/es/_internal/close/src/styles/index.cssr.js
var index_cssr_default3 = cB("base-close", `
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 background-color: transparent;
 color: var(--n-close-icon-color);
 border-radius: var(--n-close-border-radius);
 height: var(--n-close-size);
 width: var(--n-close-size);
 font-size: var(--n-close-icon-size);
 outline: none;
 border: none;
 position: relative;
 padding: 0;
`, [cM("absolute", `
 height: var(--n-close-icon-size);
 width: var(--n-close-icon-size);
 `), c3("&::before", `
 content: "";
 position: absolute;
 width: var(--n-close-size);
 height: var(--n-close-size);
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 transition: inherit;
 border-radius: inherit;
 `), cNotM("disabled", [c3("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c3("&:hover::before", `
 background-color: var(--n-close-color-hover);
 `), c3("&:focus::before", `
 background-color: var(--n-close-color-hover);
 `), c3("&:active", `
 color: var(--n-close-icon-color-pressed);
 `), c3("&:active::before", `
 background-color: var(--n-close-color-pressed);
 `)]), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-close-icon-color-disabled);
 background-color: transparent;
 `), cM("round", [c3("&::before", `
 border-radius: 50%;
 `)])]);

// node_modules/naive-ui/es/_internal/close/src/Close.js
var Close_default2 = defineComponent({
  name: "BaseClose",
  props: {
    isButtonTag: {
      type: Boolean,
      default: true
    },
    clsPrefix: {
      type: String,
      required: true
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    focusable: {
      type: Boolean,
      default: true
    },
    round: Boolean,
    onClick: Function,
    absolute: Boolean
  },
  setup(props) {
    useStyle("-base-close", index_cssr_default3, toRef(props, "clsPrefix"));
    return () => {
      const { clsPrefix, disabled, absolute, round: round2, isButtonTag } = props;
      const Tag2 = isButtonTag ? "button" : "div";
      return h3(Tag2, { type: isButtonTag ? "button" : void 0, tabindex: disabled || !props.focusable ? -1 : 0, "aria-disabled": disabled, "aria-label": "close", role: isButtonTag ? void 0 : "button", disabled, class: [
        `${clsPrefix}-base-close`,
        absolute && `${clsPrefix}-base-close--absolute`,
        disabled && `${clsPrefix}-base-close--disabled`,
        round2 && `${clsPrefix}-base-close--round`
      ], onMousedown: (e3) => {
        if (!props.focusable) {
          e3.preventDefault();
        }
      }, onClick: props.onClick }, h3(Icon_default, { clsPrefix }, {
        default: () => h3(Close_default, null)
      }));
    };
  }
});

// node_modules/naive-ui/es/_styles/transitions/icon-switch.cssr.js
var {
  cubicBezierEaseInOut
} = common_default;
function iconSwitchTransition({
  originalTransform = "",
  left = 0,
  top = 0,
  transition = `all .3s ${cubicBezierEaseInOut} !important`
} = {}) {
  return [c3("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
    transform: originalTransform + " scale(0.75)",
    left,
    top,
    opacity: 0
  }), c3("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
    transform: `scale(1) ${originalTransform}`,
    left,
    top,
    opacity: 1
  }), c3("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
    transformOrigin: "center",
    position: "absolute",
    left,
    top,
    transition
  })];
}

// node_modules/naive-ui/es/_internal/loading/src/styles/index.cssr.js
var index_cssr_default4 = c3([c3("@keyframes loading-container-rotate", `
 to {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }
 `), c3("@keyframes loading-layer-rotate", `
 12.5% {
 -webkit-transform: rotate(135deg);
 transform: rotate(135deg);
 }
 25% {
 -webkit-transform: rotate(270deg);
 transform: rotate(270deg);
 }
 37.5% {
 -webkit-transform: rotate(405deg);
 transform: rotate(405deg);
 }
 50% {
 -webkit-transform: rotate(540deg);
 transform: rotate(540deg);
 }
 62.5% {
 -webkit-transform: rotate(675deg);
 transform: rotate(675deg);
 }
 75% {
 -webkit-transform: rotate(810deg);
 transform: rotate(810deg);
 }
 87.5% {
 -webkit-transform: rotate(945deg);
 transform: rotate(945deg);
 }
 100% {
 -webkit-transform: rotate(1080deg);
 transform: rotate(1080deg);
 } 
 `), c3("@keyframes loading-left-spin", `
 from {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 50% {
 -webkit-transform: rotate(130deg);
 transform: rotate(130deg);
 }
 to {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 `), c3("@keyframes loading-right-spin", `
 from {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 50% {
 -webkit-transform: rotate(-130deg);
 transform: rotate(-130deg);
 }
 to {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 `), cB("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE("container", `
 display: inline-flex;
 position: relative;
 direction: ltr;
 line-height: 0;
 animation: loading-container-rotate 1568.2352941176ms linear infinite;
 font-size: 0;
 letter-spacing: 0;
 white-space: nowrap;
 opacity: 1;
 width: 100%;
 height: 100%;
 `, [cE("svg", `
 stroke: var(--n-text-color);
 fill: transparent;
 position: absolute;
 height: 100%;
 overflow: hidden;
 `), cE("container-layer", `
 position: absolute;
 width: 100%;
 height: 100%;
 animation: loading-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 `, [cE("container-layer-left", `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [cE("svg", `
 animation: loading-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 width: 200%;
 `)]), cE("container-layer-patch", `
 position: absolute;
 top: 0;
 left: 47.5%;
 box-sizing: border-box;
 width: 5%;
 height: 100%;
 overflow: hidden;
 `, [cE("svg", `
 left: -900%;
 width: 2000%;
 transform: rotate(180deg);
 `)]), cE("container-layer-right", `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [cE("svg", `
 animation: loading-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 left: -100%;
 width: 200%;
 `)])])]), cE("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
  left: "50%",
  top: "50%",
  originalTransform: "translateX(-50%) translateY(-50%)"
})])])]);

// node_modules/naive-ui/es/_internal/loading/src/Loading.js
var exposedLoadingProps = {
  strokeWidth: {
    type: Number,
    default: 28
  },
  stroke: {
    type: String,
    default: void 0
  }
};
var Loading_default = defineComponent({
  name: "BaseLoading",
  props: Object.assign({ clsPrefix: {
    type: String,
    required: true
  }, show: {
    type: Boolean,
    default: true
  }, scale: {
    type: Number,
    default: 1
  }, radius: {
    type: Number,
    default: 100
  } }, exposedLoadingProps),
  setup(props) {
    useStyle("-base-loading", index_cssr_default4, toRef(props, "clsPrefix"));
  },
  render() {
    const { clsPrefix, radius, strokeWidth, stroke, scale } = this;
    const scaledRadius = radius / scale;
    return h3("div", { class: `${clsPrefix}-base-loading`, role: "img", "aria-label": "loading" }, h3(IconSwitchTransition_default, null, {
      default: () => this.show ? h3("div", { key: "icon", class: `${clsPrefix}-base-loading__transition-wrapper` }, h3("div", { class: `${clsPrefix}-base-loading__container` }, h3("div", { class: `${clsPrefix}-base-loading__container-layer` }, h3("div", { class: `${clsPrefix}-base-loading__container-layer-left` }, h3("svg", { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } }, h3("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius }))), h3("div", { class: `${clsPrefix}-base-loading__container-layer-patch` }, h3("svg", { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } }, h3("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius }))), h3("div", { class: `${clsPrefix}-base-loading__container-layer-right` }, h3("svg", { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } }, h3("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius })))))) : h3("div", { key: "placeholder", class: `${clsPrefix}-base-loading__placeholder` }, this.$slots)
    }));
  }
});

// node_modules/treemate/es/utils.js
function toArray2(arg) {
  if (Array.isArray(arg))
    return arg;
  return [arg];
}
var TRAVERSE_COMMAND = {
  STOP: "STOP"
};
function traverseWithCb(treeNode, callback2) {
  const command = callback2(treeNode);
  if (treeNode.children !== void 0 && command !== TRAVERSE_COMMAND.STOP) {
    treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback2));
  }
}
function getNonLeafKeys(treeNodes, options = {}) {
  const { preserveGroup = false } = options;
  const keys2 = [];
  const cb = preserveGroup ? (node) => {
    if (!node.isLeaf) {
      keys2.push(node.key);
      traverse2(node.children);
    }
  } : (node) => {
    if (!node.isLeaf) {
      if (!node.isGroup)
        keys2.push(node.key);
      traverse2(node.children);
    }
  };
  function traverse2(nodes) {
    nodes.forEach(cb);
  }
  traverse2(treeNodes);
  return keys2;
}
function isLeaf(rawNode, getChildren) {
  const { isLeaf: isLeaf2 } = rawNode;
  if (isLeaf2 !== void 0)
    return isLeaf2;
  else if (!getChildren(rawNode))
    return true;
  return false;
}
function defaultGetChildren(node) {
  return node.children;
}
function defaultGetKey(node) {
  return node.key;
}
function isIgnored() {
  return false;
}
function isShallowLoaded(rawNode, getChildren) {
  const { isLeaf: isLeaf2 } = rawNode;
  if (isLeaf2 === false && !Array.isArray(getChildren(rawNode)))
    return false;
  return true;
}
function isDisabled(rawNode) {
  return rawNode.disabled === true;
}
function isExpilicitlyNotLoaded(rawNode, getChildren) {
  return rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode));
}
function unwrapCheckedKeys(result) {
  var _a3;
  if (result === void 0 || result === null)
    return [];
  if (Array.isArray(result))
    return result;
  return (_a3 = result.checkedKeys) !== null && _a3 !== void 0 ? _a3 : [];
}
function unwrapIndeterminateKeys(result) {
  var _a3;
  if (result === void 0 || result === null || Array.isArray(result)) {
    return [];
  }
  return (_a3 = result.indeterminateKeys) !== null && _a3 !== void 0 ? _a3 : [];
}
function merge2(originalKeys, keysToAdd) {
  const set3 = new Set(originalKeys);
  keysToAdd.forEach((key) => {
    if (!set3.has(key)) {
      set3.add(key);
    }
  });
  return Array.from(set3);
}
function minus(originalKeys, keysToRemove) {
  const set3 = new Set(originalKeys);
  keysToRemove.forEach((key) => {
    if (set3.has(key)) {
      set3.delete(key);
    }
  });
  return Array.from(set3);
}
function isGroup(rawNode) {
  return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === "group";
}

// node_modules/treemate/es/check.js
var SubtreeNotLoadedError = class extends Error {
  constructor() {
    super();
    this.message = "SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.";
  }
};
function getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
  return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);
}
function getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {
  const visitedKeys = /* @__PURE__ */ new Set();
  uncheckedKeys.forEach((uncheckedKey) => {
    const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);
    if (uncheckedTreeNode !== void 0) {
      let nodeCursor = uncheckedTreeNode.parent;
      while (nodeCursor !== null) {
        if (nodeCursor.disabled)
          break;
        if (visitedKeys.has(nodeCursor.key))
          break;
        else {
          visitedKeys.add(nodeCursor.key);
        }
        nodeCursor = nodeCursor.parent;
      }
    }
  });
  return visitedKeys;
}
function getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
  const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);
  const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);
  const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);
  const keysToRemove = [];
  extendedCheckedKeySet.forEach((key) => {
    if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {
      keysToRemove.push(key);
    }
  });
  keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));
  return extendedCheckedKeySet;
}
function getCheckedKeys(options, treeMate) {
  const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;
  if (!cascade) {
    if (keysToCheck !== void 0) {
      return {
        checkedKeys: merge2(checkedKeys, keysToCheck),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    } else if (keysToUncheck !== void 0) {
      return {
        checkedKeys: minus(checkedKeys, keysToUncheck),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    } else {
      return {
        checkedKeys: Array.from(checkedKeys),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    }
  }
  const { levelTreeNodeMap } = treeMate;
  let extendedCheckedKeySet;
  if (keysToUncheck !== void 0) {
    extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);
  } else if (keysToCheck !== void 0) {
    extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);
  } else {
    extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);
  }
  const checkStrategyIsParent = checkStrategy === "parent";
  const checkStrategyIsChild = checkStrategy === "child" || leafOnly;
  const syntheticCheckedKeySet = extendedCheckedKeySet;
  const syntheticIndeterminateKeySet = /* @__PURE__ */ new Set();
  const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));
  for (let level = maxLevel; level >= 0; level -= 1) {
    const levelIsZero = level === 0;
    const levelTreeNodes = levelTreeNodeMap.get(level);
    for (const levelTreeNode of levelTreeNodes) {
      if (levelTreeNode.isLeaf)
        continue;
      const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;
      if (checkStrategyIsChild && shallowLoaded) {
        levelTreeNode.children.forEach((v) => {
          if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {
            syntheticCheckedKeySet.delete(v.key);
          }
        });
      }
      if (levelTreeNode.disabled || !shallowLoaded) {
        continue;
      }
      let fullyChecked = true;
      let partialChecked = false;
      let allDisabled = true;
      for (const childNode of levelTreeNode.children) {
        const childKey = childNode.key;
        if (childNode.disabled)
          continue;
        if (allDisabled)
          allDisabled = false;
        if (syntheticCheckedKeySet.has(childKey)) {
          partialChecked = true;
        } else if (syntheticIndeterminateKeySet.has(childKey)) {
          partialChecked = true;
          fullyChecked = false;
          break;
        } else {
          fullyChecked = false;
          if (partialChecked) {
            break;
          }
        }
      }
      if (fullyChecked && !allDisabled) {
        if (checkStrategyIsParent) {
          levelTreeNode.children.forEach((v) => {
            if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {
              syntheticCheckedKeySet.delete(v.key);
            }
          });
        }
        syntheticCheckedKeySet.add(levelTreeNodeKey);
      } else if (partialChecked) {
        syntheticIndeterminateKeySet.add(levelTreeNodeKey);
      }
      if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {
        syntheticCheckedKeySet.delete(levelTreeNodeKey);
      }
    }
  }
  return {
    checkedKeys: Array.from(syntheticCheckedKeySet),
    indeterminateKeys: Array.from(syntheticIndeterminateKeySet)
  };
}
function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {
  const { treeNodeMap, getChildren } = treeMate;
  const visitedKeySet = /* @__PURE__ */ new Set();
  const extendedKeySet = new Set(checkedKeys);
  checkedKeys.forEach((checkedKey) => {
    const checkedTreeNode = treeNodeMap.get(checkedKey);
    if (checkedTreeNode !== void 0) {
      traverseWithCb(checkedTreeNode, (treeNode) => {
        if (treeNode.disabled) {
          return TRAVERSE_COMMAND.STOP;
        }
        const { key } = treeNode;
        if (visitedKeySet.has(key))
          return;
        visitedKeySet.add(key);
        extendedKeySet.add(key);
        if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {
          if (isUnchecking) {
            return TRAVERSE_COMMAND.STOP;
          } else if (!allowNotLoaded) {
            throw new SubtreeNotLoadedError();
          }
        }
      });
    }
  });
  return extendedKeySet;
}

// node_modules/treemate/es/path.js
function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {
  var _a3;
  const treeNodeMap = treeMate.treeNodeMap;
  let treeNode = key === null || key === void 0 ? null : (_a3 = treeNodeMap.get(key)) !== null && _a3 !== void 0 ? _a3 : null;
  const mergedPath = {
    keyPath: [],
    treeNodePath: [],
    treeNode
  };
  if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {
    mergedPath.treeNode = null;
    return mergedPath;
  }
  while (treeNode) {
    if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {
      mergedPath.treeNodePath.push(treeNode);
    }
    treeNode = treeNode.parent;
  }
  mergedPath.treeNodePath.reverse();
  if (!includeSelf)
    mergedPath.treeNodePath.pop();
  mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode2) => treeNode2.key);
  return mergedPath;
}

// node_modules/treemate/es/move.js
function getFirstAvailableNode(nodes) {
  if (nodes.length === 0)
    return null;
  const node = nodes[0];
  if (node.isGroup || node.ignored || node.disabled) {
    return node.getNext();
  }
  return node;
}
function rawGetNext(node, loop2) {
  const sibs = node.siblings;
  const l2 = sibs.length;
  const { index: index2 } = node;
  if (loop2) {
    return sibs[(index2 + 1) % l2];
  } else {
    if (index2 === sibs.length - 1)
      return null;
    return sibs[index2 + 1];
  }
}
function move(fromNode, dir, { loop: loop2 = false, includeDisabled = false } = {}) {
  const iterate = dir === "prev" ? rawGetPrev : rawGetNext;
  const getChildOptions = {
    reverse: dir === "prev"
  };
  let meet = false;
  let endNode = null;
  function traverse2(node) {
    if (node === null)
      return;
    if (node === fromNode) {
      if (!meet) {
        meet = true;
      } else if (!fromNode.disabled && !fromNode.isGroup) {
        endNode = fromNode;
        return;
      }
    } else {
      if ((!node.disabled || includeDisabled) && !node.ignored && !node.isGroup) {
        endNode = node;
        return;
      }
    }
    if (node.isGroup) {
      const child = getChild(node, getChildOptions);
      if (child !== null) {
        endNode = child;
      } else {
        traverse2(iterate(node, loop2));
      }
    } else {
      const nextNode = iterate(node, false);
      if (nextNode !== null) {
        traverse2(nextNode);
      } else {
        const parent = rawGetParent(node);
        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
          traverse2(iterate(parent, loop2));
        } else if (loop2) {
          traverse2(iterate(node, true));
        }
      }
    }
  }
  traverse2(fromNode);
  return endNode;
}
function rawGetPrev(node, loop2) {
  const sibs = node.siblings;
  const l2 = sibs.length;
  const { index: index2 } = node;
  if (loop2) {
    return sibs[(index2 - 1 + l2) % l2];
  } else {
    if (index2 === 0)
      return null;
    return sibs[index2 - 1];
  }
}
function rawGetParent(node) {
  return node.parent;
}
function getChild(node, options = {}) {
  const { reverse = false } = options;
  const { children: children2 } = node;
  if (children2) {
    const { length } = children2;
    const start = reverse ? length - 1 : 0;
    const end = reverse ? -1 : length;
    const delta = reverse ? -1 : 1;
    for (let i3 = start; i3 !== end; i3 += delta) {
      const child = children2[i3];
      if (!child.disabled && !child.ignored) {
        if (child.isGroup) {
          const childInGroup = getChild(child, options);
          if (childInGroup !== null)
            return childInGroup;
        } else {
          return child;
        }
      }
    }
  }
  return null;
}
var moveMethods = {
  getChild() {
    if (this.ignored)
      return null;
    return getChild(this);
  },
  getParent() {
    const { parent } = this;
    if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
      return parent.getParent();
    }
    return parent;
  },
  getNext(options = {}) {
    return move(this, "next", options);
  },
  getPrev(options = {}) {
    return move(this, "prev", options);
  }
};

// node_modules/treemate/es/flatten.js
function flatten3(treeNodes, expandedKeys) {
  const expandedKeySet = expandedKeys ? new Set(expandedKeys) : void 0;
  const flattenedNodes = [];
  function traverse2(treeNodes2) {
    treeNodes2.forEach((treeNode) => {
      flattenedNodes.push(treeNode);
      if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)
        return;
      if (treeNode.isGroup) {
        traverse2(treeNode.children);
      } else if (expandedKeySet === void 0 || expandedKeySet.has(treeNode.key)) {
        traverse2(treeNode.children);
      }
    });
  }
  traverse2(treeNodes);
  return flattenedNodes;
}

// node_modules/treemate/es/contains.js
function contains2(parent, child) {
  const parentKey = parent.key;
  while (child) {
    if (child.key === parentKey)
      return true;
    child = child.parent;
  }
  return false;
}

// node_modules/treemate/es/create.js
function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {
  const treeNodes = [];
  rawNodes.forEach((rawNode, index2) => {
    var _a3;
    if (false) {
      console.error("[treemate]: node", rawNode, "is invalid");
    }
    const treeNode = Object.create(nodeProto);
    treeNode.rawNode = rawNode;
    treeNode.siblings = treeNodes;
    treeNode.level = level;
    treeNode.index = index2;
    treeNode.isFirstChild = index2 === 0;
    treeNode.isLastChild = index2 + 1 === rawNodes.length;
    treeNode.parent = parent;
    if (!treeNode.ignored) {
      const rawChildren = getChildren(rawNode);
      if (Array.isArray(rawChildren)) {
        treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);
      }
    }
    treeNodes.push(treeNode);
    treeNodeMap.set(treeNode.key, treeNode);
    if (!levelTreeNodeMap.has(level))
      levelTreeNodeMap.set(level, []);
    (_a3 = levelTreeNodeMap.get(level)) === null || _a3 === void 0 ? void 0 : _a3.push(treeNode);
  });
  return treeNodes;
}
function createTreeMate(rawNodes, options = {}) {
  var _a3;
  const treeNodeMap = /* @__PURE__ */ new Map();
  const levelTreeNodeMap = /* @__PURE__ */ new Map();
  const { getDisabled = isDisabled, getIgnored = isIgnored, getIsGroup = isGroup, getKey = defaultGetKey } = options;
  const _getChildren = (_a3 = options.getChildren) !== null && _a3 !== void 0 ? _a3 : defaultGetChildren;
  const getChildren = options.ignoreEmptyChildren ? (node) => {
    const children2 = _getChildren(node);
    if (Array.isArray(children2)) {
      if (!children2.length)
        return null;
      return children2;
    }
    return children2;
  } : _getChildren;
  const nodeProto = Object.assign({
    get key() {
      return getKey(this.rawNode);
    },
    get disabled() {
      return getDisabled(this.rawNode);
    },
    get isGroup() {
      return getIsGroup(this.rawNode);
    },
    get isLeaf() {
      return isLeaf(this.rawNode, getChildren);
    },
    get shallowLoaded() {
      return isShallowLoaded(this.rawNode, getChildren);
    },
    get ignored() {
      return getIgnored(this.rawNode);
    },
    contains(node) {
      return contains2(this, node);
    }
  }, moveMethods);
  const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);
  function getNode(key) {
    if (key === null || key === void 0)
      return null;
    const tmNode = treeNodeMap.get(key);
    if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
      return tmNode;
    }
    return null;
  }
  function _getNode(key) {
    if (key === null || key === void 0)
      return null;
    const tmNode = treeNodeMap.get(key);
    if (tmNode && !tmNode.ignored) {
      return tmNode;
    }
    return null;
  }
  function getPrev(key, options2) {
    const node = _getNode(key);
    if (!node)
      return null;
    return node.getPrev(options2);
  }
  function getNext(key, options2) {
    const node = _getNode(key);
    if (!node)
      return null;
    return node.getNext(options2);
  }
  function getParent(key) {
    const node = _getNode(key);
    if (!node)
      return null;
    return node.getParent();
  }
  function getChild2(key) {
    const node = _getNode(key);
    if (!node)
      return null;
    return node.getChild();
  }
  const treemate = {
    treeNodes,
    treeNodeMap,
    levelTreeNodeMap,
    maxLevel: Math.max(...levelTreeNodeMap.keys()),
    getChildren,
    getFlattenedNodes(expandedKeys) {
      return flatten3(treeNodes, expandedKeys);
    },
    getNode,
    getPrev,
    getNext,
    getParent,
    getChild: getChild2,
    getFirstAvailableNode() {
      return getFirstAvailableNode(treeNodes);
    },
    getPath(key, options2 = {}) {
      return getPath(key, options2, treemate);
    },
    getCheckedKeys(checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    check(keysToCheck, checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        keysToCheck: keysToCheck === void 0 || keysToCheck === null ? [] : toArray2(keysToCheck),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    uncheck(keysToUncheck, checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        keysToUncheck: keysToUncheck === null || keysToUncheck === void 0 ? [] : toArray2(keysToUncheck),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    getNonLeafKeys(options2 = {}) {
      return getNonLeafKeys(treeNodes, options2);
    }
  };
  return treemate;
}

// node_modules/naive-ui/es/_styles/common/dark.js
var base = {
  neutralBase: "#000",
  neutralInvertBase: "#fff",
  neutralTextBase: "#fff",
  neutralPopover: "rgb(72, 72, 78)",
  neutralCard: "rgb(24, 24, 28)",
  neutralModal: "rgb(44, 44, 50)",
  neutralBody: "rgb(16, 16, 20)",
  alpha1: "0.9",
  alpha2: "0.82",
  alpha3: "0.52",
  alpha4: "0.38",
  alpha5: "0.28",
  alphaClose: "0.52",
  alphaDisabled: "0.38",
  alphaDisabledInput: "0.06",
  alphaPending: "0.09",
  alphaTablePending: "0.06",
  alphaTableStriped: "0.05",
  alphaPressed: "0.05",
  alphaAvatar: "0.18",
  alphaRail: "0.2",
  alphaProgressRail: "0.12",
  alphaBorder: "0.24",
  alphaDivider: "0.09",
  alphaInput: "0.1",
  alphaAction: "0.06",
  alphaTab: "0.04",
  alphaScrollbar: "0.2",
  alphaScrollbarHover: "0.3",
  alphaCode: "0.12",
  alphaTag: "0.2",
  primaryHover: "#7fe7c4",
  primaryDefault: "#63e2b7",
  primaryActive: "#5acea7",
  primarySuppl: "rgb(42, 148, 125)",
  infoHover: "#8acbec",
  infoDefault: "#70c0e8",
  infoActive: "#66afd3",
  infoSuppl: "rgb(56, 137, 197)",
  errorHover: "#e98b8b",
  errorDefault: "#e88080",
  errorActive: "#e57272",
  errorSuppl: "rgb(208, 58, 82)",
  warningHover: "#f5d599",
  warningDefault: "#f2c97d",
  warningActive: "#e6c260",
  warningSuppl: "rgb(240, 138, 0)",
  successHover: "#7fe7c4",
  successDefault: "#63e2b7",
  successActive: "#5acea7",
  successSuppl: "rgb(42, 148, 125)"
};
var baseBackgroundRgb = rgba(base.neutralBase);
var baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
var overlayPrefix = "rgba(" + baseInvertBackgroundRgb.slice(0, 3).join(", ") + ", ";
function overlay(alpha2) {
  return overlayPrefix + String(alpha2) + ")";
}
function neutral(alpha2) {
  const overlayRgba = Array.from(baseInvertBackgroundRgb);
  overlayRgba[3] = Number(alpha2);
  return composite(baseBackgroundRgb, overlayRgba);
}
var derived = Object.assign(Object.assign({ name: "common" }, common_default), {
  baseColor: base.neutralBase,
  primaryColor: base.primaryDefault,
  primaryColorHover: base.primaryHover,
  primaryColorPressed: base.primaryActive,
  primaryColorSuppl: base.primarySuppl,
  infoColor: base.infoDefault,
  infoColorHover: base.infoHover,
  infoColorPressed: base.infoActive,
  infoColorSuppl: base.infoSuppl,
  successColor: base.successDefault,
  successColorHover: base.successHover,
  successColorPressed: base.successActive,
  successColorSuppl: base.successSuppl,
  warningColor: base.warningDefault,
  warningColorHover: base.warningHover,
  warningColorPressed: base.warningActive,
  warningColorSuppl: base.warningSuppl,
  errorColor: base.errorDefault,
  errorColorHover: base.errorHover,
  errorColorPressed: base.errorActive,
  errorColorSuppl: base.errorSuppl,
  textColorBase: base.neutralTextBase,
  textColor1: overlay(base.alpha1),
  textColor2: overlay(base.alpha2),
  textColor3: overlay(base.alpha3),
  textColorDisabled: overlay(base.alpha4),
  placeholderColor: overlay(base.alpha4),
  placeholderColorDisabled: overlay(base.alpha5),
  iconColor: overlay(base.alpha4),
  iconColorDisabled: overlay(base.alpha5),
  iconColorHover: overlay(Number(base.alpha4) * 1.25),
  iconColorPressed: overlay(Number(base.alpha4) * 0.8),
  opacity1: base.alpha1,
  opacity2: base.alpha2,
  opacity3: base.alpha3,
  opacity4: base.alpha4,
  opacity5: base.alpha5,
  dividerColor: overlay(base.alphaDivider),
  borderColor: overlay(base.alphaBorder),
  closeIconColorHover: overlay(Number(base.alphaClose)),
  closeIconColor: overlay(Number(base.alphaClose)),
  closeIconColorPressed: overlay(Number(base.alphaClose)),
  closeColorHover: "rgba(255, 255, 255, .12)",
  closeColorPressed: "rgba(255, 255, 255, .08)",
  clearColor: overlay(base.alpha4),
  clearColorHover: scaleColor(overlay(base.alpha4), { alpha: 1.25 }),
  clearColorPressed: scaleColor(overlay(base.alpha4), { alpha: 0.8 }),
  scrollbarColor: overlay(base.alphaScrollbar),
  scrollbarColorHover: overlay(base.alphaScrollbarHover),
  scrollbarWidth: "5px",
  scrollbarHeight: "5px",
  scrollbarBorderRadius: "5px",
  progressRailColor: overlay(base.alphaProgressRail),
  railColor: overlay(base.alphaRail),
  popoverColor: base.neutralPopover,
  tableColor: base.neutralCard,
  cardColor: base.neutralCard,
  modalColor: base.neutralModal,
  bodyColor: base.neutralBody,
  tagColor: neutral(base.alphaTag),
  avatarColor: overlay(base.alphaAvatar),
  invertedColor: base.neutralBase,
  inputColor: overlay(base.alphaInput),
  codeColor: overlay(base.alphaCode),
  tabColor: overlay(base.alphaTab),
  actionColor: overlay(base.alphaAction),
  tableHeaderColor: overlay(base.alphaAction),
  hoverColor: overlay(base.alphaPending),
  tableColorHover: overlay(base.alphaTablePending),
  tableColorStriped: overlay(base.alphaTableStriped),
  pressedColor: overlay(base.alphaPressed),
  opacityDisabled: base.alphaDisabled,
  inputColorDisabled: overlay(base.alphaDisabledInput),
  buttonColor2: "rgba(255, 255, 255, .08)",
  buttonColor2Hover: "rgba(255, 255, 255, .12)",
  buttonColor2Pressed: "rgba(255, 255, 255, .08)",
  boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .24), 0 3px 6px 0 rgba(0, 0, 0, .18), 0 5px 12px 4px rgba(0, 0, 0, .12)",
  boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .24), 0 6px 12px 0 rgba(0, 0, 0, .16), 0 9px 18px 8px rgba(0, 0, 0, .10)",
  boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
});
var dark_default = derived;

// node_modules/naive-ui/es/_styles/common/light.js
var base2 = {
  neutralBase: "#FFF",
  neutralInvertBase: "#000",
  neutralTextBase: "#000",
  neutralPopover: "#fff",
  neutralCard: "#fff",
  neutralModal: "#fff",
  neutralBody: "#fff",
  alpha1: "0.82",
  alpha2: "0.72",
  alpha3: "0.38",
  alpha4: "0.24",
  alpha5: "0.18",
  alphaClose: "0.6",
  alphaDisabled: "0.5",
  alphaDisabledInput: "0.02",
  alphaPending: "0.05",
  alphaTablePending: "0.02",
  alphaPressed: "0.07",
  alphaAvatar: "0.2",
  alphaRail: "0.14",
  alphaProgressRail: ".08",
  alphaBorder: "0.12",
  alphaDivider: "0.06",
  alphaInput: "0",
  alphaAction: "0.02",
  alphaTab: "0.04",
  alphaScrollbar: "0.25",
  alphaScrollbarHover: "0.4",
  alphaCode: "0.05",
  alphaTag: "0.02",
  primaryHover: "#36ad6a",
  primaryDefault: "#18a058",
  primaryActive: "#0c7a43",
  primarySuppl: "#36ad6a",
  infoHover: "#4098fc",
  infoDefault: "#2080f0",
  infoActive: "#1060c9",
  infoSuppl: "#4098fc",
  errorHover: "#de576d",
  errorDefault: "#d03050",
  errorActive: "#ab1f3f",
  errorSuppl: "#de576d",
  warningHover: "#fcb040",
  warningDefault: "#f0a020",
  warningActive: "#c97c10",
  warningSuppl: "#fcb040",
  successHover: "#36ad6a",
  successDefault: "#18a058",
  successActive: "#0c7a43",
  successSuppl: "#36ad6a"
};
var baseBackgroundRgb2 = rgba(base2.neutralBase);
var baseInvertBackgroundRgb2 = rgba(base2.neutralInvertBase);
var overlayPrefix2 = "rgba(" + baseInvertBackgroundRgb2.slice(0, 3).join(", ") + ", ";
function overlay2(alpha2) {
  return overlayPrefix2 + String(alpha2) + ")";
}
function neutral2(alpha2) {
  const overlayRgba = Array.from(baseInvertBackgroundRgb2);
  overlayRgba[3] = Number(alpha2);
  return composite(baseBackgroundRgb2, overlayRgba);
}
var derived2 = Object.assign(Object.assign({ name: "common" }, common_default), {
  baseColor: base2.neutralBase,
  primaryColor: base2.primaryDefault,
  primaryColorHover: base2.primaryHover,
  primaryColorPressed: base2.primaryActive,
  primaryColorSuppl: base2.primarySuppl,
  infoColor: base2.infoDefault,
  infoColorHover: base2.infoHover,
  infoColorPressed: base2.infoActive,
  infoColorSuppl: base2.infoSuppl,
  successColor: base2.successDefault,
  successColorHover: base2.successHover,
  successColorPressed: base2.successActive,
  successColorSuppl: base2.successSuppl,
  warningColor: base2.warningDefault,
  warningColorHover: base2.warningHover,
  warningColorPressed: base2.warningActive,
  warningColorSuppl: base2.warningSuppl,
  errorColor: base2.errorDefault,
  errorColorHover: base2.errorHover,
  errorColorPressed: base2.errorActive,
  errorColorSuppl: base2.errorSuppl,
  textColorBase: base2.neutralTextBase,
  textColor1: "rgb(31, 34, 37)",
  textColor2: "rgb(51, 54, 57)",
  textColor3: "rgb(118, 124, 130)",
  textColorDisabled: neutral2(base2.alpha4),
  placeholderColor: neutral2(base2.alpha4),
  placeholderColorDisabled: neutral2(base2.alpha5),
  iconColor: neutral2(base2.alpha4),
  iconColorHover: scaleColor(neutral2(base2.alpha4), { lightness: 0.75 }),
  iconColorPressed: scaleColor(neutral2(base2.alpha4), { lightness: 0.9 }),
  iconColorDisabled: neutral2(base2.alpha5),
  opacity1: base2.alpha1,
  opacity2: base2.alpha2,
  opacity3: base2.alpha3,
  opacity4: base2.alpha4,
  opacity5: base2.alpha5,
  dividerColor: "rgb(239, 239, 245)",
  borderColor: "rgb(224, 224, 230)",
  closeIconColor: neutral2(Number(base2.alphaClose)),
  closeIconColorHover: neutral2(Number(base2.alphaClose)),
  closeIconColorPressed: neutral2(Number(base2.alphaClose)),
  closeColorHover: "rgba(0, 0, 0, .09)",
  closeColorPressed: "rgba(0, 0, 0, .13)",
  clearColor: neutral2(base2.alpha4),
  clearColorHover: scaleColor(neutral2(base2.alpha4), { lightness: 0.75 }),
  clearColorPressed: scaleColor(neutral2(base2.alpha4), { lightness: 0.9 }),
  scrollbarColor: overlay2(base2.alphaScrollbar),
  scrollbarColorHover: overlay2(base2.alphaScrollbarHover),
  scrollbarWidth: "5px",
  scrollbarHeight: "5px",
  scrollbarBorderRadius: "5px",
  progressRailColor: neutral2(base2.alphaProgressRail),
  railColor: "rgb(219, 219, 223)",
  popoverColor: base2.neutralPopover,
  tableColor: base2.neutralCard,
  cardColor: base2.neutralCard,
  modalColor: base2.neutralModal,
  bodyColor: base2.neutralBody,
  tagColor: "#eee",
  avatarColor: neutral2(base2.alphaAvatar),
  invertedColor: "rgb(0, 20, 40)",
  inputColor: neutral2(base2.alphaInput),
  codeColor: "rgb(244, 244, 248)",
  tabColor: "rgb(247, 247, 250)",
  actionColor: "rgb(250, 250, 252)",
  tableHeaderColor: "rgb(250, 250, 252)",
  hoverColor: "rgb(243, 243, 245)",
  tableColorHover: "rgba(0, 0, 100, 0.03)",
  tableColorStriped: "rgba(0, 0, 100, 0.02)",
  pressedColor: "rgb(237, 237, 239)",
  opacityDisabled: base2.alphaDisabled,
  inputColorDisabled: "rgb(250, 250, 252)",
  buttonColor2: "rgba(46, 51, 56, .05)",
  buttonColor2Hover: "rgba(46, 51, 56, .09)",
  buttonColor2Pressed: "rgba(46, 51, 56, .13)",
  boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
  boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
  boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
});
var light_default = derived2;

// node_modules/naive-ui/es/empty/styles/_common.js
var common_default2 = {
  iconSizeSmall: "34px",
  iconSizeMedium: "40px",
  iconSizeLarge: "46px",
  iconSizeHuge: "52px"
};

// node_modules/naive-ui/es/empty/styles/light.js
var self2 = (vars) => {
  const { textColorDisabled, iconColor, textColor2, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge } = vars;
  return Object.assign(Object.assign({}, common_default2), {
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    fontSizeHuge,
    textColor: textColorDisabled,
    iconColor,
    extraTextColor: textColor2
  });
};
var emptyLight = {
  name: "Empty",
  common: light_default,
  self: self2
};
var light_default2 = emptyLight;

// node_modules/naive-ui/es/empty/styles/dark.js
var emptyDark = {
  name: "Empty",
  common: dark_default,
  self: self2
};
var dark_default2 = emptyDark;

// node_modules/naive-ui/es/empty/src/styles/index.cssr.js
var index_cssr_default5 = cB("empty", `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [cE("icon", `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [c3("+", [cE("description", `
 margin-top: 8px;
 `)])]), cE("description", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE("extra", `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]);

// node_modules/naive-ui/es/empty/src/Empty.js
var emptyProps = Object.assign(Object.assign({}, use_theme_default.props), { description: String, showDescription: {
  type: Boolean,
  default: true
}, showIcon: {
  type: Boolean,
  default: true
}, size: {
  type: String,
  default: "medium"
}, renderIcon: Function });
var Empty_default2 = defineComponent({
  name: "Empty",
  props: emptyProps,
  setup(props) {
    const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
    const themeRef = use_theme_default("Empty", "-empty", index_cssr_default5, light_default2, props, mergedClsPrefixRef);
    const { localeRef } = useLocale("Empty");
    const NConfigProvider = inject(configProviderInjectionKey, null);
    const mergedDescriptionRef = computed2(() => {
      var _a3, _b2, _c;
      return (_a3 = props.description) !== null && _a3 !== void 0 ? _a3 : (_c = (_b2 = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value) === null || _b2 === void 0 ? void 0 : _b2.Empty) === null || _c === void 0 ? void 0 : _c.description;
    });
    const mergedRenderIconRef = computed2(() => {
      var _a3, _b2;
      return ((_b2 = (_a3 = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value) === null || _a3 === void 0 ? void 0 : _a3.Empty) === null || _b2 === void 0 ? void 0 : _b2.renderIcon) || (() => h3(Empty_default, null));
    });
    const cssVarsRef = computed2(() => {
      const { size: size3 } = props;
      const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut5 }, self: { [createKey("iconSize", size3)]: iconSize, [createKey("fontSize", size3)]: fontSize2, textColor, iconColor, extraTextColor } } = themeRef.value;
      return {
        "--n-icon-size": iconSize,
        "--n-font-size": fontSize2,
        "--n-bezier": cubicBezierEaseInOut5,
        "--n-text-color": textColor,
        "--n-icon-color": iconColor,
        "--n-extra-text-color": extraTextColor
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("empty", computed2(() => {
      let hash = "";
      const { size: size3 } = props;
      hash += size3[0];
      return hash;
    }), cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      mergedRenderIcon: mergedRenderIconRef,
      localizedDescription: computed2(() => {
        return mergedDescriptionRef.value || localeRef.value.description;
      }),
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const { $slots, mergedClsPrefix, onRender } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return h3("div", { class: [`${mergedClsPrefix}-empty`, this.themeClass], style: this.cssVars }, this.showIcon ? h3("div", { class: `${mergedClsPrefix}-empty__icon` }, $slots.icon ? $slots.icon() : h3(Icon_default, { clsPrefix: mergedClsPrefix }, { default: this.mergedRenderIcon })) : null, this.showDescription ? h3("div", { class: `${mergedClsPrefix}-empty__description` }, $slots.default ? $slots.default() : this.localizedDescription) : null, $slots.extra ? h3("div", { class: `${mergedClsPrefix}-empty__extra` }, $slots.extra()) : null);
  }
});

// node_modules/naive-ui/es/_internal/scrollbar/styles/light.js
var self3 = (vars) => {
  const { scrollbarColor, scrollbarColorHover } = vars;
  return {
    color: scrollbarColor,
    colorHover: scrollbarColorHover
  };
};
var scrollbarLight = {
  name: "Scrollbar",
  common: light_default,
  self: self3
};
var light_default3 = scrollbarLight;

// node_modules/naive-ui/es/_internal/scrollbar/styles/dark.js
var scrollbarDark = {
  name: "Scrollbar",
  common: dark_default,
  self: self3
};
var dark_default3 = scrollbarDark;

// node_modules/naive-ui/es/_styles/transitions/fade-in.cssr.js
var {
  cubicBezierEaseInOut: cubicBezierEaseInOut2
} = common_default;
function fadeInTransition({
  name: name2 = "fade-in",
  enterDuration = "0.2s",
  leaveDuration = "0.2s",
  enterCubicBezier = cubicBezierEaseInOut2,
  leaveCubicBezier = cubicBezierEaseInOut2
} = {}) {
  return [c3(`&.${name2}-transition-enter-active`, {
    transition: `all ${enterDuration} ${enterCubicBezier}!important`
  }), c3(`&.${name2}-transition-leave-active`, {
    transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
  }), c3(`&.${name2}-transition-enter-from, &.${name2}-transition-leave-to`, {
    opacity: 0
  }), c3(`&.${name2}-transition-leave-from, &.${name2}-transition-enter-to`, {
    opacity: 1
  })];
}

// node_modules/naive-ui/es/_internal/scrollbar/src/styles/index.cssr.js
var index_cssr_default6 = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c3(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 max-height: inherit;
 scrollbar-width: none;
 `, [c3("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c3(">", [cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)])])]), c3(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 -webkit-user-select: none;
 `, [cM("horizontal", `
 left: 2px;
 right: 2px;
 bottom: 4px;
 height: var(--n-scrollbar-height);
 `, [c3(">", [cE("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM("vertical", `
 right: 4px;
 top: 2px;
 bottom: 2px;
 width: var(--n-scrollbar-width);
 `, [c3(">", [cE("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM("disabled", [c3(">", [cE("scrollbar", {
  pointerEvents: "none"
})])]), c3(">", [cE("scrollbar", `
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c3("&:hover", {
  backgroundColor: "var(--n-scrollbar-color-hover)"
})])])])])]);

// node_modules/naive-ui/es/_internal/scrollbar/src/Scrollbar.js
var scrollbarProps = Object.assign(Object.assign({}, use_theme_default.props), {
  size: {
    type: Number,
    default: 5
  },
  duration: {
    type: Number,
    default: 0
  },
  scrollable: {
    type: Boolean,
    default: true
  },
  xScrollable: Boolean,
  trigger: {
    type: String,
    default: "hover"
  },
  useUnifiedContainer: Boolean,
  triggerDisplayManually: Boolean,
  container: Function,
  content: Function,
  containerClass: String,
  containerStyle: [String, Object],
  contentClass: String,
  contentStyle: [String, Object],
  horizontalRailStyle: [String, Object],
  verticalRailStyle: [String, Object],
  onScroll: Function,
  onWheel: Function,
  onResize: Function,
  internalOnUpdateScrollLeft: Function,
  internalHoistYRail: Boolean
});
var Scrollbar = defineComponent({
  name: "Scrollbar",
  props: scrollbarProps,
  inheritAttrs: false,
  setup(props) {
    const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
    const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
    const wrapperRef = ref(null);
    const containerRef = ref(null);
    const contentRef = ref(null);
    const yRailRef = ref(null);
    const xRailRef = ref(null);
    const contentHeightRef = ref(null);
    const contentWidthRef = ref(null);
    const containerHeightRef = ref(null);
    const containerWidthRef = ref(null);
    const yRailSizeRef = ref(null);
    const xRailSizeRef = ref(null);
    const containerScrollTopRef = ref(0);
    const containerScrollLeftRef = ref(0);
    const isShowXBarRef = ref(false);
    const isShowYBarRef = ref(false);
    let yBarPressed = false;
    let xBarPressed = false;
    let xBarVanishTimerId;
    let yBarVanishTimerId;
    let memoYTop = 0;
    let memoXLeft = 0;
    let memoMouseX = 0;
    let memoMouseY = 0;
    const isIos2 = useIsIos();
    const yBarSizeRef = computed2(() => {
      const { value: containerHeight } = containerHeightRef;
      const { value: contentHeight } = contentHeightRef;
      const { value: yRailSize } = yRailSizeRef;
      if (containerHeight === null || contentHeight === null || yRailSize === null) {
        return 0;
      } else {
        return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + props.size * 1.5);
      }
    });
    const yBarSizePxRef = computed2(() => {
      return `${yBarSizeRef.value}px`;
    });
    const xBarSizeRef = computed2(() => {
      const { value: containerWidth } = containerWidthRef;
      const { value: contentWidth } = contentWidthRef;
      const { value: xRailSize } = xRailSizeRef;
      if (containerWidth === null || contentWidth === null || xRailSize === null) {
        return 0;
      } else {
        return xRailSize * containerWidth / contentWidth + props.size * 1.5;
      }
    });
    const xBarSizePxRef = computed2(() => {
      return `${xBarSizeRef.value}px`;
    });
    const yBarTopRef = computed2(() => {
      const { value: containerHeight } = containerHeightRef;
      const { value: containerScrollTop } = containerScrollTopRef;
      const { value: contentHeight } = contentHeightRef;
      const { value: yRailSize } = yRailSizeRef;
      if (containerHeight === null || contentHeight === null || yRailSize === null) {
        return 0;
      } else {
        const heightDiff = contentHeight - containerHeight;
        if (!heightDiff)
          return 0;
        return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
      }
    });
    const yBarTopPxRef = computed2(() => {
      return `${yBarTopRef.value}px`;
    });
    const xBarLeftRef = computed2(() => {
      const { value: containerWidth } = containerWidthRef;
      const { value: containerScrollLeft } = containerScrollLeftRef;
      const { value: contentWidth } = contentWidthRef;
      const { value: xRailSize } = xRailSizeRef;
      if (containerWidth === null || contentWidth === null || xRailSize === null) {
        return 0;
      } else {
        const widthDiff = contentWidth - containerWidth;
        if (!widthDiff)
          return 0;
        return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
      }
    });
    const xBarLeftPxRef = computed2(() => {
      return `${xBarLeftRef.value}px`;
    });
    const needYBarRef = computed2(() => {
      const { value: containerHeight } = containerHeightRef;
      const { value: contentHeight } = contentHeightRef;
      return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
    });
    const needXBarRef = computed2(() => {
      const { value: containerWidth } = containerWidthRef;
      const { value: contentWidth } = contentWidthRef;
      return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
    });
    const mergedShowXBarRef = computed2(() => {
      const { trigger: trigger3 } = props;
      return trigger3 === "none" || isShowXBarRef.value;
    });
    const mergedShowYBarRef = computed2(() => {
      const { trigger: trigger3 } = props;
      return trigger3 === "none" || isShowYBarRef.value;
    });
    const mergedContainerRef = computed2(() => {
      const { container } = props;
      if (container)
        return container();
      return containerRef.value;
    });
    const mergedContentRef = computed2(() => {
      const { content } = props;
      if (content)
        return content();
      return contentRef.value;
    });
    const activateState = useReactivated(() => {
      if (!props.container) {
        scrollTo({
          top: containerScrollTopRef.value,
          left: containerScrollLeftRef.value
        });
      }
    });
    const handleContentResize = () => {
      if (activateState.isDeactivated)
        return;
      sync();
    };
    const handleContainerResize = (e3) => {
      if (activateState.isDeactivated)
        return;
      const { onResize } = props;
      if (onResize)
        onResize(e3);
      sync();
    };
    const scrollTo = (options, y3) => {
      if (!props.scrollable)
        return;
      if (typeof options === "number") {
        scrollToPosition(y3 !== null && y3 !== void 0 ? y3 : 0, options, 0, false, "auto");
        return;
      }
      const { left, top, index: index2, elSize, position, behavior, el, debounce: debounce3 = true } = options;
      if (left !== void 0 || top !== void 0) {
        scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
      }
      if (el !== void 0) {
        scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce3, behavior);
      } else if (index2 !== void 0 && elSize !== void 0) {
        scrollToPosition(0, index2 * elSize, elSize, debounce3, behavior);
      } else if (position === "bottom") {
        scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
      } else if (position === "top") {
        scrollToPosition(0, 0, 0, false, behavior);
      }
    };
    const scrollBy = (options, y3) => {
      if (!props.scrollable)
        return;
      const { value: container } = mergedContainerRef;
      if (!container)
        return;
      if (typeof options === "object") {
        container.scrollBy(options);
      } else {
        container.scrollBy(options, y3 || 0);
      }
    };
    function scrollToPosition(left, top, elSize, debounce3, behavior) {
      const { value: container } = mergedContainerRef;
      if (!container)
        return;
      if (debounce3) {
        const { scrollTop, offsetHeight } = container;
        if (top > scrollTop) {
          if (top + elSize <= scrollTop + offsetHeight) {
          } else {
            container.scrollTo({
              left,
              top: top + elSize - offsetHeight,
              behavior
            });
          }
          return;
        }
      }
      container.scrollTo({
        left,
        top,
        behavior
      });
    }
    function handleMouseEnterWrapper() {
      showXBar();
      showYBar();
      sync();
    }
    function handleMouseLeaveWrapper() {
      hideBar();
    }
    function hideBar() {
      hideYBar();
      hideXBar();
    }
    function hideYBar() {
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      yBarVanishTimerId = window.setTimeout(() => {
        isShowYBarRef.value = false;
      }, props.duration);
    }
    function hideXBar() {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      xBarVanishTimerId = window.setTimeout(() => {
        isShowXBarRef.value = false;
      }, props.duration);
    }
    function showXBar() {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      isShowXBarRef.value = true;
    }
    function showYBar() {
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      isShowYBarRef.value = true;
    }
    function handleScroll(e3) {
      const { onScroll } = props;
      if (onScroll)
        onScroll(e3);
      syncScrollState();
    }
    function syncScrollState() {
      const { value: container } = mergedContainerRef;
      if (container) {
        containerScrollTopRef.value = container.scrollTop;
        containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
      }
    }
    function syncPositionState() {
      const { value: content } = mergedContentRef;
      if (content) {
        contentHeightRef.value = content.offsetHeight;
        contentWidthRef.value = content.offsetWidth;
      }
      const { value: container } = mergedContainerRef;
      if (container) {
        containerHeightRef.value = container.offsetHeight;
        containerWidthRef.value = container.offsetWidth;
      }
      const { value: xRailEl } = xRailRef;
      const { value: yRailEl } = yRailRef;
      if (xRailEl) {
        xRailSizeRef.value = xRailEl.offsetWidth;
      }
      if (yRailEl) {
        yRailSizeRef.value = yRailEl.offsetHeight;
      }
    }
    function syncUnifiedContainer() {
      const { value: container } = mergedContainerRef;
      if (container) {
        containerScrollTopRef.value = container.scrollTop;
        containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
        containerHeightRef.value = container.offsetHeight;
        containerWidthRef.value = container.offsetWidth;
        contentHeightRef.value = container.scrollHeight;
        contentWidthRef.value = container.scrollWidth;
      }
      const { value: xRailEl } = xRailRef;
      const { value: yRailEl } = yRailRef;
      if (xRailEl) {
        xRailSizeRef.value = xRailEl.offsetWidth;
      }
      if (yRailEl) {
        yRailSizeRef.value = yRailEl.offsetHeight;
      }
    }
    function sync() {
      if (!props.scrollable)
        return;
      if (props.useUnifiedContainer) {
        syncUnifiedContainer();
      } else {
        syncPositionState();
        syncScrollState();
      }
    }
    function isMouseUpAway(e3) {
      var _a3;
      return !((_a3 = wrapperRef.value) === null || _a3 === void 0 ? void 0 : _a3.contains(getPreciseEventTarget(e3)));
    }
    function handleXScrollMouseDown(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      xBarPressed = true;
      on("mousemove", window, handleXScrollMouseMove, true);
      on("mouseup", window, handleXScrollMouseUp, true);
      memoXLeft = containerScrollLeftRef.value;
      memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e3.clientX : e3.clientX;
    }
    function handleXScrollMouseMove(e3) {
      if (!xBarPressed)
        return;
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      const { value: containerWidth } = containerWidthRef;
      const { value: contentWidth } = contentWidthRef;
      const { value: xBarSize } = xBarSizeRef;
      if (containerWidth === null || contentWidth === null)
        return;
      const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e3.clientX - memoMouseX : e3.clientX - memoMouseX;
      const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
      const toScrollLeftUpperBound = contentWidth - containerWidth;
      let toScrollLeft = memoXLeft + dScrollLeft;
      toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
      toScrollLeft = Math.max(toScrollLeft, 0);
      const { value: container } = mergedContainerRef;
      if (container) {
        container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
        const { internalOnUpdateScrollLeft } = props;
        if (internalOnUpdateScrollLeft)
          internalOnUpdateScrollLeft(toScrollLeft);
      }
    }
    function handleXScrollMouseUp(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      off("mousemove", window, handleXScrollMouseMove, true);
      off("mouseup", window, handleXScrollMouseUp, true);
      xBarPressed = false;
      sync();
      if (isMouseUpAway(e3)) {
        hideBar();
      }
    }
    function handleYScrollMouseDown(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      yBarPressed = true;
      on("mousemove", window, handleYScrollMouseMove, true);
      on("mouseup", window, handleYScrollMouseUp, true);
      memoYTop = containerScrollTopRef.value;
      memoMouseY = e3.clientY;
    }
    function handleYScrollMouseMove(e3) {
      if (!yBarPressed)
        return;
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      const { value: containerHeight } = containerHeightRef;
      const { value: contentHeight } = contentHeightRef;
      const { value: yBarSize } = yBarSizeRef;
      if (containerHeight === null || contentHeight === null)
        return;
      const dY = e3.clientY - memoMouseY;
      const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
      const toScrollTopUpperBound = contentHeight - containerHeight;
      let toScrollTop = memoYTop + dScrollTop;
      toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
      toScrollTop = Math.max(toScrollTop, 0);
      const { value: container } = mergedContainerRef;
      if (container) {
        container.scrollTop = toScrollTop;
      }
    }
    function handleYScrollMouseUp(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      off("mousemove", window, handleYScrollMouseMove, true);
      off("mouseup", window, handleYScrollMouseUp, true);
      yBarPressed = false;
      sync();
      if (isMouseUpAway(e3)) {
        hideBar();
      }
    }
    watchEffect(() => {
      const { value: needXBar } = needXBarRef;
      const { value: needYBar } = needYBarRef;
      const { value: mergedClsPrefix } = mergedClsPrefixRef;
      const { value: xRailEl } = xRailRef;
      const { value: yRailEl } = yRailRef;
      if (xRailEl) {
        if (!needXBar) {
          xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        } else {
          xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        }
      }
      if (yRailEl) {
        if (!needYBar) {
          yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        } else {
          yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        }
      }
    });
    onMounted(() => {
      if (props.container)
        return;
      sync();
    });
    onBeforeUnmount(() => {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      off("mousemove", window, handleYScrollMouseMove, true);
      off("mouseup", window, handleYScrollMouseUp, true);
    });
    const themeRef = use_theme_default("Scrollbar", "-scrollbar", index_cssr_default6, light_default3, props, mergedClsPrefixRef);
    const cssVarsRef = computed2(() => {
      const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut5, scrollbarBorderRadius, scrollbarHeight, scrollbarWidth }, self: { color: color2, colorHover } } = themeRef.value;
      return {
        "--n-scrollbar-bezier": cubicBezierEaseInOut5,
        "--n-scrollbar-color": color2,
        "--n-scrollbar-color-hover": colorHover,
        "--n-scrollbar-border-radius": scrollbarBorderRadius,
        "--n-scrollbar-width": scrollbarWidth,
        "--n-scrollbar-height": scrollbarHeight
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
    const exposedMethods = {
      scrollTo,
      scrollBy,
      sync,
      syncUnifiedContainer,
      handleMouseEnterWrapper,
      handleMouseLeaveWrapper
    };
    return Object.assign(Object.assign({}, exposedMethods), {
      mergedClsPrefix: mergedClsPrefixRef,
      rtlEnabled: rtlEnabledRef,
      containerScrollTop: containerScrollTopRef,
      wrapperRef,
      containerRef,
      contentRef,
      yRailRef,
      xRailRef,
      needYBar: needYBarRef,
      needXBar: needXBarRef,
      yBarSizePx: yBarSizePxRef,
      xBarSizePx: xBarSizePxRef,
      yBarTopPx: yBarTopPxRef,
      xBarLeftPx: xBarLeftPxRef,
      isShowXBar: mergedShowXBarRef,
      isShowYBar: mergedShowYBarRef,
      isIos: isIos2,
      handleScroll,
      handleContentResize,
      handleContainerResize,
      handleYScrollMouseDown,
      handleXScrollMouseDown,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    });
  },
  render() {
    var _a3;
    const { $slots, mergedClsPrefix, triggerDisplayManually, rtlEnabled, internalHoistYRail } = this;
    if (!this.scrollable)
      return (_a3 = $slots.default) === null || _a3 === void 0 ? void 0 : _a3.call($slots);
    const triggerIsNone = this.trigger === "none";
    const createYRail = () => {
      return h3("div", { ref: "yRailRef", class: [
        `${mergedClsPrefix}-scrollbar-rail`,
        `${mergedClsPrefix}-scrollbar-rail--vertical`
      ], "data-scrollbar-rail": true, style: this.verticalRailStyle, "aria-hidden": true }, h3(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : { name: "fade-in-transition" }, {
        default: () => this.needYBar && this.isShowYBar && !this.isIos ? h3("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
          height: this.yBarSizePx,
          top: this.yBarTopPx
        }, onMousedown: this.handleYScrollMouseDown }) : null
      }));
    };
    const createChildren = () => {
      var _a4, _b2;
      (_a4 = this.onRender) === null || _a4 === void 0 ? void 0 : _a4.call(this);
      return h3("div", mergeProps(this.$attrs, {
        role: "none",
        ref: "wrapperRef",
        class: [
          `${mergedClsPrefix}-scrollbar`,
          this.themeClass,
          rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`
        ],
        style: this.cssVars,
        onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
        onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
      }), [
        this.container ? (_b2 = $slots.default) === null || _b2 === void 0 ? void 0 : _b2.call($slots) : h3("div", { role: "none", ref: "containerRef", class: [
          `${mergedClsPrefix}-scrollbar-container`,
          this.containerClass
        ], style: this.containerStyle, onScroll: this.handleScroll, onWheel: this.onWheel }, h3(VResizeObserver_default, { onResize: this.handleContentResize }, {
          default: () => h3("div", { ref: "contentRef", role: "none", style: [
            {
              width: this.xScrollable ? "fit-content" : null
            },
            this.contentStyle
          ], class: [
            `${mergedClsPrefix}-scrollbar-content`,
            this.contentClass
          ] }, $slots)
        })),
        internalHoistYRail ? null : createYRail(),
        this.xScrollable && h3("div", { ref: "xRailRef", class: [
          `${mergedClsPrefix}-scrollbar-rail`,
          `${mergedClsPrefix}-scrollbar-rail--horizontal`
        ], style: this.horizontalRailStyle, "data-scrollbar-rail": true, "aria-hidden": true }, h3(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : { name: "fade-in-transition" }, {
          default: () => this.needXBar && this.isShowXBar && !this.isIos ? h3("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
            width: this.xBarSizePx,
            right: rtlEnabled ? this.xBarLeftPx : void 0,
            left: rtlEnabled ? void 0 : this.xBarLeftPx
          }, onMousedown: this.handleXScrollMouseDown }) : null
        }))
      ]);
    };
    const scrollbarNode = this.container ? createChildren() : h3(VResizeObserver_default, { onResize: this.handleContainerResize }, {
      default: createChildren
    });
    if (internalHoistYRail) {
      return h3(Fragment, null, scrollbarNode, createYRail());
    } else {
      return scrollbarNode;
    }
  }
});
var XScrollbar = Scrollbar;

// node_modules/naive-ui/es/_internal/select-menu/styles/_common.js
var common_default3 = {
  height: "calc(var(--n-option-height) * 7.6)",
  paddingSmall: "4px 0",
  paddingMedium: "4px 0",
  paddingLarge: "4px 0",
  paddingHuge: "4px 0",
  optionPaddingSmall: "0 12px",
  optionPaddingMedium: "0 12px",
  optionPaddingLarge: "0 12px",
  optionPaddingHuge: "0 12px",
  loadingSize: "18px"
};

// node_modules/naive-ui/es/_internal/select-menu/styles/light.js
var self4 = (vars) => {
  const { borderRadius, popoverColor, textColor3, dividerColor, textColor2, primaryColorPressed, textColorDisabled, primaryColor, opacityDisabled, hoverColor, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge, heightSmall, heightMedium, heightLarge, heightHuge } = vars;
  return Object.assign(Object.assign({}, common_default3), { optionFontSizeSmall: fontSizeSmall, optionFontSizeMedium: fontSizeMedium, optionFontSizeLarge: fontSizeLarge, optionFontSizeHuge: fontSizeHuge, optionHeightSmall: heightSmall, optionHeightMedium: heightMedium, optionHeightLarge: heightLarge, optionHeightHuge: heightHuge, borderRadius, color: popoverColor, groupHeaderTextColor: textColor3, actionDividerColor: dividerColor, optionTextColor: textColor2, optionTextColorPressed: primaryColorPressed, optionTextColorDisabled: textColorDisabled, optionTextColorActive: primaryColor, optionOpacityDisabled: opacityDisabled, optionCheckColor: primaryColor, optionColorPending: hoverColor, optionColorActive: "rgba(0, 0, 0, 0)", optionColorActivePending: hoverColor, actionTextColor: textColor2, loadingColor: primaryColor });
};
var internalSelectMenuLight = createTheme({
  name: "InternalSelectMenu",
  common: light_default,
  peers: {
    Scrollbar: light_default3,
    Empty: light_default2
  },
  self: self4
});
var light_default4 = internalSelectMenuLight;

// node_modules/naive-ui/es/_internal/select-menu/styles/dark.js
var internalSelectMenuDark = {
  name: "InternalSelectMenu",
  common: dark_default,
  peers: {
    Scrollbar: dark_default3,
    Empty: dark_default2
  },
  self: self4
};
var dark_default4 = internalSelectMenuDark;

// node_modules/naive-ui/es/_styles/transitions/fade-in-scale-up.cssr.js
var {
  cubicBezierEaseIn,
  cubicBezierEaseOut
} = common_default;
function fadeInScaleUpTransition({
  transformOrigin = "inherit",
  duration = ".2s",
  enterScale = ".9",
  originalTransform = "",
  originalTransition = ""
} = {}) {
  return [c3("&.fade-in-scale-up-transition-leave-active", {
    transformOrigin,
    transition: `opacity ${duration} ${cubicBezierEaseIn}, transform ${duration} ${cubicBezierEaseIn} ${originalTransition && "," + originalTransition}`
  }), c3("&.fade-in-scale-up-transition-enter-active", {
    transformOrigin,
    transition: `opacity ${duration} ${cubicBezierEaseOut}, transform ${duration} ${cubicBezierEaseOut} ${originalTransition && "," + originalTransition}`
  }), c3("&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to", {
    opacity: 0,
    transform: `${originalTransform} scale(${enterScale})`
  }), c3("&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to", {
    opacity: 1,
    transform: `${originalTransform} scale(1)`
  })];
}

// node_modules/naive-ui/es/_internal/wave/src/styles/index.cssr.js
var index_cssr_default7 = cB("base-wave", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`);

// node_modules/naive-ui/es/_internal/wave/src/Wave.js
var Wave_default = defineComponent({
  name: "BaseWave",
  props: {
    clsPrefix: {
      type: String,
      required: true
    }
  },
  setup(props) {
    useStyle("-base-wave", index_cssr_default7, toRef(props, "clsPrefix"));
    const selfRef = ref(null);
    const activeRef = ref(false);
    let animationTimerId = null;
    onBeforeUnmount(() => {
      if (animationTimerId !== null) {
        window.clearTimeout(animationTimerId);
      }
    });
    return {
      active: activeRef,
      selfRef,
      play() {
        if (animationTimerId !== null) {
          window.clearTimeout(animationTimerId);
          activeRef.value = false;
          animationTimerId = null;
        }
        void nextTick(() => {
          var _a3;
          void ((_a3 = selfRef.value) === null || _a3 === void 0 ? void 0 : _a3.offsetHeight);
          activeRef.value = true;
          animationTimerId = window.setTimeout(() => {
            activeRef.value = false;
            animationTimerId = null;
          }, 1e3);
        });
      }
    };
  },
  render() {
    const { clsPrefix } = this;
    return h3("div", { ref: "selfRef", "aria-hidden": true, class: [
      `${clsPrefix}-base-wave`,
      this.active && `${clsPrefix}-base-wave--active`
    ] });
  }
});

// node_modules/naive-ui/es/popover/styles/_common.js
var common_default4 = {
  space: "6px",
  spaceArrow: "10px",
  arrowOffset: "10px",
  arrowOffsetVertical: "10px",
  arrowHeight: "6px",
  padding: "8px 14px"
};

// node_modules/naive-ui/es/popover/styles/light.js
var self5 = (vars) => {
  const { boxShadow2, popoverColor, textColor2, borderRadius, fontSize: fontSize2, dividerColor } = vars;
  return Object.assign(Object.assign({}, common_default4), {
    fontSize: fontSize2,
    borderRadius,
    color: popoverColor,
    dividerColor,
    textColor: textColor2,
    boxShadow: boxShadow2
  });
};
var popoverLight = {
  name: "Popover",
  common: light_default,
  self: self5
};
var light_default5 = popoverLight;

// node_modules/naive-ui/es/popover/styles/dark.js
var popoverDark = {
  name: "Popover",
  common: dark_default,
  self: self5
};
var dark_default5 = popoverDark;

// node_modules/naive-ui/es/popover/src/styles/index.cssr.js
var oppositePlacement = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
var arrowSize = "var(--n-arrow-height) * 1.414";
var index_cssr_default8 = c3([cB("popover", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 box-shadow: var(--n-box-shadow);
 word-break: break-word;
 `, [c3(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("raw", `
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 `, [cNotM("scrollable", [cNotM("show-header-or-footer", "padding: var(--n-padding);")])]), cE("header", `
 padding: var(--n-padding);
 border-bottom: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cE("footer", `
 padding: var(--n-padding);
 border-top: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cM("scrollable, show-header-or-footer", [cE("content", `
 padding: var(--n-padding);
 `)])]), cB("popover-shared", `
 transform-origin: inherit;
 `, [
  cB("popover-arrow-wrapper", `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [cB("popover-arrow", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 display: block;
 width: calc(${arrowSize});
 height: calc(${arrowSize});
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--n-color);
 pointer-events: all;
 `)]),
  c3("&.popover-transition-enter-from, &.popover-transition-leave-to", `
 opacity: 0;
 transform: scale(.85);
 `),
  c3("&.popover-transition-enter-to, &.popover-transition-leave-from", `
 transform: scale(1);
 opacity: 1;
 `),
  c3("&.popover-transition-enter-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-out),
 transform .15s var(--n-bezier-ease-out);
 `),
  c3("&.popover-transition-leave-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-in),
 transform .15s var(--n-bezier-ease-in);
 `)
]), placementStyle("top-start", `
 top: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("top-start")} - var(--v-offset-left));
 `), placementStyle("top", `
 top: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("top-end", `
 top: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("top-end")} + var(--v-offset-left));
 `), placementStyle("bottom-start", `
 bottom: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("bottom-start")} - var(--v-offset-left));
 `), placementStyle("bottom", `
 bottom: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("bottom-end", `
 bottom: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("bottom-end")} + var(--v-offset-left));
 `), placementStyle("left-start", `
 left: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("left-start")} - var(--v-offset-top));
 `), placementStyle("left", `
 left: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("left-end", `
 left: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("left-end")} + var(--v-offset-top));
 `), placementStyle("right-start", `
 right: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("right-start")} - var(--v-offset-top));
 `), placementStyle("right", `
 right: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("right-end", `
 right: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("right-end")} + var(--v-offset-top));
 `), ...map_default({
  top: ["right-start", "left-start"],
  right: ["top-end", "bottom-end"],
  bottom: ["right-end", "left-end"],
  left: ["top-start", "bottom-start"]
}, (placements, direction) => {
  const isVertical = ["right", "left"].includes(direction);
  const sizeType = isVertical ? "width" : "height";
  return placements.map((placement) => {
    const isReverse = placement.split("-")[1] === "end";
    const targetSize = `var(--v-target-${sizeType}, 0px)`;
    const centerOffset = `calc((${targetSize} - ${arrowSize}) / 2)`;
    const offset = getArrowOffset(placement);
    return c3(`[v-placement="${placement}"] >`, [cB("popover-shared", [cM("center-arrow", [cB("popover-arrow", `${direction}: calc(max(${centerOffset}, ${offset}) ${isReverse ? "+" : "-"} var(--v-offset-${isVertical ? "left" : "top"}));`)])])]);
  });
})]);
function getArrowOffset(placement) {
  return ["top", "bottom"].includes(placement.split("-")[0]) ? "var(--n-arrow-offset)" : "var(--n-arrow-offset-vertical)";
}
function placementStyle(placement, arrowStyleLiteral) {
  const position = placement.split("-")[0];
  const sizeStyle = ["top", "bottom"].includes(position) ? "height: var(--n-space-arrow);" : "width: var(--n-space-arrow);";
  return c3(`[v-placement="${placement}"] >`, [cB("popover-shared", `
 margin-${oppositePlacement[position]}: var(--n-space);
 `, [cM("show-arrow", `
 margin-${oppositePlacement[position]}: var(--n-space-arrow);
 `), cM("overlap", `
 margin: 0;
 `), cCB("popover-arrow-wrapper", `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${position}: 100%;
 ${oppositePlacement[position]}: auto;
 ${sizeStyle}
 `, [cB("popover-arrow", arrowStyleLiteral)])])]);
}

// node_modules/naive-ui/es/popover/src/PopoverBody.js
var popoverBodyProps = Object.assign(Object.assign({}, use_theme_default.props), {
  to: useAdjustedTo.propTo,
  show: Boolean,
  trigger: String,
  showArrow: Boolean,
  delay: Number,
  duration: Number,
  raw: Boolean,
  arrowPointToCenter: Boolean,
  arrowStyle: [String, Object],
  displayDirective: String,
  x: Number,
  y: Number,
  flip: Boolean,
  overlap: Boolean,
  placement: String,
  width: [Number, String],
  keepAliveOnHover: Boolean,
  scrollable: Boolean,
  contentStyle: [Object, String],
  headerStyle: [Object, String],
  footerStyle: [Object, String],
  internalDeactivateImmediately: Boolean,
  animated: Boolean,
  onClickoutside: Function,
  internalTrapFocus: Boolean,
  internalOnAfterLeave: Function,
  minWidth: Number,
  maxWidth: Number
});
var renderArrow = ({ arrowStyle, clsPrefix }) => {
  return h3("div", { key: "__popover-arrow__", class: `${clsPrefix}-popover-arrow-wrapper` }, h3("div", { class: `${clsPrefix}-popover-arrow`, style: arrowStyle }));
};
var PopoverBody_default = defineComponent({
  name: "PopoverBody",
  inheritAttrs: false,
  props: popoverBodyProps,
  setup(props, { slots, attrs }) {
    const { namespaceRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
    const themeRef = use_theme_default("Popover", "-popover", index_cssr_default8, light_default5, props, mergedClsPrefixRef);
    const followerRef = ref(null);
    const NPopover = inject("NPopover");
    const bodyRef = ref(null);
    const followerEnabledRef = ref(props.show);
    const displayedRef = ref(false);
    watchEffect(() => {
      const { show } = props;
      if (show && !isJsdom() && !props.internalDeactivateImmediately) {
        displayedRef.value = true;
      }
    });
    const directivesRef = computed2(() => {
      const { trigger: trigger3, onClickoutside } = props;
      const directives = [];
      const { positionManuallyRef: { value: positionManually } } = NPopover;
      if (!positionManually) {
        if (trigger3 === "click" && !onClickoutside) {
          directives.push([
            clickoutside_default,
            handleClickOutside,
            void 0,
            { capture: true }
          ]);
        }
        if (trigger3 === "hover") {
          directives.push([mousemoveoutside_default, handleMouseMoveOutside]);
        }
      }
      if (onClickoutside) {
        directives.push([
          clickoutside_default,
          handleClickOutside,
          void 0,
          { capture: true }
        ]);
      }
      if (props.displayDirective === "show" || props.animated && displayedRef.value) {
        directives.push([vShow, props.show]);
      }
      return directives;
    });
    const styleRef = computed2(() => {
      const width = props.width === "trigger" ? void 0 : formatLength(props.width);
      const style2 = [];
      if (width) {
        style2.push({ width });
      }
      const { maxWidth, minWidth } = props;
      if (maxWidth) {
        style2.push({ maxWidth: formatLength(maxWidth) });
      }
      if (minWidth) {
        style2.push({ maxWidth: formatLength(minWidth) });
      }
      if (!inlineThemeDisabled) {
        style2.push(cssVarsRef.value);
      }
      return style2;
    });
    const cssVarsRef = computed2(() => {
      const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut5, cubicBezierEaseIn: cubicBezierEaseIn3, cubicBezierEaseOut: cubicBezierEaseOut3 }, self: { space: space2, spaceArrow, padding, fontSize: fontSize2, textColor, dividerColor, color: color2, boxShadow, borderRadius, arrowHeight, arrowOffset, arrowOffsetVertical } } = themeRef.value;
      return {
        "--n-box-shadow": boxShadow,
        "--n-bezier": cubicBezierEaseInOut5,
        "--n-bezier-ease-in": cubicBezierEaseIn3,
        "--n-bezier-ease-out": cubicBezierEaseOut3,
        "--n-font-size": fontSize2,
        "--n-text-color": textColor,
        "--n-color": color2,
        "--n-divider-color": dividerColor,
        "--n-border-radius": borderRadius,
        "--n-arrow-height": arrowHeight,
        "--n-arrow-offset": arrowOffset,
        "--n-arrow-offset-vertical": arrowOffsetVertical,
        "--n-padding": padding,
        "--n-space": space2,
        "--n-space-arrow": spaceArrow
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("popover", void 0, cssVarsRef, props) : void 0;
    NPopover.setBodyInstance({
      syncPosition
    });
    onBeforeUnmount(() => {
      NPopover.setBodyInstance(null);
    });
    watch(toRef(props, "show"), (value) => {
      if (props.animated)
        return;
      if (value) {
        followerEnabledRef.value = true;
      } else {
        followerEnabledRef.value = false;
      }
    });
    function syncPosition() {
      var _a3;
      (_a3 = followerRef.value) === null || _a3 === void 0 ? void 0 : _a3.syncPosition();
    }
    function handleMouseEnter(e3) {
      if (props.trigger === "hover" && props.keepAliveOnHover && props.show) {
        NPopover.handleMouseEnter(e3);
      }
    }
    function handleMouseLeave(e3) {
      if (props.trigger === "hover" && props.keepAliveOnHover) {
        NPopover.handleMouseLeave(e3);
      }
    }
    function handleMouseMoveOutside(e3) {
      if (props.trigger === "hover" && !getTriggerElement().contains(getPreciseEventTarget(e3))) {
        NPopover.handleMouseMoveOutside(e3);
      }
    }
    function handleClickOutside(e3) {
      if (props.trigger === "click" && !getTriggerElement().contains(getPreciseEventTarget(e3)) || props.onClickoutside) {
        NPopover.handleClickOutside(e3);
      }
    }
    function getTriggerElement() {
      return NPopover.getTriggerElement();
    }
    provide(popoverBodyInjectionKey, bodyRef);
    provide(drawerBodyInjectionKey, null);
    provide(modalBodyInjectionKey, null);
    function renderContentNode() {
      themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
      const shouldRenderDom = props.displayDirective === "show" || props.show || props.animated && displayedRef.value;
      if (!shouldRenderDom) {
        return null;
      }
      let contentNode;
      const renderBody = NPopover.internalRenderBodyRef.value;
      const { value: mergedClsPrefix } = mergedClsPrefixRef;
      if (!renderBody) {
        const { value: extraClass } = NPopover.extraClassRef;
        const { internalTrapFocus } = props;
        const hasHeaderOrFooter = !isSlotEmpty(slots.header) || !isSlotEmpty(slots.footer);
        const renderContentInnerNode = () => {
          var _a3;
          const body = hasHeaderOrFooter ? h3(Fragment, null, resolveWrappedSlot(slots.header, (children2) => {
            return children2 ? h3("div", { class: `${mergedClsPrefix}-popover__header`, style: props.headerStyle }, children2) : null;
          }), resolveWrappedSlot(slots.default, (children2) => {
            return children2 ? h3("div", { class: `${mergedClsPrefix}-popover__content`, style: props.contentStyle }, slots) : null;
          }), resolveWrappedSlot(slots.footer, (children2) => {
            return children2 ? h3("div", { class: `${mergedClsPrefix}-popover__footer`, style: props.footerStyle }, children2) : null;
          })) : props.scrollable ? (_a3 = slots.default) === null || _a3 === void 0 ? void 0 : _a3.call(slots) : h3("div", { class: `${mergedClsPrefix}-popover__content`, style: props.contentStyle }, slots);
          const maybeScrollableBody = props.scrollable ? h3(XScrollbar, { contentClass: hasHeaderOrFooter ? void 0 : `${mergedClsPrefix}-popover__content`, contentStyle: hasHeaderOrFooter ? void 0 : props.contentStyle }, {
            default: () => body
          }) : body;
          const arrow = props.showArrow ? renderArrow({
            arrowStyle: props.arrowStyle,
            clsPrefix: mergedClsPrefix
          }) : null;
          return [maybeScrollableBody, arrow];
        };
        contentNode = h3("div", mergeProps({
          class: [
            `${mergedClsPrefix}-popover`,
            `${mergedClsPrefix}-popover-shared`,
            themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value,
            extraClass.map((v) => `${mergedClsPrefix}-${v}`),
            {
              [`${mergedClsPrefix}-popover--scrollable`]: props.scrollable,
              [`${mergedClsPrefix}-popover--show-header-or-footer`]: hasHeaderOrFooter,
              [`${mergedClsPrefix}-popover--raw`]: props.raw,
              [`${mergedClsPrefix}-popover-shared--overlap`]: props.overlap,
              [`${mergedClsPrefix}-popover-shared--show-arrow`]: props.showArrow,
              [`${mergedClsPrefix}-popover-shared--center-arrow`]: props.arrowPointToCenter
            }
          ],
          ref: bodyRef,
          style: styleRef.value,
          onKeydown: NPopover.handleKeydown,
          onMouseenter: handleMouseEnter,
          onMouseleave: handleMouseLeave
        }, attrs), internalTrapFocus ? h3(FocusTrap, { active: props.show, autoFocus: true }, { default: renderContentInnerNode }) : renderContentInnerNode());
      } else {
        contentNode = renderBody([
          `${mergedClsPrefix}-popover-shared`,
          themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value,
          props.overlap && `${mergedClsPrefix}-popover-shared--overlap`,
          props.showArrow && `${mergedClsPrefix}-popover-shared--show-arrow`,
          props.arrowPointToCenter && `${mergedClsPrefix}-popover-shared--center-arrow`
        ], bodyRef, styleRef.value, handleMouseEnter, handleMouseLeave);
      }
      return withDirectives(contentNode, directivesRef.value);
    }
    return {
      displayed: displayedRef,
      namespace: namespaceRef,
      isMounted: NPopover.isMountedRef,
      zIndex: NPopover.zIndexRef,
      followerRef,
      adjustedTo: useAdjustedTo(props),
      followerEnabled: followerEnabledRef,
      renderContentNode
    };
  },
  render() {
    return h3(Follower_default, { ref: "followerRef", zIndex: this.zIndex, show: this.show, enabled: this.followerEnabled, to: this.adjustedTo, x: this.x, y: this.y, flip: this.flip, placement: this.placement, containerClass: this.namespace, overlap: this.overlap, width: this.width === "trigger" ? "target" : void 0, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey }, {
      default: () => {
        return this.animated ? h3(Transition, {
          name: "popover-transition",
          appear: this.isMounted,
          onEnter: () => {
            this.followerEnabled = true;
          },
          onAfterLeave: () => {
            var _a3;
            (_a3 = this.internalOnAfterLeave) === null || _a3 === void 0 ? void 0 : _a3.call(this);
            this.followerEnabled = false;
            this.displayed = false;
          }
        }, {
          default: this.renderContentNode
        }) : this.renderContentNode();
      }
    });
  }
});

// node_modules/naive-ui/es/popover/src/Popover.js
var bodyPropKeys = Object.keys(popoverBodyProps);
var triggerEventMap = {
  focus: ["onFocus", "onBlur"],
  click: ["onClick"],
  hover: ["onMouseenter", "onMouseleave"],
  manual: [],
  nested: ["onFocus", "onBlur", "onMouseenter", "onMouseleave", "onClick"]
};
function appendEvents(vNode, trigger3, events2) {
  triggerEventMap[trigger3].forEach((eventName) => {
    if (!vNode.props)
      vNode.props = {};
    else {
      vNode.props = Object.assign({}, vNode.props);
    }
    const originalHandler = vNode.props[eventName];
    const handler = events2[eventName];
    if (!originalHandler)
      vNode.props[eventName] = handler;
    else {
      vNode.props[eventName] = (...args) => {
        originalHandler(...args);
        handler(...args);
      };
    }
  });
}
var textVNodeType = createTextVNode("").type;
var popoverBaseProps = {
  show: {
    type: Boolean,
    default: void 0
  },
  defaultShow: Boolean,
  showArrow: {
    type: Boolean,
    default: true
  },
  trigger: {
    type: String,
    default: "hover"
  },
  delay: {
    type: Number,
    default: 100
  },
  duration: {
    type: Number,
    default: 100
  },
  raw: Boolean,
  placement: {
    type: String,
    default: "top"
  },
  x: Number,
  y: Number,
  arrowPointToCenter: Boolean,
  disabled: Boolean,
  getDisabled: Function,
  displayDirective: {
    type: String,
    default: "if"
  },
  arrowStyle: [String, Object],
  flip: {
    type: Boolean,
    default: true
  },
  animated: {
    type: Boolean,
    default: true
  },
  width: {
    type: [Number, String],
    default: void 0
  },
  overlap: Boolean,
  keepAliveOnHover: {
    type: Boolean,
    default: true
  },
  zIndex: Number,
  to: useAdjustedTo.propTo,
  scrollable: Boolean,
  contentStyle: [Object, String],
  headerStyle: [Object, String],
  footerStyle: [Object, String],
  onClickoutside: Function,
  "onUpdate:show": [Function, Array],
  onUpdateShow: [Function, Array],
  internalDeactivateImmediately: Boolean,
  internalSyncTargetWithParent: Boolean,
  internalInheritedEventHandlers: {
    type: Array,
    default: () => []
  },
  internalTrapFocus: Boolean,
  internalExtraClass: {
    type: Array,
    default: () => []
  },
  onShow: [Function, Array],
  onHide: [Function, Array],
  arrow: {
    type: Boolean,
    default: void 0
  },
  minWidth: Number,
  maxWidth: Number
};
var popoverProps = Object.assign(Object.assign(Object.assign({}, use_theme_default.props), popoverBaseProps), { internalOnAfterLeave: Function, internalRenderBody: Function });
var Popover_default = defineComponent({
  name: "Popover",
  inheritAttrs: false,
  props: popoverProps,
  __popover__: true,
  setup(props) {
    if (false) {
      watchEffect(() => {
        if (props.maxWidth !== void 0) {
          warnOnce("popover", "`max-width` is deprecated, please use `style` instead.");
        }
        if (props.minWidth !== void 0) {
          warnOnce("popover", "`min-width` is deprecated, please use `style` instead.");
        }
        if (props.arrow !== void 0) {
          warnOnce("popover", "`arrow` is deprecated, please use `showArrow` instead.");
        }
        if (props.onHide !== void 0) {
          warnOnce("popover", "`on-hide` is deprecated, please use `on-update:show` instead.");
        }
        if (props.onShow !== void 0) {
          warnOnce("popover", "`on-show` is deprecated, please use `on-update:show` instead.");
        }
      });
    }
    const isMountedRef = isMounted();
    const binderInstRef = ref(null);
    const controlledShowRef = computed2(() => props.show);
    const uncontrolledShowRef = ref(props.defaultShow);
    const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
    const mergedShowConsideringDisabledPropRef = use_memo_default(() => {
      if (props.disabled)
        return false;
      return mergedShowWithoutDisabledRef.value;
    });
    const getMergedDisabled = () => {
      if (props.disabled)
        return true;
      const { getDisabled } = props;
      if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled())
        return true;
      return false;
    };
    const getMergedShow = () => {
      if (getMergedDisabled())
        return false;
      return mergedShowWithoutDisabledRef.value;
    };
    const compatibleShowArrowRef = useCompitable(props, ["arrow", "showArrow"]);
    const mergedShowArrowRef = computed2(() => {
      if (props.overlap)
        return false;
      return compatibleShowArrowRef.value;
    });
    let bodyInstance = null;
    const showTimerIdRef = ref(null);
    const hideTimerIdRef = ref(null);
    const positionManuallyRef = use_memo_default(() => {
      return props.x !== void 0 && props.y !== void 0;
    });
    function doUpdateShow(value) {
      const { "onUpdate:show": _onUpdateShow, onUpdateShow, onShow, onHide } = props;
      uncontrolledShowRef.value = value;
      if (_onUpdateShow) {
        call(_onUpdateShow, value);
      }
      if (onUpdateShow) {
        call(onUpdateShow, value);
      }
      if (value && onShow) {
        call(onShow, true);
      }
      if (value && onHide) {
        call(onHide, false);
      }
    }
    function syncPosition() {
      if (bodyInstance) {
        bodyInstance.syncPosition();
      }
    }
    function clearShowTimer() {
      const { value: showTimerId } = showTimerIdRef;
      if (showTimerId) {
        window.clearTimeout(showTimerId);
        showTimerIdRef.value = null;
      }
    }
    function clearHideTimer() {
      const { value: hideTimerId } = hideTimerIdRef;
      if (hideTimerId) {
        window.clearTimeout(hideTimerId);
        hideTimerIdRef.value = null;
      }
    }
    function handleFocus() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "focus" && !mergedDisabled) {
        if (getMergedShow())
          return;
        doUpdateShow(true);
      }
    }
    function handleBlur() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "focus" && !mergedDisabled) {
        if (!getMergedShow())
          return;
        doUpdateShow(false);
      }
    }
    function handleMouseEnter() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "hover" && !mergedDisabled) {
        clearHideTimer();
        if (showTimerIdRef.value !== null)
          return;
        if (getMergedShow())
          return;
        const delayCallback = () => {
          doUpdateShow(true);
          showTimerIdRef.value = null;
        };
        const { delay } = props;
        if (delay === 0) {
          delayCallback();
        } else {
          showTimerIdRef.value = window.setTimeout(delayCallback, delay);
        }
      }
    }
    function handleMouseLeave() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "hover" && !mergedDisabled) {
        clearShowTimer();
        if (hideTimerIdRef.value !== null)
          return;
        if (!getMergedShow())
          return;
        const delayedCallback = () => {
          doUpdateShow(false);
          hideTimerIdRef.value = null;
        };
        const { duration } = props;
        if (duration === 0) {
          delayedCallback();
        } else {
          hideTimerIdRef.value = window.setTimeout(delayedCallback, duration);
        }
      }
    }
    function handleMouseMoveOutside() {
      handleMouseLeave();
    }
    function handleClickOutside(e3) {
      var _a3;
      if (!getMergedShow())
        return;
      if (props.trigger === "click") {
        clearShowTimer();
        clearHideTimer();
        doUpdateShow(false);
      }
      (_a3 = props.onClickoutside) === null || _a3 === void 0 ? void 0 : _a3.call(props, e3);
    }
    function handleClick() {
      if (props.trigger === "click" && !getMergedDisabled()) {
        clearShowTimer();
        clearHideTimer();
        const nextShow = !getMergedShow();
        doUpdateShow(nextShow);
      }
    }
    function handleKeydown(e3) {
      if (!props.internalTrapFocus)
        return;
      if (e3.key === "Escape") {
        clearShowTimer();
        clearHideTimer();
        doUpdateShow(false);
      }
    }
    function setShow(value) {
      uncontrolledShowRef.value = value;
    }
    function getTriggerElement() {
      var _a3;
      return (_a3 = binderInstRef.value) === null || _a3 === void 0 ? void 0 : _a3.targetRef;
    }
    function setBodyInstance(value) {
      bodyInstance = value;
    }
    provide("NPopover", {
      getTriggerElement,
      handleKeydown,
      handleMouseEnter,
      handleMouseLeave,
      handleClickOutside,
      handleMouseMoveOutside,
      setBodyInstance,
      positionManuallyRef,
      isMountedRef,
      zIndexRef: toRef(props, "zIndex"),
      extraClassRef: toRef(props, "internalExtraClass"),
      internalRenderBodyRef: toRef(props, "internalRenderBody")
    });
    watchEffect(() => {
      if (mergedShowWithoutDisabledRef.value && getMergedDisabled()) {
        doUpdateShow(false);
      }
    });
    return {
      binderInstRef,
      positionManually: positionManuallyRef,
      mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
      uncontrolledShow: uncontrolledShowRef,
      mergedShowArrow: mergedShowArrowRef,
      getMergedShow,
      setShow,
      handleClick,
      handleMouseEnter,
      handleMouseLeave,
      handleFocus,
      handleBlur,
      syncPosition
    };
  },
  render() {
    var _a3;
    const { positionManually, $slots: slots } = this;
    let triggerVNode;
    let popoverInside = false;
    if (!positionManually) {
      if (slots.activator) {
        triggerVNode = getFirstSlotVNode(slots, "activator");
      } else {
        triggerVNode = getFirstSlotVNode(slots, "trigger");
      }
      if (triggerVNode) {
        triggerVNode = cloneVNode(triggerVNode);
        triggerVNode = triggerVNode.type === textVNodeType ? h3("span", [triggerVNode]) : triggerVNode;
        const handlers = {
          onClick: this.handleClick,
          onMouseenter: this.handleMouseEnter,
          onMouseleave: this.handleMouseLeave,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur
        };
        if ((_a3 = triggerVNode.type) === null || _a3 === void 0 ? void 0 : _a3.__popover__) {
          popoverInside = true;
          if (!triggerVNode.props) {
            triggerVNode.props = {
              internalSyncTargetWithParent: true,
              internalInheritedEventHandlers: []
            };
          }
          triggerVNode.props.internalSyncTargetWithParent = true;
          if (!triggerVNode.props.internalInheritedEventHandlers) {
            triggerVNode.props.internalInheritedEventHandlers = [handlers];
          } else {
            triggerVNode.props.internalInheritedEventHandlers = [
              handlers,
              ...triggerVNode.props.internalInheritedEventHandlers
            ];
          }
        } else {
          const { internalInheritedEventHandlers } = this;
          const ascendantAndCurrentHandlers = [
            handlers,
            ...internalInheritedEventHandlers
          ];
          const mergedHandlers = {
            onBlur: (e3) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onBlur(e3);
              });
            },
            onFocus: (e3) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onFocus(e3);
              });
            },
            onClick: (e3) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onClick(e3);
              });
            },
            onMouseenter: (e3) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onMouseenter(e3);
              });
            },
            onMouseleave: (e3) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onMouseleave(e3);
              });
            }
          };
          appendEvents(triggerVNode, internalInheritedEventHandlers ? "nested" : positionManually ? "manual" : this.trigger, mergedHandlers);
        }
      }
    }
    return h3(Binder_default, { ref: "binderInstRef", syncTarget: !popoverInside, syncTargetWithParent: this.internalSyncTargetWithParent }, {
      default: () => {
        void this.mergedShowConsideringDisabledProp;
        const mergedShow = this.getMergedShow();
        return [
          this.internalTrapFocus && mergedShow ? withDirectives(h3("div", { style: { position: "fixed", inset: 0 } }), [
            [
              zindexable_default,
              {
                enabled: mergedShow,
                zIndex: this.zIndex
              }
            ]
          ]) : null,
          positionManually ? null : h3(Target_default, null, {
            default: () => triggerVNode
          }),
          h3(PopoverBody_default, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), { showArrow: this.mergedShowArrow, show: mergedShow })), {
            default: () => {
              var _a4, _b2;
              return (_b2 = (_a4 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a4);
            },
            header: () => {
              var _a4, _b2;
              return (_b2 = (_a4 = this.$slots).header) === null || _b2 === void 0 ? void 0 : _b2.call(_a4);
            },
            footer: () => {
              var _a4, _b2;
              return (_b2 = (_a4 = this.$slots).footer) === null || _b2 === void 0 ? void 0 : _b2.call(_a4);
            }
          })
        ];
      }
    });
  }
});

// node_modules/naive-ui/es/tag/styles/_common.js
var common_default5 = {
  closeIconSizeTiny: "12px",
  closeIconSizeSmall: "12px",
  closeIconSizeMedium: "14px",
  closeIconSizeLarge: "14px",
  closeSizeTiny: "16px",
  closeSizeSmall: "16px",
  closeSizeMedium: "18px",
  closeSizeLarge: "18px",
  padding: "0 7px",
  closeMargin: "0 0 0 4px",
  closeMarginRtl: "0 4px 0 0"
};

// node_modules/naive-ui/es/tag/styles/dark.js
var tagDark = {
  name: "Tag",
  common: dark_default,
  self(vars) {
    const { textColor2, primaryColorHover, primaryColorPressed, primaryColor, infoColor, successColor, warningColor, errorColor, baseColor, borderColor, tagColor, opacityDisabled, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, borderRadiusSmall: borderRadius, fontSizeMini, fontSizeTiny, fontSizeSmall, fontSizeMedium, heightMini, heightTiny, heightSmall, heightMedium, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
    return Object.assign(Object.assign({}, common_default5), {
      closeBorderRadius: borderRadius,
      heightTiny: heightMini,
      heightSmall: heightTiny,
      heightMedium: heightSmall,
      heightLarge: heightMedium,
      borderRadius,
      opacityDisabled,
      fontSizeTiny: fontSizeMini,
      fontSizeSmall: fontSizeTiny,
      fontSizeMedium: fontSizeSmall,
      fontSizeLarge: fontSizeMedium,
      fontWeightStrong,
      textColorCheckable: textColor2,
      textColorHoverCheckable: textColor2,
      textColorPressedCheckable: textColor2,
      textColorChecked: baseColor,
      colorCheckable: "#0000",
      colorHoverCheckable: buttonColor2Hover,
      colorPressedCheckable: buttonColor2Pressed,
      colorChecked: primaryColor,
      colorCheckedHover: primaryColorHover,
      colorCheckedPressed: primaryColorPressed,
      border: `1px solid ${borderColor}`,
      textColor: textColor2,
      color: tagColor,
      colorBordered: "#0000",
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      closeColorHover,
      closeColorPressed,
      borderPrimary: `1px solid ${changeColor(primaryColor, { alpha: 0.3 })}`,
      textColorPrimary: primaryColor,
      colorPrimary: changeColor(primaryColor, { alpha: 0.16 }),
      colorBorderedPrimary: "#0000",
      closeIconColorPrimary: scaleColor(primaryColor, { lightness: 0.7 }),
      closeIconColorHoverPrimary: scaleColor(primaryColor, { lightness: 0.7 }),
      closeIconColorPressedPrimary: scaleColor(primaryColor, {
        lightness: 0.7
      }),
      closeColorHoverPrimary: changeColor(primaryColor, { alpha: 0.16 }),
      closeColorPressedPrimary: changeColor(primaryColor, { alpha: 0.12 }),
      borderInfo: `1px solid ${changeColor(infoColor, { alpha: 0.3 })}`,
      textColorInfo: infoColor,
      colorInfo: changeColor(infoColor, { alpha: 0.16 }),
      colorBorderedInfo: "#0000",
      closeIconColorInfo: scaleColor(infoColor, { alpha: 0.7 }),
      closeIconColorHoverInfo: scaleColor(infoColor, { alpha: 0.7 }),
      closeIconColorPressedInfo: scaleColor(infoColor, { alpha: 0.7 }),
      closeColorHoverInfo: changeColor(infoColor, { alpha: 0.16 }),
      closeColorPressedInfo: changeColor(infoColor, { alpha: 0.12 }),
      borderSuccess: `1px solid ${changeColor(successColor, { alpha: 0.3 })}`,
      textColorSuccess: successColor,
      colorSuccess: changeColor(successColor, { alpha: 0.16 }),
      colorBorderedSuccess: "#0000",
      closeIconColorSuccess: scaleColor(successColor, { alpha: 0.7 }),
      closeIconColorHoverSuccess: scaleColor(successColor, { alpha: 0.7 }),
      closeIconColorPressedSuccess: scaleColor(successColor, { alpha: 0.7 }),
      closeColorHoverSuccess: changeColor(successColor, { alpha: 0.16 }),
      closeColorPressedSuccess: changeColor(successColor, { alpha: 0.12 }),
      borderWarning: `1px solid ${changeColor(warningColor, { alpha: 0.3 })}`,
      textColorWarning: warningColor,
      colorWarning: changeColor(warningColor, { alpha: 0.16 }),
      colorBorderedWarning: "#0000",
      closeIconColorWarning: scaleColor(warningColor, { alpha: 0.7 }),
      closeIconColorHoverWarning: scaleColor(warningColor, { alpha: 0.7 }),
      closeIconColorPressedWarning: scaleColor(warningColor, { alpha: 0.7 }),
      closeColorHoverWarning: changeColor(warningColor, { alpha: 0.16 }),
      closeColorPressedWarning: changeColor(warningColor, { alpha: 0.11 }),
      borderError: `1px solid ${changeColor(errorColor, { alpha: 0.3 })}`,
      textColorError: errorColor,
      colorError: changeColor(errorColor, { alpha: 0.16 }),
      colorBorderedError: "#0000",
      closeIconColorError: scaleColor(errorColor, { alpha: 0.7 }),
      closeIconColorHoverError: scaleColor(errorColor, { alpha: 0.7 }),
      closeIconColorPressedError: scaleColor(errorColor, { alpha: 0.7 }),
      closeColorHoverError: changeColor(errorColor, { alpha: 0.16 }),
      closeColorPressedError: changeColor(errorColor, { alpha: 0.12 })
    });
  }
};
var dark_default6 = tagDark;

// node_modules/naive-ui/es/tag/styles/light.js
var self6 = (vars) => {
  const { textColor2, primaryColorHover, primaryColorPressed, primaryColor, infoColor, successColor, warningColor, errorColor, baseColor, borderColor, opacityDisabled, tagColor, closeIconColor, closeIconColorHover, closeIconColorPressed, borderRadiusSmall: borderRadius, fontSizeMini, fontSizeTiny, fontSizeSmall, fontSizeMedium, heightMini, heightTiny, heightSmall, heightMedium, closeColorHover, closeColorPressed, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
  return Object.assign(Object.assign({}, common_default5), {
    closeBorderRadius: borderRadius,
    heightTiny: heightMini,
    heightSmall: heightTiny,
    heightMedium: heightSmall,
    heightLarge: heightMedium,
    borderRadius,
    opacityDisabled,
    fontSizeTiny: fontSizeMini,
    fontSizeSmall: fontSizeTiny,
    fontSizeMedium: fontSizeSmall,
    fontSizeLarge: fontSizeMedium,
    fontWeightStrong,
    textColorCheckable: textColor2,
    textColorHoverCheckable: textColor2,
    textColorPressedCheckable: textColor2,
    textColorChecked: baseColor,
    colorCheckable: "#0000",
    colorHoverCheckable: buttonColor2Hover,
    colorPressedCheckable: buttonColor2Pressed,
    colorChecked: primaryColor,
    colorCheckedHover: primaryColorHover,
    colorCheckedPressed: primaryColorPressed,
    border: `1px solid ${borderColor}`,
    textColor: textColor2,
    color: tagColor,
    colorBordered: "rgb(250, 250, 252)",
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    closeColorHover,
    closeColorPressed,
    borderPrimary: `1px solid ${changeColor(primaryColor, { alpha: 0.3 })}`,
    textColorPrimary: primaryColor,
    colorPrimary: changeColor(primaryColor, { alpha: 0.12 }),
    colorBorderedPrimary: changeColor(primaryColor, { alpha: 0.1 }),
    closeIconColorPrimary: primaryColor,
    closeIconColorHoverPrimary: primaryColor,
    closeIconColorPressedPrimary: primaryColor,
    closeColorHoverPrimary: changeColor(primaryColor, { alpha: 0.12 }),
    closeColorPressedPrimary: changeColor(primaryColor, { alpha: 0.18 }),
    borderInfo: `1px solid ${changeColor(infoColor, { alpha: 0.3 })}`,
    textColorInfo: infoColor,
    colorInfo: changeColor(infoColor, { alpha: 0.12 }),
    colorBorderedInfo: changeColor(infoColor, { alpha: 0.1 }),
    closeIconColorInfo: infoColor,
    closeIconColorHoverInfo: infoColor,
    closeIconColorPressedInfo: infoColor,
    closeColorHoverInfo: changeColor(infoColor, { alpha: 0.12 }),
    closeColorPressedInfo: changeColor(infoColor, { alpha: 0.18 }),
    borderSuccess: `1px solid ${changeColor(successColor, { alpha: 0.3 })}`,
    textColorSuccess: successColor,
    colorSuccess: changeColor(successColor, { alpha: 0.12 }),
    colorBorderedSuccess: changeColor(successColor, { alpha: 0.1 }),
    closeIconColorSuccess: successColor,
    closeIconColorHoverSuccess: successColor,
    closeIconColorPressedSuccess: successColor,
    closeColorHoverSuccess: changeColor(successColor, { alpha: 0.12 }),
    closeColorPressedSuccess: changeColor(successColor, { alpha: 0.18 }),
    borderWarning: `1px solid ${changeColor(warningColor, { alpha: 0.35 })}`,
    textColorWarning: warningColor,
    colorWarning: changeColor(warningColor, { alpha: 0.15 }),
    colorBorderedWarning: changeColor(warningColor, { alpha: 0.12 }),
    closeIconColorWarning: warningColor,
    closeIconColorHoverWarning: warningColor,
    closeIconColorPressedWarning: warningColor,
    closeColorHoverWarning: changeColor(warningColor, { alpha: 0.12 }),
    closeColorPressedWarning: changeColor(warningColor, { alpha: 0.18 }),
    borderError: `1px solid ${changeColor(errorColor, { alpha: 0.23 })}`,
    textColorError: errorColor,
    colorError: changeColor(errorColor, { alpha: 0.1 }),
    colorBorderedError: changeColor(errorColor, { alpha: 0.08 }),
    closeIconColorError: errorColor,
    closeIconColorHoverError: errorColor,
    closeIconColorPressedError: errorColor,
    closeColorHoverError: changeColor(errorColor, { alpha: 0.12 }),
    closeColorPressedError: changeColor(errorColor, { alpha: 0.18 })
  });
};
var tagLight = {
  name: "Tag",
  common: light_default,
  self: self6
};
var light_default6 = tagLight;

// node_modules/naive-ui/es/tag/src/common-props.js
var common_props_default = {
  color: Object,
  type: {
    type: String,
    default: "default"
  },
  round: Boolean,
  size: {
    type: String,
    default: "medium"
  },
  closable: Boolean,
  disabled: {
    type: Boolean,
    default: void 0
  }
};

// node_modules/naive-ui/es/tag/src/styles/index.cssr.js
var index_cssr_default9 = cB("tag", `
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [cM("strong", `
 font-weight: var(--n-font-weight-strong);
 `), cE("border", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), cE("icon", `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), cE("avatar", `
 display: flex;
 margin: 0 6px 0 0;
 `), cE("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cM("round", `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [cE("icon", `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), cE("avatar", `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), cM("closable", `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), cM("icon, avatar", [cM("round", `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), cM("disabled", `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), cM("checkable", `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [cNotM("disabled", [c3("&:hover", "background-color: var(--n-color-hover-checkable);", [cNotM("checked", "color: var(--n-text-color-hover-checkable);")]), c3("&:active", "background-color: var(--n-color-pressed-checkable);", [cNotM("checked", "color: var(--n-text-color-pressed-checkable);")])]), cM("checked", `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [cNotM("disabled", [c3("&:hover", "background-color: var(--n-color-checked-hover);"), c3("&:active", "background-color: var(--n-color-checked-pressed);")])])])]);

// node_modules/naive-ui/es/tag/src/Tag.js
var tagProps = Object.assign(Object.assign(Object.assign({}, use_theme_default.props), common_props_default), {
  bordered: {
    type: Boolean,
    default: void 0
  },
  checked: Boolean,
  checkable: Boolean,
  strong: Boolean,
  triggerClickOnClose: Boolean,
  onClose: [Array, Function],
  onMouseenter: Function,
  onMouseleave: Function,
  "onUpdate:checked": Function,
  onUpdateChecked: Function,
  internalCloseFocusable: {
    type: Boolean,
    default: true
  },
  internalCloseIsButtonTag: {
    type: Boolean,
    default: true
  },
  onCheckedChange: Function
});
var tagInjectionKey = createInjectionKey("n-tag");
var Tag_default = defineComponent({
  name: "Tag",
  props: tagProps,
  setup(props) {
    if (false) {
      watchEffect(() => {
        if (props.onCheckedChange !== void 0) {
          warnOnce("tag", "`on-checked-change` is deprecated, please use `on-update:checked` instead");
        }
      });
    }
    const contentRef = ref(null);
    const { mergedBorderedRef, mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
    const themeRef = use_theme_default("Tag", "-tag", index_cssr_default9, light_default6, props, mergedClsPrefixRef);
    provide(tagInjectionKey, {
      roundRef: toRef(props, "round")
    });
    function handleClick(e3) {
      if (!props.disabled) {
        if (props.checkable) {
          const { checked, onCheckedChange, onUpdateChecked, "onUpdate:checked": _onUpdateChecked } = props;
          if (onUpdateChecked)
            onUpdateChecked(!checked);
          if (_onUpdateChecked)
            _onUpdateChecked(!checked);
          if (onCheckedChange)
            onCheckedChange(!checked);
        }
      }
    }
    function handleCloseClick(e3) {
      if (!props.triggerClickOnClose) {
        e3.stopPropagation();
      }
      if (!props.disabled) {
        const { onClose } = props;
        if (onClose)
          call(onClose, e3);
      }
    }
    const tagPublicMethods = {
      setTextContent(textContent) {
        const { value } = contentRef;
        if (value)
          value.textContent = textContent;
      }
    };
    const rtlEnabledRef = useRtl("Tag", mergedRtlRef, mergedClsPrefixRef);
    const cssVarsRef = computed2(() => {
      const { type, size: size3, color: { color: color2, textColor } = {} } = props;
      const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut5 }, self: { padding, closeMargin, closeMarginRtl, borderRadius, opacityDisabled, textColorCheckable, textColorHoverCheckable, textColorPressedCheckable, textColorChecked, colorCheckable, colorHoverCheckable, colorPressedCheckable, colorChecked, colorCheckedHover, colorCheckedPressed, closeBorderRadius, fontWeightStrong, [createKey("colorBordered", type)]: colorBordered, [createKey("closeSize", size3)]: closeSize, [createKey("closeIconSize", size3)]: closeIconSize, [createKey("fontSize", size3)]: fontSize2, [createKey("height", size3)]: height, [createKey("color", type)]: typedColor, [createKey("textColor", type)]: typeTextColor, [createKey("border", type)]: border, [createKey("closeIconColor", type)]: closeIconColor, [createKey("closeIconColorHover", type)]: closeIconColorHover, [createKey("closeIconColorPressed", type)]: closeIconColorPressed, [createKey("closeColorHover", type)]: closeColorHover, [createKey("closeColorPressed", type)]: closeColorPressed } } = themeRef.value;
      return {
        "--n-font-weight-strong": fontWeightStrong,
        "--n-avatar-size-override": `calc(${height} - 8px)`,
        "--n-bezier": cubicBezierEaseInOut5,
        "--n-border-radius": borderRadius,
        "--n-border": border,
        "--n-close-icon-size": closeIconSize,
        "--n-close-color-pressed": closeColorPressed,
        "--n-close-color-hover": closeColorHover,
        "--n-close-border-radius": closeBorderRadius,
        "--n-close-icon-color": closeIconColor,
        "--n-close-icon-color-hover": closeIconColorHover,
        "--n-close-icon-color-pressed": closeIconColorPressed,
        "--n-close-icon-color-disabled": closeIconColor,
        "--n-close-margin": closeMargin,
        "--n-close-margin-rtl": closeMarginRtl,
        "--n-close-size": closeSize,
        "--n-color": color2 || (mergedBorderedRef.value ? colorBordered : typedColor),
        "--n-color-checkable": colorCheckable,
        "--n-color-checked": colorChecked,
        "--n-color-checked-hover": colorCheckedHover,
        "--n-color-checked-pressed": colorCheckedPressed,
        "--n-color-hover-checkable": colorHoverCheckable,
        "--n-color-pressed-checkable": colorPressedCheckable,
        "--n-font-size": fontSize2,
        "--n-height": height,
        "--n-opacity-disabled": opacityDisabled,
        "--n-padding": padding,
        "--n-text-color": textColor || typeTextColor,
        "--n-text-color-checkable": textColorCheckable,
        "--n-text-color-checked": textColorChecked,
        "--n-text-color-hover-checkable": textColorHoverCheckable,
        "--n-text-color-pressed-checkable": textColorPressedCheckable
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("tag", computed2(() => {
      let hash = "";
      const { type, size: size3, color: { color: color2, textColor } = {} } = props;
      hash += type[0];
      hash += size3[0];
      if (color2) {
        hash += `a${color2Class(color2)}`;
      }
      if (textColor) {
        hash += `b${color2Class(textColor)}`;
      }
      if (mergedBorderedRef.value) {
        hash += "c";
      }
      return hash;
    }), cssVarsRef, props) : void 0;
    return Object.assign(Object.assign({}, tagPublicMethods), {
      rtlEnabled: rtlEnabledRef,
      mergedClsPrefix: mergedClsPrefixRef,
      contentRef,
      mergedBordered: mergedBorderedRef,
      handleClick,
      handleCloseClick,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    });
  },
  render() {
    var _a3, _b2;
    const { mergedClsPrefix, rtlEnabled, closable, color: { borderColor } = {}, round: round2, onRender, $slots } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    const avatarNode = resolveWrappedSlot($slots.avatar, (children2) => children2 && h3("div", { class: `${mergedClsPrefix}-tag__avatar` }, children2));
    const iconNode = resolveWrappedSlot($slots.icon, (children2) => children2 && h3("div", { class: `${mergedClsPrefix}-tag__icon` }, children2));
    return h3("div", { class: [
      `${mergedClsPrefix}-tag`,
      this.themeClass,
      {
        [`${mergedClsPrefix}-tag--rtl`]: rtlEnabled,
        [`${mergedClsPrefix}-tag--strong`]: this.strong,
        [`${mergedClsPrefix}-tag--disabled`]: this.disabled,
        [`${mergedClsPrefix}-tag--checkable`]: this.checkable,
        [`${mergedClsPrefix}-tag--checked`]: this.checkable && this.checked,
        [`${mergedClsPrefix}-tag--round`]: round2,
        [`${mergedClsPrefix}-tag--avatar`]: avatarNode,
        [`${mergedClsPrefix}-tag--icon`]: iconNode,
        [`${mergedClsPrefix}-tag--closable`]: closable
      }
    ], style: this.cssVars, onClick: this.handleClick, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, iconNode || avatarNode, h3("span", { class: `${mergedClsPrefix}-tag__content`, ref: "contentRef" }, (_b2 = (_a3 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a3)), !this.checkable && closable ? h3(Close_default2, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-tag__close`, disabled: this.disabled, onClick: this.handleCloseClick, focusable: this.internalCloseFocusable, round: round2, isButtonTag: this.internalCloseIsButtonTag, absolute: true }) : null, !this.checkable && this.mergedBordered ? h3("div", { class: `${mergedClsPrefix}-tag__border`, style: { borderColor } }) : null);
  }
});

// node_modules/naive-ui/es/_internal/selection/styles/_common.js
var common_default6 = {
  paddingSingle: "0 26px 0 12px",
  paddingMultiple: "3px 26px 0 12px",
  clearSize: "16px",
  arrowSize: "16px"
};

// node_modules/naive-ui/es/_internal/selection/styles/light.js
var self7 = (vars) => {
  const { borderRadius, textColor2, textColorDisabled, inputColor, inputColorDisabled, primaryColor, primaryColorHover, warningColor, warningColorHover, errorColor, errorColorHover, borderColor, iconColor, iconColorDisabled, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge } = vars;
  return Object.assign(Object.assign({}, common_default6), {
    fontSizeTiny,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    heightTiny,
    heightSmall,
    heightMedium,
    heightLarge,
    borderRadius,
    textColor: textColor2,
    textColorDisabled,
    placeholderColor,
    placeholderColorDisabled,
    color: inputColor,
    colorDisabled: inputColorDisabled,
    colorActive: inputColor,
    border: `1px solid ${borderColor}`,
    borderHover: `1px solid ${primaryColorHover}`,
    borderActive: `1px solid ${primaryColor}`,
    borderFocus: `1px solid ${primaryColorHover}`,
    boxShadowHover: "none",
    boxShadowActive: `0 0 0 2px ${changeColor(primaryColor, {
      alpha: 0.2
    })}`,
    boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
      alpha: 0.2
    })}`,
    caretColor: primaryColor,
    arrowColor: iconColor,
    arrowColorDisabled: iconColorDisabled,
    loadingColor: primaryColor,
    borderWarning: `1px solid ${warningColor}`,
    borderHoverWarning: `1px solid ${warningColorHover}`,
    borderActiveWarning: `1px solid ${warningColor}`,
    borderFocusWarning: `1px solid ${warningColorHover}`,
    boxShadowHoverWarning: "none",
    boxShadowActiveWarning: `0 0 0 2px ${changeColor(warningColor, {
      alpha: 0.2
    })}`,
    boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
      alpha: 0.2
    })}`,
    colorActiveWarning: inputColor,
    caretColorWarning: warningColor,
    borderError: `1px solid ${errorColor}`,
    borderHoverError: `1px solid ${errorColorHover}`,
    borderActiveError: `1px solid ${errorColor}`,
    borderFocusError: `1px solid ${errorColorHover}`,
    boxShadowHoverError: "none",
    boxShadowActiveError: `0 0 0 2px ${changeColor(errorColor, {
      alpha: 0.2
    })}`,
    boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
      alpha: 0.2
    })}`,
    colorActiveError: inputColor,
    caretColorError: errorColor,
    clearColor,
    clearColorHover,
    clearColorPressed
  });
};
var internalSelectionLight = createTheme({
  name: "InternalSelection",
  common: light_default,
  peers: {
    Popover: light_default5
  },
  self: self7
});
var light_default7 = internalSelectionLight;

// node_modules/naive-ui/es/_internal/selection/styles/dark.js
var internalSelectionDark = {
  name: "InternalSelection",
  common: dark_default,
  peers: {
    Popover: dark_default5
  },
  self(vars) {
    const { borderRadius, textColor2, textColorDisabled, inputColor, inputColorDisabled, primaryColor, primaryColorHover, warningColor, warningColorHover, errorColor, errorColorHover, iconColor, iconColorDisabled, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge } = vars;
    return Object.assign(Object.assign({}, common_default6), {
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      borderRadius,
      textColor: textColor2,
      textColorDisabled,
      placeholderColor,
      placeholderColorDisabled,
      color: inputColor,
      colorDisabled: inputColorDisabled,
      colorActive: changeColor(primaryColor, { alpha: 0.1 }),
      border: "1px solid #0000",
      borderHover: `1px solid ${primaryColorHover}`,
      borderActive: `1px solid ${primaryColor}`,
      borderFocus: `1px solid ${primaryColorHover}`,
      boxShadowHover: "none",
      boxShadowActive: `0 0 8px 0 ${changeColor(primaryColor, {
        alpha: 0.4
      })}`,
      boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
        alpha: 0.4
      })}`,
      caretColor: primaryColor,
      arrowColor: iconColor,
      arrowColorDisabled: iconColorDisabled,
      loadingColor: primaryColor,
      borderWarning: `1px solid ${warningColor}`,
      borderHoverWarning: `1px solid ${warningColorHover}`,
      borderActiveWarning: `1px solid ${warningColor}`,
      borderFocusWarning: `1px solid ${warningColorHover}`,
      boxShadowHoverWarning: "none",
      boxShadowActiveWarning: `0 0 8px 0 ${changeColor(warningColor, {
        alpha: 0.4
      })}`,
      boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
        alpha: 0.4
      })}`,
      colorActiveWarning: changeColor(warningColor, { alpha: 0.1 }),
      caretColorWarning: warningColor,
      borderError: `1px solid ${errorColor}`,
      borderHoverError: `1px solid ${errorColorHover}`,
      borderActiveError: `1px solid ${errorColor}`,
      borderFocusError: `1px solid ${errorColorHover}`,
      boxShadowHoverError: "none",
      boxShadowActiveError: `0 0 8px 0 ${changeColor(errorColor, {
        alpha: 0.4
      })}`,
      boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
        alpha: 0.4
      })}`,
      colorActiveError: changeColor(errorColor, { alpha: 0.1 }),
      caretColorError: errorColor,
      clearColor,
      clearColorHover,
      clearColorPressed
    });
  }
};
var dark_default7 = internalSelectionDark;

// node_modules/naive-ui/es/_styles/transitions/fade-in-width-expand.cssr.js
var {
  cubicBezierEaseInOut: cubicBezierEaseInOut3
} = common_default;
function fadeInWidthExpandTransition({
  duration = ".2s",
  delay = ".1s"
} = {}) {
  return [c3("&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to", {
    opacity: 1
  }), c3("&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from", `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), c3("&.fade-in-width-expand-transition-leave-active", `
 overflow: hidden;
 transition:
 opacity ${duration} ${cubicBezierEaseInOut3},
 max-width ${duration} ${cubicBezierEaseInOut3} ${delay},
 margin-left ${duration} ${cubicBezierEaseInOut3} ${delay},
 margin-right ${duration} ${cubicBezierEaseInOut3} ${delay};
 `), c3("&.fade-in-width-expand-transition-enter-active", `
 overflow: hidden;
 transition:
 opacity ${duration} ${cubicBezierEaseInOut3} ${delay},
 max-width ${duration} ${cubicBezierEaseInOut3},
 margin-left ${duration} ${cubicBezierEaseInOut3},
 margin-right ${duration} ${cubicBezierEaseInOut3};
 `)];
}

// node_modules/naive-ui/es/alert/styles/_common.js
var common_default7 = {
  iconMargin: "11px 8px 0 12px",
  iconMarginRtl: "11px 12px 0 8px",
  iconSize: "24px",
  closeIconSize: "16px",
  closeSize: "20px",
  closeMargin: "13px 14px 0 0",
  closeMarginRtl: "13px 0 0 14px",
  padding: "13px"
};

// node_modules/naive-ui/es/alert/styles/dark.js
var alertDark = {
  name: "Alert",
  common: dark_default,
  self(vars) {
    const { lineHeight: lineHeight3, borderRadius, fontWeightStrong, dividerColor, inputColor, textColor1, textColor2, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, infoColorSuppl, successColorSuppl, warningColorSuppl, errorColorSuppl, fontSize: fontSize2 } = vars;
    return Object.assign(Object.assign({}, common_default7), {
      fontSize: fontSize2,
      lineHeight: lineHeight3,
      titleFontWeight: fontWeightStrong,
      borderRadius,
      border: `1px solid ${dividerColor}`,
      color: inputColor,
      titleTextColor: textColor1,
      iconColor: textColor2,
      contentTextColor: textColor2,
      closeBorderRadius: borderRadius,
      closeColorHover,
      closeColorPressed,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      borderInfo: `1px solid ${changeColor(infoColorSuppl, { alpha: 0.35 })}`,
      colorInfo: changeColor(infoColorSuppl, { alpha: 0.25 }),
      titleTextColorInfo: textColor1,
      iconColorInfo: infoColorSuppl,
      contentTextColorInfo: textColor2,
      closeColorHoverInfo: closeColorHover,
      closeColorPressedInfo: closeColorPressed,
      closeIconColorInfo: closeIconColor,
      closeIconColorHoverInfo: closeIconColorHover,
      closeIconColorPressedInfo: closeIconColorPressed,
      borderSuccess: `1px solid ${changeColor(successColorSuppl, {
        alpha: 0.35
      })}`,
      colorSuccess: changeColor(successColorSuppl, { alpha: 0.25 }),
      titleTextColorSuccess: textColor1,
      iconColorSuccess: successColorSuppl,
      contentTextColorSuccess: textColor2,
      closeColorHoverSuccess: closeColorHover,
      closeColorPressedSuccess: closeColorPressed,
      closeIconColorSuccess: closeIconColor,
      closeIconColorHoverSuccess: closeIconColorHover,
      closeIconColorPressedSuccess: closeIconColorPressed,
      borderWarning: `1px solid ${changeColor(warningColorSuppl, {
        alpha: 0.35
      })}`,
      colorWarning: changeColor(warningColorSuppl, { alpha: 0.25 }),
      titleTextColorWarning: textColor1,
      iconColorWarning: warningColorSuppl,
      contentTextColorWarning: textColor2,
      closeColorHoverWarning: closeColorHover,
      closeColorPressedWarning: closeColorPressed,
      closeIconColorWarning: closeIconColor,
      closeIconColorHoverWarning: closeIconColorHover,
      closeIconColorPressedWarning: closeIconColorPressed,
      borderError: `1px solid ${changeColor(errorColorSuppl, { alpha: 0.35 })}`,
      colorError: changeColor(errorColorSuppl, { alpha: 0.25 }),
      titleTextColorError: textColor1,
      iconColorError: errorColorSuppl,
      contentTextColorError: textColor2,
      closeColorHoverError: closeColorHover,
      closeColorPressedError: closeColorPressed,
      closeIconColorError: closeIconColor,
      closeIconColorHoverError: closeIconColorHover,
      closeIconColorPressedError: closeIconColorPressed
    });
  }
};
var dark_default8 = alertDark;

// node_modules/naive-ui/es/alert/styles/light.js
var self8 = (vars) => {
  const { lineHeight: lineHeight3, borderRadius, fontWeightStrong, baseColor, dividerColor, actionColor, textColor1, textColor2, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, infoColor, successColor, warningColor, errorColor, fontSize: fontSize2 } = vars;
  return Object.assign(Object.assign({}, common_default7), {
    fontSize: fontSize2,
    lineHeight: lineHeight3,
    titleFontWeight: fontWeightStrong,
    borderRadius,
    border: `1px solid ${dividerColor}`,
    color: actionColor,
    titleTextColor: textColor1,
    iconColor: textColor2,
    contentTextColor: textColor2,
    closeBorderRadius: borderRadius,
    closeColorHover,
    closeColorPressed,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    borderInfo: `1px solid ${composite(baseColor, changeColor(infoColor, { alpha: 0.25 }))}`,
    colorInfo: composite(baseColor, changeColor(infoColor, { alpha: 0.08 })),
    titleTextColorInfo: textColor1,
    iconColorInfo: infoColor,
    contentTextColorInfo: textColor2,
    closeColorHoverInfo: closeColorHover,
    closeColorPressedInfo: closeColorPressed,
    closeIconColorInfo: closeIconColor,
    closeIconColorHoverInfo: closeIconColorHover,
    closeIconColorPressedInfo: closeIconColorPressed,
    borderSuccess: `1px solid ${composite(baseColor, changeColor(successColor, { alpha: 0.25 }))}`,
    colorSuccess: composite(baseColor, changeColor(successColor, { alpha: 0.08 })),
    titleTextColorSuccess: textColor1,
    iconColorSuccess: successColor,
    contentTextColorSuccess: textColor2,
    closeColorHoverSuccess: closeColorHover,
    closeColorPressedSuccess: closeColorPressed,
    closeIconColorSuccess: closeIconColor,
    closeIconColorHoverSuccess: closeIconColorHover,
    closeIconColorPressedSuccess: closeIconColorPressed,
    borderWarning: `1px solid ${composite(baseColor, changeColor(warningColor, { alpha: 0.33 }))}`,
    colorWarning: composite(baseColor, changeColor(warningColor, { alpha: 0.08 })),
    titleTextColorWarning: textColor1,
    iconColorWarning: warningColor,
    contentTextColorWarning: textColor2,
    closeColorHoverWarning: closeColorHover,
    closeColorPressedWarning: closeColorPressed,
    closeIconColorWarning: closeIconColor,
    closeIconColorHoverWarning: closeIconColorHover,
    closeIconColorPressedWarning: closeIconColorPressed,
    borderError: `1px solid ${composite(baseColor, changeColor(errorColor, { alpha: 0.25 }))}`,
    colorError: composite(baseColor, changeColor(errorColor, { alpha: 0.08 })),
    titleTextColorError: textColor1,
    iconColorError: errorColor,
    contentTextColorError: textColor2,
    closeColorHoverError: closeColorHover,
    closeColorPressedError: closeColorPressed,
    closeIconColorError: closeIconColor,
    closeIconColorHoverError: closeIconColorHover,
    closeIconColorPressedError: closeIconColorPressed
  });
};
var alertLight = {
  name: "Alert",
  common: light_default,
  self: self8
};
var light_default8 = alertLight;

// node_modules/naive-ui/es/_styles/transitions/fade-in-height-expand.cssr.js
var {
  cubicBezierEaseInOut: cubicBezierEaseInOut4,
  cubicBezierEaseOut: cubicBezierEaseOut2,
  cubicBezierEaseIn: cubicBezierEaseIn2
} = common_default;
function fadeInHeightExpandTransition({
  overflow = "hidden",
  duration = ".3s",
  originalTransition = "",
  leavingDelay = "0s",
  foldPadding = false,
  enterToProps = void 0,
  leaveToProps = void 0,
  reverse = false
} = {}) {
  const enterClass = reverse ? "leave" : "enter";
  const leaveClass = reverse ? "enter" : "leave";
  return [c3(`&.fade-in-height-expand-transition-${leaveClass}-from,
 &.fade-in-height-expand-transition-${enterClass}-to`, Object.assign(Object.assign({}, enterToProps), {
    opacity: 1
  })), c3(`&.fade-in-height-expand-transition-${leaveClass}-to,
 &.fade-in-height-expand-transition-${enterClass}-from`, Object.assign(Object.assign({}, leaveToProps), {
    opacity: 0,
    marginTop: "0 !important",
    marginBottom: "0 !important",
    paddingTop: foldPadding ? "0 !important" : void 0,
    paddingBottom: foldPadding ? "0 !important" : void 0
  })), c3(`&.fade-in-height-expand-transition-${leaveClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration} ${cubicBezierEaseInOut4} ${leavingDelay},
 opacity ${duration} ${cubicBezierEaseOut2} ${leavingDelay},
 margin-top ${duration} ${cubicBezierEaseInOut4} ${leavingDelay},
 margin-bottom ${duration} ${cubicBezierEaseInOut4} ${leavingDelay},
 padding-top ${duration} ${cubicBezierEaseInOut4} ${leavingDelay},
 padding-bottom ${duration} ${cubicBezierEaseInOut4} ${leavingDelay}
 ${originalTransition ? "," + originalTransition : ""}
 `), c3(`&.fade-in-height-expand-transition-${enterClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration} ${cubicBezierEaseInOut4},
 opacity ${duration} ${cubicBezierEaseIn2},
 margin-top ${duration} ${cubicBezierEaseInOut4},
 margin-bottom ${duration} ${cubicBezierEaseInOut4},
 padding-top ${duration} ${cubicBezierEaseInOut4},
 padding-bottom ${duration} ${cubicBezierEaseInOut4}
 ${originalTransition ? "," + originalTransition : ""}
 `)];
}

// node_modules/naive-ui/es/anchor/styles/_common.js
var common_default8 = {
  linkFontSize: "13px",
  linkPadding: "0 0 0 16px",
  railWidth: "4px"
};

// node_modules/naive-ui/es/anchor/styles/light.js
var self9 = (vars) => {
  const { borderRadius, railColor, primaryColor, primaryColorHover, primaryColorPressed, textColor2 } = vars;
  return Object.assign(Object.assign({}, common_default8), {
    borderRadius,
    railColor,
    railColorActive: primaryColor,
    linkColor: changeColor(primaryColor, { alpha: 0.15 }),
    linkTextColor: textColor2,
    linkTextColorHover: primaryColorHover,
    linkTextColorPressed: primaryColorPressed,
    linkTextColorActive: primaryColor
  });
};
var anchorLight = {
  name: "Anchor",
  common: light_default,
  self: self9
};
var light_default9 = anchorLight;

// node_modules/naive-ui/es/anchor/styles/dark.js
var anchorDark = {
  name: "Anchor",
  common: dark_default,
  self: self9
};
var dark_default9 = anchorDark;

// node_modules/naive-ui/es/_utils/env/browser.js
var isChrome = isBrowser && "chrome" in window;
var isFirefox = isBrowser && navigator.userAgent.includes("Firefox");
var isSafari = isBrowser && navigator.userAgent.includes("Safari") && !isChrome;

// node_modules/naive-ui/es/input/styles/_common.js
var common_default9 = {
  paddingTiny: "0 8px",
  paddingSmall: "0 10px",
  paddingMedium: "0 12px",
  paddingLarge: "0 14px",
  clearSize: "16px"
};

// node_modules/naive-ui/es/input/styles/dark.js
var inputDark = {
  name: "Input",
  common: dark_default,
  self(vars) {
    const { textColor2, textColor3, textColorDisabled, primaryColor, primaryColorHover, inputColor, inputColorDisabled, warningColor, warningColorHover, errorColor, errorColorHover, borderRadius, lineHeight: lineHeight3, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, iconColor, iconColorDisabled, iconColorHover, iconColorPressed } = vars;
    return Object.assign(Object.assign({}, common_default9), {
      countTextColorDisabled: textColorDisabled,
      countTextColor: textColor3,
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      lineHeight: lineHeight3,
      lineHeightTextarea: lineHeight3,
      borderRadius,
      iconSize: "16px",
      groupLabelColor: inputColor,
      textColor: textColor2,
      textColorDisabled,
      textDecorationColor: textColor2,
      groupLabelTextColor: textColor2,
      caretColor: primaryColor,
      placeholderColor,
      placeholderColorDisabled,
      color: inputColor,
      colorDisabled: inputColorDisabled,
      colorFocus: changeColor(primaryColor, { alpha: 0.1 }),
      groupLabelBorder: "1px solid #0000",
      border: "1px solid #0000",
      borderHover: `1px solid ${primaryColorHover}`,
      borderDisabled: "1px solid #0000",
      borderFocus: `1px solid ${primaryColorHover}`,
      boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, { alpha: 0.3 })}`,
      loadingColor: primaryColor,
      loadingColorWarning: warningColor,
      borderWarning: `1px solid ${warningColor}`,
      borderHoverWarning: `1px solid ${warningColorHover}`,
      colorFocusWarning: changeColor(warningColor, { alpha: 0.1 }),
      borderFocusWarning: `1px solid ${warningColorHover}`,
      boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
        alpha: 0.3
      })}`,
      caretColorWarning: warningColor,
      loadingColorError: errorColor,
      borderError: `1px solid ${errorColor}`,
      borderHoverError: `1px solid ${errorColorHover}`,
      colorFocusError: changeColor(errorColor, { alpha: 0.1 }),
      borderFocusError: `1px solid ${errorColorHover}`,
      boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
        alpha: 0.3
      })}`,
      caretColorError: errorColor,
      clearColor,
      clearColorHover,
      clearColorPressed,
      iconColor,
      iconColorDisabled,
      iconColorHover,
      iconColorPressed,
      suffixTextColor: textColor2
    });
  }
};
var dark_default10 = inputDark;

// node_modules/naive-ui/es/input/styles/light.js
var self10 = (vars) => {
  const { textColor2, textColor3, textColorDisabled, primaryColor, primaryColorHover, inputColor, inputColorDisabled, borderColor, warningColor, warningColorHover, errorColor, errorColorHover, borderRadius, lineHeight: lineHeight3, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge, actionColor, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, iconColor, iconColorDisabled, iconColorHover, iconColorPressed } = vars;
  return Object.assign(Object.assign({}, common_default9), {
    countTextColorDisabled: textColorDisabled,
    countTextColor: textColor3,
    heightTiny,
    heightSmall,
    heightMedium,
    heightLarge,
    fontSizeTiny,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    lineHeight: lineHeight3,
    lineHeightTextarea: lineHeight3,
    borderRadius,
    iconSize: "16px",
    groupLabelColor: actionColor,
    groupLabelTextColor: textColor2,
    textColor: textColor2,
    textColorDisabled,
    textDecorationColor: textColor2,
    caretColor: primaryColor,
    placeholderColor,
    placeholderColorDisabled,
    color: inputColor,
    colorDisabled: inputColorDisabled,
    colorFocus: inputColor,
    groupLabelBorder: `1px solid ${borderColor}`,
    border: `1px solid ${borderColor}`,
    borderHover: `1px solid ${primaryColorHover}`,
    borderDisabled: `1px solid ${borderColor}`,
    borderFocus: `1px solid ${primaryColorHover}`,
    boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}`,
    loadingColor: primaryColor,
    loadingColorWarning: warningColor,
    borderWarning: `1px solid ${warningColor}`,
    borderHoverWarning: `1px solid ${warningColorHover}`,
    colorFocusWarning: inputColor,
    borderFocusWarning: `1px solid ${warningColorHover}`,
    boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
      alpha: 0.2
    })}`,
    caretColorWarning: warningColor,
    loadingColorError: errorColor,
    borderError: `1px solid ${errorColor}`,
    borderHoverError: `1px solid ${errorColorHover}`,
    colorFocusError: inputColor,
    borderFocusError: `1px solid ${errorColorHover}`,
    boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
      alpha: 0.2
    })}`,
    caretColorError: errorColor,
    clearColor,
    clearColorHover,
    clearColorPressed,
    iconColor,
    iconColorDisabled,
    iconColorHover,
    iconColorPressed,
    suffixTextColor: textColor2
  });
};
var inputLight = {
  name: "Input",
  common: light_default,
  self: self10
};
var light_default10 = inputLight;

// node_modules/naive-ui/es/auto-complete/styles/light.js
function self11(vars) {
  const { boxShadow2 } = vars;
  return {
    menuBoxShadow: boxShadow2
  };
}
var autoCompleteLight = createTheme({
  name: "AutoComplete",
  common: light_default,
  peers: {
    InternalSelectMenu: light_default4,
    Input: light_default10
  },
  self: self11
});
var light_default11 = autoCompleteLight;

// node_modules/naive-ui/es/auto-complete/styles/dark.js
var autoCompleteDark = {
  name: "AutoComplete",
  common: dark_default,
  peers: {
    InternalSelectMenu: dark_default4,
    Input: dark_default10
  },
  self: self11
};
var dark_default11 = autoCompleteDark;

// node_modules/naive-ui/es/avatar/styles/light.js
var self12 = (vars) => {
  const { borderRadius, avatarColor, cardColor, fontSize: fontSize2, heightTiny, heightSmall, heightMedium, heightLarge, heightHuge, modalColor, popoverColor } = vars;
  return {
    borderRadius,
    fontSize: fontSize2,
    border: `2px solid ${cardColor}`,
    heightTiny,
    heightSmall,
    heightMedium,
    heightLarge,
    heightHuge,
    color: composite(cardColor, avatarColor),
    colorModal: composite(modalColor, avatarColor),
    colorPopover: composite(popoverColor, avatarColor)
  };
};
var avatarLight = {
  name: "Avatar",
  common: light_default,
  self: self12
};
var light_default12 = avatarLight;

// node_modules/naive-ui/es/avatar/styles/dark.js
var avatarDark = {
  name: "Avatar",
  common: dark_default,
  self: self12
};
var dark_default12 = avatarDark;

// node_modules/naive-ui/es/avatar-group/styles/light.js
var self13 = () => {
  return {
    gap: "-12px"
  };
};
var avatarGroupLight = createTheme({
  name: "AvatarGroup",
  common: light_default,
  peers: {
    Avatar: light_default12
  },
  self: self13
});
var light_default13 = avatarGroupLight;

// node_modules/naive-ui/es/avatar-group/styles/dark.js
var avatarGroupDark = {
  name: "AvatarGroup",
  common: dark_default,
  peers: {
    Avatar: dark_default12
  },
  self: self13
};
var dark_default13 = avatarGroupDark;

// node_modules/naive-ui/es/back-top/styles/_common.js
var common_default10 = {
  width: "44px",
  height: "44px",
  borderRadius: "22px",
  iconSize: "26px"
};

// node_modules/naive-ui/es/back-top/styles/dark.js
var backTopDark = {
  name: "BackTop",
  common: dark_default,
  self(vars) {
    const { popoverColor, textColor2, primaryColorHover, primaryColorPressed } = vars;
    return Object.assign(Object.assign({}, common_default10), { color: popoverColor, textColor: textColor2, iconColor: textColor2, iconColorHover: primaryColorHover, iconColorPressed: primaryColorPressed, boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)", boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)", boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)" });
  }
};
var dark_default14 = backTopDark;

// node_modules/naive-ui/es/back-top/styles/light.js
var self14 = (vars) => {
  const { popoverColor, textColor2, primaryColorHover, primaryColorPressed } = vars;
  return Object.assign(Object.assign({}, common_default10), { color: popoverColor, textColor: textColor2, iconColor: textColor2, iconColorHover: primaryColorHover, iconColorPressed: primaryColorPressed, boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)", boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)", boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)" });
};
var backTopLight = {
  name: "BackTop",
  common: light_default,
  self: self14
};
var light_default14 = backTopLight;

// node_modules/naive-ui/es/badge/styles/dark.js
var badgeDark = {
  name: "Badge",
  common: dark_default,
  self(vars) {
    const { errorColorSuppl, infoColorSuppl, successColorSuppl, warningColorSuppl, fontFamily: fontFamily2 } = vars;
    return {
      color: errorColorSuppl,
      colorInfo: infoColorSuppl,
      colorSuccess: successColorSuppl,
      colorError: errorColorSuppl,
      colorWarning: warningColorSuppl,
      fontSize: "12px",
      fontFamily: fontFamily2
    };
  }
};
var dark_default15 = badgeDark;

// node_modules/naive-ui/es/badge/styles/light.js
var self15 = (vars) => {
  const { errorColor, infoColor, successColor, warningColor, fontFamily: fontFamily2 } = vars;
  return {
    color: errorColor,
    colorInfo: infoColor,
    colorSuccess: successColor,
    colorError: errorColor,
    colorWarning: warningColor,
    fontSize: "12px",
    fontFamily: fontFamily2
  };
};
var badgeLight = {
  name: "Badge",
  common: light_default,
  self: self15
};
var light_default15 = badgeLight;

// node_modules/naive-ui/es/breadcrumb/styles/_common.js
var common_default11 = {
  fontWeightActive: "400"
};

// node_modules/naive-ui/es/breadcrumb/styles/light.js
var self16 = (vars) => {
  const { fontSize: fontSize2, textColor3, textColor2, borderRadius, buttonColor2Hover, buttonColor2Pressed } = vars;
  return Object.assign(Object.assign({}, common_default11), { fontSize: fontSize2, itemLineHeight: "1.25", itemTextColor: textColor3, itemTextColorHover: textColor2, itemTextColorPressed: textColor2, itemTextColorActive: textColor2, itemBorderRadius: borderRadius, itemColorHover: buttonColor2Hover, itemColorPressed: buttonColor2Pressed, separatorColor: textColor3 });
};
var breadcrumbLight = {
  name: "Breadcrumb",
  common: light_default,
  self: self16
};
var light_default16 = breadcrumbLight;

// node_modules/naive-ui/es/breadcrumb/styles/dark.js
var breadcrumbDark = {
  name: "Breadcrumb",
  common: dark_default,
  self: self16
};
var dark_default16 = breadcrumbDark;

// node_modules/naive-ui/es/_utils/color/index.js
function createHoverColor(rgb) {
  return composite(rgb, [255, 255, 255, 0.16]);
}
function createPressedColor(rgb) {
  return composite(rgb, [0, 0, 0, 0.12]);
}

// node_modules/naive-ui/es/button-group/src/context.js
var buttonGroupInjectionKey = createInjectionKey("n-button-group");

// node_modules/naive-ui/es/button/styles/_common.js
var common_default12 = {
  paddingTiny: "0 6px",
  paddingSmall: "0 10px",
  paddingMedium: "0 14px",
  paddingLarge: "0 18px",
  paddingRoundTiny: "0 10px",
  paddingRoundSmall: "0 14px",
  paddingRoundMedium: "0 18px",
  paddingRoundLarge: "0 22px",
  iconMarginTiny: "6px",
  iconMarginSmall: "6px",
  iconMarginMedium: "6px",
  iconMarginLarge: "6px",
  iconSizeTiny: "14px",
  iconSizeSmall: "18px",
  iconSizeMedium: "18px",
  iconSizeLarge: "20px",
  rippleDuration: ".6s"
};

// node_modules/naive-ui/es/button/styles/light.js
var self17 = (vars) => {
  const { heightTiny, heightSmall, heightMedium, heightLarge, borderRadius, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, opacityDisabled, textColor2, textColor3, primaryColorHover, primaryColorPressed, borderColor, primaryColor, baseColor, infoColor, infoColorHover, infoColorPressed, successColor, successColorHover, successColorPressed, warningColor, warningColorHover, warningColorPressed, errorColor, errorColorHover, errorColorPressed, fontWeight, buttonColor2, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
  return Object.assign(Object.assign({}, common_default12), {
    heightTiny,
    heightSmall,
    heightMedium,
    heightLarge,
    borderRadiusTiny: borderRadius,
    borderRadiusSmall: borderRadius,
    borderRadiusMedium: borderRadius,
    borderRadiusLarge: borderRadius,
    fontSizeTiny,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    opacityDisabled,
    colorOpacitySecondary: "0.16",
    colorOpacitySecondaryHover: "0.22",
    colorOpacitySecondaryPressed: "0.28",
    colorSecondary: buttonColor2,
    colorSecondaryHover: buttonColor2Hover,
    colorSecondaryPressed: buttonColor2Pressed,
    colorTertiary: buttonColor2,
    colorTertiaryHover: buttonColor2Hover,
    colorTertiaryPressed: buttonColor2Pressed,
    colorQuaternary: "#0000",
    colorQuaternaryHover: buttonColor2Hover,
    colorQuaternaryPressed: buttonColor2Pressed,
    color: "#0000",
    colorHover: "#0000",
    colorPressed: "#0000",
    colorFocus: "#0000",
    colorDisabled: "#0000",
    textColor: textColor2,
    textColorTertiary: textColor3,
    textColorHover: primaryColorHover,
    textColorPressed: primaryColorPressed,
    textColorFocus: primaryColorHover,
    textColorDisabled: textColor2,
    textColorText: textColor2,
    textColorTextHover: primaryColorHover,
    textColorTextPressed: primaryColorPressed,
    textColorTextFocus: primaryColorHover,
    textColorTextDisabled: textColor2,
    textColorGhost: textColor2,
    textColorGhostHover: primaryColorHover,
    textColorGhostPressed: primaryColorPressed,
    textColorGhostFocus: primaryColorHover,
    textColorGhostDisabled: textColor2,
    border: `1px solid ${borderColor}`,
    borderHover: `1px solid ${primaryColorHover}`,
    borderPressed: `1px solid ${primaryColorPressed}`,
    borderFocus: `1px solid ${primaryColorHover}`,
    borderDisabled: `1px solid ${borderColor}`,
    rippleColor: primaryColor,
    colorPrimary: primaryColor,
    colorHoverPrimary: primaryColorHover,
    colorPressedPrimary: primaryColorPressed,
    colorFocusPrimary: primaryColorHover,
    colorDisabledPrimary: primaryColor,
    textColorPrimary: baseColor,
    textColorHoverPrimary: baseColor,
    textColorPressedPrimary: baseColor,
    textColorFocusPrimary: baseColor,
    textColorDisabledPrimary: baseColor,
    textColorTextPrimary: primaryColor,
    textColorTextHoverPrimary: primaryColorHover,
    textColorTextPressedPrimary: primaryColorPressed,
    textColorTextFocusPrimary: primaryColorHover,
    textColorTextDisabledPrimary: textColor2,
    textColorGhostPrimary: primaryColor,
    textColorGhostHoverPrimary: primaryColorHover,
    textColorGhostPressedPrimary: primaryColorPressed,
    textColorGhostFocusPrimary: primaryColorHover,
    textColorGhostDisabledPrimary: primaryColor,
    borderPrimary: `1px solid ${primaryColor}`,
    borderHoverPrimary: `1px solid ${primaryColorHover}`,
    borderPressedPrimary: `1px solid ${primaryColorPressed}`,
    borderFocusPrimary: `1px solid ${primaryColorHover}`,
    borderDisabledPrimary: `1px solid ${primaryColor}`,
    rippleColorPrimary: primaryColor,
    colorInfo: infoColor,
    colorHoverInfo: infoColorHover,
    colorPressedInfo: infoColorPressed,
    colorFocusInfo: infoColorHover,
    colorDisabledInfo: infoColor,
    textColorInfo: baseColor,
    textColorHoverInfo: baseColor,
    textColorPressedInfo: baseColor,
    textColorFocusInfo: baseColor,
    textColorDisabledInfo: baseColor,
    textColorTextInfo: infoColor,
    textColorTextHoverInfo: infoColorHover,
    textColorTextPressedInfo: infoColorPressed,
    textColorTextFocusInfo: infoColorHover,
    textColorTextDisabledInfo: textColor2,
    textColorGhostInfo: infoColor,
    textColorGhostHoverInfo: infoColorHover,
    textColorGhostPressedInfo: infoColorPressed,
    textColorGhostFocusInfo: infoColorHover,
    textColorGhostDisabledInfo: infoColor,
    borderInfo: `1px solid ${infoColor}`,
    borderHoverInfo: `1px solid ${infoColorHover}`,
    borderPressedInfo: `1px solid ${infoColorPressed}`,
    borderFocusInfo: `1px solid ${infoColorHover}`,
    borderDisabledInfo: `1px solid ${infoColor}`,
    rippleColorInfo: infoColor,
    colorSuccess: successColor,
    colorHoverSuccess: successColorHover,
    colorPressedSuccess: successColorPressed,
    colorFocusSuccess: successColorHover,
    colorDisabledSuccess: successColor,
    textColorSuccess: baseColor,
    textColorHoverSuccess: baseColor,
    textColorPressedSuccess: baseColor,
    textColorFocusSuccess: baseColor,
    textColorDisabledSuccess: baseColor,
    textColorTextSuccess: successColor,
    textColorTextHoverSuccess: successColorHover,
    textColorTextPressedSuccess: successColorPressed,
    textColorTextFocusSuccess: successColorHover,
    textColorTextDisabledSuccess: textColor2,
    textColorGhostSuccess: successColor,
    textColorGhostHoverSuccess: successColorHover,
    textColorGhostPressedSuccess: successColorPressed,
    textColorGhostFocusSuccess: successColorHover,
    textColorGhostDisabledSuccess: successColor,
    borderSuccess: `1px solid ${successColor}`,
    borderHoverSuccess: `1px solid ${successColorHover}`,
    borderPressedSuccess: `1px solid ${successColorPressed}`,
    borderFocusSuccess: `1px solid ${successColorHover}`,
    borderDisabledSuccess: `1px solid ${successColor}`,
    rippleColorSuccess: successColor,
    colorWarning: warningColor,
    colorHoverWarning: warningColorHover,
    colorPressedWarning: warningColorPressed,
    colorFocusWarning: warningColorHover,
    colorDisabledWarning: warningColor,
    textColorWarning: baseColor,
    textColorHoverWarning: baseColor,
    textColorPressedWarning: baseColor,
    textColorFocusWarning: baseColor,
    textColorDisabledWarning: baseColor,
    textColorTextWarning: warningColor,
    textColorTextHoverWarning: warningColorHover,
    textColorTextPressedWarning: warningColorPressed,
    textColorTextFocusWarning: warningColorHover,
    textColorTextDisabledWarning: textColor2,
    textColorGhostWarning: warningColor,
    textColorGhostHoverWarning: warningColorHover,
    textColorGhostPressedWarning: warningColorPressed,
    textColorGhostFocusWarning: warningColorHover,
    textColorGhostDisabledWarning: warningColor,
    borderWarning: `1px solid ${warningColor}`,
    borderHoverWarning: `1px solid ${warningColorHover}`,
    borderPressedWarning: `1px solid ${warningColorPressed}`,
    borderFocusWarning: `1px solid ${warningColorHover}`,
    borderDisabledWarning: `1px solid ${warningColor}`,
    rippleColorWarning: warningColor,
    colorError: errorColor,
    colorHoverError: errorColorHover,
    colorPressedError: errorColorPressed,
    colorFocusError: errorColorHover,
    colorDisabledError: errorColor,
    textColorError: baseColor,
    textColorHoverError: baseColor,
    textColorPressedError: baseColor,
    textColorFocusError: baseColor,
    textColorDisabledError: baseColor,
    textColorTextError: errorColor,
    textColorTextHoverError: errorColorHover,
    textColorTextPressedError: errorColorPressed,
    textColorTextFocusError: errorColorHover,
    textColorTextDisabledError: textColor2,
    textColorGhostError: errorColor,
    textColorGhostHoverError: errorColorHover,
    textColorGhostPressedError: errorColorPressed,
    textColorGhostFocusError: errorColorHover,
    textColorGhostDisabledError: errorColor,
    borderError: `1px solid ${errorColor}`,
    borderHoverError: `1px solid ${errorColorHover}`,
    borderPressedError: `1px solid ${errorColorPressed}`,
    borderFocusError: `1px solid ${errorColorHover}`,
    borderDisabledError: `1px solid ${errorColor}`,
    rippleColorError: errorColor,
    waveOpacity: "0.6",
    fontWeight,
    fontWeightStrong
  });
};
var buttonLight = {
  name: "Button",
  common: light_default,
  self: self17
};
var light_default17 = buttonLight;

// node_modules/naive-ui/es/button/styles/dark.js
var buttonDark = {
  name: "Button",
  common: dark_default,
  self(vars) {
    const commonSelf = self17(vars);
    commonSelf.waveOpacity = "0.8";
    commonSelf.colorOpacitySecondary = "0.16";
    commonSelf.colorOpacitySecondaryHover = "0.2";
    commonSelf.colorOpacitySecondaryPressed = "0.12";
    return commonSelf;
  }
};
var dark_default17 = buttonDark;

// node_modules/naive-ui/es/button/src/styles/index.cssr.js
var index_cssr_default10 = c3([cB("button", `
 margin: 0;
 font-weight: var(--n-font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--n-padding);
 height: var(--n-height);
 font-size: var(--n-font-size);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 width: var(--n-width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 -webkit-user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("color", [cE("border", {
  borderColor: "var(--n-border-color)"
}), cM("disabled", [cE("border", {
  borderColor: "var(--n-border-color-disabled)"
})]), cNotM("disabled", [c3("&:focus", [cE("state-border", {
  borderColor: "var(--n-border-color-focus)"
})]), c3("&:hover", [cE("state-border", {
  borderColor: "var(--n-border-color-hover)"
})]), c3("&:active", [cE("state-border", {
  borderColor: "var(--n-border-color-pressed)"
})]), cM("pressed", [cE("state-border", {
  borderColor: "var(--n-border-color-pressed)"
})])])]), cM("disabled", {
  backgroundColor: "var(--n-color-disabled)",
  color: "var(--n-text-color-disabled)"
}, [cE("border", {
  border: "var(--n-border-disabled)"
})]), cNotM("disabled", [c3("&:focus", {
  backgroundColor: "var(--n-color-focus)",
  color: "var(--n-text-color-focus)"
}, [cE("state-border", {
  border: "var(--n-border-focus)"
})]), c3("&:hover", {
  backgroundColor: "var(--n-color-hover)",
  color: "var(--n-text-color-hover)"
}, [cE("state-border", {
  border: "var(--n-border-hover)"
})]), c3("&:active", {
  backgroundColor: "var(--n-color-pressed)",
  color: "var(--n-text-color-pressed)"
}, [cE("state-border", {
  border: "var(--n-border-pressed)"
})]), cM("pressed", {
  backgroundColor: "var(--n-color-pressed)",
  color: "var(--n-text-color-pressed)"
}, [cE("state-border", {
  border: "var(--n-border-pressed)"
})])]), cM("loading", "cursor: wait;"), cB("base-wave", `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--n-ripple-duration);
 animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
 `, [cM("active", {
  zIndex: 1,
  animationName: "button-wave-spread, button-wave-opacity"
})]), isBrowser && "MozBoxSizing" in document.createElement("div").style ? c3("&::moz-focus-inner", {
  border: 0
}) : null, cE("border, state-border", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 `), cE("border", {
  border: "var(--n-border)"
}), cE("state-border", {
  border: "var(--n-border)",
  borderColor: "#0000",
  zIndex: 1
}), cE("icon", `
 margin: var(--n-icon-margin);
 margin-left: 0;
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 max-width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB("icon-slot", `
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [iconSwitchTransition({
  top: "50%",
  originalTransform: "translateY(-50%)"
})]), fadeInWidthExpandTransition()]), cE("content", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 min-width: 0;
 `, [c3("~", [cE("icon", {
  margin: "var(--n-icon-margin)",
  marginRight: 0
})])]), cM("block", `
 display: flex;
 width: 100%;
 `), cM("dashed", [cE("border, state-border", {
  borderStyle: "dashed !important"
})]), cM("disabled", {
  cursor: "not-allowed",
  opacity: "var(--n-opacity-disabled)"
})]), c3("@keyframes button-wave-spread", {
  from: {
    boxShadow: "0 0 0.5px 0 var(--n-ripple-color)"
  },
  to: {
    boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)"
  }
}), c3("@keyframes button-wave-opacity", {
  from: {
    opacity: "var(--n-wave-opacity)"
  },
  to: {
    opacity: 0
  }
})]);

// node_modules/naive-ui/es/button/src/Button.js
var buttonProps = Object.assign(Object.assign({}, use_theme_default.props), { color: String, textColor: String, text: Boolean, block: Boolean, loading: Boolean, disabled: Boolean, circle: Boolean, size: String, ghost: Boolean, round: Boolean, secondary: Boolean, tertiary: Boolean, quaternary: Boolean, strong: Boolean, focusable: {
  type: Boolean,
  default: true
}, keyboard: {
  type: Boolean,
  default: true
}, tag: {
  type: String,
  default: "button"
}, type: {
  type: String,
  default: "default"
}, dashed: Boolean, renderIcon: Function, iconPlacement: {
  type: String,
  default: "left"
}, attrType: {
  type: String,
  default: "button"
}, bordered: {
  type: Boolean,
  default: true
}, onClick: [Function, Array], nativeFocusBehavior: {
  type: Boolean,
  default: !isSafari
} });
var Button = defineComponent({
  name: "Button",
  props: buttonProps,
  setup(props) {
    if (false) {
      watchEffect(() => {
        const { dashed, ghost, text: text2, secondary, tertiary, quaternary } = props;
        if ((dashed || ghost || text2) && (secondary || tertiary || quaternary)) {
          warnOnce("button", "`dashed`, `ghost` and `text` props can't be used along with `secondary`, `tertiary` and `quaterary` props.");
        }
      });
    }
    const selfElRef = ref(null);
    const waveElRef = ref(null);
    const enterPressedRef = ref(false);
    const showBorderRef = use_memo_default(() => {
      return !props.quaternary && !props.tertiary && !props.secondary && !props.text && (!props.color || props.ghost || props.dashed) && props.bordered;
    });
    const NButtonGroup = inject(buttonGroupInjectionKey, {});
    const { mergedSizeRef } = useFormItem({}, {
      defaultSize: "medium",
      mergedSize: (NFormItem) => {
        const { size: size3 } = props;
        if (size3)
          return size3;
        const { size: buttonGroupSize } = NButtonGroup;
        if (buttonGroupSize)
          return buttonGroupSize;
        const { mergedSize: formItemSize } = NFormItem || {};
        if (formItemSize) {
          return formItemSize.value;
        }
        return "medium";
      }
    });
    const mergedFocusableRef = computed2(() => {
      return props.focusable && !props.disabled;
    });
    const handleMousedown = (e3) => {
      var _a3;
      if (!mergedFocusableRef.value) {
        e3.preventDefault();
      }
      if (props.nativeFocusBehavior) {
        return;
      }
      e3.preventDefault();
      if (props.disabled) {
        return;
      }
      if (mergedFocusableRef.value) {
        (_a3 = selfElRef.value) === null || _a3 === void 0 ? void 0 : _a3.focus({ preventScroll: true });
      }
    };
    const handleClick = (e3) => {
      var _a3;
      if (!props.disabled && !props.loading) {
        const { onClick } = props;
        if (onClick)
          call(onClick, e3);
        if (!props.text) {
          (_a3 = waveElRef.value) === null || _a3 === void 0 ? void 0 : _a3.play();
        }
      }
    };
    const handleKeyup = (e3) => {
      switch (e3.key) {
        case "Enter":
          if (!props.keyboard) {
            return;
          }
          enterPressedRef.value = false;
      }
    };
    const handleKeydown = (e3) => {
      switch (e3.key) {
        case "Enter":
          if (!props.keyboard || props.loading) {
            e3.preventDefault();
            return;
          }
          enterPressedRef.value = true;
      }
    };
    const handleBlur = () => {
      enterPressedRef.value = false;
    };
    const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
    const themeRef = use_theme_default("Button", "-button", index_cssr_default10, light_default17, props, mergedClsPrefixRef);
    const rtlEnabledRef = useRtl("Button", mergedRtlRef, mergedClsPrefixRef);
    const cssVarsRef = computed2(() => {
      const theme = themeRef.value;
      const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut5, cubicBezierEaseOut: cubicBezierEaseOut3 }, self: self79 } = theme;
      const { rippleDuration, opacityDisabled, fontWeight, fontWeightStrong } = self79;
      const size3 = mergedSizeRef.value;
      const { dashed, type, ghost, text: text2, color: color2, round: round2, circle, textColor, secondary, tertiary, quaternary, strong } = props;
      const fontProps = {
        "font-weight": strong ? fontWeightStrong : fontWeight
      };
      let colorProps = {
        "--n-color": "initial",
        "--n-color-hover": "initial",
        "--n-color-pressed": "initial",
        "--n-color-focus": "initial",
        "--n-color-disabled": "initial",
        "--n-ripple-color": "initial",
        "--n-text-color": "initial",
        "--n-text-color-hover": "initial",
        "--n-text-color-pressed": "initial",
        "--n-text-color-focus": "initial",
        "--n-text-color-disabled": "initial"
      };
      const typeIsTertiary = type === "tertiary";
      const typeIsDefault = type === "default";
      const mergedType = typeIsTertiary ? "default" : type;
      if (text2) {
        const propTextColor = textColor || color2;
        const mergedTextColor = propTextColor || self79[createKey("textColorText", mergedType)];
        colorProps = {
          "--n-color": "#0000",
          "--n-color-hover": "#0000",
          "--n-color-pressed": "#0000",
          "--n-color-focus": "#0000",
          "--n-color-disabled": "#0000",
          "--n-ripple-color": "#0000",
          "--n-text-color": mergedTextColor,
          "--n-text-color-hover": propTextColor ? createHoverColor(propTextColor) : self79[createKey("textColorTextHover", mergedType)],
          "--n-text-color-pressed": propTextColor ? createPressedColor(propTextColor) : self79[createKey("textColorTextPressed", mergedType)],
          "--n-text-color-focus": propTextColor ? createHoverColor(propTextColor) : self79[createKey("textColorTextHover", mergedType)],
          "--n-text-color-disabled": propTextColor || self79[createKey("textColorTextDisabled", mergedType)]
        };
      } else if (ghost || dashed) {
        const mergedTextColor = textColor || color2;
        colorProps = {
          "--n-color": "#0000",
          "--n-color-hover": "#0000",
          "--n-color-pressed": "#0000",
          "--n-color-focus": "#0000",
          "--n-color-disabled": "#0000",
          "--n-ripple-color": color2 || self79[createKey("rippleColor", mergedType)],
          "--n-text-color": mergedTextColor || self79[createKey("textColorGhost", mergedType)],
          "--n-text-color-hover": mergedTextColor ? createHoverColor(mergedTextColor) : self79[createKey("textColorGhostHover", mergedType)],
          "--n-text-color-pressed": mergedTextColor ? createPressedColor(mergedTextColor) : self79[createKey("textColorGhostPressed", mergedType)],
          "--n-text-color-focus": mergedTextColor ? createHoverColor(mergedTextColor) : self79[createKey("textColorGhostHover", mergedType)],
          "--n-text-color-disabled": mergedTextColor || self79[createKey("textColorGhostDisabled", mergedType)]
        };
      } else if (secondary) {
        const typeTextColor = typeIsDefault ? self79.textColor : typeIsTertiary ? self79.textColorTertiary : self79[createKey("color", mergedType)];
        const mergedTextColor = color2 || typeTextColor;
        const isColoredType = type !== "default" && type !== "tertiary";
        colorProps = {
          "--n-color": isColoredType ? changeColor(mergedTextColor, {
            alpha: Number(self79.colorOpacitySecondary)
          }) : self79.colorSecondary,
          "--n-color-hover": isColoredType ? changeColor(mergedTextColor, {
            alpha: Number(self79.colorOpacitySecondaryHover)
          }) : self79.colorSecondaryHover,
          "--n-color-pressed": isColoredType ? changeColor(mergedTextColor, {
            alpha: Number(self79.colorOpacitySecondaryPressed)
          }) : self79.colorSecondaryPressed,
          "--n-color-focus": isColoredType ? changeColor(mergedTextColor, {
            alpha: Number(self79.colorOpacitySecondaryHover)
          }) : self79.colorSecondaryHover,
          "--n-color-disabled": self79.colorSecondary,
          "--n-ripple-color": "#0000",
          "--n-text-color": mergedTextColor,
          "--n-text-color-hover": mergedTextColor,
          "--n-text-color-pressed": mergedTextColor,
          "--n-text-color-focus": mergedTextColor,
          "--n-text-color-disabled": mergedTextColor
        };
      } else if (tertiary || quaternary) {
        const typeColor = typeIsDefault ? self79.textColor : typeIsTertiary ? self79.textColorTertiary : self79[createKey("color", mergedType)];
        const mergedColor = color2 || typeColor;
        if (tertiary) {
          colorProps["--n-color"] = self79.colorTertiary;
          colorProps["--n-color-hover"] = self79.colorTertiaryHover;
          colorProps["--n-color-pressed"] = self79.colorTertiaryPressed;
          colorProps["--n-color-focus"] = self79.colorSecondaryHover;
          colorProps["--n-color-disabled"] = self79.colorTertiary;
        } else {
          colorProps["--n-color"] = self79.colorQuaternary;
          colorProps["--n-color-hover"] = self79.colorQuaternaryHover;
          colorProps["--n-color-pressed"] = self79.colorQuaternaryPressed;
          colorProps["--n-color-focus"] = self79.colorQuaternaryHover;
          colorProps["--n-color-disabled"] = self79.colorQuaternary;
        }
        colorProps["--n-ripple-color"] = "#0000";
        colorProps["--n-text-color"] = mergedColor;
        colorProps["--n-text-color-hover"] = mergedColor;
        colorProps["--n-text-color-pressed"] = mergedColor;
        colorProps["--n-text-color-focus"] = mergedColor;
        colorProps["--n-text-color-disabled"] = mergedColor;
      } else {
        colorProps = {
          "--n-color": color2 || self79[createKey("color", mergedType)],
          "--n-color-hover": color2 ? createHoverColor(color2) : self79[createKey("colorHover", mergedType)],
          "--n-color-pressed": color2 ? createPressedColor(color2) : self79[createKey("colorPressed", mergedType)],
          "--n-color-focus": color2 ? createHoverColor(color2) : self79[createKey("colorFocus", mergedType)],
          "--n-color-disabled": color2 || self79[createKey("colorDisabled", mergedType)],
          "--n-ripple-color": color2 || self79[createKey("rippleColor", mergedType)],
          "--n-text-color": textColor || (color2 ? self79.textColorPrimary : typeIsTertiary ? self79.textColorTertiary : self79[createKey("textColor", mergedType)]),
          "--n-text-color-hover": textColor || (color2 ? self79.textColorHoverPrimary : self79[createKey("textColorHover", mergedType)]),
          "--n-text-color-pressed": textColor || (color2 ? self79.textColorPressedPrimary : self79[createKey("textColorPressed", mergedType)]),
          "--n-text-color-focus": textColor || (color2 ? self79.textColorFocusPrimary : self79[createKey("textColorFocus", mergedType)]),
          "--n-text-color-disabled": textColor || (color2 ? self79.textColorDisabledPrimary : self79[createKey("textColorDisabled", mergedType)])
        };
      }
      let borderProps2 = {
        "--n-border": "initial",
        "--n-border-hover": "initial",
        "--n-border-pressed": "initial",
        "--n-border-focus": "initial",
        "--n-border-disabled": "initial"
      };
      if (text2) {
        borderProps2 = {
          "--n-border": "none",
          "--n-border-hover": "none",
          "--n-border-pressed": "none",
          "--n-border-focus": "none",
          "--n-border-disabled": "none"
        };
      } else {
        borderProps2 = {
          "--n-border": self79[createKey("border", mergedType)],
          "--n-border-hover": self79[createKey("borderHover", mergedType)],
          "--n-border-pressed": self79[createKey("borderPressed", mergedType)],
          "--n-border-focus": self79[createKey("borderFocus", mergedType)],
          "--n-border-disabled": self79[createKey("borderDisabled", mergedType)]
        };
      }
      const { [createKey("height", size3)]: height, [createKey("fontSize", size3)]: fontSize2, [createKey("padding", size3)]: padding, [createKey("paddingRound", size3)]: paddingRound, [createKey("iconSize", size3)]: iconSize, [createKey("borderRadius", size3)]: borderRadius, [createKey("iconMargin", size3)]: iconMargin, waveOpacity } = self79;
      const sizeProps = {
        "--n-width": circle && !text2 ? height : "initial",
        "--n-height": text2 ? "initial" : height,
        "--n-font-size": fontSize2,
        "--n-padding": circle ? "initial" : text2 ? "initial" : round2 ? paddingRound : padding,
        "--n-icon-size": iconSize,
        "--n-icon-margin": iconMargin,
        "--n-border-radius": text2 ? "initial" : circle || round2 ? height : borderRadius
      };
      return Object.assign(Object.assign(Object.assign(Object.assign({ "--n-bezier": cubicBezierEaseInOut5, "--n-bezier-ease-out": cubicBezierEaseOut3, "--n-ripple-duration": rippleDuration, "--n-opacity-disabled": opacityDisabled, "--n-wave-opacity": waveOpacity }, fontProps), colorProps), borderProps2), sizeProps);
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("button", computed2(() => {
      let hash = "";
      const { dashed, type, ghost, text: text2, color: color2, round: round2, circle, textColor, secondary, tertiary, quaternary, strong } = props;
      if (dashed)
        hash += "a";
      if (ghost)
        hash += "b";
      if (text2)
        hash += "c";
      if (round2)
        hash += "d";
      if (circle)
        hash += "e";
      if (secondary)
        hash += "f";
      if (tertiary)
        hash += "g";
      if (quaternary)
        hash += "h";
      if (strong)
        hash += "i";
      if (color2)
        hash += "j" + color2Class(color2);
      if (textColor)
        hash += "k" + color2Class(textColor);
      const { value: size3 } = mergedSizeRef;
      hash += "l" + size3[0];
      hash += "m" + type[0];
      return hash;
    }), cssVarsRef, props) : void 0;
    return {
      selfElRef,
      waveElRef,
      mergedClsPrefix: mergedClsPrefixRef,
      mergedFocusable: mergedFocusableRef,
      mergedSize: mergedSizeRef,
      showBorder: showBorderRef,
      enterPressed: enterPressedRef,
      rtlEnabled: rtlEnabledRef,
      handleMousedown,
      handleKeydown,
      handleBlur,
      handleKeyup,
      handleClick,
      customColorCssVars: computed2(() => {
        const { color: color2 } = props;
        if (!color2)
          return null;
        const hoverColor = createHoverColor(color2);
        return {
          "--n-border-color": color2,
          "--n-border-color-hover": hoverColor,
          "--n-border-color-pressed": createPressedColor(color2),
          "--n-border-color-focus": hoverColor,
          "--n-border-color-disabled": color2
        };
      }),
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const { mergedClsPrefix, tag: Component2, onRender } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    const children2 = resolveWrappedSlot(this.$slots.default, (children3) => children3 && h3("span", { class: `${mergedClsPrefix}-button__content` }, children3));
    return h3(Component2, { ref: "selfElRef", class: [
      this.themeClass,
      `${mergedClsPrefix}-button`,
      `${mergedClsPrefix}-button--${this.type}-type`,
      `${mergedClsPrefix}-button--${this.mergedSize}-type`,
      this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
      this.disabled && `${mergedClsPrefix}-button--disabled`,
      this.block && `${mergedClsPrefix}-button--block`,
      this.enterPressed && `${mergedClsPrefix}-button--pressed`,
      !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
      this.color && `${mergedClsPrefix}-button--color`,
      this.secondary && `${mergedClsPrefix}-button--secondary`,
      this.loading && `${mergedClsPrefix}-button--loading`,
      this.ghost && `${mergedClsPrefix}-button--ghost`
    ], tabindex: this.mergedFocusable ? 0 : -1, type: this.attrType, style: this.cssVars, disabled: this.disabled, onClick: this.handleClick, onBlur: this.handleBlur, onMousedown: this.handleMousedown, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown }, this.iconPlacement === "right" && children2, h3(FadeInExpandTransition_default, { width: true }, {
      default: () => resolveWrappedSlot(this.$slots.icon, (children3) => (this.loading || this.renderIcon || children3) && h3("span", { class: `${mergedClsPrefix}-button__icon`, style: {
        margin: isSlotEmpty(this.$slots.default) ? "0" : ""
      } }, h3(IconSwitchTransition_default, null, {
        default: () => this.loading ? h3(Loading_default, { clsPrefix: mergedClsPrefix, key: "loading", class: `${mergedClsPrefix}-icon-slot`, strokeWidth: 20 }) : h3("div", { key: "icon", class: `${mergedClsPrefix}-icon-slot`, role: "none" }, this.renderIcon ? this.renderIcon() : children3)
      })))
    }), this.iconPlacement === "left" && children2, !this.text ? h3(Wave_default, { ref: "waveElRef", clsPrefix: mergedClsPrefix }) : null, this.showBorder ? h3("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__border`, style: this.customColorCssVars }) : null, this.showBorder ? h3("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__state-border`, style: this.customColorCssVars }) : null);
  }
});
var Button_default = Button;

// node_modules/naive-ui/es/button-group/src/styles/index.cssr.js
var zero = "0!important";
var n1 = "-1px!important";
function createLeftBorderStyle(type) {
  return cM(type + "-type", [c3("& +", [cB("button", {}, [cM(type + "-type", [cE("border", {
    borderLeftWidth: zero
  }), cE("state-border", {
    left: n1
  })])])])]);
}
function createTopBorderStyle(type) {
  return cM(type + "-type", [c3("& +", [cB("button", [cM(type + "-type", [cE("border", {
    borderTopWidth: zero
  }), cE("state-border", {
    top: n1
  })])])])]);
}
var index_cssr_default11 = cB("button-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [cNotM("vertical", {
  flexDirection: "row"
}, [cNotM("rtl", [cB("button", [c3("&:first-child:not(:last-child)", `
 margin-right: ${zero};
 border-top-right-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), c3("&:last-child:not(:first-child)", `
 margin-left: ${zero};
 border-top-left-radius: ${zero};
 border-bottom-left-radius: ${zero};
 `), c3("&:not(:first-child):not(:last-child)", `
 margin-left: ${zero};
 margin-right: ${zero};
 border-radius: ${zero};
 `), createLeftBorderStyle("default"), cM("ghost", [createLeftBorderStyle("primary"), createLeftBorderStyle("info"), createLeftBorderStyle("success"), createLeftBorderStyle("warning"), createLeftBorderStyle("error")])])])]), cM("vertical", {
  flexDirection: "column"
}, [cB("button", [c3("&:first-child:not(:last-child)", `
 margin-bottom: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-bottom-left-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), c3("&:last-child:not(:first-child)", `
 margin-top: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-top-left-radius: ${zero};
 border-top-right-radius: ${zero};
 `), c3("&:not(:first-child):not(:last-child)", `
 margin: ${zero};
 border-radius: ${zero};
 `), createTopBorderStyle("default"), cM("ghost", [createTopBorderStyle("primary"), createTopBorderStyle("info"), createTopBorderStyle("success"), createTopBorderStyle("warning"), createTopBorderStyle("error")])])])]);

// node_modules/naive-ui/es/button-group/src/ButtonGroup.js
var buttonGroupProps = {
  size: {
    type: String,
    default: void 0
  },
  vertical: Boolean
};
var ButtonGroup_default = defineComponent({
  name: "ButtonGroup",
  props: buttonGroupProps,
  setup(props) {
    const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
    useStyle("-button-group", index_cssr_default11, mergedClsPrefixRef);
    provide(buttonGroupInjectionKey, props);
    const rtlEnabledRef = useRtl("ButtonGroup", mergedRtlRef, mergedClsPrefixRef);
    return {
      rtlEnabled: rtlEnabledRef,
      mergedClsPrefix: mergedClsPrefixRef
    };
  },
  render() {
    const { mergedClsPrefix } = this;
    return h3("div", { class: [
      `${mergedClsPrefix}-button-group`,
      this.rtlEnabled && `${mergedClsPrefix}-button-group--rtl`,
      this.vertical && `${mergedClsPrefix}-button-group--vertical`
    ], role: "group" }, this.$slots);
  }
});

// node_modules/naive-ui/es/date-picker/src/utils.js
var matcherMap = {
  date: isSameDay,
  month: isSameMonth,
  year: isSameYear,
  quarter: isSameQuarter
};
function matchDate(sourceTime, patternTime, type) {
  const matcher = matcherMap[type];
  if (Array.isArray(sourceTime)) {
    return sourceTime.some((time2) => matcher(time2, patternTime));
  } else {
    return matcher(sourceTime, patternTime);
  }
}
function dateItem(time2, monthTs, valueTs, currentTs) {
  let inSpan = false;
  let startOfSpan = false;
  let endOfSpan = false;
  if (Array.isArray(valueTs)) {
    if (valueTs[0] < time2 && time2 < valueTs[1]) {
      inSpan = true;
    }
    if (matchDate(valueTs[0], time2, "date"))
      startOfSpan = true;
    if (matchDate(valueTs[1], time2, "date"))
      endOfSpan = true;
  }
  const selected = valueTs !== null && (Array.isArray(valueTs) ? matchDate(valueTs[0], time2, "date") || matchDate(valueTs[1], time2, "date") : matchDate(valueTs, time2, "date"));
  return {
    type: "date",
    dateObject: {
      date: getDate(time2),
      month: getMonth(time2),
      year: getYear(time2)
    },
    inCurrentMonth: isSameMonth(time2, monthTs),
    isCurrentDate: matchDate(currentTs, time2, "date"),
    inSpan,
    startOfSpan,
    endOfSpan,
    selected,
    ts: getTime(time2)
  };
}
function dateArray(monthTs, valueTs, currentTs, startDay, strip = false) {
  const displayMonth = getMonth(monthTs);
  let displayMonthIterator = getTime(startOfMonth(monthTs));
  let lastMonthIterator = getTime(addDays(displayMonthIterator, -1));
  const calendarDays = [];
  let protectLastMonthDateIsShownFlag = !strip;
  while (getDay(lastMonthIterator) !== startDay || protectLastMonthDateIsShownFlag) {
    calendarDays.unshift(dateItem(lastMonthIterator, monthTs, valueTs, currentTs));
    lastMonthIterator = getTime(addDays(lastMonthIterator, -1));
    protectLastMonthDateIsShownFlag = false;
  }
  while (getMonth(displayMonthIterator) === displayMonth) {
    calendarDays.push(dateItem(displayMonthIterator, monthTs, valueTs, currentTs));
    displayMonthIterator = getTime(addDays(displayMonthIterator, 1));
  }
  const endIndex = strip ? calendarDays.length <= 28 ? 28 : calendarDays.length <= 35 ? 35 : 42 : 42;
  while (calendarDays.length < endIndex) {
    calendarDays.push(dateItem(displayMonthIterator, monthTs, valueTs, currentTs));
    displayMonthIterator = getTime(addDays(displayMonthIterator, 1));
  }
  return calendarDays;
}

// node_modules/naive-ui/es/calendar/styles/_common.js
var common_default13 = {
  titleFontSize: "22px"
};

// node_modules/naive-ui/es/calendar/styles/light.js
var self18 = (vars) => {
  const { borderRadius, fontSize: fontSize2, lineHeight: lineHeight3, textColor2, textColor1, textColorDisabled, dividerColor, fontWeightStrong, primaryColor, baseColor, hoverColor, cardColor, modalColor, popoverColor } = vars;
  return Object.assign(Object.assign({}, common_default13), {
    borderRadius,
    borderColor: composite(cardColor, dividerColor),
    borderColorModal: composite(modalColor, dividerColor),
    borderColorPopover: composite(popoverColor, dividerColor),
    textColor: textColor2,
    titleFontWeight: fontWeightStrong,
    titleTextColor: textColor1,
    dayTextColor: textColorDisabled,
    fontSize: fontSize2,
    lineHeight: lineHeight3,
    dateColorCurrent: primaryColor,
    dateTextColorCurrent: baseColor,
    cellColorHover: composite(cardColor, hoverColor),
    cellColorHoverModal: composite(modalColor, hoverColor),
    cellColorHoverPopover: composite(popoverColor, hoverColor),
    cellColor: cardColor,
    cellColorModal: modalColor,
    cellColorPopover: popoverColor,
    barColor: primaryColor
  });
};
var calendarLight = createTheme({
  name: "Calendar",
  common: light_default,
  peers: {
    Button: light_default17
  },
  self: self18
});
var light_default18 = calendarLight;

// node_modules/naive-ui/es/calendar/styles/dark.js
var calendarDark = {
  name: "Calendar",
  common: dark_default,
  peers: {
    Button: dark_default17
  },
  self: self18
};
var dark_default18 = calendarDark;

// node_modules/naive-ui/es/calendar/src/styles/index.cssr.js
var index_cssr_default12 = c3([cB("calendar", `
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 height: 720px;
 display: flex;
 flex-direction: column;
 `, [cB("calendar-prev-btn", `
 cursor: pointer;
 `), cB("calendar-next-btn", `
 cursor: pointer;
 `), cB("calendar-header", `
 display: flex;
 align-items: center;
 line-height: 1;
 font-size: var(--n-title-font-size);
 padding: 0 0 18px 0;
 justify-content: space-between;
 `, [cE("title", `
 color: var(--n-title-text-color);
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 `), cE("extra", `
 display: flex;
 align-items: center;
 `)]), cB("calendar-dates", `
 display: grid;
 grid-template-columns: repeat(7, minmax(0, 1fr));
 grid-auto-rows: 1fr;
 border-radius: var(--n-border-radius);
 flex: 1;
 border-top: 1px solid;
 border-left: 1px solid;
 border-color: var(--n-border-color);
 transition: border-color .3s var(--n-bezier);
 `), cB("calendar-cell", `
 box-sizing: border-box;
 padding: 10px;
 border-right: 1px solid;
 border-bottom: 1px solid;
 border-color: var(--n-border-color);
 cursor: pointer;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c3("&:nth-child(7)", `
 border-top-right-radius: var(--n-border-radius);
 `), c3("&:nth-last-child(7)", `
 border-bottom-left-radius: var(--n-border-radius);
 `), c3("&:last-child", `
 border-bottom-right-radius: var(--n-border-radius);
 `), c3("&:hover", `
 background-color: var(--n-cell-color-hover);
 `), cE("bar", `
 position: absolute;
 left: 0;
 right: 0;
 bottom: -1px;
 height: 3px;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `), cM("selected", [cE("bar", `
 background-color: var(--n-bar-color);
 `)]), cB("calendar-date", `
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 color: var(--n-text-color);
 `, [cE("date", `
 color: var(--n-text-color);
 `)]), cM("disabled, other-month", `
 color: var(--n-day-text-color);
 `, [cB("calendar-date", [cE("date", `
 color: var(--n-day-text-color);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 `), cM("current", [cB("calendar-date", [cE("date", `
 color: var(--n-date-text-color-current);
 background-color: var(--n-date-color-current);
 `)])]), cB("calendar-date", `
 position: relative;
 line-height: 1;
 display: flex;
 align-items: center;
 height: 1em;
 justify-content: space-between;
 padding-bottom: .75em;
 `, [cE("date", `
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 margin-left: -0.4em;
 width: 1.8em;
 height: 1.8em;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cE("day", `
 color: var(--n-day-text-color);
 transition: color .3s var(--n-bezier);
 `)])])]), insideModal(cB("calendar", [cB("calendar-dates", `
 border-color: var(--n-border-color-modal);
 `), cB("calendar-cell", `
 border-color: var(--n-border-color-modal);
 `, [c3("&:hover", `
 background-color: var(--n-cell-color-hover-modal);
 `)])])), insidePopover(cB("calendar", [cB("calendar-dates", `
 border-color: var(--n-border-color-popover);
 `), cB("calendar-cell", `
 border-color: var(--n-border-color-popover);
 `, [c3("&:hover", `
 background-color: var(--n-cell-color-hover-popover);
 `)])]))]);

// node_modules/naive-ui/es/calendar/src/Calendar.js
var calendarProps = Object.assign(Object.assign({}, use_theme_default.props), { isDateDisabled: Function, value: Number, defaultValue: {
  type: Number,
  default: null
}, onPanelChange: Function, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] });
var Calendar_default = defineComponent({
  name: "Calendar",
  props: calendarProps,
  setup(props) {
    var _a3;
    const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
    const themeRef = use_theme_default("Calendar", "-calendar", index_cssr_default12, light_default18, props, mergedClsPrefixRef);
    const { localeRef, dateLocaleRef } = useLocale("DatePicker");
    const now = Date.now();
    const monthTsRef = ref(startOfMonth((_a3 = props.defaultValue) !== null && _a3 !== void 0 ? _a3 : now).valueOf());
    const uncontrolledValueRef = ref(props.defaultValue || null);
    const mergedValueRef = useMergedState(toRef(props, "value"), uncontrolledValueRef);
    function doUpdateValue(value, time2) {
      const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
      if (onUpdateValue) {
        call(onUpdateValue, value, time2);
      }
      if (_onUpdateValue) {
        call(_onUpdateValue, value, time2);
      }
      uncontrolledValueRef.value = value;
    }
    function handlePrevClick() {
      var _a4;
      const monthTs = addMonths(monthTsRef.value, -1).valueOf();
      monthTsRef.value = monthTs;
      (_a4 = props.onPanelChange) === null || _a4 === void 0 ? void 0 : _a4.call(props, {
        year: getYear(monthTs),
        month: getMonth(monthTs) + 1
      });
    }
    function handleNextClick() {
      var _a4;
      const monthTs = addMonths(monthTsRef.value, 1).valueOf();
      monthTsRef.value = monthTs;
      (_a4 = props.onPanelChange) === null || _a4 === void 0 ? void 0 : _a4.call(props, {
        year: getYear(monthTs),
        month: getMonth(monthTs) + 1
      });
    }
    function handleTodayClick() {
      var _a4;
      const { value: monthTs } = monthTsRef;
      const oldYear = getYear(monthTs);
      const oldMonth = getMonth(monthTs);
      const newMonthTs = startOfMonth(now).valueOf();
      monthTsRef.value = newMonthTs;
      const newYear = getYear(newMonthTs);
      const newMonth = getMonth(newMonthTs);
      if (oldYear !== newYear || oldMonth !== newMonth) {
        (_a4 = props.onPanelChange) === null || _a4 === void 0 ? void 0 : _a4.call(props, {
          year: newYear,
          month: newMonth + 1
        });
      }
    }
    const cssVarsRef = computed2(() => {
      const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut5 }, self: { borderColor, borderColorModal, borderColorPopover, borderRadius, titleFontSize, textColor, titleFontWeight, titleTextColor, dayTextColor, fontSize: fontSize2, lineHeight: lineHeight3, dateColorCurrent, dateTextColorCurrent, cellColorHover, cellColor, cellColorModal, barColor, cellColorPopover, cellColorHoverModal, cellColorHoverPopover } } = themeRef.value;
      return {
        "--n-bezier": cubicBezierEaseInOut5,
        "--n-border-color": borderColor,
        "--n-border-color-modal": borderColorModal,
        "--n-border-color-popover": borderColorPopover,
        "--n-border-radius": borderRadius,
        "--n-text-color": textColor,
        "--n-title-font-weight": titleFontWeight,
        "--n-title-font-size": titleFontSize,
        "--n-title-text-color": titleTextColor,
        "--n-day-text-color": dayTextColor,
        "--n-font-size": fontSize2,
        "--n-line-height": lineHeight3,
        "--n-date-color-current": dateColorCurrent,
        "--n-date-text-color-current": dateTextColorCurrent,
        "--n-cell-color": cellColor,
        "--n-cell-color-modal": cellColorModal,
        "--n-cell-color-popover": cellColorPopover,
        "--n-cell-color-hover": cellColorHover,
        "--n-cell-color-hover-modal": cellColorHoverModal,
        "--n-cell-color-hover-popover": cellColorHoverPopover,
        "--n-bar-color": barColor
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("calendar", void 0, cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      locale: localeRef,
      dateLocale: dateLocaleRef,
      now,
      mergedValue: mergedValueRef,
      monthTs: monthTsRef,
      dateItems: computed2(() => {
        return dateArray(monthTsRef.value, mergedValueRef.value, now, localeRef.value.firstDayOfWeek, true);
      }),
      doUpdateValue,
      handleTodayClick,
      handlePrevClick,
      handleNextClick,
      mergedTheme: themeRef,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const { isDateDisabled, mergedClsPrefix, monthTs, cssVars, mergedValue, mergedTheme, $slots, locale: { monthBeforeYear, today }, dateLocale: { locale: locale3 }, handleTodayClick, handlePrevClick, handleNextClick, onRender } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    const normalizedValue = mergedValue && startOfDay(mergedValue).valueOf();
    const year = getYear(monthTs);
    const calendarMonth = getMonth(monthTs) + 1;
    return h3("div", { class: [`${mergedClsPrefix}-calendar`, this.themeClass], style: cssVars }, h3("div", { class: `${mergedClsPrefix}-calendar-header` }, h3("div", { class: `${mergedClsPrefix}-calendar-header__title` }, resolveSlotWithProps($slots.header, { year, month: calendarMonth }, () => {
      const localeMonth = format(monthTs, "MMMM", { locale: locale3 });
      return [
        monthBeforeYear ? `${localeMonth} ${year}` : `${year} ${localeMonth}`
      ];
    })), h3("div", { class: `${mergedClsPrefix}-calendar-header__extra` }, h3(ButtonGroup_default, null, {
      default: () => h3(Fragment, null, h3(Button_default, { size: "small", onClick: handlePrevClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, {
        icon: () => h3(Icon_default, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-calendar-prev-btn` }, { default: () => h3(ChevronLeft_default, null) })
      }), h3(Button_default, { size: "small", onClick: handleTodayClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, { default: () => today }), h3(Button_default, { size: "small", onClick: handleNextClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, {
        icon: () => h3(Icon_default, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-calendar-next-btn` }, { default: () => h3(ChevronRight_default, null) })
      }))
    }))), h3("div", { class: `${mergedClsPrefix}-calendar-dates` }, this.dateItems.map(({ dateObject, ts, inCurrentMonth, isCurrentDate }, index2) => {
      var _a3;
      const { year: year2, month, date } = dateObject;
      const fullDate = format(ts, "yyyy-MM-dd");
      const notInCurrentMonth = !inCurrentMonth;
      const disabled = (isDateDisabled === null || isDateDisabled === void 0 ? void 0 : isDateDisabled(ts)) === true;
      const selected = normalizedValue === startOfDay(ts).valueOf();
      return h3("div", { key: `${calendarMonth}-${index2}`, class: [
        `${mergedClsPrefix}-calendar-cell`,
        disabled && `${mergedClsPrefix}-calendar-cell--disabled`,
        notInCurrentMonth && `${mergedClsPrefix}-calendar-cell--other-month`,
        disabled && `${mergedClsPrefix}-calendar-cell--not-allowed`,
        isCurrentDate && `${mergedClsPrefix}-calendar-cell--current`,
        selected && `${mergedClsPrefix}-calendar-cell--selected`
      ], onClick: () => {
        var _a4;
        if (disabled)
          return;
        const monthTs2 = startOfMonth(ts).valueOf();
        this.monthTs = monthTs2;
        if (notInCurrentMonth) {
          (_a4 = this.onPanelChange) === null || _a4 === void 0 ? void 0 : _a4.call(this, {
            year: getYear(monthTs2),
            month: getMonth(monthTs2) + 1
          });
        }
        this.doUpdateValue(ts, {
          year: year2,
          month: month + 1,
          date
        });
      } }, h3("div", { class: `${mergedClsPrefix}-calendar-date` }, h3("div", { class: `${mergedClsPrefix}-calendar-date__date`, title: fullDate }, date), index2 < 7 && h3("div", { class: `${mergedClsPrefix}-calendar-date__day`, title: fullDate }, format(ts, "EEE", {
        locale: locale3
      }))), (_a3 = $slots.default) === null || _a3 === void 0 ? void 0 : _a3.call($slots, {
        year: year2,
        month: month + 1,
        date
      }), h3("div", { class: `${mergedClsPrefix}-calendar-cell__bar` }));
    })));
  }
});

// node_modules/naive-ui/es/color-picker/styles/light.js
var self19 = (vars) => {
  const { fontSize: fontSize2, boxShadow2, popoverColor, textColor2, borderRadius, borderColor, heightSmall, heightMedium, heightLarge, fontSizeSmall, fontSizeMedium, fontSizeLarge, dividerColor } = vars;
  return {
    panelFontSize: fontSize2,
    boxShadow: boxShadow2,
    color: popoverColor,
    textColor: textColor2,
    borderRadius,
    border: `1px solid ${borderColor}`,
    heightSmall,
    heightMedium,
    heightLarge,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    dividerColor
  };
};
var colorPickerLight = createTheme({
  name: "ColorPicker",
  common: light_default,
  peers: {
    Input: light_default10,
    Button: light_default17
  },
  self: self19
});
var light_default19 = colorPickerLight;

// node_modules/naive-ui/es/color-picker/styles/dark.js
var colorPickerDark = {
  name: "ColorPicker",
  common: dark_default,
  peers: {
    Input: dark_default10,
    Button: dark_default17
  },
  self: self19
};
var dark_default19 = colorPickerDark;

// node_modules/naive-ui/es/card/styles/_common.js
var common_default14 = {
  paddingSmall: "12px 16px 12px",
  paddingMedium: "19px 24px 20px",
  paddingLarge: "23px 32px 24px",
  paddingHuge: "27px 40px 28px",
  titleFontSizeSmall: "16px",
  titleFontSizeMedium: "18px",
  titleFontSizeLarge: "18px",
  titleFontSizeHuge: "18px",
  closeIconSize: "18px",
  closeSize: "22px"
};

// node_modules/naive-ui/es/card/styles/light.js
var self20 = (vars) => {
  const { primaryColor, borderRadius, lineHeight: lineHeight3, fontSize: fontSize2, cardColor, textColor2, textColor1, dividerColor, fontWeightStrong, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, modalColor, boxShadow1, popoverColor, actionColor } = vars;
  return Object.assign(Object.assign({}, common_default14), {
    lineHeight: lineHeight3,
    color: cardColor,
    colorModal: modalColor,
    colorPopover: popoverColor,
    colorTarget: primaryColor,
    colorEmbedded: actionColor,
    colorEmbeddedModal: actionColor,
    colorEmbeddedPopover: actionColor,
    textColor: textColor2,
    titleTextColor: textColor1,
    borderColor: dividerColor,
    actionColor,
    titleFontWeight: fontWeightStrong,
    closeColorHover,
    closeColorPressed,
    closeBorderRadius: borderRadius,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    fontSizeSmall: fontSize2,
    fontSizeMedium: fontSize2,
    fontSizeLarge: fontSize2,
    fontSizeHuge: fontSize2,
    boxShadow: boxShadow1,
    borderRadius
  });
};
var cardLight = {
  name: "Card",
  common: light_default,
  self: self20
};
var light_default20 = cardLight;

// node_modules/naive-ui/es/card/styles/dark.js
var cardDark = {
  name: "Card",
  common: dark_default,
  self(vars) {
    const commonSelf = self20(vars);
    const { cardColor, modalColor, popoverColor } = vars;
    commonSelf.colorEmbedded = cardColor;
    commonSelf.colorEmbeddedModal = modalColor;
    commonSelf.colorEmbeddedPopover = popoverColor;
    return commonSelf;
  }
};
var dark_default20 = cardDark;

// node_modules/naive-ui/es/card/src/styles/index.cssr.js
var index_cssr_default13 = c3([cB("card", `
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 display: flex;
 flex-direction: column;
 width: 100%;
 box-sizing: border-box;
 position: relative;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 color: var(--n-text-color);
 word-break: break-word;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [asModal({
  background: "var(--n-color-modal)"
}), cM("hoverable", [c3("&:hover", "box-shadow: var(--n-box-shadow);")]), cM("content-segmented", [c3(">", [cE("content", {
  paddingTop: "var(--n-padding-bottom)"
})])]), cM("content-soft-segmented", [c3(">", [cE("content", `
 margin: 0 var(--n-padding-left);
 padding: var(--n-padding-bottom) 0;
 `)])]), cM("footer-segmented", [c3(">", [cE("footer", {
  paddingTop: "var(--n-padding-bottom)"
})])]), cM("footer-soft-segmented", [c3(">", [cE("footer", `
 padding: var(--n-padding-bottom) 0;
 margin: 0 var(--n-padding-left);
 `)])]), c3(">", [cB("card-header", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 padding:
 var(--n-padding-top)
 var(--n-padding-left)
 var(--n-padding-bottom)
 var(--n-padding-left);
 `, [cE("main", `
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 min-width: 0;
 color: var(--n-title-text-color);
 `), cE("extra", `
 display: flex;
 align-items: center;
 font-size: var(--n-font-size);
 font-weight: 400;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE("close", `
 margin: 0 0 0 8px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE("action", `
 box-sizing: border-box;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 background-clip: padding-box;
 background-color: var(--n-action-color);
 `), cE("content", "flex: 1; min-width: 0;"), cE("content, footer", `
 box-sizing: border-box;
 padding: 0 var(--n-padding-left) var(--n-padding-bottom) var(--n-padding-left);
 font-size: var(--n-font-size);
 `, [c3("&:first-child", {
  paddingTop: "var(--n-padding-bottom)"
})]), cE("action", `
 background-color: var(--n-action-color);
 padding: var(--n-padding-bottom) var(--n-padding-left);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `)]), cB("card-cover", `
 overflow: hidden;
 width: 100%;
 border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
 `, [c3("img", `
 display: block;
 width: 100%;
 `)]), cM("bordered", `
 border: 1px solid var(--n-border-color);
 `, [c3("&:target", "border-color: var(--n-color-target);")]), cM("action-segmented", [c3(">", [cE("action", [c3("&:not(:first-child)", {
  borderTop: "1px solid var(--n-border-color)"
})])])]), cM("content-segmented, content-soft-segmented", [c3(">", [cE("content", {
  transition: "border-color 0.3s var(--n-bezier)"
}, [c3("&:not(:first-child)", {
  borderTop: "1px solid var(--n-border-color)"
})])])]), cM("footer-segmented, footer-soft-segmented", [c3(">", [cE("footer", {
  transition: "border-color 0.3s var(--n-bezier)"
}, [c3("&:not(:first-child)", {
  borderTop: "1px solid var(--n-border-color)"
})])])]), cM("embedded", `
 background-color: var(--n-color-embedded);
 `)]), insideModal(cB("card", `
 background: var(--n-color-modal);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-modal);
 `)])), insidePopover(cB("card", `
 background: var(--n-color-popover);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-popover);
 `)]))]);

// node_modules/naive-ui/es/card/src/Card.js
var cardBaseProps = {
  title: String,
  contentStyle: [Object, String],
  headerStyle: [Object, String],
  headerExtraStyle: [Object, String],
  footerStyle: [Object, String],
  embedded: Boolean,
  segmented: {
    type: [Boolean, Object],
    default: false
  },
  size: {
    type: String,
    default: "medium"
  },
  bordered: {
    type: Boolean,
    default: true
  },
  closable: Boolean,
  hoverable: Boolean,
  role: String,
  onClose: [Function, Array],
  tag: {
    type: String,
    default: "div"
  }
};
var cardBasePropKeys = keysOf(cardBaseProps);
var cardProps = Object.assign(Object.assign({}, use_theme_default.props), cardBaseProps);
var Card_default = defineComponent({
  name: "Card",
  props: cardProps,
  setup(props) {
    const handleCloseClick = () => {
      const { onClose } = props;
      if (onClose)
        call(onClose);
    };
    const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
    const themeRef = use_theme_default("Card", "-card", index_cssr_default13, light_default20, props, mergedClsPrefixRef);
    const rtlEnabledRef = useRtl("Card", mergedRtlRef, mergedClsPrefixRef);
    const cssVarsRef = computed2(() => {
      const { size: size3 } = props;
      const { self: { color: color2, colorModal, colorTarget, textColor, titleTextColor, titleFontWeight, borderColor, actionColor, borderRadius, lineHeight: lineHeight3, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, closeBorderRadius, closeIconSize, closeSize, boxShadow, colorPopover, colorEmbedded, colorEmbeddedModal, colorEmbeddedPopover, [createKey("padding", size3)]: padding, [createKey("fontSize", size3)]: fontSize2, [createKey("titleFontSize", size3)]: titleFontSize }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut5 } } = themeRef.value;
      const { top: paddingTop, left: paddingLeft, bottom: paddingBottom } = getMargin(padding);
      return {
        "--n-bezier": cubicBezierEaseInOut5,
        "--n-border-radius": borderRadius,
        "--n-color": color2,
        "--n-color-modal": colorModal,
        "--n-color-popover": colorPopover,
        "--n-color-embedded": colorEmbedded,
        "--n-color-embedded-modal": colorEmbeddedModal,
        "--n-color-embedded-popover": colorEmbeddedPopover,
        "--n-color-target": colorTarget,
        "--n-text-color": textColor,
        "--n-line-height": lineHeight3,
        "--n-action-color": actionColor,
        "--n-title-text-color": titleTextColor,
        "--n-title-font-weight": titleFontWeight,
        "--n-close-icon-color": closeIconColor,
        "--n-close-icon-color-hover": closeIconColorHover,
        "--n-close-icon-color-pressed": closeIconColorPressed,
        "--n-close-color-hover": closeColorHover,
        "--n-close-color-pressed": closeColorPressed,
        "--n-border-color": borderColor,
        "--n-box-shadow": boxShadow,
        "--n-padding-top": paddingTop,
        "--n-padding-bottom": paddingBottom,
        "--n-padding-left": paddingLeft,
        "--n-font-size": fontSize2,
        "--n-title-font-size": titleFontSize,
        "--n-close-size": closeSize,
        "--n-close-icon-size": closeIconSize,
        "--n-close-border-radius": closeBorderRadius
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("card", computed2(() => {
      return props.size[0];
    }), cssVarsRef, props) : void 0;
    return {
      rtlEnabled: rtlEnabledRef,
      mergedClsPrefix: mergedClsPrefixRef,
      mergedTheme: themeRef,
      handleCloseClick,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const { segmented, bordered, hoverable, mergedClsPrefix, rtlEnabled, onRender, embedded, tag: Component2, $slots } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return h3(Component2, { class: [
      `${mergedClsPrefix}-card`,
      this.themeClass,
      embedded && `${mergedClsPrefix}-card--embedded`,
      {
        [`${mergedClsPrefix}-card--rtl`]: rtlEnabled,
        [`${mergedClsPrefix}-card--content${typeof segmented !== "boolean" && segmented.content === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.content,
        [`${mergedClsPrefix}-card--footer${typeof segmented !== "boolean" && segmented.footer === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.footer,
        [`${mergedClsPrefix}-card--action-segmented`]: segmented === true || segmented !== false && segmented.action,
        [`${mergedClsPrefix}-card--bordered`]: bordered,
        [`${mergedClsPrefix}-card--hoverable`]: hoverable
      }
    ], style: this.cssVars, role: this.role }, resolveWrappedSlot($slots.cover, (children2) => children2 && h3("div", { class: `${mergedClsPrefix}-card-cover`, role: "none" }, children2)), resolveWrappedSlot($slots.header, (children2) => {
      return children2 || this.title || this.closable ? h3("div", { class: `${mergedClsPrefix}-card-header`, style: this.headerStyle }, h3("div", { class: `${mergedClsPrefix}-card-header__main`, role: "heading" }, children2 || this.title), resolveWrappedSlot($slots["header-extra"], (children3) => children3 && h3("div", { class: `${mergedClsPrefix}-card-header__extra`, style: this.headerExtraStyle }, children3)), this.closable ? h3(Close_default2, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-card-header__close`, onClick: this.handleCloseClick, absolute: true }) : null) : null;
    }), resolveWrappedSlot($slots.default, (children2) => children2 && h3("div", { class: `${mergedClsPrefix}-card__content`, style: this.contentStyle, role: "none" }, children2)), resolveWrappedSlot($slots.footer, (children2) => children2 && [
      h3("div", { class: `${mergedClsPrefix}-card__footer`, style: this.footerStyle, role: "none" }, children2)
    ]), resolveWrappedSlot($slots.action, (children2) => children2 && h3("div", { class: `${mergedClsPrefix}-card__action`, role: "none" }, children2)));
  }
});

// node_modules/naive-ui/es/carousel/styles/light.js
var self21 = (vars) => {
  return {
    dotSize: "8px",
    dotColor: "rgba(255, 255, 255, .3)",
    dotColorActive: "rgba(255, 255, 255, 1)",
    dotColorFocus: "rgba(255, 255, 255, .5)",
    dotLineWidth: "16px",
    dotLineWidthActive: "24px",
    arrowColor: "#eee"
  };
};
var carouselLight = {
  name: "Carousel",
  common: light_default,
  self: self21
};
var light_default21 = carouselLight;

// node_modules/naive-ui/es/carousel/styles/dark.js
var carouselDark = {
  name: "Carousel",
  common: dark_default,
  self: self21
};
var dark_default21 = carouselDark;

// node_modules/naive-ui/es/checkbox/styles/_common.js
var common_default15 = {
  sizeSmall: "14px",
  sizeMedium: "16px",
  sizeLarge: "18px",
  labelPadding: "0 8px",
  labelFontWeight: "400"
};

// node_modules/naive-ui/es/checkbox/styles/light.js
var self22 = (vars) => {
  const { baseColor, inputColorDisabled, cardColor, modalColor, popoverColor, textColorDisabled, borderColor, primaryColor, textColor2, fontSizeSmall, fontSizeMedium, fontSizeLarge, borderRadiusSmall, lineHeight: lineHeight3 } = vars;
  return Object.assign(Object.assign({}, common_default15), {
    labelLineHeight: lineHeight3,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    borderRadius: borderRadiusSmall,
    color: baseColor,
    colorChecked: primaryColor,
    colorDisabled: inputColorDisabled,
    colorDisabledChecked: inputColorDisabled,
    colorTableHeader: cardColor,
    colorTableHeaderModal: modalColor,
    colorTableHeaderPopover: popoverColor,
    checkMarkColor: baseColor,
    checkMarkColorDisabled: textColorDisabled,
    checkMarkColorDisabledChecked: textColorDisabled,
    border: `1px solid ${borderColor}`,
    borderDisabled: `1px solid ${borderColor}`,
    borderDisabledChecked: `1px solid ${borderColor}`,
    borderChecked: `1px solid ${primaryColor}`,
    borderFocus: `1px solid ${primaryColor}`,
    boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
    textColor: textColor2,
    textColorDisabled
  });
};
var checkboxLight = {
  name: "Checkbox",
  common: light_default,
  self: self22
};
var light_default22 = checkboxLight;

// node_modules/naive-ui/es/checkbox/styles/dark.js
var checkboxDark = {
  name: "Checkbox",
  common: dark_default,
  self(vars) {
    const { cardColor } = vars;
    const commonSelf = self22(vars);
    commonSelf.color = "#0000";
    commonSelf.checkMarkColor = cardColor;
    return commonSelf;
  }
};
var dark_default22 = checkboxDark;

// node_modules/naive-ui/es/cascader/styles/light.js
var self23 = (vars) => {
  const { borderRadius, boxShadow2, popoverColor, textColor2, textColor3, primaryColor, textColorDisabled, dividerColor, hoverColor, fontSizeMedium, heightMedium } = vars;
  return {
    menuBorderRadius: borderRadius,
    menuColor: popoverColor,
    menuBoxShadow: boxShadow2,
    menuDividerColor: dividerColor,
    menuHeight: "calc(var(--n-option-height) * 6.6)",
    optionArrowColor: textColor3,
    optionHeight: heightMedium,
    optionFontSize: fontSizeMedium,
    optionColorHover: hoverColor,
    optionTextColor: textColor2,
    optionTextColorActive: primaryColor,
    optionTextColorDisabled: textColorDisabled,
    optionCheckMarkColor: primaryColor,
    loadingColor: primaryColor,
    columnWidth: "180px"
  };
};
var cascaderLight = createTheme({
  name: "Cascader",
  common: light_default,
  peers: {
    InternalSelectMenu: light_default4,
    InternalSelection: light_default7,
    Scrollbar: light_default3,
    Checkbox: light_default22,
    Empty: light_default2
  },
  self: self23
});
var light_default23 = cascaderLight;

// node_modules/naive-ui/es/cascader/styles/dark.js
var cascaderDark = {
  name: "Cascader",
  common: dark_default,
  peers: {
    InternalSelectMenu: dark_default4,
    InternalSelection: dark_default7,
    Scrollbar: dark_default3,
    Checkbox: dark_default22,
    Empty: light_default2
  },
  self: self23
};
var dark_default23 = cascaderDark;

// node_modules/naive-ui/es/code/styles/dark.js
var codeDark = {
  name: "Code",
  common: dark_default,
  self(vars) {
    const { textColor2, fontSize: fontSize2, fontWeightStrong, textColor3 } = vars;
    return {
      textColor: textColor2,
      fontSize: fontSize2,
      fontWeightStrong,
      "mono-3": "#5c6370",
      "hue-1": "#56b6c2",
      "hue-2": "#61aeee",
      "hue-3": "#c678dd",
      "hue-4": "#98c379",
      "hue-5": "#e06c75",
      "hue-5-2": "#be5046",
      "hue-6": "#d19a66",
      "hue-6-2": "#e6c07b",
      lineNumberTextColor: textColor3
    };
  }
};
var dark_default24 = codeDark;

// node_modules/naive-ui/es/code/styles/light.js
var self24 = (vars) => {
  const { textColor2, fontSize: fontSize2, fontWeightStrong, textColor3 } = vars;
  return {
    textColor: textColor2,
    fontSize: fontSize2,
    fontWeightStrong,
    "mono-3": "#a0a1a7",
    "hue-1": "#0184bb",
    "hue-2": "#4078f2",
    "hue-3": "#a626a4",
    "hue-4": "#50a14f",
    "hue-5": "#e45649",
    "hue-5-2": "#c91243",
    "hue-6": "#986801",
    "hue-6-2": "#c18401",
    lineNumberTextColor: textColor3
  };
};
var codeLight = {
  name: "Code",
  common: light_default,
  self: self24
};
var light_default24 = codeLight;

// node_modules/naive-ui/es/collapse/styles/light.js
var self25 = (vars) => {
  const { fontWeight, textColor1, textColor2, textColorDisabled, dividerColor, fontSize: fontSize2 } = vars;
  return {
    titleFontSize: fontSize2,
    titleFontWeight: fontWeight,
    dividerColor,
    titleTextColor: textColor1,
    titleTextColorDisabled: textColorDisabled,
    fontSize: fontSize2,
    textColor: textColor2,
    arrowColor: textColor2,
    arrowColorDisabled: textColorDisabled,
    itemMargin: "16px 0 0 0"
  };
};
var collapseLight = {
  name: "Collapse",
  common: light_default,
  self: self25
};
var light_default25 = collapseLight;

// node_modules/naive-ui/es/collapse/styles/dark.js
var collapseDark = {
  name: "Collapse",
  common: dark_default,
  self: self25
};
var dark_default25 = collapseDark;

// node_modules/naive-ui/es/collapse-transition/styles/light.js
var self26 = (vars) => {
  const { cubicBezierEaseInOut: cubicBezierEaseInOut5 } = vars;
  return {
    bezier: cubicBezierEaseInOut5
  };
};
var collapseTransitionLight = {
  name: "CollapseTransition",
  common: light_default,
  self: self26
};
var light_default26 = collapseTransitionLight;

// node_modules/naive-ui/es/collapse-transition/styles/dark.js
var collapseTransitionDark = {
  name: "CollapseTransition",
  common: dark_default,
  self: self26
};
var dark_default26 = collapseTransitionDark;

// node_modules/naive-ui/es/config-provider/src/ConfigProvider.js
var configProviderProps = {
  abstract: Boolean,
  bordered: {
    type: Boolean,
    default: void 0
  },
  clsPrefix: String,
  locale: Object,
  dateLocale: Object,
  namespace: String,
  rtl: Array,
  tag: {
    type: String,
    default: "div"
  },
  hljs: Object,
  katex: Object,
  theme: Object,
  themeOverrides: Object,
  componentOptions: Object,
  icons: Object,
  breakpoints: Object,
  preflightStyleDisabled: Boolean,
  inlineThemeDisabled: {
    type: Boolean,
    default: void 0
  },
  as: {
    type: String,
    validator: () => {
      warn2("config-provider", "`as` is deprecated, please use `tag` instead.");
      return true;
    },
    default: void 0
  }
};
var ConfigProvider_default = defineComponent({
  name: "ConfigProvider",
  alias: ["App"],
  props: configProviderProps,
  setup(props) {
    const NConfigProvider = inject(configProviderInjectionKey, null);
    const mergedThemeRef = computed2(() => {
      const { theme } = props;
      if (theme === null)
        return void 0;
      const inheritedTheme = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value;
      return theme === void 0 ? inheritedTheme : inheritedTheme === void 0 ? theme : Object.assign({}, inheritedTheme, theme);
    });
    const mergedThemeOverridesRef = computed2(() => {
      const { themeOverrides } = props;
      if (themeOverrides === null)
        return void 0;
      if (themeOverrides === void 0) {
        return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value;
      } else {
        const inheritedThemeOverrides = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value;
        if (inheritedThemeOverrides === void 0) {
          return themeOverrides;
        } else {
          return merge_default({}, inheritedThemeOverrides, themeOverrides);
        }
      }
    });
    const mergedNamespaceRef = use_memo_default(() => {
      const { namespace: namespace2 } = props;
      return namespace2 === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value : namespace2;
    });
    const mergedBorderedRef = use_memo_default(() => {
      const { bordered } = props;
      return bordered === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value : bordered;
    });
    const mergedIconsRef = computed2(() => {
      const { icons } = props;
      return icons === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedIconsRef.value : icons;
    });
    const mergedComponentPropsRef = computed2(() => {
      const { componentOptions } = props;
      if (componentOptions !== void 0)
        return componentOptions;
      return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value;
    });
    const mergedClsPrefixRef = computed2(() => {
      const { clsPrefix } = props;
      if (clsPrefix !== void 0)
        return clsPrefix;
      return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedClsPrefixRef.value;
    });
    const mergedRtlRef = computed2(() => {
      var _a3;
      const { rtl } = props;
      if (rtl === void 0) {
        return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef.value;
      }
      const rtlEnabledState = {};
      for (const rtlInfo of rtl) {
        rtlEnabledState[rtlInfo.name] = markRaw(rtlInfo);
        (_a3 = rtlInfo.peers) === null || _a3 === void 0 ? void 0 : _a3.forEach((peerRtlInfo) => {
          if (!(peerRtlInfo.name in rtlEnabledState)) {
            rtlEnabledState[peerRtlInfo.name] = markRaw(peerRtlInfo);
          }
        });
      }
      return rtlEnabledState;
    });
    const mergedBreakpointsRef = computed2(() => {
      return props.breakpoints || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBreakpointsRef.value);
    });
    const inlineThemeDisabled = props.inlineThemeDisabled || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.inlineThemeDisabled);
    const preflightStyleDisabled = props.preflightStyleDisabled || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled);
    const mergedThemeHashRef = computed2(() => {
      const { value: theme } = mergedThemeRef;
      const { value: mergedThemeOverrides } = mergedThemeOverridesRef;
      const hasThemeOverrides = mergedThemeOverrides && Object.keys(mergedThemeOverrides).length !== 0;
      const themeName = theme === null || theme === void 0 ? void 0 : theme.name;
      if (themeName) {
        if (hasThemeOverrides) {
          return `${themeName}-${hash_browser_esm_default(JSON.stringify(mergedThemeOverridesRef.value))}`;
        }
        return themeName;
      } else {
        if (hasThemeOverrides) {
          return hash_browser_esm_default(JSON.stringify(mergedThemeOverridesRef.value));
        }
        return "";
      }
    });
    provide(configProviderInjectionKey, {
      mergedThemeHashRef,
      mergedBreakpointsRef,
      mergedRtlRef,
      mergedIconsRef,
      mergedComponentPropsRef,
      mergedBorderedRef,
      mergedNamespaceRef,
      mergedClsPrefixRef,
      mergedLocaleRef: computed2(() => {
        const { locale: locale3 } = props;
        if (locale3 === null)
          return void 0;
        return locale3 === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedLocaleRef.value : locale3;
      }),
      mergedDateLocaleRef: computed2(() => {
        const { dateLocale } = props;
        if (dateLocale === null)
          return void 0;
        return dateLocale === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedDateLocaleRef.value : dateLocale;
      }),
      mergedHljsRef: computed2(() => {
        const { hljs } = props;
        return hljs === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedHljsRef.value : hljs;
      }),
      mergedKatexRef: computed2(() => {
        const { katex } = props;
        return katex === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedKatexRef.value : katex;
      }),
      mergedThemeRef,
      mergedThemeOverridesRef,
      inlineThemeDisabled: inlineThemeDisabled || false,
      preflightStyleDisabled: preflightStyleDisabled || false
    });
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      mergedBordered: mergedBorderedRef,
      mergedNamespace: mergedNamespaceRef,
      mergedTheme: mergedThemeRef,
      mergedThemeOverrides: mergedThemeOverridesRef
    };
  },
  render() {
    var _a3, _b2, _c, _d;
    return !this.abstract ? h3(this.as || this.tag, {
      class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
    }, (_b2 = (_a3 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a3)) : (_d = (_c = this.$slots).default) === null || _d === void 0 ? void 0 : _d.call(_c);
  }
});

// node_modules/naive-ui/es/popselect/styles/dark.js
var popselect = {
  name: "Popselect",
  common: dark_default,
  peers: {
    Popover: dark_default5,
    InternalSelectMenu: dark_default4
  }
};
var dark_default27 = popselect;

// node_modules/naive-ui/es/popselect/styles/light.js
function self27(vars) {
  const { boxShadow2 } = vars;
  return {
    menuBoxShadow: boxShadow2
  };
}
var popselectLight = createTheme({
  name: "Popselect",
  common: light_default,
  peers: {
    Popover: light_default5,
    InternalSelectMenu: light_default4
  },
  self: self27
});
var light_default27 = popselectLight;

// node_modules/naive-ui/es/select/styles/light.js
function self28(vars) {
  const { boxShadow2 } = vars;
  return {
    menuBoxShadow: boxShadow2
  };
}
var selectLight = createTheme({
  name: "Select",
  common: light_default,
  peers: {
    InternalSelection: light_default7,
    InternalSelectMenu: light_default4
  },
  self: self28
});
var light_default28 = selectLight;

// node_modules/naive-ui/es/select/styles/dark.js
var selectDark = {
  name: "Select",
  common: dark_default,
  peers: {
    InternalSelection: dark_default7,
    InternalSelectMenu: dark_default4
  },
  self: self28
};
var dark_default28 = selectDark;

// node_modules/naive-ui/es/pagination/styles/_common.js
var common_default16 = {
  itemPaddingSmall: "0 4px",
  itemMarginSmall: "0 0 0 8px",
  itemMarginSmallRtl: "0 8px 0 0",
  itemPaddingMedium: "0 4px",
  itemMarginMedium: "0 0 0 8px",
  itemMarginMediumRtl: "0 8px 0 0",
  itemPaddingLarge: "0 4px",
  itemMarginLarge: "0 0 0 8px",
  itemMarginLargeRtl: "0 8px 0 0",
  buttonIconSizeSmall: "14px",
  buttonIconSizeMedium: "16px",
  buttonIconSizeLarge: "18px",
  inputWidthSmall: "60px",
  selectWidthSmall: "unset",
  inputMarginSmall: "0 0 0 8px",
  inputMarginSmallRtl: "0 8px 0 0",
  selectMarginSmall: "0 0 0 8px",
  prefixMarginSmall: "0 8px 0 0",
  suffixMarginSmall: "0 0 0 8px",
  inputWidthMedium: "60px",
  selectWidthMedium: "unset",
  inputMarginMedium: "0 0 0 8px",
  inputMarginMediumRtl: "0 8px 0 0",
  selectMarginMedium: "0 0 0 8px",
  prefixMarginMedium: "0 8px 0 0",
  suffixMarginMedium: "0 0 0 8px",
  inputWidthLarge: "60px",
  selectWidthLarge: "unset",
  inputMarginLarge: "0 0 0 8px",
  inputMarginLargeRtl: "0 8px 0 0",
  selectMarginLarge: "0 0 0 8px",
  prefixMarginLarge: "0 8px 0 0",
  suffixMarginLarge: "0 0 0 8px"
};

// node_modules/naive-ui/es/pagination/styles/light.js
var self29 = (vars) => {
  const {
    textColor2,
    primaryColor,
    primaryColorHover,
    primaryColorPressed,
    inputColorDisabled,
    textColorDisabled,
    borderColor,
    borderRadius,
    fontSizeTiny,
    fontSizeSmall,
    fontSizeMedium,
    heightTiny,
    heightSmall,
    heightMedium
  } = vars;
  return Object.assign(Object.assign({}, common_default16), { buttonColor: "#0000", buttonColorHover: "#0000", buttonColorPressed: "#0000", buttonBorder: `1px solid ${borderColor}`, buttonBorderHover: `1px solid ${borderColor}`, buttonBorderPressed: `1px solid ${borderColor}`, buttonIconColor: textColor2, buttonIconColorHover: textColor2, buttonIconColorPressed: textColor2, itemTextColor: textColor2, itemTextColorHover: primaryColorHover, itemTextColorPressed: primaryColorPressed, itemTextColorActive: primaryColor, itemTextColorDisabled: textColorDisabled, itemColor: "#0000", itemColorHover: "#0000", itemColorPressed: "#0000", itemColorActive: "#0000", itemColorActiveHover: "#0000", itemColorDisabled: inputColorDisabled, itemBorder: "1px solid #0000", itemBorderHover: "1px solid #0000", itemBorderPressed: "1px solid #0000", itemBorderActive: `1px solid ${primaryColor}`, itemBorderDisabled: `1px solid ${borderColor}`, itemBorderRadius: borderRadius, itemSizeSmall: heightTiny, itemSizeMedium: heightSmall, itemSizeLarge: heightMedium, itemFontSizeSmall: fontSizeTiny, itemFontSizeMedium: fontSizeSmall, itemFontSizeLarge: fontSizeMedium, jumperFontSizeSmall: fontSizeTiny, jumperFontSizeMedium: fontSizeSmall, jumperFontSizeLarge: fontSizeMedium, jumperTextColor: textColor2, jumperTextColorDisabled: textColorDisabled });
};
var paginationLight = createTheme({
  name: "Pagination",
  common: light_default,
  peers: {
    Select: light_default28,
    Input: light_default10,
    Popselect: light_default27
  },
  self: self29
});
var light_default29 = paginationLight;

// node_modules/naive-ui/es/pagination/styles/dark.js
var paginationDark = {
  name: "Pagination",
  common: dark_default,
  peers: {
    Select: dark_default28,
    Input: dark_default10,
    Popselect: dark_default27
  },
  self(vars) {
    const { primaryColor, opacity3 } = vars;
    const borderColorActive = changeColor(primaryColor, {
      alpha: Number(opacity3)
    });
    const commonSelf = self29(vars);
    commonSelf.itemBorderActive = `1px solid ${borderColorActive}`;
    commonSelf.itemBorderDisabled = "1px solid #0000";
    return commonSelf;
  }
};
var dark_default29 = paginationDark;

// node_modules/naive-ui/es/tooltip/styles/_common.js
var common_default17 = {
  padding: "8px 14px"
};

// node_modules/naive-ui/es/tooltip/styles/dark.js
var tooltipDark = {
  name: "Tooltip",
  common: dark_default,
  peers: {
    Popover: dark_default5
  },
  self(vars) {
    const { borderRadius, boxShadow2, popoverColor, textColor2 } = vars;
    return Object.assign(Object.assign({}, common_default17), { borderRadius, boxShadow: boxShadow2, color: popoverColor, textColor: textColor2 });
  }
};
var dark_default30 = tooltipDark;

// node_modules/naive-ui/es/tooltip/styles/light.js
var self30 = (vars) => {
  const { borderRadius, boxShadow2, baseColor } = vars;
  return Object.assign(Object.assign({}, common_default17), { borderRadius, boxShadow: boxShadow2, color: composite(baseColor, "rgba(0, 0, 0, .85)"), textColor: baseColor });
};
var tooltipLight = createTheme({
  name: "Tooltip",
  common: light_default,
  peers: {
    Popover: light_default5
  },
  self: self30
});
var light_default30 = tooltipLight;

// node_modules/naive-ui/es/ellipsis/styles/dark.js
var ellipsisDark = {
  name: "Ellipsis",
  common: dark_default,
  peers: {
    Tooltip: dark_default30
  }
};
var dark_default31 = ellipsisDark;

// node_modules/naive-ui/es/ellipsis/styles/light.js
var ellipsisLight = createTheme({
  name: "Ellipsis",
  common: light_default,
  peers: {
    Tooltip: light_default30
  }
});
var light_default31 = ellipsisLight;

// node_modules/naive-ui/es/radio/styles/_common.js
var common_default18 = {
  radioSizeSmall: "14px",
  radioSizeMedium: "16px",
  radioSizeLarge: "18px",
  labelPadding: "0 8px",
  labelFontWeight: "400"
};

// node_modules/naive-ui/es/radio/styles/dark.js
var radioDark = {
  name: "Radio",
  common: dark_default,
  self(vars) {
    const { borderColor, primaryColor, baseColor, textColorDisabled, inputColorDisabled, textColor2, opacityDisabled, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightSmall, heightMedium, heightLarge, lineHeight: lineHeight3 } = vars;
    return Object.assign(Object.assign({}, common_default18), {
      labelLineHeight: lineHeight3,
      buttonHeightSmall: heightSmall,
      buttonHeightMedium: heightMedium,
      buttonHeightLarge: heightLarge,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      boxShadow: `inset 0 0 0 1px ${borderColor}`,
      boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
      boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
      boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
      boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
      color: "#0000",
      colorDisabled: inputColorDisabled,
      colorActive: "#0000",
      textColor: textColor2,
      textColorDisabled,
      dotColorActive: primaryColor,
      dotColorDisabled: borderColor,
      buttonBorderColor: borderColor,
      buttonBorderColorActive: primaryColor,
      buttonBorderColorHover: primaryColor,
      buttonColor: "#0000",
      buttonColorActive: primaryColor,
      buttonTextColor: textColor2,
      buttonTextColorActive: baseColor,
      buttonTextColorHover: primaryColor,
      opacityDisabled,
      buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
      buttonBoxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
      buttonBoxShadow: "inset 0 0 0 1px #0000",
      buttonBorderRadius: borderRadius
    });
  }
};
var dark_default32 = radioDark;

// node_modules/naive-ui/es/radio/styles/light.js
var self31 = (vars) => {
  const { borderColor, primaryColor, baseColor, textColorDisabled, inputColorDisabled, textColor2, opacityDisabled, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightSmall, heightMedium, heightLarge, lineHeight: lineHeight3 } = vars;
  return Object.assign(Object.assign({}, common_default18), {
    labelLineHeight: lineHeight3,
    buttonHeightSmall: heightSmall,
    buttonHeightMedium: heightMedium,
    buttonHeightLarge: heightLarge,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    boxShadow: `inset 0 0 0 1px ${borderColor}`,
    boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
    boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}`,
    boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
    boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
    color: baseColor,
    colorDisabled: inputColorDisabled,
    colorActive: "#0000",
    textColor: textColor2,
    textColorDisabled,
    dotColorActive: primaryColor,
    dotColorDisabled: borderColor,
    buttonBorderColor: borderColor,
    buttonBorderColorActive: primaryColor,
    buttonBorderColorHover: borderColor,
    buttonColor: baseColor,
    buttonColorActive: baseColor,
    buttonTextColor: textColor2,
    buttonTextColorActive: primaryColor,
    buttonTextColorHover: primaryColor,
    opacityDisabled,
    buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
    buttonBoxShadowHover: "inset 0 0 0 1px #0000",
    buttonBoxShadow: "inset 0 0 0 1px #0000",
    buttonBorderRadius: borderRadius
  });
};
var radioLight = {
  name: "Radio",
  common: light_default,
  self: self31
};
var light_default32 = radioLight;

// node_modules/naive-ui/es/dropdown/styles/_common.js
var common_default19 = {
  padding: "4px 0",
  optionIconSizeSmall: "14px",
  optionIconSizeMedium: "16px",
  optionIconSizeLarge: "16px",
  optionIconSizeHuge: "18px",
  optionSuffixWidthSmall: "14px",
  optionSuffixWidthMedium: "14px",
  optionSuffixWidthLarge: "16px",
  optionSuffixWidthHuge: "16px",
  optionIconSuffixWidthSmall: "32px",
  optionIconSuffixWidthMedium: "32px",
  optionIconSuffixWidthLarge: "36px",
  optionIconSuffixWidthHuge: "36px",
  optionPrefixWidthSmall: "14px",
  optionPrefixWidthMedium: "14px",
  optionPrefixWidthLarge: "16px",
  optionPrefixWidthHuge: "16px",
  optionIconPrefixWidthSmall: "36px",
  optionIconPrefixWidthMedium: "36px",
  optionIconPrefixWidthLarge: "40px",
  optionIconPrefixWidthHuge: "40px"
};

// node_modules/naive-ui/es/dropdown/styles/light.js
var self32 = (vars) => {
  const { primaryColor, textColor2, dividerColor, hoverColor, popoverColor, invertedColor, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge, heightSmall, heightMedium, heightLarge, heightHuge, textColor3, opacityDisabled } = vars;
  return Object.assign(Object.assign({}, common_default19), {
    optionHeightSmall: heightSmall,
    optionHeightMedium: heightMedium,
    optionHeightLarge: heightLarge,
    optionHeightHuge: heightHuge,
    borderRadius,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    fontSizeHuge,
    optionTextColor: textColor2,
    optionTextColorHover: textColor2,
    optionTextColorActive: primaryColor,
    optionTextColorChildActive: primaryColor,
    color: popoverColor,
    dividerColor,
    suffixColor: textColor2,
    prefixColor: textColor2,
    optionColorHover: hoverColor,
    optionColorActive: changeColor(primaryColor, { alpha: 0.1 }),
    groupHeaderTextColor: textColor3,
    optionTextColorInverted: "#BBB",
    optionTextColorHoverInverted: "#FFF",
    optionTextColorActiveInverted: "#FFF",
    optionTextColorChildActiveInverted: "#FFF",
    colorInverted: invertedColor,
    dividerColorInverted: "#BBB",
    suffixColorInverted: "#BBB",
    prefixColorInverted: "#BBB",
    optionColorHoverInverted: primaryColor,
    optionColorActiveInverted: primaryColor,
    groupHeaderTextColorInverted: "#AAA",
    optionOpacityDisabled: opacityDisabled
  });
};
var dropdownLight = createTheme({
  name: "Dropdown",
  common: light_default,
  peers: {
    Popover: light_default5
  },
  self: self32
});
var light_default33 = dropdownLight;

// node_modules/naive-ui/es/dropdown/styles/dark.js
var dropdownDark = {
  name: "Dropdown",
  common: dark_default,
  peers: {
    Popover: dark_default5
  },
  self(vars) {
    const { primaryColorSuppl, primaryColor, popoverColor } = vars;
    const commonSelf = self32(vars);
    commonSelf.colorInverted = popoverColor;
    commonSelf.optionColorActive = changeColor(primaryColor, { alpha: 0.15 });
    commonSelf.optionColorActiveInverted = primaryColorSuppl;
    commonSelf.optionColorHoverInverted = primaryColorSuppl;
    return commonSelf;
  }
};
var dark_default33 = dropdownDark;

// node_modules/naive-ui/es/data-table/styles/_common.js
var common_default20 = {
  thPaddingSmall: "8px",
  thPaddingMedium: "12px",
  thPaddingLarge: "12px",
  tdPaddingSmall: "8px",
  tdPaddingMedium: "12px",
  tdPaddingLarge: "12px",
  sorterSize: "15px",
  resizableContainerSize: "8px",
  resizableSize: "2px",
  filterSize: "15px",
  paginationMargin: "12px 0 0 0",
  emptyPadding: "48px 0",
  actionPadding: "8px 12px",
  actionButtonMargin: "0 8px 0 0"
};

// node_modules/naive-ui/es/data-table/styles/light.js
var self33 = (vars) => {
  const { cardColor, modalColor, popoverColor, textColor2, textColor1, tableHeaderColor, tableColorHover, iconColor, primaryColor, fontWeightStrong, borderRadius, lineHeight: lineHeight3, fontSizeSmall, fontSizeMedium, fontSizeLarge, dividerColor, heightSmall, opacityDisabled, tableColorStriped } = vars;
  return Object.assign(Object.assign({}, common_default20), {
    actionDividerColor: dividerColor,
    lineHeight: lineHeight3,
    borderRadius,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    borderColor: composite(cardColor, dividerColor),
    tdColorHover: composite(cardColor, tableColorHover),
    tdColorStriped: composite(cardColor, tableColorStriped),
    thColor: composite(cardColor, tableHeaderColor),
    thColorHover: composite(composite(cardColor, tableHeaderColor), tableColorHover),
    tdColor: cardColor,
    tdTextColor: textColor2,
    thTextColor: textColor1,
    thFontWeight: fontWeightStrong,
    thButtonColorHover: tableColorHover,
    thIconColor: iconColor,
    thIconColorActive: primaryColor,
    borderColorModal: composite(modalColor, dividerColor),
    tdColorHoverModal: composite(modalColor, tableColorHover),
    tdColorStripedModal: composite(modalColor, tableColorStriped),
    thColorModal: composite(modalColor, tableHeaderColor),
    thColorHoverModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
    tdColorModal: modalColor,
    borderColorPopover: composite(popoverColor, dividerColor),
    tdColorHoverPopover: composite(popoverColor, tableColorHover),
    tdColorStripedPopover: composite(popoverColor, tableColorStriped),
    thColorPopover: composite(popoverColor, tableHeaderColor),
    thColorHoverPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
    tdColorPopover: popoverColor,
    boxShadowBefore: "inset -12px 0 8px -12px rgba(0, 0, 0, .18)",
    boxShadowAfter: "inset 12px 0 8px -12px rgba(0, 0, 0, .18)",
    loadingColor: primaryColor,
    loadingSize: heightSmall,
    opacityLoading: opacityDisabled
  });
};
var dataTableLight = createTheme({
  name: "DataTable",
  common: light_default,
  peers: {
    Button: light_default17,
    Checkbox: light_default22,
    Radio: light_default32,
    Pagination: light_default29,
    Scrollbar: light_default3,
    Empty: light_default2,
    Popover: light_default5,
    Ellipsis: light_default31,
    Dropdown: light_default33
  },
  self: self33
});
var light_default34 = dataTableLight;

// node_modules/naive-ui/es/data-table/styles/dark.js
var dataTableDark = {
  name: "DataTable",
  common: dark_default,
  peers: {
    Button: dark_default17,
    Checkbox: dark_default22,
    Radio: dark_default32,
    Pagination: dark_default29,
    Scrollbar: dark_default3,
    Empty: dark_default2,
    Popover: dark_default5,
    Ellipsis: dark_default31,
    Dropdown: dark_default33
  },
  self(vars) {
    const commonSelf = self33(vars);
    commonSelf.boxShadowAfter = "inset 12px 0 8px -12px rgba(0, 0, 0, .36)";
    commonSelf.boxShadowBefore = "inset -12px 0 8px -12px rgba(0, 0, 0, .36)";
    return commonSelf;
  }
};
var dark_default34 = dataTableDark;

// node_modules/naive-ui/es/tooltip/src/Tooltip.js
var tooltipProps = Object.assign(Object.assign({}, popoverBaseProps), use_theme_default.props);
var Tooltip_default = defineComponent({
  name: "Tooltip",
  props: tooltipProps,
  __popover__: true,
  setup(props) {
    const themeRef = use_theme_default("Tooltip", "-tooltip", void 0, light_default30, props);
    const popoverRef = ref(null);
    const tooltipExposedMethod = {
      syncPosition() {
        popoverRef.value.syncPosition();
      },
      setShow(show) {
        popoverRef.value.setShow(show);
      }
    };
    return Object.assign(Object.assign({}, tooltipExposedMethod), { popoverRef, mergedTheme: themeRef, popoverThemeOverrides: computed2(() => {
      return themeRef.value.self;
    }) });
  },
  render() {
    const { mergedTheme, internalExtraClass } = this;
    return h3(Popover_default, Object.assign(Object.assign({}, this.$props), { theme: mergedTheme.peers.Popover, themeOverrides: mergedTheme.peerOverrides.Popover, builtinThemeOverrides: this.popoverThemeOverrides, internalExtraClass: internalExtraClass.concat("tooltip"), ref: "popoverRef" }), this.$slots);
  }
});

// node_modules/naive-ui/es/ellipsis/src/styles/index.cssr.js
var index_cssr_default14 = cB("ellipsis", {
  overflow: "hidden"
}, [cNotM("line-clamp", `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), cM("line-clamp", `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), cM("cursor-pointer", `
 cursor: pointer;
 `)]);

// node_modules/naive-ui/es/ellipsis/src/Ellipsis.js
function createLineClampClass(clsPrefix) {
  return `${clsPrefix}-ellipsis--line-clamp`;
}
function createCursorClass(clsPrefix, cursor) {
  return `${clsPrefix}-ellipsis--cursor-${cursor}`;
}
var ellipsisProps = Object.assign(Object.assign({}, use_theme_default.props), { expandTrigger: String, lineClamp: [Number, String], tooltip: {
  type: [Boolean, Object],
  default: true
} });
var Ellipsis_default = defineComponent({
  name: "Ellipsis",
  inheritAttrs: false,
  props: ellipsisProps,
  setup(props, { slots, attrs }) {
    const { mergedClsPrefixRef } = useConfig(props);
    const mergedTheme = use_theme_default("Ellipsis", "-ellipsis", index_cssr_default14, light_default31, props, mergedClsPrefixRef);
    const triggerRef2 = ref(null);
    const triggerInnerRef = ref(null);
    const tooltipRef = ref(null);
    const expandedRef = ref(false);
    const ellipsisStyleRef = computed2(() => {
      const { lineClamp } = props;
      const { value: expanded } = expandedRef;
      if (lineClamp !== void 0) {
        return {
          textOverflow: "",
          "-webkit-line-clamp": expanded ? "" : lineClamp
        };
      } else {
        return {
          textOverflow: expanded ? "" : "ellipsis",
          "-webkit-line-clamp": ""
        };
      }
    });
    function getTooltipDisabled() {
      let tooltipDisabled = false;
      const { value: expanded } = expandedRef;
      if (expanded)
        return true;
      const { value: trigger3 } = triggerRef2;
      if (trigger3) {
        const { lineClamp } = props;
        syncEllipsisStyle(trigger3);
        if (lineClamp !== void 0) {
          tooltipDisabled = trigger3.scrollHeight <= trigger3.offsetHeight;
        } else {
          const { value: triggerInner } = triggerInnerRef;
          if (triggerInner) {
            tooltipDisabled = triggerInner.getBoundingClientRect().width <= trigger3.getBoundingClientRect().width;
          }
        }
        syncCursorStyle(trigger3, tooltipDisabled);
      }
      return tooltipDisabled;
    }
    const handleClickRef = computed2(() => {
      return props.expandTrigger === "click" ? () => {
        var _a3;
        const { value: expanded } = expandedRef;
        if (expanded) {
          (_a3 = tooltipRef.value) === null || _a3 === void 0 ? void 0 : _a3.setShow(false);
        }
        expandedRef.value = !expanded;
      } : void 0;
    });
    onDeactivated(() => {
      var _a3;
      if (props.tooltip) {
        (_a3 = tooltipRef.value) === null || _a3 === void 0 ? void 0 : _a3.setShow(false);
      }
    });
    const renderTrigger = () => h3("span", Object.assign({}, mergeProps(attrs, {
      class: [
        `${mergedClsPrefixRef.value}-ellipsis`,
        props.lineClamp !== void 0 ? createLineClampClass(mergedClsPrefixRef.value) : void 0,
        props.expandTrigger === "click" ? createCursorClass(mergedClsPrefixRef.value, "pointer") : void 0
      ],
      style: ellipsisStyleRef.value
    }), { ref: "triggerRef", onClick: handleClickRef.value, onMouseenter: props.expandTrigger === "click" ? getTooltipDisabled : void 0 }), props.lineClamp ? slots : h3("span", { ref: "triggerInnerRef" }, slots));
    function syncEllipsisStyle(trigger3) {
      if (!trigger3)
        return;
      const latestStyle = ellipsisStyleRef.value;
      const lineClampClass = createLineClampClass(mergedClsPrefixRef.value);
      if (props.lineClamp !== void 0) {
        syncTriggerClass(trigger3, lineClampClass, "add");
      } else {
        syncTriggerClass(trigger3, lineClampClass, "remove");
      }
      for (const key in latestStyle) {
        if (trigger3.style[key] !== latestStyle[key]) {
          ;
          trigger3.style[key] = latestStyle[key];
        }
      }
    }
    function syncCursorStyle(trigger3, tooltipDisabled) {
      const cursorClass = createCursorClass(mergedClsPrefixRef.value, "pointer");
      if (props.expandTrigger === "click" && !tooltipDisabled) {
        syncTriggerClass(trigger3, cursorClass, "add");
      } else {
        syncTriggerClass(trigger3, cursorClass, "remove");
      }
    }
    function syncTriggerClass(trigger3, styleClass, action) {
      if (action === "add") {
        if (!trigger3.classList.contains(styleClass)) {
          trigger3.classList.add(styleClass);
        }
      } else {
        if (trigger3.classList.contains(styleClass)) {
          trigger3.classList.remove(styleClass);
        }
      }
    }
    return {
      mergedTheme,
      triggerRef: triggerRef2,
      triggerInnerRef,
      tooltipRef,
      handleClick: handleClickRef,
      renderTrigger,
      getTooltipDisabled
    };
  },
  render() {
    var _a3;
    const { tooltip, renderTrigger, $slots } = this;
    if (tooltip) {
      const { mergedTheme } = this;
      return h3(Tooltip_default, Object.assign({ ref: "tooltipRef", placement: "top" }, tooltip, { getDisabled: this.getTooltipDisabled, theme: mergedTheme.peers.Tooltip, themeOverrides: mergedTheme.peerOverrides.Tooltip }), {
        trigger: renderTrigger,
        default: (_a3 = $slots.tooltip) !== null && _a3 !== void 0 ? _a3 : $slots.default
      });
    } else
      return renderTrigger();
  }
});

// node_modules/naive-ui/es/dropdown/src/DropdownDivider.js
var DropdownDivider_default = defineComponent({
  name: "DropdownDivider",
  props: {
    clsPrefix: {
      type: String,
      required: true
    }
  },
  render() {
    return h3("div", { class: `${this.clsPrefix}-dropdown-divider` });
  }
});

// node_modules/naive-ui/es/icon/styles/light.js
var self34 = (vars) => {
  const { textColorBase, opacity1, opacity2, opacity3, opacity4, opacity5 } = vars;
  return {
    color: textColorBase,
    opacity1Depth: opacity1,
    opacity2Depth: opacity2,
    opacity3Depth: opacity3,
    opacity4Depth: opacity4,
    opacity5Depth: opacity5
  };
};
var iconLight = {
  name: "Icon",
  common: light_default,
  self: self34
};
var light_default35 = iconLight;

// node_modules/naive-ui/es/icon/styles/dark.js
var iconDark = {
  name: "Icon",
  common: dark_default,
  self: self34
};
var dark_default35 = iconDark;

// node_modules/naive-ui/es/icon/src/styles/index.cssr.js
var index_cssr_default15 = cB("icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [cM("color-transition", {
  transition: "color .3s var(--n-bezier)"
}), cM("depth", {
  color: "var(--n-color)"
}, [c3("svg", {
  opacity: "var(--n-opacity)",
  transition: "opacity .3s var(--n-bezier)"
})]), c3("svg", {
  height: "1em",
  width: "1em"
})]);

// node_modules/naive-ui/es/icon/src/Icon.js
var iconProps = Object.assign(Object.assign({}, use_theme_default.props), { depth: [String, Number], size: [Number, String], color: String, component: Object });
var NIcon = defineComponent({
  _n_icon__: true,
  name: "Icon",
  inheritAttrs: false,
  props: iconProps,
  setup(props) {
    const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
    const themeRef = use_theme_default("Icon", "-icon", index_cssr_default15, light_default35, props, mergedClsPrefixRef);
    const cssVarsRef = computed2(() => {
      const { depth } = props;
      const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut5 }, self: self79 } = themeRef.value;
      if (depth !== void 0) {
        const { color: color2, [`opacity${depth}Depth`]: opacity } = self79;
        return {
          "--n-bezier": cubicBezierEaseInOut5,
          "--n-color": color2,
          "--n-opacity": opacity
        };
      }
      return {
        "--n-bezier": cubicBezierEaseInOut5,
        "--n-color": "",
        "--n-opacity": ""
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon", computed2(() => `${props.depth || "d"}`), cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      mergedStyle: computed2(() => {
        const { size: size3, color: color2 } = props;
        return {
          fontSize: formatLength(size3),
          color: color2
        };
      }),
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    var _a3;
    const { $parent, depth, mergedClsPrefix, component, onRender, themeClass } = this;
    if ((_a3 = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a3 === void 0 ? void 0 : _a3._n_icon__) {
      warn2("icon", "don't wrap `n-icon` inside `n-icon`");
    }
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return h3("i", mergeProps(this.$attrs, {
      role: "img",
      class: [
        `${mergedClsPrefix}-icon`,
        themeClass,
        {
          [`${mergedClsPrefix}-icon--depth`]: depth,
          [`${mergedClsPrefix}-icon--color-transition`]: depth !== void 0
        }
      ],
      style: [this.cssVars, this.mergedStyle]
    }), component ? h3(component) : this.$slots);
  }
});

// node_modules/naive-ui/es/dropdown/src/context.js
var dropdownMenuInjectionKey = createInjectionKey("n-dropdown-menu");
var dropdownInjectionKey = createInjectionKey("n-dropdown");
var dropdownOptionInjectionKey = createInjectionKey("n-dropdown-option");

// node_modules/naive-ui/es/dropdown/src/utils.js
function isSubmenuNode(rawNode, childrenField) {
  return rawNode.type === "submenu" || rawNode.type === void 0 && rawNode[childrenField] !== void 0;
}
function isGroupNode(rawNode) {
  return rawNode.type === "group";
}
function isDividerNode(rawNode) {
  return rawNode.type === "divider";
}
function isRenderNode(rawNode) {
  return rawNode.type === "render";
}

// node_modules/naive-ui/es/dropdown/src/DropdownOption.js
var DropdownOption_default = defineComponent({
  name: "DropdownOption",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    },
    parentKey: {
      type: [String, Number],
      default: null
    },
    placement: {
      type: String,
      default: "right-start"
    },
    props: Object,
    scrollable: Boolean
  },
  setup(props) {
    const NDropdown = inject(dropdownInjectionKey);
    const { hoverKeyRef, keyboardKeyRef, lastToggledSubmenuKeyRef, pendingKeyPathRef, activeKeyPathRef, animatedRef, mergedShowRef, renderLabelRef, renderIconRef, labelFieldRef, childrenFieldRef, renderOptionRef, nodePropsRef, menuPropsRef } = NDropdown;
    const NDropdownOption = inject(dropdownOptionInjectionKey, null);
    const NDropdownMenu = inject(dropdownMenuInjectionKey);
    const NPopoverBody = inject(popoverBodyInjectionKey);
    const rawNodeRef = computed2(() => props.tmNode.rawNode);
    const hasSubmenuRef = computed2(() => {
      const { value: childrenField } = childrenFieldRef;
      return isSubmenuNode(props.tmNode.rawNode, childrenField);
    });
    const mergedDisabledRef = computed2(() => {
      const { disabled } = props.tmNode;
      return disabled;
    });
    const showSubmenuRef = computed2(() => {
      if (!hasSubmenuRef.value)
        return false;
      const { key, disabled } = props.tmNode;
      if (disabled)
        return false;
      const { value: hoverKey } = hoverKeyRef;
      const { value: keyboardKey } = keyboardKeyRef;
      const { value: lastToggledSubmenuKey } = lastToggledSubmenuKeyRef;
      const { value: pendingKeyPath } = pendingKeyPathRef;
      if (hoverKey !== null)
        return pendingKeyPath.includes(key);
      if (keyboardKey !== null) {
        return pendingKeyPath.includes(key) && pendingKeyPath[pendingKeyPath.length - 1] !== key;
      }
      if (lastToggledSubmenuKey !== null)
        return pendingKeyPath.includes(key);
      return false;
    });
    const shouldDelayRef = computed2(() => {
      return keyboardKeyRef.value === null && !animatedRef.value;
    });
    const deferredShowSubmenuRef = useDeferredTrue(showSubmenuRef, 300, shouldDelayRef);
    const parentEnteringSubmenuRef = computed2(() => {
      return !!(NDropdownOption === null || NDropdownOption === void 0 ? void 0 : NDropdownOption.enteringSubmenuRef.value);
    });
    const enteringSubmenuRef = ref(false);
    provide(dropdownOptionInjectionKey, {
      enteringSubmenuRef
    });
    function handleSubmenuBeforeEnter() {
      enteringSubmenuRef.value = true;
    }
    function handleSubmenuAfterEnter() {
      enteringSubmenuRef.value = false;
    }
    function handleMouseEnter() {
      const { parentKey, tmNode } = props;
      if (tmNode.disabled)
        return;
      if (!mergedShowRef.value)
        return;
      lastToggledSubmenuKeyRef.value = parentKey;
      keyboardKeyRef.value = null;
      hoverKeyRef.value = tmNode.key;
    }
    function handleMouseMove() {
      const { tmNode } = props;
      if (tmNode.disabled)
        return;
      if (!mergedShowRef.value)
        return;
      if (hoverKeyRef.value === tmNode.key)
        return;
      handleMouseEnter();
    }
    function handleMouseLeave(e3) {
      if (props.tmNode.disabled)
        return;
      if (!mergedShowRef.value)
        return;
      const { relatedTarget } = e3;
      if (relatedTarget && !happensIn({ target: relatedTarget }, "dropdownOption") && !happensIn({ target: relatedTarget }, "scrollbarRail")) {
        hoverKeyRef.value = null;
      }
    }
    function handleClick() {
      const { value: hasSubmenu } = hasSubmenuRef;
      const { tmNode } = props;
      if (!mergedShowRef.value)
        return;
      if (!hasSubmenu && !tmNode.disabled) {
        NDropdown.doSelect(tmNode.key, tmNode.rawNode);
        NDropdown.doUpdateShow(false);
      }
    }
    return {
      labelField: labelFieldRef,
      renderLabel: renderLabelRef,
      renderIcon: renderIconRef,
      siblingHasIcon: NDropdownMenu.showIconRef,
      siblingHasSubmenu: NDropdownMenu.hasSubmenuRef,
      menuProps: menuPropsRef,
      popoverBody: NPopoverBody,
      animated: animatedRef,
      mergedShowSubmenu: computed2(() => {
        return deferredShowSubmenuRef.value && !parentEnteringSubmenuRef.value;
      }),
      rawNode: rawNodeRef,
      hasSubmenu: hasSubmenuRef,
      pending: use_memo_default(() => {
        const { value: pendingKeyPath } = pendingKeyPathRef;
        const { key } = props.tmNode;
        return pendingKeyPath.includes(key);
      }),
      childActive: use_memo_default(() => {
        const { value: activeKeyPath } = activeKeyPathRef;
        const { key } = props.tmNode;
        const index2 = activeKeyPath.findIndex((k2) => key === k2);
        if (index2 === -1)
          return false;
        return index2 < activeKeyPath.length - 1;
      }),
      active: use_memo_default(() => {
        const { value: activeKeyPath } = activeKeyPathRef;
        const { key } = props.tmNode;
        const index2 = activeKeyPath.findIndex((k2) => key === k2);
        if (index2 === -1)
          return false;
        return index2 === activeKeyPath.length - 1;
      }),
      mergedDisabled: mergedDisabledRef,
      renderOption: renderOptionRef,
      nodeProps: nodePropsRef,
      handleClick,
      handleMouseMove,
      handleMouseEnter,
      handleMouseLeave,
      handleSubmenuBeforeEnter,
      handleSubmenuAfterEnter
    };
  },
  render() {
    var _a3, _b2;
    const { animated, rawNode, mergedShowSubmenu, clsPrefix, siblingHasIcon, siblingHasSubmenu, renderLabel, renderIcon, renderOption, nodeProps, props, scrollable } = this;
    let submenuVNode = null;
    if (mergedShowSubmenu) {
      const submenuNodeProps = (_a3 = this.menuProps) === null || _a3 === void 0 ? void 0 : _a3.call(this, rawNode, rawNode.children);
      submenuVNode = h3(DropdownMenu_default, Object.assign({}, submenuNodeProps, { clsPrefix, scrollable: this.scrollable, tmNodes: this.tmNode.children, parentKey: this.tmNode.key }));
    }
    const builtinProps = {
      class: [
        `${clsPrefix}-dropdown-option-body`,
        this.pending && `${clsPrefix}-dropdown-option-body--pending`,
        this.active && `${clsPrefix}-dropdown-option-body--active`,
        this.childActive && `${clsPrefix}-dropdown-option-body--child-active`,
        this.mergedDisabled && `${clsPrefix}-dropdown-option-body--disabled`
      ],
      onMousemove: this.handleMouseMove,
      onMouseenter: this.handleMouseEnter,
      onMouseleave: this.handleMouseLeave,
      onClick: this.handleClick
    };
    const optionNodeProps = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
    const node = h3("div", Object.assign({ class: [`${clsPrefix}-dropdown-option`, optionNodeProps === null || optionNodeProps === void 0 ? void 0 : optionNodeProps.class], "data-dropdown-option": true }, optionNodeProps), h3("div", mergeProps(builtinProps, props), [
      h3("div", { class: [
        `${clsPrefix}-dropdown-option-body__prefix`,
        siblingHasIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`
      ] }, [renderIcon ? renderIcon(rawNode) : render(rawNode.icon)]),
      h3("div", { "data-dropdown-option": true, class: `${clsPrefix}-dropdown-option-body__label` }, renderLabel ? renderLabel(rawNode) : render((_b2 = rawNode[this.labelField]) !== null && _b2 !== void 0 ? _b2 : rawNode.title)),
      h3("div", { "data-dropdown-option": true, class: [
        `${clsPrefix}-dropdown-option-body__suffix`,
        siblingHasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`
      ] }, this.hasSubmenu ? h3(NIcon, null, {
        default: () => h3(ChevronRight_default, null)
      }) : null)
    ]), this.hasSubmenu ? h3(Binder_default, null, {
      default: () => [
        h3(Target_default, null, {
          default: () => h3("div", { class: `${clsPrefix}-dropdown-offset-container` }, h3(Follower_default, { show: this.mergedShowSubmenu, placement: this.placement, to: scrollable ? this.popoverBody || void 0 : void 0, teleportDisabled: !scrollable }, {
            default: () => {
              return h3("div", { class: `${clsPrefix}-dropdown-menu-wrapper` }, animated ? h3(Transition, { onBeforeEnter: this.handleSubmenuBeforeEnter, onAfterEnter: this.handleSubmenuAfterEnter, name: "fade-in-scale-up-transition", appear: true }, {
                default: () => submenuVNode
              }) : submenuVNode);
            }
          }))
        })
      ]
    }) : null);
    if (renderOption) {
      return renderOption({ node, option: rawNode });
    }
    return node;
  }
});

// node_modules/naive-ui/es/dropdown/src/DropdownGroupHeader.js
var DropdownGroupHeader_default = defineComponent({
  name: "DropdownGroupHeader",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    }
  },
  setup() {
    const {
      showIconRef,
      hasSubmenuRef
    } = inject(dropdownMenuInjectionKey);
    const { renderLabelRef, labelFieldRef, nodePropsRef, renderOptionRef } = inject(dropdownInjectionKey);
    return {
      labelField: labelFieldRef,
      showIcon: showIconRef,
      hasSubmenu: hasSubmenuRef,
      renderLabel: renderLabelRef,
      nodeProps: nodePropsRef,
      renderOption: renderOptionRef
    };
  },
  render() {
    var _a3;
    const { clsPrefix, hasSubmenu, showIcon, nodeProps, renderLabel, renderOption } = this;
    const { rawNode } = this.tmNode;
    const node = h3("div", Object.assign({ class: `${clsPrefix}-dropdown-option` }, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode)), h3("div", { class: `${clsPrefix}-dropdown-option-body ${clsPrefix}-dropdown-option-body--group` }, h3("div", { "data-dropdown-option": true, class: [
      `${clsPrefix}-dropdown-option-body__prefix`,
      showIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`
    ] }, render(rawNode.icon)), h3("div", { class: `${clsPrefix}-dropdown-option-body__label`, "data-dropdown-option": true }, renderLabel ? renderLabel(rawNode) : render((_a3 = rawNode.title) !== null && _a3 !== void 0 ? _a3 : rawNode[this.labelField])), h3("div", { class: [
      `${clsPrefix}-dropdown-option-body__suffix`,
      hasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`
    ], "data-dropdown-option": true })));
    if (renderOption) {
      return renderOption({ node, option: rawNode });
    }
    return node;
  }
});

// node_modules/naive-ui/es/dropdown/src/DropdownGroup.js
var DropdownGroup_default = defineComponent({
  name: "NDropdownGroup",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    },
    parentKey: {
      type: [String, Number],
      default: null
    }
  },
  render() {
    const { tmNode, parentKey, clsPrefix } = this;
    const { children: children2 } = tmNode;
    return h3(Fragment, null, h3(DropdownGroupHeader_default, { clsPrefix, tmNode, key: tmNode.key }), children2 === null || children2 === void 0 ? void 0 : children2.map((child) => {
      const { rawNode } = child;
      if (rawNode.show === false)
        return null;
      if (isDividerNode(rawNode)) {
        return h3(DropdownDivider_default, {
          clsPrefix,
          key: child.key
        });
      }
      if (child.isGroup) {
        warn2("dropdown", "`group` node is not allowed to be put in `group` node.");
        return null;
      }
      return h3(DropdownOption_default, { clsPrefix, tmNode: child, parentKey, key: child.key });
    }));
  }
});

// node_modules/naive-ui/es/dropdown/src/DropdownRenderOption.js
var DropdownRenderOption_default = defineComponent({
  name: "DropdownRenderOption",
  props: {
    tmNode: {
      type: Object,
      required: true
    }
  },
  render() {
    const { rawNode: { render: render14, props } } = this.tmNode;
    return h3("div", props, [render14 === null || render14 === void 0 ? void 0 : render14()]);
  }
});

// node_modules/naive-ui/es/dropdown/src/DropdownMenu.js
var DropdownMenu_default = defineComponent({
  name: "DropdownMenu",
  props: {
    scrollable: Boolean,
    showArrow: Boolean,
    arrowStyle: [String, Object],
    clsPrefix: {
      type: String,
      required: true
    },
    tmNodes: {
      type: Array,
      default: () => []
    },
    parentKey: {
      type: [String, Number],
      default: null
    }
  },
  setup(props) {
    const { renderIconRef, childrenFieldRef } = inject(dropdownInjectionKey);
    provide(dropdownMenuInjectionKey, {
      showIconRef: computed2(() => {
        const renderIcon = renderIconRef.value;
        return props.tmNodes.some((tmNode) => {
          var _a3;
          if (tmNode.isGroup) {
            return (_a3 = tmNode.children) === null || _a3 === void 0 ? void 0 : _a3.some(({ rawNode: rawChild }) => renderIcon ? renderIcon(rawChild) : rawChild.icon);
          }
          const { rawNode } = tmNode;
          return renderIcon ? renderIcon(rawNode) : rawNode.icon;
        });
      }),
      hasSubmenuRef: computed2(() => {
        const { value: childrenField } = childrenFieldRef;
        return props.tmNodes.some((tmNode) => {
          var _a3;
          if (tmNode.isGroup) {
            return (_a3 = tmNode.children) === null || _a3 === void 0 ? void 0 : _a3.some(({ rawNode: rawChild }) => isSubmenuNode(rawChild, childrenField));
          }
          const { rawNode } = tmNode;
          return isSubmenuNode(rawNode, childrenField);
        });
      })
    });
    const bodyRef = ref(null);
    provide(modalBodyInjectionKey, null);
    provide(drawerBodyInjectionKey, null);
    provide(popoverBodyInjectionKey, bodyRef);
    return {
      bodyRef
    };
  },
  render() {
    const { parentKey, clsPrefix, scrollable } = this;
    const menuOptionsNode = this.tmNodes.map((tmNode) => {
      const { rawNode } = tmNode;
      if (rawNode.show === false)
        return null;
      if (isRenderNode(rawNode)) {
        return h3(DropdownRenderOption_default, { tmNode, key: tmNode.key });
      }
      if (isDividerNode(rawNode)) {
        return h3(DropdownDivider_default, { clsPrefix, key: tmNode.key });
      }
      if (isGroupNode(rawNode)) {
        return h3(DropdownGroup_default, { clsPrefix, tmNode, parentKey, key: tmNode.key });
      }
      return h3(DropdownOption_default, { clsPrefix, tmNode, parentKey, key: tmNode.key, props: rawNode.props, scrollable });
    });
    return h3("div", { class: [
      `${clsPrefix}-dropdown-menu`,
      scrollable && `${clsPrefix}-dropdown-menu--scrollable`
    ], ref: "bodyRef" }, scrollable ? h3(XScrollbar, { contentClass: `${clsPrefix}-dropdown-menu__content` }, {
      default: () => menuOptionsNode
    }) : menuOptionsNode, this.showArrow ? renderArrow({
      clsPrefix,
      arrowStyle: this.arrowStyle
    }) : null);
  }
});

// node_modules/naive-ui/es/dropdown/src/styles/index.cssr.js
var index_cssr_default16 = cB("dropdown-menu", `
 transform-origin: var(--v-transform-origin);
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 position: relative;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [fadeInScaleUpTransition(), cB("dropdown-option", `
 position: relative;
 `, [c3("a", `
 text-decoration: none;
 color: inherit;
 outline: none;
 `, [c3("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("dropdown-option-body", `
 display: flex;
 cursor: pointer;
 position: relative;
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-font-size);
 color: var(--n-option-text-color);
 transition: color .3s var(--n-bezier);
 `, [c3("&::before", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 left: 4px;
 right: 4px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `), cNotM("disabled", [cM("pending", `
 color: var(--n-option-text-color-hover);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-hover);
 `), c3("&::before", "background-color: var(--n-option-color-hover);")]), cM("active", `
 color: var(--n-option-text-color-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-active);
 `), c3("&::before", "background-color: var(--n-option-color-active);")]), cM("child-active", `
 color: var(--n-option-text-color-child-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-child-active);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-option-opacity-disabled);
 `), cM("group", `
 font-size: calc(var(--n-font-size) - 1px);
 color: var(--n-group-header-text-color);
 `, [cE("prefix", `
 width: calc(var(--n-option-prefix-width) / 2);
 `, [cM("show-icon", `
 width: calc(var(--n-option-icon-prefix-width) / 2);
 `)])]), cE("prefix", `
 width: var(--n-option-prefix-width);
 display: flex;
 justify-content: center;
 align-items: center;
 color: var(--n-prefix-color);
 transition: color .3s var(--n-bezier);
 z-index: 1;
 `, [cM("show-icon", `
 width: var(--n-option-icon-prefix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cE("label", `
 white-space: nowrap;
 flex: 1;
 z-index: 1;
 `), cE("suffix", `
 box-sizing: border-box;
 flex-grow: 0;
 flex-shrink: 0;
 display: flex;
 justify-content: flex-end;
 align-items: center;
 min-width: var(--n-option-suffix-width);
 padding: 0 8px;
 transition: color .3s var(--n-bezier);
 color: var(--n-suffix-color);
 z-index: 1;
 `, [cM("has-submenu", `
 width: var(--n-option-icon-suffix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cB("dropdown-menu", "pointer-events: all;")]), cB("dropdown-offset-container", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: -4px;
 bottom: -4px;
 `)]), cB("dropdown-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 4px 0;
 `), cB("dropdown-menu-wrapper", `
 transform-origin: var(--v-transform-origin);
 width: fit-content;
 `), c3(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("scrollable", `
 padding: var(--n-padding);
 `), cM("scrollable", [cE("content", `
 padding: var(--n-padding);
 `)])]);

// node_modules/naive-ui/es/dropdown/src/Dropdown.js
var dropdownBaseProps = {
  animated: {
    type: Boolean,
    default: true
  },
  keyboard: {
    type: Boolean,
    default: true
  },
  size: {
    type: String,
    default: "medium"
  },
  inverted: Boolean,
  placement: {
    type: String,
    default: "bottom"
  },
  onSelect: [Function, Array],
  options: {
    type: Array,
    default: () => []
  },
  menuProps: Function,
  showArrow: Boolean,
  renderLabel: Function,
  renderIcon: Function,
  renderOption: Function,
  nodeProps: Function,
  labelField: {
    type: String,
    default: "label"
  },
  keyField: {
    type: String,
    default: "key"
  },
  childrenField: {
    type: String,
    default: "children"
  },
  value: [String, Number]
};
var popoverPropKeys = Object.keys(popoverBaseProps);
var dropdownProps = Object.assign(Object.assign(Object.assign({}, popoverBaseProps), dropdownBaseProps), use_theme_default.props);
var Dropdown_default = defineComponent({
  name: "Dropdown",
  inheritAttrs: false,
  props: dropdownProps,
  setup(props) {
    const uncontrolledShowRef = ref(false);
    const mergedShowRef = useMergedState(toRef(props, "show"), uncontrolledShowRef);
    const treemateRef = computed2(() => {
      const { keyField, childrenField } = props;
      return createTreeMate(props.options, {
        getKey(node) {
          return node[keyField];
        },
        getDisabled(node) {
          return node.disabled === true;
        },
        getIgnored(node) {
          return node.type === "divider" || node.type === "render";
        },
        getChildren(node) {
          return node[childrenField];
        }
      });
    });
    const tmNodesRef = computed2(() => {
      return treemateRef.value.treeNodes;
    });
    const hoverKeyRef = ref(null);
    const keyboardKeyRef = ref(null);
    const lastToggledSubmenuKeyRef = ref(null);
    const pendingKeyRef = computed2(() => {
      var _a3, _b2, _c;
      return (_c = (_b2 = (_a3 = hoverKeyRef.value) !== null && _a3 !== void 0 ? _a3 : keyboardKeyRef.value) !== null && _b2 !== void 0 ? _b2 : lastToggledSubmenuKeyRef.value) !== null && _c !== void 0 ? _c : null;
    });
    const pendingKeyPathRef = computed2(() => treemateRef.value.getPath(pendingKeyRef.value).keyPath);
    const activeKeyPathRef = computed2(() => treemateRef.value.getPath(props.value).keyPath);
    const keyboardEnabledRef = use_memo_default(() => {
      return props.keyboard && mergedShowRef.value;
    });
    useKeyboard({
      keydown: {
        ArrowUp: {
          prevent: true,
          handler: handleKeydownUp
        },
        ArrowRight: {
          prevent: true,
          handler: handleKeydownRight
        },
        ArrowDown: {
          prevent: true,
          handler: handleKeydownDown
        },
        ArrowLeft: {
          prevent: true,
          handler: handleKeydownLeft
        },
        Enter: {
          prevent: true,
          handler: handleKeydownEnter
        },
        Escape: handleKeydownEsc
      }
    }, keyboardEnabledRef);
    const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
    const themeRef = use_theme_default("Dropdown", "-dropdown", index_cssr_default16, light_default33, props, mergedClsPrefixRef);
    provide(dropdownInjectionKey, {
      labelFieldRef: toRef(props, "labelField"),
      childrenFieldRef: toRef(props, "childrenField"),
      renderLabelRef: toRef(props, "renderLabel"),
      renderIconRef: toRef(props, "renderIcon"),
      hoverKeyRef,
      keyboardKeyRef,
      lastToggledSubmenuKeyRef,
      pendingKeyPathRef,
      activeKeyPathRef,
      animatedRef: toRef(props, "animated"),
      mergedShowRef,
      nodePropsRef: toRef(props, "nodeProps"),
      renderOptionRef: toRef(props, "renderOption"),
      menuPropsRef: toRef(props, "menuProps"),
      doSelect,
      doUpdateShow
    });
    watch(mergedShowRef, (value) => {
      if (!props.animated && !value) {
        clearPendingState();
      }
    });
    function doSelect(key, node) {
      const { onSelect } = props;
      if (onSelect)
        call(onSelect, key, node);
    }
    function doUpdateShow(value) {
      const { "onUpdate:show": _onUpdateShow, onUpdateShow } = props;
      if (_onUpdateShow)
        call(_onUpdateShow, value);
      if (onUpdateShow)
        call(onUpdateShow, value);
      uncontrolledShowRef.value = value;
    }
    function clearPendingState() {
      hoverKeyRef.value = null;
      keyboardKeyRef.value = null;
      lastToggledSubmenuKeyRef.value = null;
    }
    function handleKeydownEsc() {
      doUpdateShow(false);
    }
    function handleKeydownLeft() {
      handleKeydown("left");
    }
    function handleKeydownRight() {
      handleKeydown("right");
    }
    function handleKeydownUp() {
      handleKeydown("up");
    }
    function handleKeydownDown() {
      handleKeydown("down");
    }
    function handleKeydownEnter() {
      const pendingNode = getPendingNode();
      if ((pendingNode === null || pendingNode === void 0 ? void 0 : pendingNode.isLeaf) && mergedShowRef.value) {
        doSelect(pendingNode.key, pendingNode.rawNode);
        doUpdateShow(false);
      }
    }
    function getPendingNode() {
      var _a3;
      const { value: treeMate } = treemateRef;
      const { value: pendingKey } = pendingKeyRef;
      if (!treeMate || pendingKey === null)
        return null;
      return (_a3 = treeMate.getNode(pendingKey)) !== null && _a3 !== void 0 ? _a3 : null;
    }
    function handleKeydown(direction) {
      const { value: pendingKey } = pendingKeyRef;
      const { value: { getFirstAvailableNode: getFirstAvailableNode2 } } = treemateRef;
      let nextKeyboardKey = null;
      if (pendingKey === null) {
        const firstNode = getFirstAvailableNode2();
        if (firstNode !== null) {
          nextKeyboardKey = firstNode.key;
        }
      } else {
        const currentNode = getPendingNode();
        if (currentNode) {
          let nextNode;
          switch (direction) {
            case "down":
              nextNode = currentNode.getNext();
              break;
            case "up":
              nextNode = currentNode.getPrev();
              break;
            case "right":
              nextNode = currentNode.getChild();
              break;
            case "left":
              nextNode = currentNode.getParent();
              break;
          }
          if (nextNode)
            nextKeyboardKey = nextNode.key;
        }
      }
      if (nextKeyboardKey !== null) {
        hoverKeyRef.value = null;
        keyboardKeyRef.value = nextKeyboardKey;
      }
    }
    const cssVarsRef = computed2(() => {
      const { size: size3, inverted } = props;
      const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut5 }, self: self79 } = themeRef.value;
      const { padding, dividerColor, borderRadius, optionOpacityDisabled, [createKey("optionIconSuffixWidth", size3)]: optionIconSuffixWidth, [createKey("optionSuffixWidth", size3)]: optionSuffixWidth, [createKey("optionIconPrefixWidth", size3)]: optionIconPrefixWidth, [createKey("optionPrefixWidth", size3)]: optionPrefixWidth, [createKey("fontSize", size3)]: fontSize2, [createKey("optionHeight", size3)]: optionHeight, [createKey("optionIconSize", size3)]: optionIconSize } = self79;
      const vars = {
        "--n-bezier": cubicBezierEaseInOut5,
        "--n-font-size": fontSize2,
        "--n-padding": padding,
        "--n-border-radius": borderRadius,
        "--n-option-height": optionHeight,
        "--n-option-prefix-width": optionPrefixWidth,
        "--n-option-icon-prefix-width": optionIconPrefixWidth,
        "--n-option-suffix-width": optionSuffixWidth,
        "--n-option-icon-suffix-width": optionIconSuffixWidth,
        "--n-option-icon-size": optionIconSize,
        "--n-divider-color": dividerColor,
        "--n-option-opacity-disabled": optionOpacityDisabled
      };
      if (inverted) {
        vars["--n-color"] = self79.colorInverted;
        vars["--n-option-color-hover"] = self79.optionColorHoverInverted;
        vars["--n-option-color-active"] = self79.optionColorActiveInverted;
        vars["--n-option-text-color"] = self79.optionTextColorInverted;
        vars["--n-option-text-color-hover"] = self79.optionTextColorHoverInverted;
        vars["--n-option-text-color-active"] = self79.optionTextColorActiveInverted;
        vars["--n-option-text-color-child-active"] = self79.optionTextColorChildActiveInverted;
        vars["--n-prefix-color"] = self79.prefixColorInverted;
        vars["--n-suffix-color"] = self79.suffixColorInverted;
        vars["--n-group-header-text-color"] = self79.groupHeaderTextColorInverted;
      } else {
        vars["--n-color"] = self79.color;
        vars["--n-option-color-hover"] = self79.optionColorHover;
        vars["--n-option-color-active"] = self79.optionColorActive;
        vars["--n-option-text-color"] = self79.optionTextColor;
        vars["--n-option-text-color-hover"] = self79.optionTextColorHover;
        vars["--n-option-text-color-active"] = self79.optionTextColorActive;
        vars["--n-option-text-color-child-active"] = self79.optionTextColorChildActive;
        vars["--n-prefix-color"] = self79.prefixColor;
        vars["--n-suffix-color"] = self79.suffixColor;
        vars["--n-group-header-text-color"] = self79.groupHeaderTextColor;
      }
      return vars;
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("dropdown", computed2(() => `${props.size[0]}${props.inverted ? "i" : ""}`), cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      mergedTheme: themeRef,
      tmNodes: tmNodesRef,
      mergedShow: mergedShowRef,
      handleAfterLeave: () => {
        if (!props.animated)
          return;
        clearPendingState();
      },
      doUpdateShow,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const renderPopoverBody = (className, ref2, style2, onMouseenter, onMouseleave) => {
      var _a3;
      const { mergedClsPrefix, menuProps } = this;
      (_a3 = this.onRender) === null || _a3 === void 0 ? void 0 : _a3.call(this);
      const menuNodeProps = (menuProps === null || menuProps === void 0 ? void 0 : menuProps(void 0, this.tmNodes.map((v) => v.rawNode))) || {};
      const dropdownProps2 = {
        ref: createRefSetter(ref2),
        class: [className, `${mergedClsPrefix}-dropdown`, this.themeClass],
        clsPrefix: mergedClsPrefix,
        tmNodes: this.tmNodes,
        style: [style2, this.cssVars],
        showArrow: this.showArrow,
        arrowStyle: this.arrowStyle,
        scrollable: this.scrollable,
        onMouseenter,
        onMouseleave
      };
      return h3(DropdownMenu_default, mergeProps(this.$attrs, dropdownProps2, menuNodeProps));
    };
    const { mergedTheme } = this;
    const popoverProps2 = {
      show: this.mergedShow,
      theme: mergedTheme.peers.Popover,
      themeOverrides: mergedTheme.peerOverrides.Popover,
      internalOnAfterLeave: this.handleAfterLeave,
      internalRenderBody: renderPopoverBody,
      onUpdateShow: this.doUpdateShow,
      "onUpdate:show": void 0
    };
    return h3(Popover_default, Object.assign({}, keep(this.$props, popoverPropKeys), popoverProps2), {
      trigger: () => {
        var _a3, _b2;
        return (_b2 = (_a3 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a3);
      }
    });
  }
});

// node_modules/naive-ui/es/time-picker/styles/_common.js
var common_default21 = {
  itemFontSize: "12px",
  itemHeight: "36px",
  itemWidth: "52px",
  panelActionPadding: "8px 0"
};

// node_modules/naive-ui/es/time-picker/styles/light.js
var self35 = (vars) => {
  const { popoverColor, textColor2, primaryColor, hoverColor, dividerColor, opacityDisabled, boxShadow2, borderRadius, iconColor, iconColorDisabled } = vars;
  return Object.assign(Object.assign({}, common_default21), {
    panelColor: popoverColor,
    panelBoxShadow: boxShadow2,
    panelDividerColor: dividerColor,
    itemTextColor: textColor2,
    itemTextColorActive: primaryColor,
    itemColorHover: hoverColor,
    itemOpacityDisabled: opacityDisabled,
    itemBorderRadius: borderRadius,
    borderRadius,
    iconColor,
    iconColorDisabled
  });
};
var timePickerLight = createTheme({
  name: "TimePicker",
  common: light_default,
  peers: {
    Scrollbar: light_default3,
    Button: light_default17,
    Input: light_default10
  },
  self: self35
});
var light_default36 = timePickerLight;

// node_modules/naive-ui/es/time-picker/styles/dark.js
var timePickerDark = {
  name: "TimePicker",
  common: dark_default,
  peers: {
    Scrollbar: dark_default3,
    Button: dark_default17,
    Input: dark_default10
  },
  self: self35
};
var dark_default36 = timePickerDark;

// node_modules/naive-ui/es/date-picker/styles/_common.js
var common_default22 = {
  itemSize: "24px",
  itemCellWidth: "38px",
  itemCellHeight: "32px",
  scrollItemWidth: "80px",
  scrollItemHeight: "40px",
  panelExtraFooterPadding: "8px 12px",
  panelActionPadding: "8px 12px",
  calendarTitlePadding: "0",
  calendarTitleHeight: "28px",
  arrowSize: "14px",
  panelHeaderPadding: "8px 12px",
  calendarDaysHeight: "32px",
  calendarTitleGridTempateColumns: "28px 28px 1fr 28px 28px",
  calendarLeftPaddingDate: "6px 12px 4px 12px",
  calendarLeftPaddingDatetime: "4px 12px",
  calendarLeftPaddingDaterange: "6px 12px 4px 12px",
  calendarLeftPaddingDatetimerange: "4px 12px",
  calendarLeftPaddingMonth: "0",
  calendarLeftPaddingYear: "0",
  calendarLeftPaddingQuarter: "0",
  calendarLeftPaddingMonthrange: "0",
  calendarLeftPaddingQuarterrange: "0",
  calendarLeftPaddingYearrange: "0",
  calendarRightPaddingDate: "6px 12px 4px 12px",
  calendarRightPaddingDatetime: "4px 12px",
  calendarRightPaddingDaterange: "6px 12px 4px 12px",
  calendarRightPaddingDatetimerange: "4px 12px",
  calendarRightPaddingMonth: "0",
  calendarRightPaddingYear: "0",
  calendarRightPaddingQuarter: "0",
  calendarRightPaddingMonthrange: "0",
  calendarRightPaddingQuarterrange: "0",
  calendarRightPaddingYearrange: "0"
};

// node_modules/naive-ui/es/date-picker/styles/light.js
var self36 = (vars) => {
  const { hoverColor, fontSize: fontSize2, textColor2, textColorDisabled, popoverColor, primaryColor, borderRadiusSmall, iconColor, iconColorDisabled, textColor1, dividerColor, boxShadow2, borderRadius, fontWeightStrong } = vars;
  return Object.assign(Object.assign({}, common_default22), {
    itemFontSize: fontSize2,
    calendarDaysFontSize: fontSize2,
    calendarTitleFontSize: fontSize2,
    itemTextColor: textColor2,
    itemTextColorDisabled: textColorDisabled,
    itemTextColorActive: popoverColor,
    itemTextColorCurrent: primaryColor,
    itemColorIncluded: changeColor(primaryColor, { alpha: 0.1 }),
    itemColorHover: hoverColor,
    itemColorDisabled: hoverColor,
    itemColorActive: primaryColor,
    itemBorderRadius: borderRadiusSmall,
    panelColor: popoverColor,
    panelTextColor: textColor2,
    arrowColor: iconColor,
    calendarTitleTextColor: textColor1,
    calendarTitleColorHover: hoverColor,
    calendarDaysTextColor: textColor2,
    panelHeaderDividerColor: dividerColor,
    calendarDaysDividerColor: dividerColor,
    calendarDividerColor: dividerColor,
    panelActionDividerColor: dividerColor,
    panelBoxShadow: boxShadow2,
    panelBorderRadius: borderRadius,
    calendarTitleFontWeight: fontWeightStrong,
    scrollItemBorderRadius: borderRadius,
    iconColor,
    iconColorDisabled
  });
};
var datePickerLight = createTheme({
  name: "DatePicker",
  common: light_default,
  peers: {
    Input: light_default10,
    Button: light_default17,
    TimePicker: light_default36,
    Scrollbar: light_default3
  },
  self: self36
});
var light_default37 = datePickerLight;

// node_modules/naive-ui/es/date-picker/styles/dark.js
var datePickerDark = {
  name: "DatePicker",
  common: dark_default,
  peers: {
    Input: dark_default10,
    Button: dark_default17,
    TimePicker: dark_default36,
    Scrollbar: dark_default3
  },
  self(vars) {
    const { popoverColor, hoverColor, primaryColor } = vars;
    const commonSelf = self36(vars);
    commonSelf.itemColorDisabled = composite(popoverColor, hoverColor);
    commonSelf.itemColorIncluded = changeColor(primaryColor, { alpha: 0.15 });
    commonSelf.itemColorHover = composite(popoverColor, hoverColor);
    return commonSelf;
  }
};
var dark_default37 = datePickerDark;

// node_modules/naive-ui/es/descriptions/styles/_common.js
var common_default23 = {
  thPaddingBorderedSmall: "8px 12px",
  thPaddingBorderedMedium: "12px 16px",
  thPaddingBorderedLarge: "16px 24px",
  thPaddingSmall: "0",
  thPaddingMedium: "0",
  thPaddingLarge: "0",
  tdPaddingBorderedSmall: "8px 12px",
  tdPaddingBorderedMedium: "12px 16px",
  tdPaddingBorderedLarge: "16px 24px",
  tdPaddingSmall: "0 0 8px 0",
  tdPaddingMedium: "0 0 12px 0",
  tdPaddingLarge: "0 0 16px 0"
};

// node_modules/naive-ui/es/descriptions/styles/light.js
var self37 = (vars) => {
  const { tableHeaderColor, textColor2, textColor1, cardColor, modalColor, popoverColor, dividerColor, borderRadius, fontWeightStrong, lineHeight: lineHeight3, fontSizeSmall, fontSizeMedium, fontSizeLarge } = vars;
  return Object.assign(Object.assign({}, common_default23), {
    lineHeight: lineHeight3,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    titleTextColor: textColor1,
    thColor: composite(cardColor, tableHeaderColor),
    thColorModal: composite(modalColor, tableHeaderColor),
    thColorPopover: composite(popoverColor, tableHeaderColor),
    thTextColor: textColor1,
    thFontWeight: fontWeightStrong,
    tdTextColor: textColor2,
    tdColor: cardColor,
    tdColorModal: modalColor,
    tdColorPopover: popoverColor,
    borderColor: composite(cardColor, dividerColor),
    borderColorModal: composite(modalColor, dividerColor),
    borderColorPopover: composite(popoverColor, dividerColor),
    borderRadius
  });
};
var descriptionsLight = {
  name: "Descriptions",
  common: light_default,
  self: self37
};
var light_default38 = descriptionsLight;

// node_modules/naive-ui/es/descriptions/styles/dark.js
var descriptionsDark = {
  name: "Descriptions",
  common: dark_default,
  self: self37
};
var dark_default38 = descriptionsDark;

// node_modules/naive-ui/es/dialog/styles/_common.js
var common_default24 = {
  titleFontSize: "18px",
  padding: "16px 28px 20px 28px",
  iconSize: "28px",
  actionSpace: "12px",
  contentMargin: "8px 0 16px 0",
  iconMargin: "0 4px 0 0",
  iconMarginIconTop: "4px 0 8px 0",
  closeSize: "22px",
  closeIconSize: "18px",
  closeMargin: "20px 26px 0 0",
  closeMarginIconTop: "10px 16px 0 0"
};

// node_modules/naive-ui/es/dialog/styles/light.js
var self38 = (vars) => {
  const { textColor1, textColor2, modalColor, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, infoColor, successColor, warningColor, errorColor, primaryColor, dividerColor, borderRadius, fontWeightStrong, lineHeight: lineHeight3, fontSize: fontSize2 } = vars;
  return Object.assign(Object.assign({}, common_default24), {
    fontSize: fontSize2,
    lineHeight: lineHeight3,
    border: `1px solid ${dividerColor}`,
    titleTextColor: textColor1,
    textColor: textColor2,
    color: modalColor,
    closeColorHover,
    closeColorPressed,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    closeBorderRadius: borderRadius,
    iconColor: primaryColor,
    iconColorInfo: infoColor,
    iconColorSuccess: successColor,
    iconColorWarning: warningColor,
    iconColorError: errorColor,
    borderRadius,
    titleFontWeight: fontWeightStrong
  });
};
var dialogLight = createTheme({
  name: "Dialog",
  common: light_default,
  peers: {
    Button: light_default17
  },
  self: self38
});
var light_default39 = dialogLight;

// node_modules/naive-ui/es/dialog/styles/dark.js
var dialogDark = {
  name: "Dialog",
  common: dark_default,
  peers: {
    Button: dark_default17
  },
  self: self38
};
var dark_default39 = dialogDark;

// node_modules/naive-ui/es/modal/styles/light.js
var self39 = (vars) => {
  const { modalColor, textColor2, boxShadow3 } = vars;
  return {
    color: modalColor,
    textColor: textColor2,
    boxShadow: boxShadow3
  };
};
var modalLight = createTheme({
  name: "Modal",
  common: light_default,
  peers: {
    Scrollbar: light_default3,
    Dialog: light_default39,
    Card: light_default20
  },
  self: self39
});
var light_default40 = modalLight;

// node_modules/naive-ui/es/modal/styles/dark.js
var modalDark = {
  name: "Modal",
  common: dark_default,
  peers: {
    Scrollbar: dark_default3,
    Dialog: dark_default39,
    Card: dark_default20
  },
  self: self39
};
var dark_default40 = modalDark;

// node_modules/naive-ui/es/divider/styles/light.js
var self40 = (vars) => {
  const { textColor1, dividerColor, fontWeightStrong } = vars;
  return {
    textColor: textColor1,
    color: dividerColor,
    fontWeight: fontWeightStrong
  };
};
var dividerLight = {
  name: "Divider",
  common: light_default,
  self: self40
};
var light_default41 = dividerLight;

// node_modules/naive-ui/es/divider/styles/dark.js
var dividerDark = {
  name: "Divider",
  common: dark_default,
  self: self40
};
var dark_default41 = dividerDark;

// node_modules/naive-ui/es/drawer/styles/light.js
var self41 = (vars) => {
  const { modalColor, textColor1, textColor2, boxShadow3, lineHeight: lineHeight3, fontWeightStrong, dividerColor, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, borderRadius, primaryColorHover } = vars;
  return {
    bodyPadding: "16px 24px",
    headerPadding: "16px 24px",
    footerPadding: "16px 24px",
    color: modalColor,
    textColor: textColor2,
    titleTextColor: textColor1,
    titleFontSize: "18px",
    titleFontWeight: fontWeightStrong,
    boxShadow: boxShadow3,
    lineHeight: lineHeight3,
    headerBorderBottom: `1px solid ${dividerColor}`,
    footerBorderTop: `1px solid ${dividerColor}`,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    closeSize: "22px",
    closeIconSize: "18px",
    closeColorHover,
    closeColorPressed,
    closeBorderRadius: borderRadius,
    resizableTriggerColorHover: primaryColorHover
  };
};
var drawerLight = createTheme({
  name: "Drawer",
  common: light_default,
  peers: {
    Scrollbar: light_default3
  },
  self: self41
});
var light_default42 = drawerLight;

// node_modules/naive-ui/es/drawer/styles/dark.js
var drawerDark = {
  name: "Drawer",
  common: dark_default,
  peers: {
    Scrollbar: dark_default3
  },
  self: self41
};
var dark_default42 = drawerDark;

// node_modules/naive-ui/es/dynamic-input/styles/_common.js
var common_default25 = {
  actionMargin: "0 0 0 20px",
  actionMarginRtl: "0 20px 0 0"
};

// node_modules/naive-ui/es/dynamic-input/styles/dark.js
var dynamicInputDark = {
  name: "DynamicInput",
  common: dark_default,
  peers: {
    Input: dark_default10,
    Button: dark_default17
  },
  self() {
    return common_default25;
  }
};
var dark_default43 = dynamicInputDark;

// node_modules/naive-ui/es/dynamic-input/styles/light.js
var self42 = () => {
  return common_default25;
};
var dynamicInputLight = createTheme({
  name: "DynamicInput",
  common: light_default,
  peers: {
    Input: light_default10,
    Button: light_default17
  },
  self: self42
});
var light_default43 = dynamicInputLight;

// node_modules/naive-ui/es/space/styles/_common.js
var common_default26 = {
  gapSmall: "4px 8px",
  gapMedium: "8px 12px",
  gapLarge: "12px 16px"
};

// node_modules/naive-ui/es/space/styles/dark.js
var spaceDark = {
  name: "Space",
  self() {
    return common_default26;
  }
};
var dark_default44 = spaceDark;

// node_modules/naive-ui/es/space/styles/light.js
var self43 = () => {
  return common_default26;
};
var spaceLight = {
  name: "Space",
  self: self43
};
var light_default44 = spaceLight;

// node_modules/naive-ui/es/space/src/utils.js
var supportFlexGap;
var ensureSupportFlexGap = () => {
  if (!isBrowser)
    return true;
  if (supportFlexGap === void 0) {
    const flex = document.createElement("div");
    flex.style.display = "flex";
    flex.style.flexDirection = "column";
    flex.style.rowGap = "1px";
    flex.appendChild(document.createElement("div"));
    flex.appendChild(document.createElement("div"));
    document.body.appendChild(flex);
    const isSupported = flex.scrollHeight === 1;
    document.body.removeChild(flex);
    return supportFlexGap = isSupported;
  }
  return supportFlexGap;
};

// node_modules/naive-ui/es/space/src/Space.js
var spaceProps = Object.assign(Object.assign({}, use_theme_default.props), {
  align: String,
  justify: {
    type: String,
    default: "start"
  },
  inline: Boolean,
  vertical: Boolean,
  size: {
    type: [String, Number, Array],
    default: "medium"
  },
  wrapItem: {
    type: Boolean,
    default: true
  },
  itemStyle: [String, Object],
  wrap: {
    type: Boolean,
    default: true
  },
  internalUseGap: {
    type: Boolean,
    default: void 0
  }
});
var Space_default = defineComponent({
  name: "Space",
  props: spaceProps,
  setup(props) {
    const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
    const themeRef = use_theme_default("Space", "-space", void 0, light_default44, props, mergedClsPrefixRef);
    const rtlEnabledRef = useRtl("Space", mergedRtlRef, mergedClsPrefixRef);
    return {
      useGap: ensureSupportFlexGap(),
      rtlEnabled: rtlEnabledRef,
      mergedClsPrefix: mergedClsPrefixRef,
      margin: computed2(() => {
        const { size: size3 } = props;
        if (Array.isArray(size3)) {
          return {
            horizontal: size3[0],
            vertical: size3[1]
          };
        }
        if (typeof size3 === "number") {
          return {
            horizontal: size3,
            vertical: size3
          };
        }
        const { self: { [createKey("gap", size3)]: gap } } = themeRef.value;
        const { row, col } = getGap(gap);
        return {
          horizontal: depx(col),
          vertical: depx(row)
        };
      })
    };
  },
  render() {
    const { vertical, align, inline, justify, itemStyle, margin, wrap, mergedClsPrefix, rtlEnabled, useGap, wrapItem, internalUseGap } = this;
    const children2 = flatten(getSlot(this));
    if (!children2.length)
      return null;
    const horizontalMargin = `${margin.horizontal}px`;
    const semiHorizontalMargin = `${margin.horizontal / 2}px`;
    const verticalMargin = `${margin.vertical}px`;
    const semiVerticalMargin = `${margin.vertical / 2}px`;
    const lastIndex = children2.length - 1;
    const isJustifySpace = justify.startsWith("space-");
    return h3("div", { role: "none", class: [
      `${mergedClsPrefix}-space`,
      rtlEnabled && `${mergedClsPrefix}-space--rtl`
    ], style: {
      display: inline ? "inline-flex" : "flex",
      flexDirection: vertical ? "column" : "row",
      justifyContent: ["start", "end"].includes(justify) ? "flex-" + justify : justify,
      flexWrap: !wrap || vertical ? "nowrap" : "wrap",
      marginTop: useGap || vertical ? "" : `-${semiVerticalMargin}`,
      marginBottom: useGap || vertical ? "" : `-${semiVerticalMargin}`,
      alignItems: align,
      gap: useGap ? `${margin.vertical}px ${margin.horizontal}px` : ""
    } }, !wrapItem && (useGap || internalUseGap) ? children2 : children2.map((child, index2) => h3("div", { role: "none", style: [
      itemStyle,
      {
        maxWidth: "100%"
      },
      useGap ? "" : vertical ? {
        marginBottom: index2 !== lastIndex ? verticalMargin : ""
      } : rtlEnabled ? {
        marginLeft: isJustifySpace ? justify === "space-between" && index2 === lastIndex ? "" : semiHorizontalMargin : index2 !== lastIndex ? horizontalMargin : "",
        marginRight: isJustifySpace ? justify === "space-between" && index2 === 0 ? "" : semiHorizontalMargin : "",
        paddingTop: semiVerticalMargin,
        paddingBottom: semiVerticalMargin
      } : {
        marginRight: isJustifySpace ? justify === "space-between" && index2 === lastIndex ? "" : semiHorizontalMargin : index2 !== lastIndex ? horizontalMargin : "",
        marginLeft: isJustifySpace ? justify === "space-between" && index2 === 0 ? "" : semiHorizontalMargin : "",
        paddingTop: semiVerticalMargin,
        paddingBottom: semiVerticalMargin
      }
    ] }, child)));
  }
});

// node_modules/naive-ui/es/dynamic-tags/styles/dark.js
var dynamicTagsDark = {
  name: "DynamicTags",
  common: dark_default,
  peers: {
    Input: dark_default10,
    Button: dark_default17,
    Tag: dark_default6,
    Space: dark_default44
  },
  self() {
    return {
      inputWidth: "64px"
    };
  }
};
var dark_default45 = dynamicTagsDark;

// node_modules/naive-ui/es/dynamic-tags/styles/light.js
var dynamicTagsLight = createTheme({
  name: "DynamicTags",
  common: light_default,
  peers: {
    Input: light_default10,
    Button: light_default17,
    Tag: light_default6,
    Space: light_default44
  },
  self() {
    return {
      inputWidth: "64px"
    };
  }
});
var light_default45 = dynamicTagsLight;

// node_modules/naive-ui/es/element/styles/dark.js
var elementDark = {
  name: "Element",
  common: dark_default
};
var dark_default46 = elementDark;

// node_modules/naive-ui/es/element/styles/light.js
var elementLight = {
  name: "Element",
  common: light_default
};
var light_default46 = elementLight;

// node_modules/naive-ui/es/form/styles/_common.js
var common_default27 = {
  feedbackPadding: "4px 0 0 2px",
  feedbackHeightSmall: "24px",
  feedbackHeightMedium: "24px",
  feedbackHeightLarge: "26px",
  feedbackFontSizeSmall: "13px",
  feedbackFontSizeMedium: "14px",
  feedbackFontSizeLarge: "14px",
  labelFontSizeLeftSmall: "14px",
  labelFontSizeLeftMedium: "14px",
  labelFontSizeLeftLarge: "15px",
  labelFontSizeTopSmall: "13px",
  labelFontSizeTopMedium: "14px",
  labelFontSizeTopLarge: "14px",
  labelHeightSmall: "24px",
  labelHeightMedium: "26px",
  labelHeightLarge: "28px",
  labelPaddingVertical: "0 0 6px 2px",
  labelPaddingHorizontal: "0 12px 0 0",
  labelTextAlignVertical: "left",
  labelTextAlignHorizontal: "right",
  labelFontWeight: "400"
};

// node_modules/naive-ui/es/form/styles/light.js
var self44 = (vars) => {
  const { heightSmall, heightMedium, heightLarge, textColor1, errorColor, warningColor, lineHeight: lineHeight3, textColor3 } = vars;
  return Object.assign(Object.assign({}, common_default27), { blankHeightSmall: heightSmall, blankHeightMedium: heightMedium, blankHeightLarge: heightLarge, lineHeight: lineHeight3, labelTextColor: textColor1, asteriskColor: errorColor, feedbackTextColorError: errorColor, feedbackTextColorWarning: warningColor, feedbackTextColor: textColor3 });
};
var formLight = {
  name: "Form",
  common: light_default,
  self: self44
};
var light_default47 = formLight;

// node_modules/naive-ui/es/form/styles/dark.js
var formItemDark = {
  name: "Form",
  common: dark_default,
  self: self44
};
var dark_default47 = formItemDark;

// node_modules/naive-ui/es/grid/src/config.js
var defaultSpan = 1;
var gridInjectionKey = createInjectionKey("n-grid");

// node_modules/naive-ui/es/grid/src/GridItem.js
var defaultSpan2 = 1;
var gridItemProps = {
  span: {
    type: [Number, String],
    default: defaultSpan2
  },
  offset: {
    type: [Number, String],
    default: 0
  },
  suffix: Boolean,
  privateOffset: Number,
  privateSpan: Number,
  privateColStart: Number,
  privateShow: {
    type: Boolean,
    default: true
  }
};
var gridItemPropKeys = keysOf(gridItemProps);
var GridItem_default = defineComponent({
  __GRID_ITEM__: true,
  name: "GridItem",
  alias: ["Gi"],
  props: gridItemProps,
  setup() {
    const {
      isSsrRef,
      xGapRef,
      itemStyleRef,
      overflowRef,
      layoutShiftDisabledRef
    } = inject(gridInjectionKey);
    const self79 = getCurrentInstance();
    return {
      overflow: overflowRef,
      itemStyle: itemStyleRef,
      layoutShiftDisabled: layoutShiftDisabledRef,
      mergedXGap: computed2(() => {
        return pxfy(xGapRef.value || 0);
      }),
      deriveStyle: () => {
        void isSsrRef.value;
        const {
          privateSpan = defaultSpan2,
          privateShow = true,
          privateColStart = void 0,
          privateOffset = 0
        } = self79.vnode.props;
        const { value: xGap } = xGapRef;
        const mergedXGap = pxfy(xGap || 0);
        return {
          display: !privateShow ? "none" : "",
          gridColumn: `${privateColStart !== null && privateColStart !== void 0 ? privateColStart : `span ${privateSpan}`} / span ${privateSpan}`,
          marginLeft: privateOffset ? `calc((100% - (${privateSpan} - 1) * ${mergedXGap}) / ${privateSpan} * ${privateOffset} + ${mergedXGap} * ${privateOffset})` : ""
        };
      }
    };
  },
  render() {
    var _a3, _b2;
    if (this.layoutShiftDisabled) {
      const { span, offset, mergedXGap } = this;
      return h3("div", { style: {
        gridColumn: `span ${span} / span ${span}`,
        marginLeft: offset ? `calc((100% - (${span} - 1) * ${mergedXGap}) / ${span} * ${offset} + ${mergedXGap} * ${offset})` : ""
      } }, this.$slots);
    }
    return h3("div", { style: [this.itemStyle, this.deriveStyle()] }, (_b2 = (_a3 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, { overflow: this.overflow }));
  }
});

// node_modules/naive-ui/es/gradient-text/styles/dark.js
var gradientTextDark = {
  name: "GradientText",
  common: dark_default,
  self(vars) {
    const { primaryColor, successColor, warningColor, errorColor, infoColor, primaryColorSuppl, successColorSuppl, warningColorSuppl, errorColorSuppl, infoColorSuppl, fontWeightStrong } = vars;
    return {
      fontWeight: fontWeightStrong,
      rotate: "252deg",
      colorStartPrimary: primaryColor,
      colorEndPrimary: primaryColorSuppl,
      colorStartInfo: infoColor,
      colorEndInfo: infoColorSuppl,
      colorStartWarning: warningColor,
      colorEndWarning: warningColorSuppl,
      colorStartError: errorColor,
      colorEndError: errorColorSuppl,
      colorStartSuccess: successColor,
      colorEndSuccess: successColorSuppl
    };
  }
};
var dark_default48 = gradientTextDark;

// node_modules/naive-ui/es/gradient-text/styles/light.js
var self45 = (vars) => {
  const { primaryColor, successColor, warningColor, errorColor, infoColor, fontWeightStrong } = vars;
  return {
    fontWeight: fontWeightStrong,
    rotate: "252deg",
    colorStartPrimary: changeColor(primaryColor, { alpha: 0.6 }),
    colorEndPrimary: primaryColor,
    colorStartInfo: changeColor(infoColor, { alpha: 0.6 }),
    colorEndInfo: infoColor,
    colorStartWarning: changeColor(warningColor, { alpha: 0.6 }),
    colorEndWarning: warningColor,
    colorStartError: changeColor(errorColor, { alpha: 0.6 }),
    colorEndError: errorColor,
    colorStartSuccess: changeColor(successColor, { alpha: 0.6 }),
    colorEndSuccess: successColor
  };
};
var gradientTextLight = {
  name: "GradientText",
  common: light_default,
  self: self45
};
var light_default48 = gradientTextLight;

// node_modules/naive-ui/es/config-provider/src/config.js
var defaultBreakpoints = {
  xs: 0,
  s: 640,
  m: 1024,
  l: 1280,
  xl: 1536,
  xxl: 1920
};

// node_modules/naive-ui/es/grid/src/Grid.js
var defaultCols = 24;
var SSR_ATTR_NAME = "__ssr__";
var gridProps = {
  layoutShiftDisabled: Boolean,
  responsive: {
    type: [String, Boolean],
    default: "self"
  },
  cols: {
    type: [Number, String],
    default: defaultCols
  },
  itemResponsive: Boolean,
  collapsed: Boolean,
  collapsedRows: {
    type: Number,
    default: 1
  },
  itemStyle: [Object, String],
  xGap: {
    type: [Number, String],
    default: 0
  },
  yGap: {
    type: [Number, String],
    default: 0
  }
};
var Grid_default = defineComponent({
  name: "Grid",
  inheritAttrs: false,
  props: gridProps,
  setup(props) {
    const { mergedClsPrefixRef, mergedBreakpointsRef } = useConfig(props);
    const numRegex = /^\d+$/;
    const widthRef = ref(void 0);
    const breakpointsRef = use_breakpoints_default((mergedBreakpointsRef === null || mergedBreakpointsRef === void 0 ? void 0 : mergedBreakpointsRef.value) || defaultBreakpoints);
    const isResponsiveRef = use_memo_default(() => {
      if (props.itemResponsive)
        return true;
      if (!numRegex.test(props.cols.toString()))
        return true;
      if (!numRegex.test(props.xGap.toString()))
        return true;
      if (!numRegex.test(props.yGap.toString()))
        return true;
      return false;
    });
    const responsiveQueryRef = computed2(() => {
      if (!isResponsiveRef.value)
        return void 0;
      return props.responsive === "self" ? widthRef.value : breakpointsRef.value;
    });
    const responsiveColsRef = use_memo_default(() => {
      var _a3;
      return (_a3 = Number(parseResponsivePropValue(props.cols.toString(), responsiveQueryRef.value))) !== null && _a3 !== void 0 ? _a3 : defaultCols;
    });
    const responsiveXGapRef = use_memo_default(() => parseResponsivePropValue(props.xGap.toString(), responsiveQueryRef.value));
    const responsiveYGapRef = use_memo_default(() => parseResponsivePropValue(props.yGap.toString(), responsiveQueryRef.value));
    const handleResize = (entry) => {
      widthRef.value = entry.contentRect.width;
    };
    const handleResizeRaf = (entry) => {
      beforeNextFrameOnce(handleResize, entry);
    };
    const overflowRef = ref(false);
    const handleResizeRef = computed2(() => {
      if (props.responsive === "self") {
        return handleResizeRaf;
      }
      return void 0;
    });
    const isSsrRef = ref(false);
    const contentElRef = ref();
    onMounted(() => {
      const { value: contentEl } = contentElRef;
      if (contentEl) {
        if (contentEl.hasAttribute(SSR_ATTR_NAME)) {
          contentEl.removeAttribute(SSR_ATTR_NAME);
          isSsrRef.value = true;
        }
      }
    });
    provide(gridInjectionKey, {
      layoutShiftDisabledRef: toRef(props, "layoutShiftDisabled"),
      isSsrRef,
      itemStyleRef: toRef(props, "itemStyle"),
      xGapRef: responsiveXGapRef,
      overflowRef
    });
    return {
      isSsr: !isBrowser,
      contentEl: contentElRef,
      mergedClsPrefix: mergedClsPrefixRef,
      style: computed2(() => {
        if (props.layoutShiftDisabled) {
          return {
            width: "100%",
            display: "grid",
            gridTemplateColumns: `repeat(${props.cols}, minmax(0, 1fr))`,
            columnGap: pxfy(props.xGap),
            rowGap: pxfy(props.yGap)
          };
        }
        return {
          width: "100%",
          display: "grid",
          gridTemplateColumns: `repeat(${responsiveColsRef.value}, minmax(0, 1fr))`,
          columnGap: pxfy(responsiveXGapRef.value),
          rowGap: pxfy(responsiveYGapRef.value)
        };
      }),
      isResponsive: isResponsiveRef,
      responsiveQuery: responsiveQueryRef,
      responsiveCols: responsiveColsRef,
      handleResize: handleResizeRef,
      overflow: overflowRef
    };
  },
  render() {
    if (this.layoutShiftDisabled) {
      return h3("div", mergeProps({
        ref: "contentEl",
        class: `${this.mergedClsPrefix}-grid`,
        style: this.style
      }, this.$attrs), this.$slots);
    }
    const renderContent = () => {
      var _a3, _b2, _c, _d, _e, _f, _g;
      this.overflow = false;
      const rawChildren = flatten(getSlot(this));
      const childrenAndRawSpan = [];
      const { collapsed, collapsedRows, responsiveCols, responsiveQuery } = this;
      rawChildren.forEach((child) => {
        var _a4, _b3, _c2, _d2;
        if (((_a4 = child === null || child === void 0 ? void 0 : child.type) === null || _a4 === void 0 ? void 0 : _a4.__GRID_ITEM__) !== true)
          return;
        if (isNodeVShowFalse(child)) {
          const clonedNode = cloneVNode(child);
          if (clonedNode.props) {
            clonedNode.props.privateShow = false;
          } else {
            clonedNode.props = { privateShow: false };
          }
          childrenAndRawSpan.push({
            child: clonedNode,
            rawChildSpan: 0
          });
          return;
        }
        child.dirs = ((_b3 = child.dirs) === null || _b3 === void 0 ? void 0 : _b3.filter(({ dir }) => dir !== vShow)) || null;
        const clonedChild = cloneVNode(child);
        const rawChildSpan = Number((_d2 = parseResponsivePropValue((_c2 = clonedChild.props) === null || _c2 === void 0 ? void 0 : _c2.span, responsiveQuery)) !== null && _d2 !== void 0 ? _d2 : defaultSpan);
        if (rawChildSpan === 0)
          return;
        childrenAndRawSpan.push({
          child: clonedChild,
          rawChildSpan
        });
      });
      let suffixSpan = 0;
      const maybeSuffixNode = (_a3 = childrenAndRawSpan[childrenAndRawSpan.length - 1]) === null || _a3 === void 0 ? void 0 : _a3.child;
      if (maybeSuffixNode === null || maybeSuffixNode === void 0 ? void 0 : maybeSuffixNode.props) {
        const suffixPropValue = (_b2 = maybeSuffixNode.props) === null || _b2 === void 0 ? void 0 : _b2.suffix;
        if (suffixPropValue !== void 0 && suffixPropValue !== false) {
          suffixSpan = (_d = (_c = maybeSuffixNode.props) === null || _c === void 0 ? void 0 : _c.span) !== null && _d !== void 0 ? _d : defaultSpan;
          maybeSuffixNode.props.privateSpan = suffixSpan;
          maybeSuffixNode.props.privateColStart = responsiveCols + 1 - suffixSpan;
          maybeSuffixNode.props.privateShow = (_e = maybeSuffixNode.props.privateShow) !== null && _e !== void 0 ? _e : true;
        }
      }
      let spanCounter = 0;
      let done = false;
      for (const { child, rawChildSpan } of childrenAndRawSpan) {
        if (done) {
          this.overflow = true;
        }
        if (!done) {
          const childOffset = Number((_g = parseResponsivePropValue((_f = child.props) === null || _f === void 0 ? void 0 : _f.offset, responsiveQuery)) !== null && _g !== void 0 ? _g : 0);
          const childSpan = Math.min(rawChildSpan + childOffset, responsiveCols);
          if (!child.props) {
            child.props = {
              privateSpan: childSpan,
              privateOffset: childOffset
            };
          } else {
            child.props.privateSpan = childSpan;
            child.props.privateOffset = childOffset;
          }
          if (collapsed) {
            const remainder = spanCounter % responsiveCols;
            if (childSpan + remainder > responsiveCols) {
              spanCounter += responsiveCols - remainder;
            }
            if (childSpan + spanCounter + suffixSpan > collapsedRows * responsiveCols) {
              done = true;
            } else {
              spanCounter += childSpan;
            }
          }
        }
        if (done) {
          if (child.props) {
            if (child.props.privateShow !== true) {
              child.props.privateShow = false;
            }
          } else {
            child.props = {
              privateShow: false
            };
          }
        }
      }
      return h3("div", mergeProps({
        ref: "contentEl",
        class: `${this.mergedClsPrefix}-grid`,
        style: this.style,
        [SSR_ATTR_NAME]: this.isSsr || void 0
      }, this.$attrs), childrenAndRawSpan.map(({ child }) => child));
    };
    return this.isResponsive && this.responsive === "self" ? h3(VResizeObserver_default, { onResize: this.handleResize }, {
      default: renderContent
    }) : renderContent();
  }
});

// node_modules/naive-ui/es/icon-wrapper/styles/light.js
var self46 = (vars) => {
  const { primaryColor, baseColor } = vars;
  return {
    color: primaryColor,
    iconColor: baseColor
  };
};
var iconWrapperLight = {
  name: "IconWrapper",
  common: light_default,
  self: self46
};
var light_default49 = iconWrapperLight;

// node_modules/naive-ui/es/icon-wrapper/styles/dark.js
var iconDark2 = {
  name: "IconWrapper",
  common: dark_default,
  self: self46
};
var dark_default49 = iconDark2;

// node_modules/naive-ui/es/image/styles/light.js
function self47() {
  return {
    toolbarIconColor: "rgba(255, 255, 255, .9)",
    toolbarColor: "rgba(0, 0, 0, .35)",
    toolbarBoxShadow: "none",
    toolbarBorderRadius: "24px"
  };
}
var imageLight = createTheme({
  name: "Image",
  common: light_default,
  peers: {
    Tooltip: light_default30
  },
  self: self47
});

// node_modules/naive-ui/es/notification/styles/_common.js
var common_default28 = {
  closeMargin: "16px 12px",
  closeSize: "20px",
  closeIconSize: "16px",
  width: "365px",
  padding: "16px",
  titleFontSize: "16px",
  metaFontSize: "12px",
  descriptionFontSize: "12px"
};

// node_modules/naive-ui/es/notification/styles/light.js
var self48 = (vars) => {
  const { textColor2, successColor, infoColor, warningColor, errorColor, popoverColor, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, textColor1, textColor3, borderRadius, fontWeightStrong, boxShadow2, lineHeight: lineHeight3, fontSize: fontSize2 } = vars;
  return Object.assign(Object.assign({}, common_default28), {
    borderRadius,
    lineHeight: lineHeight3,
    fontSize: fontSize2,
    headerFontWeight: fontWeightStrong,
    iconColor: textColor2,
    iconColorSuccess: successColor,
    iconColorInfo: infoColor,
    iconColorWarning: warningColor,
    iconColorError: errorColor,
    color: popoverColor,
    textColor: textColor2,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    closeBorderRadius: borderRadius,
    closeColorHover,
    closeColorPressed,
    headerTextColor: textColor1,
    descriptionTextColor: textColor3,
    actionTextColor: textColor2,
    boxShadow: boxShadow2
  });
};
var notificationLight = createTheme({
  name: "Notification",
  common: light_default,
  peers: {
    Scrollbar: light_default3
  },
  self: self48
});
var light_default50 = notificationLight;

// node_modules/naive-ui/es/notification/styles/dark.js
var notificationDark = {
  name: "Notification",
  common: dark_default,
  peers: {
    Scrollbar: dark_default3
  },
  self: self48
};
var dark_default50 = notificationDark;

// node_modules/naive-ui/es/message/styles/_common.js
var common_default29 = {
  margin: "0 0 8px 0",
  padding: "10px 20px",
  maxWidth: "720px",
  minWidth: "420px",
  iconMargin: "0 10px 0 0",
  closeMargin: "0 0 0 10px",
  closeSize: "20px",
  closeIconSize: "16px",
  iconSize: "20px",
  fontSize: "14px"
};

// node_modules/naive-ui/es/message/styles/light.js
var self49 = (vars) => {
  const { textColor2, closeIconColor, closeIconColorHover, closeIconColorPressed, infoColor, successColor, errorColor, warningColor, popoverColor, boxShadow2, primaryColor, lineHeight: lineHeight3, borderRadius, closeColorHover, closeColorPressed } = vars;
  return Object.assign(Object.assign({}, common_default29), {
    closeBorderRadius: borderRadius,
    textColor: textColor2,
    textColorInfo: textColor2,
    textColorSuccess: textColor2,
    textColorError: textColor2,
    textColorWarning: textColor2,
    textColorLoading: textColor2,
    color: popoverColor,
    colorInfo: popoverColor,
    colorSuccess: popoverColor,
    colorError: popoverColor,
    colorWarning: popoverColor,
    colorLoading: popoverColor,
    boxShadow: boxShadow2,
    boxShadowInfo: boxShadow2,
    boxShadowSuccess: boxShadow2,
    boxShadowError: boxShadow2,
    boxShadowWarning: boxShadow2,
    boxShadowLoading: boxShadow2,
    iconColor: textColor2,
    iconColorInfo: infoColor,
    iconColorSuccess: successColor,
    iconColorWarning: warningColor,
    iconColorError: errorColor,
    iconColorLoading: primaryColor,
    closeColorHover,
    closeColorPressed,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    closeColorHoverInfo: closeColorHover,
    closeColorPressedInfo: closeColorPressed,
    closeIconColorInfo: closeIconColor,
    closeIconColorHoverInfo: closeIconColorHover,
    closeIconColorPressedInfo: closeIconColorPressed,
    closeColorHoverSuccess: closeColorHover,
    closeColorPressedSuccess: closeColorPressed,
    closeIconColorSuccess: closeIconColor,
    closeIconColorHoverSuccess: closeIconColorHover,
    closeIconColorPressedSuccess: closeIconColorPressed,
    closeColorHoverError: closeColorHover,
    closeColorPressedError: closeColorPressed,
    closeIconColorError: closeIconColor,
    closeIconColorHoverError: closeIconColorHover,
    closeIconColorPressedError: closeIconColorPressed,
    closeColorHoverWarning: closeColorHover,
    closeColorPressedWarning: closeColorPressed,
    closeIconColorWarning: closeIconColor,
    closeIconColorHoverWarning: closeIconColorHover,
    closeIconColorPressedWarning: closeIconColorPressed,
    closeColorHoverLoading: closeColorHover,
    closeColorPressedLoading: closeColorPressed,
    closeIconColorLoading: closeIconColor,
    closeIconColorHoverLoading: closeIconColorHover,
    closeIconColorPressedLoading: closeIconColorPressed,
    loadingColor: primaryColor,
    lineHeight: lineHeight3,
    borderRadius
  });
};
var messageLight = {
  name: "Message",
  common: light_default,
  self: self49
};
var light_default51 = messageLight;

// node_modules/naive-ui/es/message/styles/dark.js
var messageDark = {
  name: "Message",
  common: dark_default,
  self: self49
};
var dark_default51 = messageDark;

// node_modules/naive-ui/es/button-group/styles/dark.js
var buttonGroupDark = {
  name: "ButtonGroup",
  common: dark_default
};
var dark_default52 = buttonGroupDark;

// node_modules/naive-ui/es/button-group/styles/light.js
var buttonGroupLight = {
  name: "ButtonGroup",
  common: light_default
};
var light_default52 = buttonGroupLight;

// node_modules/naive-ui/es/input-number/styles/dark.js
var inputNumberDark = {
  name: "InputNumber",
  common: dark_default,
  peers: {
    Button: dark_default17,
    Input: dark_default10
  },
  self(vars) {
    const { textColorDisabled } = vars;
    return {
      iconColorDisabled: textColorDisabled
    };
  }
};
var dark_default53 = inputNumberDark;

// node_modules/naive-ui/es/input-number/styles/light.js
var self50 = (vars) => {
  const { textColorDisabled } = vars;
  return {
    iconColorDisabled: textColorDisabled
  };
};
var inputNumberLight = createTheme({
  name: "InputNumber",
  common: light_default,
  peers: {
    Button: light_default17,
    Input: light_default10
  },
  self: self50
});
var light_default53 = inputNumberLight;

// node_modules/naive-ui/es/layout/styles/dark.js
var layoutDark = {
  name: "Layout",
  common: dark_default,
  peers: {
    Scrollbar: dark_default3
  },
  self(vars) {
    const { textColor2, bodyColor, popoverColor, cardColor, dividerColor, scrollbarColor, scrollbarColorHover } = vars;
    return {
      textColor: textColor2,
      textColorInverted: textColor2,
      color: bodyColor,
      colorEmbedded: bodyColor,
      headerColor: cardColor,
      headerColorInverted: cardColor,
      footerColor: cardColor,
      footerColorInverted: cardColor,
      headerBorderColor: dividerColor,
      headerBorderColorInverted: dividerColor,
      footerBorderColor: dividerColor,
      footerBorderColorInverted: dividerColor,
      siderBorderColor: dividerColor,
      siderBorderColorInverted: dividerColor,
      siderColor: cardColor,
      siderColorInverted: cardColor,
      siderToggleButtonBorder: "1px solid transparent",
      siderToggleButtonColor: popoverColor,
      siderToggleButtonIconColor: textColor2,
      siderToggleButtonIconColorInverted: textColor2,
      siderToggleBarColor: composite(bodyColor, scrollbarColor),
      siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
      __invertScrollbar: "false"
    };
  }
};
var dark_default54 = layoutDark;

// node_modules/naive-ui/es/layout/styles/light.js
var self51 = (vars) => {
  const { baseColor, textColor2, bodyColor, cardColor, dividerColor, actionColor, scrollbarColor, scrollbarColorHover, invertedColor } = vars;
  return {
    textColor: textColor2,
    textColorInverted: "#FFF",
    color: bodyColor,
    colorEmbedded: actionColor,
    headerColor: cardColor,
    headerColorInverted: invertedColor,
    footerColor: actionColor,
    footerColorInverted: invertedColor,
    headerBorderColor: dividerColor,
    headerBorderColorInverted: invertedColor,
    footerBorderColor: dividerColor,
    footerBorderColorInverted: invertedColor,
    siderBorderColor: dividerColor,
    siderBorderColorInverted: invertedColor,
    siderColor: cardColor,
    siderColorInverted: invertedColor,
    siderToggleButtonBorder: `1px solid ${dividerColor}`,
    siderToggleButtonColor: baseColor,
    siderToggleButtonIconColor: textColor2,
    siderToggleButtonIconColorInverted: textColor2,
    siderToggleBarColor: composite(bodyColor, scrollbarColor),
    siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
    __invertScrollbar: "true"
  };
};
var layoutLight = createTheme({
  name: "Layout",
  common: light_default,
  peers: {
    Scrollbar: light_default3
  },
  self: self51
});
var light_default54 = layoutLight;

// node_modules/naive-ui/es/list/styles/light.js
var self52 = (vars) => {
  const { textColor2, cardColor, modalColor, popoverColor, dividerColor, borderRadius, fontSize: fontSize2, hoverColor } = vars;
  return {
    textColor: textColor2,
    color: cardColor,
    colorHover: hoverColor,
    colorModal: modalColor,
    colorHoverModal: composite(modalColor, hoverColor),
    colorPopover: popoverColor,
    colorHoverPopover: composite(popoverColor, hoverColor),
    borderColor: dividerColor,
    borderColorModal: composite(modalColor, dividerColor),
    borderColorPopover: composite(popoverColor, dividerColor),
    borderRadius,
    fontSize: fontSize2
  };
};
var listLight = {
  name: "List",
  common: light_default,
  self: self52
};
var light_default55 = listLight;

// node_modules/naive-ui/es/list/styles/dark.js
var listDark = {
  name: "List",
  common: dark_default,
  self: self52
};
var dark_default55 = listDark;

// node_modules/naive-ui/es/loading-bar/styles/dark.js
var loadingBarDark = {
  name: "LoadingBar",
  common: dark_default,
  self(vars) {
    const { primaryColor } = vars;
    return {
      colorError: "red",
      colorLoading: primaryColor,
      height: "2px"
    };
  }
};
var dark_default56 = loadingBarDark;

// node_modules/naive-ui/es/loading-bar/styles/light.js
var self53 = (vars) => {
  const { primaryColor, errorColor } = vars;
  return {
    colorError: errorColor,
    colorLoading: primaryColor,
    height: "2px"
  };
};
var loadingBarLight = {
  name: "LoadingBar",
  common: light_default,
  self: self53
};
var light_default56 = loadingBarLight;

// node_modules/naive-ui/es/log/styles/dark.js
var logDark = {
  name: "Log",
  common: dark_default,
  peers: {
    Scrollbar: dark_default3,
    Code: dark_default24
  },
  self(vars) {
    const { textColor2, inputColor, fontSize: fontSize2, primaryColor } = vars;
    return {
      loaderFontSize: fontSize2,
      loaderTextColor: textColor2,
      loaderColor: inputColor,
      loaderBorder: "1px solid #0000",
      loadingColor: primaryColor
    };
  }
};
var dark_default57 = logDark;

// node_modules/naive-ui/es/log/styles/light.js
var self54 = (vars) => {
  const { textColor2, modalColor, borderColor, fontSize: fontSize2, primaryColor } = vars;
  return {
    loaderFontSize: fontSize2,
    loaderTextColor: textColor2,
    loaderColor: modalColor,
    loaderBorder: `1px solid ${borderColor}`,
    loadingColor: primaryColor
  };
};
var logLight = createTheme({
  name: "Log",
  common: light_default,
  peers: {
    Scrollbar: light_default3,
    Code: light_default24
  },
  self: self54
});
var light_default57 = logLight;

// node_modules/naive-ui/es/mention/styles/dark.js
var listDark2 = {
  name: "Mention",
  common: dark_default,
  peers: {
    InternalSelectMenu: dark_default4,
    Input: dark_default10
  },
  self(vars) {
    const { boxShadow2 } = vars;
    return {
      menuBoxShadow: boxShadow2
    };
  }
};
var dark_default58 = listDark2;

// node_modules/naive-ui/es/mention/styles/light.js
var self55 = (vars) => {
  const { boxShadow2 } = vars;
  return {
    menuBoxShadow: boxShadow2
  };
};
var mentionLight = createTheme({
  name: "Mention",
  common: light_default,
  peers: {
    InternalSelectMenu: light_default4,
    Input: light_default10
  },
  self: self55
});
var light_default58 = mentionLight;

// node_modules/naive-ui/es/menu/styles/light.js
function createPartialInvertedVars(color2, activeItemColor, activeTextColor, groupTextColor) {
  return {
    itemColorHoverInverted: "#0000",
    itemColorActiveInverted: activeItemColor,
    itemColorActiveHoverInverted: activeItemColor,
    itemColorActiveCollapsedInverted: activeItemColor,
    itemTextColorInverted: color2,
    itemTextColorHoverInverted: activeTextColor,
    itemTextColorChildActiveInverted: activeTextColor,
    itemTextColorChildActiveHoverInverted: activeTextColor,
    itemTextColorActiveInverted: activeTextColor,
    itemTextColorActiveHoverInverted: activeTextColor,
    itemTextColorHorizontalInverted: color2,
    itemTextColorHoverHorizontalInverted: activeTextColor,
    itemTextColorChildActiveHorizontalInverted: activeTextColor,
    itemTextColorChildActiveHoverHorizontalInverted: activeTextColor,
    itemTextColorActiveHorizontalInverted: activeTextColor,
    itemTextColorActiveHoverHorizontalInverted: activeTextColor,
    itemIconColorInverted: color2,
    itemIconColorHoverInverted: activeTextColor,
    itemIconColorActiveInverted: activeTextColor,
    itemIconColorActiveHoverInverted: activeTextColor,
    itemIconColorChildActiveInverted: activeTextColor,
    itemIconColorChildActiveHoverInverted: activeTextColor,
    itemIconColorCollapsedInverted: color2,
    itemIconColorHorizontalInverted: color2,
    itemIconColorHoverHorizontalInverted: activeTextColor,
    itemIconColorActiveHorizontalInverted: activeTextColor,
    itemIconColorActiveHoverHorizontalInverted: activeTextColor,
    itemIconColorChildActiveHorizontalInverted: activeTextColor,
    itemIconColorChildActiveHoverHorizontalInverted: activeTextColor,
    arrowColorInverted: color2,
    arrowColorHoverInverted: activeTextColor,
    arrowColorActiveInverted: activeTextColor,
    arrowColorActiveHoverInverted: activeTextColor,
    arrowColorChildActiveInverted: activeTextColor,
    arrowColorChildActiveHoverInverted: activeTextColor,
    groupTextColorInverted: groupTextColor
  };
}
var self56 = (vars) => {
  const { borderRadius, textColor3, primaryColor, textColor2, textColor1, fontSize: fontSize2, dividerColor, hoverColor, primaryColorHover } = vars;
  return Object.assign({
    borderRadius,
    color: "#0000",
    groupTextColor: textColor3,
    itemColorHover: hoverColor,
    itemColorActive: changeColor(primaryColor, { alpha: 0.1 }),
    itemColorActiveHover: changeColor(primaryColor, { alpha: 0.1 }),
    itemColorActiveCollapsed: changeColor(primaryColor, { alpha: 0.1 }),
    itemTextColor: textColor2,
    itemTextColorHover: textColor2,
    itemTextColorActive: primaryColor,
    itemTextColorActiveHover: primaryColor,
    itemTextColorChildActive: primaryColor,
    itemTextColorChildActiveHover: primaryColor,
    itemTextColorHorizontal: textColor2,
    itemTextColorHoverHorizontal: primaryColorHover,
    itemTextColorActiveHorizontal: primaryColor,
    itemTextColorActiveHoverHorizontal: primaryColor,
    itemTextColorChildActiveHorizontal: primaryColor,
    itemTextColorChildActiveHoverHorizontal: primaryColor,
    itemIconColor: textColor1,
    itemIconColorHover: textColor1,
    itemIconColorActive: primaryColor,
    itemIconColorActiveHover: primaryColor,
    itemIconColorChildActive: primaryColor,
    itemIconColorChildActiveHover: primaryColor,
    itemIconColorCollapsed: textColor1,
    itemIconColorHorizontal: textColor1,
    itemIconColorHoverHorizontal: primaryColorHover,
    itemIconColorActiveHorizontal: primaryColor,
    itemIconColorActiveHoverHorizontal: primaryColor,
    itemIconColorChildActiveHorizontal: primaryColor,
    itemIconColorChildActiveHoverHorizontal: primaryColor,
    itemHeight: "42px",
    arrowColor: textColor2,
    arrowColorHover: textColor2,
    arrowColorActive: primaryColor,
    arrowColorActiveHover: primaryColor,
    arrowColorChildActive: primaryColor,
    arrowColorChildActiveHover: primaryColor,
    colorInverted: "#0000",
    borderColorHorizontal: "#0000",
    fontSize: fontSize2,
    dividerColor
  }, createPartialInvertedVars("#BBB", primaryColor, "#FFF", "#AAA"));
};
var menuLight = createTheme({
  name: "Menu",
  common: light_default,
  peers: {
    Tooltip: light_default30,
    Dropdown: light_default33
  },
  self: self56
});
var light_default59 = menuLight;

// node_modules/naive-ui/es/menu/styles/dark.js
var menuDark = {
  name: "Menu",
  common: dark_default,
  peers: {
    Tooltip: dark_default30,
    Dropdown: dark_default33
  },
  self(vars) {
    const { primaryColor, primaryColorSuppl } = vars;
    const commonSelf = self56(vars);
    commonSelf.itemColorActive = changeColor(primaryColor, { alpha: 0.15 });
    commonSelf.itemColorActiveHover = changeColor(primaryColor, { alpha: 0.15 });
    commonSelf.itemColorActiveCollapsed = changeColor(primaryColor, {
      alpha: 0.15
    });
    commonSelf.itemColorActiveInverted = primaryColorSuppl;
    commonSelf.itemColorActiveHoverInverted = primaryColorSuppl;
    commonSelf.itemColorActiveCollapsedInverted = primaryColorSuppl;
    return commonSelf;
  }
};
var dark_default59 = menuDark;

// node_modules/naive-ui/es/page-header/styles/_common.js
var common_default30 = {
  titleFontSize: "18px",
  backSize: "22px"
};

// node_modules/naive-ui/es/page-header/styles/light.js
function self57(vars) {
  const { textColor1, textColor2, textColor3, fontSize: fontSize2, fontWeightStrong, primaryColorHover, primaryColorPressed } = vars;
  return Object.assign(Object.assign({}, common_default30), { titleFontWeight: fontWeightStrong, fontSize: fontSize2, titleTextColor: textColor1, backColor: textColor2, backColorHover: primaryColorHover, backColorPressed: primaryColorPressed, subtitleTextColor: textColor3 });
}
var pageHeaderLight = createTheme({
  name: "PageHeader",
  common: light_default,
  self: self57
});

// node_modules/naive-ui/es/page-header/styles/dark.js
var pageHeaderDark = {
  name: "PageHeader",
  common: dark_default,
  self: self57
};

// node_modules/naive-ui/es/popconfirm/styles/_common.js
var common_default31 = {
  iconSize: "22px"
};

// node_modules/naive-ui/es/popconfirm/styles/light.js
var self58 = (vars) => {
  const { fontSize: fontSize2, warningColor } = vars;
  return Object.assign(Object.assign({}, common_default31), { fontSize: fontSize2, iconColor: warningColor });
};
var popconfirmLight = createTheme({
  name: "Popconfirm",
  common: light_default,
  peers: {
    Button: light_default17,
    Popover: light_default5
  },
  self: self58
});
var light_default60 = popconfirmLight;

// node_modules/naive-ui/es/popconfirm/styles/dark.js
var popconfirmDark = {
  name: "Popconfirm",
  common: dark_default,
  peers: {
    Button: dark_default17,
    Popover: dark_default5
  },
  self: self58
};
var dark_default60 = popconfirmDark;

// node_modules/naive-ui/es/progress/styles/light.js
var self59 = (vars) => {
  const { infoColor, successColor, warningColor, errorColor, textColor2, progressRailColor, fontSize: fontSize2, fontWeight } = vars;
  return {
    fontSize: fontSize2,
    fontSizeCircle: "28px",
    fontWeightCircle: fontWeight,
    railColor: progressRailColor,
    railHeight: "8px",
    iconSizeCircle: "36px",
    iconSizeLine: "18px",
    iconColor: infoColor,
    iconColorInfo: infoColor,
    iconColorSuccess: successColor,
    iconColorWarning: warningColor,
    iconColorError: errorColor,
    textColorCircle: textColor2,
    textColorLineInner: "rgb(255, 255, 255)",
    textColorLineOuter: textColor2,
    fillColor: infoColor,
    fillColorInfo: infoColor,
    fillColorSuccess: successColor,
    fillColorWarning: warningColor,
    fillColorError: errorColor,
    lineBgProcessing: "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)"
  };
};
var progressLight = {
  name: "Progress",
  common: light_default,
  self: self59
};
var light_default61 = progressLight;

// node_modules/naive-ui/es/progress/styles/dark.js
var progressDark = {
  name: "Progress",
  common: dark_default,
  self(vars) {
    const commonSelf = self59(vars);
    commonSelf.textColorLineInner = "rgb(0, 0, 0)";
    commonSelf.lineBgProcessing = "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)";
    return commonSelf;
  }
};
var dark_default61 = progressDark;

// node_modules/naive-ui/es/rate/styles/dark.js
var rateDark = {
  name: "Rate",
  common: dark_default,
  self(vars) {
    const { railColor } = vars;
    return {
      itemColor: railColor,
      itemColorActive: "#CCAA33",
      itemSize: "20px",
      sizeSmall: "16px",
      sizeMedium: "20px",
      sizeLarge: "24px"
    };
  }
};
var dark_default62 = rateDark;

// node_modules/naive-ui/es/rate/styles/light.js
var self60 = (vars) => {
  const { railColor } = vars;
  return {
    itemColor: railColor,
    itemColorActive: "#FFCC33",
    sizeSmall: "16px",
    sizeMedium: "20px",
    sizeLarge: "24px"
  };
};
var themeLight = {
  name: "Rate",
  common: light_default,
  self: self60
};
var light_default62 = themeLight;

// node_modules/naive-ui/es/result/styles/_common.js
var common_default32 = {
  titleFontSizeSmall: "26px",
  titleFontSizeMedium: "32px",
  titleFontSizeLarge: "40px",
  titleFontSizeHuge: "48px",
  fontSizeSmall: "14px",
  fontSizeMedium: "14px",
  fontSizeLarge: "15px",
  fontSizeHuge: "16px",
  iconSizeSmall: "64px",
  iconSizeMedium: "80px",
  iconSizeLarge: "100px",
  iconSizeHuge: "125px",
  iconColor418: void 0,
  iconColor404: void 0,
  iconColor403: void 0,
  iconColor500: void 0
};

// node_modules/naive-ui/es/result/styles/light.js
var self61 = (vars) => {
  const { textColor2, textColor1, errorColor, successColor, infoColor, warningColor, lineHeight: lineHeight3, fontWeightStrong } = vars;
  return Object.assign(Object.assign({}, common_default32), { lineHeight: lineHeight3, titleFontWeight: fontWeightStrong, titleTextColor: textColor1, textColor: textColor2, iconColorError: errorColor, iconColorSuccess: successColor, iconColorInfo: infoColor, iconColorWarning: warningColor });
};
var resultLight = {
  name: "Result",
  common: light_default,
  self: self61
};
var light_default63 = resultLight;

// node_modules/naive-ui/es/result/styles/dark.js
var resultDark = {
  name: "Result",
  common: dark_default,
  self: self61
};
var dark_default63 = resultDark;

// node_modules/naive-ui/es/slider/styles/_common.js
var common_default33 = {
  railHeight: "4px",
  railWidthVertical: "4px",
  handleSize: "18px",
  dotHeight: "8px",
  dotWidth: "8px",
  dotBorderRadius: "4px"
};

// node_modules/naive-ui/es/slider/styles/dark.js
var sliderDark = {
  name: "Slider",
  common: dark_default,
  self(vars) {
    const boxShadow = "0 2px 8px 0 rgba(0, 0, 0, 0.12)";
    const { railColor, modalColor, primaryColorSuppl, popoverColor, textColor2, cardColor, borderRadius, fontSize: fontSize2, opacityDisabled } = vars;
    return Object.assign(Object.assign({}, common_default33), { fontSize: fontSize2, markFontSize: fontSize2, railColor, railColorHover: railColor, fillColor: primaryColorSuppl, fillColorHover: primaryColorSuppl, opacityDisabled, handleColor: "#FFF", dotColor: cardColor, dotColorModal: modalColor, dotColorPopover: popoverColor, handleBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowHover: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowActive: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowFocus: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", indicatorColor: popoverColor, indicatorBoxShadow: boxShadow, indicatorTextColor: textColor2, indicatorBorderRadius: borderRadius, dotBorder: `2px solid ${railColor}`, dotBorderActive: `2px solid ${primaryColorSuppl}`, dotBoxShadow: "" });
  }
};
var dark_default64 = sliderDark;

// node_modules/naive-ui/es/slider/styles/light.js
var self62 = (vars) => {
  const indicatorColor = "rgba(0, 0, 0, .85)";
  const boxShadow = "0 2px 8px 0 rgba(0, 0, 0, 0.12)";
  const { railColor, primaryColor, baseColor, cardColor, modalColor, popoverColor, borderRadius, fontSize: fontSize2, opacityDisabled } = vars;
  return Object.assign(Object.assign({}, common_default33), { fontSize: fontSize2, markFontSize: fontSize2, railColor, railColorHover: railColor, fillColor: primaryColor, fillColorHover: primaryColor, opacityDisabled, handleColor: "#FFF", dotColor: cardColor, dotColorModal: modalColor, dotColorPopover: popoverColor, handleBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", handleBoxShadowHover: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", handleBoxShadowActive: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", handleBoxShadowFocus: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", indicatorColor, indicatorBoxShadow: boxShadow, indicatorTextColor: baseColor, indicatorBorderRadius: borderRadius, dotBorder: `2px solid ${railColor}`, dotBorderActive: `2px solid ${primaryColor}`, dotBoxShadow: "" });
};
var sliderLight = {
  name: "Slider",
  common: light_default,
  self: self62
};
var light_default64 = sliderLight;

// node_modules/naive-ui/es/spin/styles/light.js
var self63 = (vars) => {
  const { opacityDisabled, heightTiny, heightSmall, heightMedium, heightLarge, heightHuge, primaryColor, fontSize: fontSize2 } = vars;
  return {
    fontSize: fontSize2,
    textColor: primaryColor,
    sizeTiny: heightTiny,
    sizeSmall: heightSmall,
    sizeMedium: heightMedium,
    sizeLarge: heightLarge,
    sizeHuge: heightHuge,
    color: primaryColor,
    opacitySpinning: opacityDisabled
  };
};
var spinLight = {
  name: "Spin",
  common: light_default,
  self: self63
};
var light_default65 = spinLight;

// node_modules/naive-ui/es/spin/styles/dark.js
var spinDark = {
  name: "Spin",
  common: dark_default,
  self: self63
};
var dark_default65 = spinDark;

// node_modules/naive-ui/es/statistic/styles/light.js
var self64 = (vars) => {
  const { textColor2, textColor3, fontSize: fontSize2, fontWeight } = vars;
  return {
    labelFontSize: fontSize2,
    labelFontWeight: fontWeight,
    valueFontWeight: fontWeight,
    valueFontSize: "24px",
    labelTextColor: textColor3,
    valuePrefixTextColor: textColor2,
    valueSuffixTextColor: textColor2,
    valueTextColor: textColor2
  };
};
var statisticLight = {
  name: "Statistic",
  common: light_default,
  self: self64
};
var light_default66 = statisticLight;

// node_modules/naive-ui/es/statistic/styles/dark.js
var statisticDark = {
  name: "Statistic",
  common: dark_default,
  self: self64
};
var dark_default66 = statisticDark;

// node_modules/naive-ui/es/steps/styles/_common.js
var common_default34 = {
  stepHeaderFontSizeSmall: "14px",
  stepHeaderFontSizeMedium: "16px",
  indicatorIndexFontSizeSmall: "14px",
  indicatorIndexFontSizeMedium: "16px",
  indicatorSizeSmall: "22px",
  indicatorSizeMedium: "28px",
  indicatorIconSizeSmall: "14px",
  indicatorIconSizeMedium: "18px"
};

// node_modules/naive-ui/es/steps/styles/light.js
var self65 = (vars) => {
  const { fontWeightStrong, baseColor, textColorDisabled, primaryColor, errorColor, textColor1, textColor2 } = vars;
  return Object.assign(Object.assign({}, common_default34), { stepHeaderFontWeight: fontWeightStrong, indicatorTextColorProcess: baseColor, indicatorTextColorWait: textColorDisabled, indicatorTextColorFinish: primaryColor, indicatorTextColorError: errorColor, indicatorBorderColorProcess: primaryColor, indicatorBorderColorWait: textColorDisabled, indicatorBorderColorFinish: primaryColor, indicatorBorderColorError: errorColor, indicatorColorProcess: primaryColor, indicatorColorWait: "#0000", indicatorColorFinish: "#0000", indicatorColorError: "#0000", splitorColorProcess: textColorDisabled, splitorColorWait: textColorDisabled, splitorColorFinish: primaryColor, splitorColorError: textColorDisabled, headerTextColorProcess: textColor1, headerTextColorWait: textColorDisabled, headerTextColorFinish: textColorDisabled, headerTextColorError: errorColor, descriptionTextColorProcess: textColor2, descriptionTextColorWait: textColorDisabled, descriptionTextColorFinish: textColorDisabled, descriptionTextColorError: errorColor });
};
var stepsLight = {
  name: "Steps",
  common: light_default,
  self: self65
};
var light_default67 = stepsLight;

// node_modules/naive-ui/es/steps/styles/dark.js
var stepsDark = {
  name: "Steps",
  common: dark_default,
  self: self65
};
var dark_default67 = stepsDark;

// node_modules/naive-ui/es/switch/styles/_common.js
var common_default35 = {
  buttonHeightSmall: "14px",
  buttonHeightMedium: "18px",
  buttonHeightLarge: "22px",
  buttonWidthSmall: "14px",
  buttonWidthMedium: "18px",
  buttonWidthLarge: "22px",
  buttonWidthPressedSmall: "20px",
  buttonWidthPressedMedium: "24px",
  buttonWidthPressedLarge: "28px",
  railHeightSmall: "18px",
  railHeightMedium: "22px",
  railHeightLarge: "26px",
  railWidthSmall: "32px",
  railWidthMedium: "40px",
  railWidthLarge: "48px"
};

// node_modules/naive-ui/es/switch/styles/dark.js
var switchDark = {
  name: "Switch",
  common: dark_default,
  self(vars) {
    const { primaryColorSuppl, opacityDisabled, borderRadius, primaryColor, textColor2, baseColor } = vars;
    const railOverlayColor = "rgba(255, 255, 255, .20)";
    return Object.assign(Object.assign({}, common_default35), { iconColor: baseColor, textColor: textColor2, loadingColor: primaryColorSuppl, opacityDisabled, railColor: railOverlayColor, railColorActive: primaryColorSuppl, buttonBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", buttonColor: "#FFF", railBorderRadiusSmall: borderRadius, railBorderRadiusMedium: borderRadius, railBorderRadiusLarge: borderRadius, buttonBorderRadiusSmall: borderRadius, buttonBorderRadiusMedium: borderRadius, buttonBorderRadiusLarge: borderRadius, boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, { alpha: 0.3 })}` });
  }
};
var dark_default68 = switchDark;

// node_modules/naive-ui/es/switch/styles/light.js
var self66 = (vars) => {
  const { primaryColor, opacityDisabled, borderRadius, textColor3 } = vars;
  const railOverlayColor = "rgba(0, 0, 0, .14)";
  return Object.assign(Object.assign({}, common_default35), { iconColor: textColor3, textColor: "white", loadingColor: primaryColor, opacityDisabled, railColor: railOverlayColor, railColorActive: primaryColor, buttonBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", buttonColor: "#FFF", railBorderRadiusSmall: borderRadius, railBorderRadiusMedium: borderRadius, railBorderRadiusLarge: borderRadius, buttonBorderRadiusSmall: borderRadius, buttonBorderRadiusMedium: borderRadius, buttonBorderRadiusLarge: borderRadius, boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}` });
};
var switchLight = {
  name: "Switch",
  common: light_default,
  self: self66
};
var light_default68 = switchLight;

// node_modules/naive-ui/es/table/styles/_common.js
var common_default36 = {
  thPaddingSmall: "6px",
  thPaddingMedium: "12px",
  thPaddingLarge: "12px",
  tdPaddingSmall: "6px",
  tdPaddingMedium: "12px",
  tdPaddingLarge: "12px"
};

// node_modules/naive-ui/es/table/styles/light.js
var self67 = (vars) => {
  const { dividerColor, cardColor, modalColor, popoverColor, tableHeaderColor, tableColorStriped, textColor1, textColor2, borderRadius, fontWeightStrong, lineHeight: lineHeight3, fontSizeSmall, fontSizeMedium, fontSizeLarge } = vars;
  return Object.assign(Object.assign({}, common_default36), {
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    lineHeight: lineHeight3,
    borderRadius,
    borderColor: composite(cardColor, dividerColor),
    borderColorModal: composite(modalColor, dividerColor),
    borderColorPopover: composite(popoverColor, dividerColor),
    tdColor: cardColor,
    tdColorModal: modalColor,
    tdColorPopover: popoverColor,
    tdColorStriped: composite(cardColor, tableColorStriped),
    tdColorStripedModal: composite(modalColor, tableColorStriped),
    tdColorStripedPopover: composite(popoverColor, tableColorStriped),
    thColor: composite(cardColor, tableHeaderColor),
    thColorModal: composite(modalColor, tableHeaderColor),
    thColorPopover: composite(popoverColor, tableHeaderColor),
    thTextColor: textColor1,
    tdTextColor: textColor2,
    thFontWeight: fontWeightStrong
  });
};
var tableLight = {
  name: "Table",
  common: light_default,
  self: self67
};
var light_default69 = tableLight;

// node_modules/naive-ui/es/table/styles/dark.js
var tableDark = {
  name: "Table",
  common: dark_default,
  self: self67
};
var dark_default69 = tableDark;

// node_modules/naive-ui/es/tabs/styles/_common.js
var common_default37 = {
  tabFontSizeSmall: "14px",
  tabFontSizeMedium: "14px",
  tabFontSizeLarge: "16px",
  tabGapSmallLine: "36px",
  tabGapMediumLine: "36px",
  tabGapLargeLine: "36px",
  tabPaddingSmallLine: "6px 0",
  tabPaddingMediumLine: "10px 0",
  tabPaddingLargeLine: "14px 0",
  tabPaddingVerticalSmallLine: "0 6px",
  tabPaddingVerticalMediumLine: "0 10px",
  tabPaddingVerticalLargeLine: "0 14px",
  tabGapSmallBar: "36px",
  tabGapMediumBar: "36px",
  tabGapLargeBar: "36px",
  tabPaddingSmallBar: "4px 0",
  tabPaddingMediumBar: "6px 0",
  tabPaddingLargeBar: "10px 0",
  tabPaddingVerticalSmallBar: "0 4px",
  tabPaddingVerticalMediumBar: "0 6px ",
  tabPaddingVerticalLargeBar: "0 10px ",
  tabGapSmallCard: "4px",
  tabGapMediumCard: "4px",
  tabGapLargeCard: "4px",
  tabPaddingSmallCard: "6px 10px",
  tabPaddingMediumCard: "8px 12px",
  tabPaddingLargeCard: "8px 16px",
  tabPaddingSmallSegment: "4px 0",
  tabPaddingMediumSegment: "6px 0",
  tabPaddingLargeSegment: "8px 0",
  tabPaddingVerticalLargeSegment: "0 8px",
  tabPaddingVerticalSmallCard: "10px 6px",
  tabPaddingVerticalMediumCard: "12px 8px",
  tabPaddingVerticalLargeCard: "16px 8px",
  tabPaddingVerticalSmallSegment: "0 4px",
  tabPaddingVerticalMediumSegment: "0 6px",
  tabGapSmallSegment: "0",
  tabGapMediumSegment: "0",
  tabGapLargeSegment: "0",
  panePaddingSmall: "8px 0 0 0",
  panePaddingMedium: "12px 0 0 0",
  panePaddingLarge: "16px 0 0 0",
  closeSize: "18px",
  closeIconSize: "14px"
};

// node_modules/naive-ui/es/tabs/styles/light.js
var self68 = (vars) => {
  const { textColor2, primaryColor, textColorDisabled, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, tabColor, baseColor, dividerColor, fontWeight, textColor1, borderRadius, fontSize: fontSize2, fontWeightStrong } = vars;
  return Object.assign(Object.assign({}, common_default37), {
    colorSegment: tabColor,
    tabFontSizeCard: fontSize2,
    tabTextColorLine: textColor1,
    tabTextColorActiveLine: primaryColor,
    tabTextColorHoverLine: primaryColor,
    tabTextColorDisabledLine: textColorDisabled,
    tabTextColorSegment: textColor1,
    tabTextColorActiveSegment: textColor2,
    tabTextColorHoverSegment: textColor2,
    tabTextColorDisabledSegment: textColorDisabled,
    tabTextColorBar: textColor1,
    tabTextColorActiveBar: primaryColor,
    tabTextColorHoverBar: primaryColor,
    tabTextColorDisabledBar: textColorDisabled,
    tabTextColorCard: textColor1,
    tabTextColorHoverCard: textColor1,
    tabTextColorActiveCard: primaryColor,
    tabTextColorDisabledCard: textColorDisabled,
    barColor: primaryColor,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed,
    closeColorHover,
    closeColorPressed,
    closeBorderRadius: borderRadius,
    tabColor,
    tabColorSegment: baseColor,
    tabBorderColor: dividerColor,
    tabFontWeightActive: fontWeight,
    tabFontWeight: fontWeight,
    tabBorderRadius: borderRadius,
    paneTextColor: textColor2,
    fontWeightStrong
  });
};
var tabsLight = {
  name: "Tabs",
  common: light_default,
  self: self68
};
var light_default70 = tabsLight;

// node_modules/naive-ui/es/tabs/styles/dark.js
var tabsDark = {
  name: "Tabs",
  common: dark_default,
  self(vars) {
    const commonSelf = self68(vars);
    const { inputColor } = vars;
    commonSelf.colorSegment = inputColor;
    commonSelf.tabColorSegment = inputColor;
    return commonSelf;
  }
};
var dark_default70 = tabsDark;

// node_modules/naive-ui/es/thing/styles/light.js
var self69 = (vars) => {
  const { textColor1, textColor2, fontWeightStrong, fontSize: fontSize2 } = vars;
  return {
    fontSize: fontSize2,
    titleTextColor: textColor1,
    textColor: textColor2,
    titleFontWeight: fontWeightStrong
  };
};
var thingLight = {
  name: "Thing",
  common: light_default,
  self: self69
};
var light_default71 = thingLight;

// node_modules/naive-ui/es/thing/styles/dark.js
var thingDark = {
  name: "Thing",
  common: dark_default,
  self: self69
};
var dark_default71 = thingDark;

// node_modules/naive-ui/es/timeline/styles/_common.js
var common_default38 = {
  titleMarginMedium: "0 0 6px 0",
  titleMarginLarge: "-2px 0 6px 0",
  titleFontSizeMedium: "14px",
  titleFontSizeLarge: "16px",
  iconSizeMedium: "14px",
  iconSizeLarge: "14px"
};

// node_modules/naive-ui/es/timeline/styles/dark.js
var timelineDark = {
  name: "Timeline",
  common: dark_default,
  self(vars) {
    const { textColor3, infoColorSuppl, errorColorSuppl, successColorSuppl, warningColorSuppl, textColor1, textColor2, railColor, fontWeightStrong, fontSize: fontSize2 } = vars;
    return Object.assign(Object.assign({}, common_default38), { contentFontSize: fontSize2, titleFontWeight: fontWeightStrong, circleBorder: `2px solid ${textColor3}`, circleBorderInfo: `2px solid ${infoColorSuppl}`, circleBorderError: `2px solid ${errorColorSuppl}`, circleBorderSuccess: `2px solid ${successColorSuppl}`, circleBorderWarning: `2px solid ${warningColorSuppl}`, iconColor: textColor3, iconColorInfo: infoColorSuppl, iconColorError: errorColorSuppl, iconColorSuccess: successColorSuppl, iconColorWarning: warningColorSuppl, titleTextColor: textColor1, contentTextColor: textColor2, metaTextColor: textColor3, lineColor: railColor });
  }
};
var dark_default72 = timelineDark;

// node_modules/naive-ui/es/timeline/styles/light.js
var self70 = (vars) => {
  const { textColor3, infoColor, errorColor, successColor, warningColor, textColor1, textColor2, railColor, fontWeightStrong, fontSize: fontSize2 } = vars;
  return Object.assign(Object.assign({}, common_default38), { contentFontSize: fontSize2, titleFontWeight: fontWeightStrong, circleBorder: `2px solid ${textColor3}`, circleBorderInfo: `2px solid ${infoColor}`, circleBorderError: `2px solid ${errorColor}`, circleBorderSuccess: `2px solid ${successColor}`, circleBorderWarning: `2px solid ${warningColor}`, iconColor: textColor3, iconColorInfo: infoColor, iconColorError: errorColor, iconColorSuccess: successColor, iconColorWarning: warningColor, titleTextColor: textColor1, contentTextColor: textColor2, metaTextColor: textColor3, lineColor: railColor });
};
var timelineLight = {
  name: "Timeline",
  common: light_default,
  self: self70
};
var light_default72 = timelineLight;

// node_modules/naive-ui/es/transfer/styles/_common.js
var common_default39 = {
  extraFontSizeSmall: "12px",
  extraFontSizeMedium: "12px",
  extraFontSizeLarge: "14px",
  titleFontSizeSmall: "14px",
  titleFontSizeMedium: "16px",
  titleFontSizeLarge: "16px",
  closeSize: "20px",
  closeIconSize: "16px",
  headerHeightSmall: "44px",
  headerHeightMedium: "44px",
  headerHeightLarge: "50px"
};

// node_modules/naive-ui/es/transfer/styles/dark.js
var transferDark = {
  name: "Transfer",
  common: dark_default,
  peers: {
    Checkbox: dark_default22,
    Scrollbar: dark_default3,
    Input: dark_default10,
    Empty: dark_default2,
    Button: dark_default17
  },
  self(vars) {
    const { fontWeight, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, borderRadius, inputColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, textColor3, hoverColor, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, dividerColor } = vars;
    return Object.assign(Object.assign({}, common_default39), {
      itemHeightSmall: heightMedium,
      itemHeightMedium: heightMedium,
      itemHeightLarge: heightLarge,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      borderRadius,
      dividerColor,
      borderColor: "#0000",
      listColor: inputColor,
      headerColor: tableHeaderColor,
      titleTextColor: textColor1,
      titleTextColorDisabled: textColorDisabled,
      extraTextColor: textColor3,
      extraTextColorDisabled: textColorDisabled,
      itemTextColor: textColor2,
      itemTextColorDisabled: textColorDisabled,
      itemColorPending: hoverColor,
      titleFontWeight: fontWeight,
      closeColorHover,
      closeColorPressed,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed
    });
  }
};
var dark_default73 = transferDark;

// node_modules/naive-ui/es/transfer/styles/light.js
var self71 = (vars) => {
  const { fontWeight, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, borderRadius, cardColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, textColor3, borderColor, hoverColor, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed } = vars;
  return Object.assign(Object.assign({}, common_default39), {
    itemHeightSmall: heightMedium,
    itemHeightMedium: heightMedium,
    itemHeightLarge: heightLarge,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    borderRadius,
    dividerColor: borderColor,
    borderColor,
    listColor: cardColor,
    headerColor: composite(cardColor, tableHeaderColor),
    titleTextColor: textColor1,
    titleTextColorDisabled: textColorDisabled,
    extraTextColor: textColor3,
    extraTextColorDisabled: textColorDisabled,
    itemTextColor: textColor2,
    itemTextColorDisabled: textColorDisabled,
    itemColorPending: hoverColor,
    titleFontWeight: fontWeight,
    closeColorHover,
    closeColorPressed,
    closeIconColor,
    closeIconColorHover,
    closeIconColorPressed
  });
};
var transferLight = createTheme({
  name: "Transfer",
  common: light_default,
  peers: {
    Checkbox: light_default22,
    Scrollbar: light_default3,
    Input: light_default10,
    Empty: light_default2,
    Button: light_default17
  },
  self: self71
});
var light_default73 = transferLight;

// node_modules/naive-ui/es/tree/styles/light.js
var self72 = (vars) => {
  const { borderRadiusSmall, hoverColor, pressedColor, primaryColor, textColor3, textColor2, textColorDisabled, fontSize: fontSize2 } = vars;
  return {
    fontSize: fontSize2,
    nodeBorderRadius: borderRadiusSmall,
    nodeColorHover: hoverColor,
    nodeColorPressed: pressedColor,
    nodeColorActive: changeColor(primaryColor, { alpha: 0.1 }),
    arrowColor: textColor3,
    nodeTextColor: textColor2,
    nodeTextColorDisabled: textColorDisabled,
    loadingColor: primaryColor,
    dropMarkColor: primaryColor
  };
};
var treeLight = createTheme({
  name: "Tree",
  common: light_default,
  peers: {
    Checkbox: light_default22,
    Scrollbar: light_default3,
    Empty: light_default2
  },
  self: self72
});
var light_default74 = treeLight;

// node_modules/naive-ui/es/tree/styles/dark.js
var treeDark = {
  name: "Tree",
  common: dark_default,
  peers: {
    Checkbox: dark_default22,
    Scrollbar: dark_default3,
    Empty: dark_default2
  },
  self(vars) {
    const { primaryColor } = vars;
    const commonSelf = self72(vars);
    commonSelf.nodeColorActive = changeColor(primaryColor, { alpha: 0.15 });
    return commonSelf;
  }
};
var dark_default74 = treeDark;

// node_modules/naive-ui/es/tree-select/styles/dark.js
var treeSelectDark = {
  name: "TreeSelect",
  common: dark_default,
  peers: {
    Tree: dark_default74,
    Empty: dark_default2,
    InternalSelection: dark_default7
  }
};
var dark_default75 = treeSelectDark;

// node_modules/naive-ui/es/tree-select/styles/light.js
var self73 = (vars) => {
  const { popoverColor, boxShadow2, borderRadius, heightMedium, dividerColor, textColor2 } = vars;
  return {
    menuPadding: "4px",
    menuColor: popoverColor,
    menuBoxShadow: boxShadow2,
    menuBorderRadius: borderRadius,
    menuHeight: `calc(${heightMedium} * 7.6)`,
    actionDividerColor: dividerColor,
    actionTextColor: textColor2,
    actionPadding: "8px 12px"
  };
};
var treeSelectLight = createTheme({
  name: "TreeSelect",
  common: light_default,
  peers: {
    Tree: light_default74,
    Empty: light_default2,
    InternalSelection: light_default7
  },
  self: self73
});
var light_default75 = treeSelectLight;

// node_modules/naive-ui/es/typography/styles/_common.js
var common_default40 = {
  headerFontSize1: "30px",
  headerFontSize2: "22px",
  headerFontSize3: "18px",
  headerFontSize4: "16px",
  headerFontSize5: "16px",
  headerFontSize6: "16px",
  headerMargin1: "28px 0 20px 0",
  headerMargin2: "28px 0 20px 0",
  headerMargin3: "28px 0 20px 0",
  headerMargin4: "28px 0 18px 0",
  headerMargin5: "28px 0 18px 0",
  headerMargin6: "28px 0 18px 0",
  headerPrefixWidth1: "16px",
  headerPrefixWidth2: "16px",
  headerPrefixWidth3: "12px",
  headerPrefixWidth4: "12px",
  headerPrefixWidth5: "12px",
  headerPrefixWidth6: "12px",
  headerBarWidth1: "4px",
  headerBarWidth2: "4px",
  headerBarWidth3: "3px",
  headerBarWidth4: "3px",
  headerBarWidth5: "3px",
  headerBarWidth6: "3px",
  pMargin: "16px 0 16px 0",
  liMargin: ".25em 0 0 0",
  olPadding: "0 0 0 2em",
  ulPadding: "0 0 0 2em"
};

// node_modules/naive-ui/es/typography/styles/light.js
var self74 = (vars) => {
  const { primaryColor, textColor2, borderColor, lineHeight: lineHeight3, fontSize: fontSize2, borderRadiusSmall, dividerColor, fontWeightStrong, textColor1, textColor3, infoColor, warningColor, errorColor, successColor, codeColor } = vars;
  return Object.assign(Object.assign({}, common_default40), { aTextColor: primaryColor, blockquoteTextColor: textColor2, blockquotePrefixColor: borderColor, blockquoteLineHeight: lineHeight3, blockquoteFontSize: fontSize2, codeBorderRadius: borderRadiusSmall, liTextColor: textColor2, liLineHeight: lineHeight3, liFontSize: fontSize2, hrColor: dividerColor, headerFontWeight: fontWeightStrong, headerTextColor: textColor1, pTextColor: textColor2, pTextColor1Depth: textColor1, pTextColor2Depth: textColor2, pTextColor3Depth: textColor3, pLineHeight: lineHeight3, pFontSize: fontSize2, headerBarColor: primaryColor, headerBarColorPrimary: primaryColor, headerBarColorInfo: infoColor, headerBarColorError: errorColor, headerBarColorWarning: warningColor, headerBarColorSuccess: successColor, textColor: textColor2, textColor1Depth: textColor1, textColor2Depth: textColor2, textColor3Depth: textColor3, textColorPrimary: primaryColor, textColorInfo: infoColor, textColorSuccess: successColor, textColorWarning: warningColor, textColorError: errorColor, codeTextColor: textColor2, codeColor, codeBorder: "1px solid #0000" });
};
var typographyLight = {
  name: "Typography",
  common: light_default,
  self: self74
};
var light_default76 = typographyLight;

// node_modules/naive-ui/es/typography/styles/dark.js
var typographyDark = {
  name: "Typography",
  common: dark_default,
  self: self74
};
var dark_default76 = typographyDark;

// node_modules/naive-ui/es/upload/styles/light.js
var self75 = (vars) => {
  const { iconColor, primaryColor, errorColor, textColor2, successColor, opacityDisabled, actionColor, borderColor, hoverColor, lineHeight: lineHeight3, borderRadius, fontSize: fontSize2 } = vars;
  return {
    fontSize: fontSize2,
    lineHeight: lineHeight3,
    borderRadius,
    draggerColor: actionColor,
    draggerBorder: `1px dashed ${borderColor}`,
    draggerBorderHover: `1px dashed ${primaryColor}`,
    itemColorHover: hoverColor,
    itemColorHoverError: changeColor(errorColor, {
      alpha: 0.06
    }),
    itemTextColor: textColor2,
    itemTextColorError: errorColor,
    itemTextColorSuccess: successColor,
    itemIconColor: iconColor,
    itemDisabledOpacity: opacityDisabled,
    itemBorderImageCardError: `1px solid ${errorColor}`,
    itemBorderImageCard: `1px solid ${borderColor}`
  };
};
var uploadLight = createTheme({
  name: "Upload",
  common: light_default,
  peers: {
    Button: light_default17,
    Progress: light_default61
  },
  self: self75
});
var light_default77 = uploadLight;

// node_modules/naive-ui/es/upload/styles/dark.js
var uploadDark = {
  name: "Upload",
  common: dark_default,
  peers: {
    Button: dark_default17,
    Progress: dark_default61
  },
  self(vars) {
    const { errorColor } = vars;
    const commonSelf = self75(vars);
    commonSelf.itemColorHoverError = changeColor(errorColor, {
      alpha: 0.09
    });
    return commonSelf;
  }
};
var dark_default77 = uploadDark;

// node_modules/naive-ui/es/watermark/styles/dark.js
var watermarkDark = {
  name: "Watermark",
  common: dark_default,
  self(vars) {
    const { fontFamily: fontFamily2 } = vars;
    return {
      fontFamily: fontFamily2
    };
  }
};
var dark_default78 = watermarkDark;

// node_modules/naive-ui/es/watermark/styles/light.js
var watermarkLight = createTheme({
  name: "Watermark",
  common: light_default,
  self(vars) {
    const { fontFamily: fontFamily2 } = vars;
    return {
      fontFamily: fontFamily2
    };
  }
});
var light_default78 = watermarkLight;

// node_modules/naive-ui/es/legacy-grid/styles/light.js
var rowLight = {
  name: "Row",
  common: light_default
};
var light_default79 = rowLight;

// node_modules/naive-ui/es/legacy-grid/styles/dark.js
var rowDark = {
  name: "Row",
  common: dark_default
};
var dark_default79 = rowDark;

// node_modules/naive-ui/es/image/styles/dark.js
var imageDark = {
  name: "Image",
  common: dark_default,
  peers: {
    Tooltip: dark_default30
  },
  self: (vars) => {
    const { textColor2 } = vars;
    return {
      toolbarIconColor: textColor2,
      toolbarColor: "rgba(0, 0, 0, .35)",
      toolbarBoxShadow: "none",
      toolbarBorderRadius: "24px"
    };
  }
};

// node_modules/naive-ui/es/legacy-transfer/styles/_common.js
var common_default41 = {
  extraFontSize: "12px",
  width: "440px"
};

// node_modules/naive-ui/es/legacy-transfer/styles/dark.js
var transferDark2 = {
  name: "Transfer",
  common: dark_default,
  peers: {
    Checkbox: dark_default22,
    Scrollbar: dark_default3,
    Input: dark_default10,
    Empty: dark_default2,
    Button: dark_default17
  },
  self(vars) {
    const { iconColorDisabled, iconColor, fontWeight, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, heightSmall, borderRadius, inputColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, hoverColor } = vars;
    return Object.assign(Object.assign({}, common_default41), {
      itemHeightSmall: heightSmall,
      itemHeightMedium: heightMedium,
      itemHeightLarge: heightLarge,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      borderRadius,
      borderColor: "#0000",
      listColor: inputColor,
      headerColor: tableHeaderColor,
      titleTextColor: textColor1,
      titleTextColorDisabled: textColorDisabled,
      extraTextColor: textColor2,
      filterDividerColor: "#0000",
      itemTextColor: textColor2,
      itemTextColorDisabled: textColorDisabled,
      itemColorPending: hoverColor,
      titleFontWeight: fontWeight,
      iconColor,
      iconColorDisabled
    });
  }
};
var dark_default80 = transferDark2;

// node_modules/naive-ui/es/legacy-transfer/styles/light.js
var self76 = (vars) => {
  const { fontWeight, iconColorDisabled, iconColor, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, heightSmall, borderRadius, cardColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, borderColor, hoverColor } = vars;
  return Object.assign(Object.assign({}, common_default41), {
    itemHeightSmall: heightSmall,
    itemHeightMedium: heightMedium,
    itemHeightLarge: heightLarge,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    borderRadius,
    borderColor,
    listColor: cardColor,
    headerColor: composite(cardColor, tableHeaderColor),
    titleTextColor: textColor1,
    titleTextColorDisabled: textColorDisabled,
    extraTextColor: textColor2,
    filterDividerColor: borderColor,
    itemTextColor: textColor2,
    itemTextColorDisabled: textColorDisabled,
    itemColorPending: hoverColor,
    titleFontWeight: fontWeight,
    iconColor,
    iconColorDisabled
  });
};
var transferLight2 = createTheme({
  name: "Transfer",
  common: light_default,
  peers: {
    Checkbox: light_default22,
    Scrollbar: light_default3,
    Input: light_default10,
    Empty: light_default2,
    Button: light_default17
  },
  self: self76
});
var light_default80 = transferLight2;

// node_modules/naive-ui/es/list/src/styles/index.cssr.js
var index_cssr_default17 = c3([cB("list", `
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `, [cM("show-divider", [cB("list-item", [c3("&:not(:last-child)", [cE("divider", `
 background-color: var(--n-merged-border-color);
 `)])])]), cM("clickable", [cB("list-item", `
 cursor: pointer;
 `)]), cM("bordered", `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `), cM("hoverable", [cB("list-item", `
 border-radius: var(--n-border-radius);
 `, [c3("&:hover", `
 background-color: var(--n-merged-color-hover);
 `, [cE("divider", `
 background-color: transparent;
 `)])])]), cM("bordered, hoverable", [cB("list-item", `
 padding: 12px 20px;
 `), cE("header, footer", `
 padding: 12px 20px;
 `)]), cE("header, footer", `
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [c3("&:not(:last-child)", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]), cB("list-item", `
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cE("prefix", `
 margin-right: 20px;
 flex: 0;
 `), cE("suffix", `
 margin-left: 20px;
 flex: 0;
 `), cE("main", `
 flex: 1;
 `), cE("divider", `
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]), insideModal(cB("list", `
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), insidePopover(cB("list", `
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]);

// node_modules/naive-ui/es/list/src/List.js
var listProps = Object.assign(Object.assign({}, use_theme_default.props), { size: {
  type: String,
  default: "medium"
}, bordered: Boolean, clickable: Boolean, hoverable: Boolean, showDivider: {
  type: Boolean,
  default: true
} });
var listInjectionKey = createInjectionKey("n-list");
var List_default = defineComponent({
  name: "List",
  props: listProps,
  setup(props) {
    const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
    const rtlEnabledRef = useRtl("List", mergedRtlRef, mergedClsPrefixRef);
    const themeRef = use_theme_default("List", "-list", index_cssr_default17, light_default55, props, mergedClsPrefixRef);
    provide(listInjectionKey, {
      showDividerRef: toRef(props, "showDivider"),
      mergedClsPrefixRef
    });
    const cssVarsRef = computed2(() => {
      const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut5 }, self: { fontSize: fontSize2, textColor, color: color2, colorModal, colorPopover, borderColor, borderColorModal, borderColorPopover, borderRadius, colorHover, colorHoverModal, colorHoverPopover } } = themeRef.value;
      return {
        "--n-font-size": fontSize2,
        "--n-bezier": cubicBezierEaseInOut5,
        "--n-text-color": textColor,
        "--n-color": color2,
        "--n-border-radius": borderRadius,
        "--n-border-color": borderColor,
        "--n-border-color-modal": borderColorModal,
        "--n-border-color-popover": borderColorPopover,
        "--n-color-modal": colorModal,
        "--n-color-popover": colorPopover,
        "--n-color-hover": colorHover,
        "--n-color-hover-modal": colorHoverModal,
        "--n-color-hover-popover": colorHoverPopover
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("list", void 0, cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      rtlEnabled: rtlEnabledRef,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    var _a3;
    const { $slots, mergedClsPrefix, onRender } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return h3("ul", { class: [
      `${mergedClsPrefix}-list`,
      this.rtlEnabled && `${mergedClsPrefix}-list--rtl`,
      this.bordered && `${mergedClsPrefix}-list--bordered`,
      this.showDivider && `${mergedClsPrefix}-list--show-divider`,
      this.hoverable && `${mergedClsPrefix}-list--hoverable`,
      this.clickable && `${mergedClsPrefix}-list--clickable`,
      this.themeClass
    ], style: this.cssVars }, $slots.header ? h3("div", { class: `${mergedClsPrefix}-list__header` }, $slots.header()) : null, (_a3 = $slots.default) === null || _a3 === void 0 ? void 0 : _a3.call($slots), $slots.footer ? h3("div", { class: `${mergedClsPrefix}-list__footer` }, $slots.footer()) : null);
  }
});

// node_modules/naive-ui/es/list/src/ListItem.js
var ListItem_default = defineComponent({
  name: "ListItem",
  setup() {
    const listInjection = inject(listInjectionKey, null);
    if (!listInjection) {
      throwError("list-item", "`n-list-item` must be placed in `n-list`.");
    }
    return {
      showDivider: listInjection.showDividerRef,
      mergedClsPrefix: listInjection.mergedClsPrefixRef
    };
  },
  render() {
    const { $slots, mergedClsPrefix } = this;
    return h3("li", { class: `${mergedClsPrefix}-list-item` }, $slots.prefix ? h3("div", { class: `${mergedClsPrefix}-list-item__prefix` }, $slots.prefix()) : null, $slots.default ? h3("div", { class: `${mergedClsPrefix}-list-item__main` }, $slots) : null, $slots.suffix ? h3("div", { class: `${mergedClsPrefix}-list-item__suffix` }, $slots.suffix()) : null, this.showDivider && h3("div", { class: `${mergedClsPrefix}-list-item__divider` }));
  }
});

// node_modules/naive-ui/es/message/src/message-props.js
var messageProps = {
  icon: Function,
  type: {
    type: String,
    default: "info"
  },
  content: [String, Number, Function],
  showIcon: {
    type: Boolean,
    default: true
  },
  closable: Boolean,
  keepAliveOnHover: Boolean,
  onClose: Function,
  onMouseenter: Function,
  onMouseleave: Function
};

// node_modules/naive-ui/es/message/src/context.js
var messageApiInjectionKey = createInjectionKey("n-message-api");
var messageProviderInjectionKey = createInjectionKey("n-message-provider");

// node_modules/naive-ui/es/message/src/styles/index.cssr.js
var index_cssr_default18 = c3([cB("message-wrapper", `
 margin: var(--n-margin);
 z-index: 0;
 transform-origin: top center;
 display: flex;
 `, [fadeInHeightExpandTransition({
  overflow: "visible",
  originalTransition: "transform .3s var(--n-bezier)",
  enterToProps: {
    transform: "scale(1)"
  },
  leaveToProps: {
    transform: "scale(0.85)"
  }
})]), cB("message", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier),
 margin-bottom .3s var(--n-bezier);
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 flex-wrap: nowrap;
 overflow: hidden;
 max-width: var(--n-max-width);
 color: var(--n-text-color);
 background-color: var(--n-color);
 box-shadow: var(--n-box-shadow);
 `, [cE("content", `
 display: inline-block;
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 `), cE("icon", `
 position: relative;
 margin: var(--n-icon-margin);
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 flex-shrink: 0;
 `, [["default", "info", "success", "warning", "error", "loading"].map((type) => cM(`${type}-type`, [c3("> *", `
 color: var(--n-icon-color-${type});
 transition: color .3s var(--n-bezier);
 `)])), c3("> *", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 `, [iconSwitchTransition()])]), cE("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 flex-shrink: 0;
 `, [c3("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c3("&:active", `
 color: var(--n-close-icon-color-pressed);
 `)])]), cB("message-container", `
 z-index: 6000;
 position: fixed;
 height: 0;
 overflow: visible;
 display: flex;
 flex-direction: column;
 align-items: center;
 `, [cM("top", `
 top: 12px;
 left: 0;
 right: 0;
 `), cM("top-left", `
 top: 12px;
 left: 12px;
 right: 0;
 align-items: flex-start;
 `), cM("top-right", `
 top: 12px;
 left: 0;
 right: 12px;
 align-items: flex-end;
 `), cM("bottom", `
 bottom: 4px;
 left: 0;
 right: 0;
 justify-content: flex-end;
 `), cM("bottom-left", `
 bottom: 4px;
 left: 12px;
 right: 0;
 justify-content: flex-end;
 align-items: flex-start;
 `), cM("bottom-right", `
 bottom: 4px;
 left: 0;
 right: 12px;
 justify-content: flex-end;
 align-items: flex-end;
 `)])]);

// node_modules/naive-ui/es/message/src/Message.js
var iconRenderMap = {
  info: () => h3(Info_default, null),
  success: () => h3(Success_default, null),
  warning: () => h3(Warning_default, null),
  error: () => h3(Error_default, null),
  default: () => null
};
var Message_default = defineComponent({
  name: "Message",
  props: Object.assign(Object.assign({}, messageProps), { render: Function }),
  setup(props) {
    const { inlineThemeDisabled, mergedRtlRef } = useConfig(props);
    const {
      props: messageProviderProps2,
      mergedClsPrefixRef
    } = inject(messageProviderInjectionKey);
    const rtlEnabledRef = useRtl("Message", mergedRtlRef, mergedClsPrefixRef);
    const themeRef = use_theme_default("Message", "-message", index_cssr_default18, light_default51, messageProviderProps2, mergedClsPrefixRef);
    const cssVarsRef = computed2(() => {
      const { type } = props;
      const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut5 }, self: { padding, margin, maxWidth, iconMargin, closeMargin, closeSize, iconSize, fontSize: fontSize2, lineHeight: lineHeight3, borderRadius, iconColorInfo, iconColorSuccess, iconColorWarning, iconColorError, iconColorLoading, closeIconSize, closeBorderRadius, [createKey("textColor", type)]: textColor, [createKey("boxShadow", type)]: boxShadow, [createKey("color", type)]: color2, [createKey("closeColorHover", type)]: closeColorHover, [createKey("closeColorPressed", type)]: closeColorPressed, [createKey("closeIconColor", type)]: closeIconColor, [createKey("closeIconColorPressed", type)]: closeIconColorPressed, [createKey("closeIconColorHover", type)]: closeIconColorHover } } = themeRef.value;
      return {
        "--n-bezier": cubicBezierEaseInOut5,
        "--n-margin": margin,
        "--n-padding": padding,
        "--n-max-width": maxWidth,
        "--n-font-size": fontSize2,
        "--n-icon-margin": iconMargin,
        "--n-icon-size": iconSize,
        "--n-close-icon-size": closeIconSize,
        "--n-close-border-radius": closeBorderRadius,
        "--n-close-size": closeSize,
        "--n-close-margin": closeMargin,
        "--n-text-color": textColor,
        "--n-color": color2,
        "--n-box-shadow": boxShadow,
        "--n-icon-color-info": iconColorInfo,
        "--n-icon-color-success": iconColorSuccess,
        "--n-icon-color-warning": iconColorWarning,
        "--n-icon-color-error": iconColorError,
        "--n-icon-color-loading": iconColorLoading,
        "--n-close-color-hover": closeColorHover,
        "--n-close-color-pressed": closeColorPressed,
        "--n-close-icon-color": closeIconColor,
        "--n-close-icon-color-pressed": closeIconColorPressed,
        "--n-close-icon-color-hover": closeIconColorHover,
        "--n-line-height": lineHeight3,
        "--n-border-radius": borderRadius
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("message", computed2(() => props.type[0]), cssVarsRef, {}) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      rtlEnabled: rtlEnabledRef,
      messageProviderProps: messageProviderProps2,
      handleClose() {
        var _a3;
        (_a3 = props.onClose) === null || _a3 === void 0 ? void 0 : _a3.call(props);
      },
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
      placement: messageProviderProps2.placement
    };
  },
  render() {
    const { render: renderMessage, type, closable, content, mergedClsPrefix, cssVars, themeClass, onRender, icon, handleClose, showIcon } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    let iconNode;
    return h3("div", { class: [`${mergedClsPrefix}-message-wrapper`, themeClass], onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave, style: [
      {
        alignItems: this.placement.startsWith("top") ? "flex-start" : "flex-end"
      },
      cssVars
    ] }, renderMessage ? renderMessage(this.$props) : h3("div", { class: [
      `${mergedClsPrefix}-message ${mergedClsPrefix}-message--${type}-type`,
      this.rtlEnabled && `${mergedClsPrefix}-message--rtl`
    ] }, (iconNode = createIconVNode(icon, type, mergedClsPrefix)) && showIcon ? h3("div", { class: `${mergedClsPrefix}-message__icon ${mergedClsPrefix}-message__icon--${type}-type` }, h3(IconSwitchTransition_default, null, {
      default: () => iconNode
    })) : null, h3("div", { class: `${mergedClsPrefix}-message__content` }, render(content)), closable ? h3(Close_default2, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-message__close`, onClick: handleClose, absolute: true }) : null));
  }
});
function createIconVNode(icon, type, clsPrefix) {
  if (typeof icon === "function") {
    return icon();
  } else {
    const innerIcon = type === "loading" ? h3(Loading_default, { clsPrefix, strokeWidth: 24, scale: 0.85 }) : iconRenderMap[type]();
    if (!innerIcon)
      return null;
    return h3(Icon_default, { clsPrefix, key: type }, {
      default: () => innerIcon
    });
  }
}

// node_modules/naive-ui/es/message/src/MessageEnvironment.js
var MessageEnvironment_default = defineComponent({
  name: "MessageEnvironment",
  props: Object.assign(Object.assign({}, messageProps), {
    duration: {
      type: Number,
      default: 3e3
    },
    onAfterLeave: Function,
    onLeave: Function,
    internalKey: {
      type: String,
      required: true
    },
    onInternalAfterLeave: Function,
    onHide: Function,
    onAfterHide: Function
  }),
  setup(props) {
    let timerId = null;
    const showRef = ref(true);
    onMounted(() => {
      setHideTimeout();
    });
    function setHideTimeout() {
      const { duration } = props;
      if (duration) {
        timerId = window.setTimeout(hide, duration);
      }
    }
    function handleMouseenter(e3) {
      if (e3.currentTarget !== e3.target)
        return;
      if (timerId !== null) {
        window.clearTimeout(timerId);
        timerId = null;
      }
    }
    function handleMouseleave(e3) {
      if (e3.currentTarget !== e3.target)
        return;
      setHideTimeout();
    }
    function hide() {
      const { onHide } = props;
      showRef.value = false;
      if (timerId) {
        window.clearTimeout(timerId);
        timerId = null;
      }
      if (onHide)
        onHide();
    }
    function handleClose() {
      const { onClose } = props;
      if (onClose)
        onClose();
      hide();
    }
    function handleAfterLeave() {
      const { onAfterLeave, onInternalAfterLeave, onAfterHide, internalKey } = props;
      if (onAfterLeave)
        onAfterLeave();
      if (onInternalAfterLeave)
        onInternalAfterLeave(internalKey);
      if (onAfterHide)
        onAfterHide();
    }
    function deactivate() {
      hide();
    }
    return {
      show: showRef,
      hide,
      handleClose,
      handleAfterLeave,
      handleMouseleave,
      handleMouseenter,
      deactivate
    };
  },
  render() {
    return h3(FadeInExpandTransition_default, { appear: true, onAfterLeave: this.handleAfterLeave, onLeave: this.onLeave }, {
      default: () => [
        this.show ? h3(Message_default, { content: this.content, type: this.type, icon: this.icon, showIcon: this.showIcon, closable: this.closable, onClose: this.handleClose, onMouseenter: this.keepAliveOnHover ? this.handleMouseenter : void 0, onMouseleave: this.keepAliveOnHover ? this.handleMouseleave : void 0 }) : null
      ]
    });
  }
});

// node_modules/naive-ui/es/message/src/MessageProvider.js
var messageProviderProps = Object.assign(Object.assign({}, use_theme_default.props), { to: [String, Object], duration: {
  type: Number,
  default: 3e3
}, keepAliveOnHover: Boolean, max: Number, placement: {
  type: String,
  default: "top"
}, closable: Boolean, containerStyle: [String, Object] });
var MessageProvider_default = defineComponent({
  name: "MessageProvider",
  props: messageProviderProps,
  setup(props) {
    const { mergedClsPrefixRef } = useConfig(props);
    const messageListRef = ref([]);
    const messageRefs = ref({});
    const api = {
      create(content, options) {
        return create(content, Object.assign({ type: "default" }, options));
      },
      info(content, options) {
        return create(content, Object.assign(Object.assign({}, options), { type: "info" }));
      },
      success(content, options) {
        return create(content, Object.assign(Object.assign({}, options), { type: "success" }));
      },
      warning(content, options) {
        return create(content, Object.assign(Object.assign({}, options), { type: "warning" }));
      },
      error(content, options) {
        return create(content, Object.assign(Object.assign({}, options), { type: "error" }));
      },
      loading(content, options) {
        return create(content, Object.assign(Object.assign({}, options), { type: "loading" }));
      },
      destroyAll
    };
    provide(messageProviderInjectionKey, {
      props,
      mergedClsPrefixRef
    });
    provide(messageApiInjectionKey, api);
    function create(content, options) {
      const key = createId();
      const messageReactive = reactive(Object.assign(Object.assign({}, options), {
        content,
        key,
        destroy: () => {
          var _a3;
          (_a3 = messageRefs.value[key]) === null || _a3 === void 0 ? void 0 : _a3.hide();
        }
      }));
      const { max } = props;
      if (max && messageListRef.value.length >= max) {
        messageListRef.value.shift();
      }
      messageListRef.value.push(messageReactive);
      return messageReactive;
    }
    function handleAfterLeave(key) {
      messageListRef.value.splice(messageListRef.value.findIndex((message) => message.key === key), 1);
      delete messageRefs.value[key];
    }
    function destroyAll() {
      Object.values(messageRefs.value).forEach((messageInstRef) => {
        messageInstRef.hide();
      });
    }
    return Object.assign({
      mergedClsPrefix: mergedClsPrefixRef,
      messageRefs,
      messageList: messageListRef,
      handleAfterLeave
    }, api);
  },
  render() {
    var _a3, _b2, _c;
    return h3(Fragment, null, (_b2 = (_a3 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a3), this.messageList.length ? h3(Teleport, { to: (_c = this.to) !== null && _c !== void 0 ? _c : "body" }, h3("div", { class: [
      `${this.mergedClsPrefix}-message-container`,
      `${this.mergedClsPrefix}-message-container--${this.placement}`
    ], key: "message-container", style: this.containerStyle }, this.messageList.map((message) => {
      return h3(MessageEnvironment_default, Object.assign({ ref: (inst) => {
        if (inst) {
          this.messageRefs[message.key] = inst;
        }
      }, internalKey: message.key, onInternalAfterLeave: this.handleAfterLeave }, omit(message, ["destroy"], void 0), { duration: message.duration === void 0 ? this.duration : message.duration, keepAliveOnHover: message.keepAliveOnHover === void 0 ? this.keepAliveOnHover : message.keepAliveOnHover, closable: message.closable === void 0 ? this.closable : message.closable }));
    }))) : null);
  }
});

// node_modules/naive-ui/es/message/src/use-message.js
function useMessage() {
  const api = inject(messageApiInjectionKey, null);
  if (api === null) {
    throwError("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A.");
  }
  return api;
}

// node_modules/naive-ui/es/result/src/404.js
var __default = h3("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" }, h3("circle", { fill: "#FFCB4C", cx: "18", cy: "17.018", r: "17" }), h3("path", { fill: "#65471B", d: "M14.524 21.036c-.145-.116-.258-.274-.312-.464-.134-.46.13-.918.59-1.021 4.528-1.021 7.577 1.363 7.706 1.465.384.306.459.845.173 1.205-.286.358-.828.401-1.211.097-.11-.084-2.523-1.923-6.182-1.098-.274.061-.554-.016-.764-.184z" }), h3("ellipse", { fill: "#65471B", cx: "13.119", cy: "11.174", rx: "2.125", ry: "2.656" }), h3("ellipse", { fill: "#65471B", cx: "24.375", cy: "12.236", rx: "2.125", ry: "2.656" }), h3("path", { fill: "#F19020", d: "M17.276 35.149s1.265-.411 1.429-1.352c.173-.972-.624-1.167-.624-1.167s1.041-.208 1.172-1.376c.123-1.101-.861-1.363-.861-1.363s.97-.4 1.016-1.539c.038-.959-.995-1.428-.995-1.428s5.038-1.221 5.556-1.341c.516-.12 1.32-.615 1.069-1.694-.249-1.08-1.204-1.118-1.697-1.003-.494.115-6.744 1.566-8.9 2.068l-1.439.334c-.54.127-.785-.11-.404-.512.508-.536.833-1.129.946-2.113.119-1.035-.232-2.313-.433-2.809-.374-.921-1.005-1.649-1.734-1.899-1.137-.39-1.945.321-1.542 1.561.604 1.854.208 3.375-.833 4.293-2.449 2.157-3.588 3.695-2.83 6.973.828 3.575 4.377 5.876 7.952 5.048l3.152-.681z" }), h3("path", { fill: "#65471B", d: "M9.296 6.351c-.164-.088-.303-.224-.391-.399-.216-.428-.04-.927.393-1.112 4.266-1.831 7.699-.043 7.843.034.433.231.608.747.391 1.154-.216.405-.74.546-1.173.318-.123-.063-2.832-1.432-6.278.047-.257.109-.547.085-.785-.042zm12.135 3.75c-.156-.098-.286-.243-.362-.424-.187-.442.023-.927.468-1.084 4.381-1.536 7.685.48 7.823.567.415.26.555.787.312 1.178-.242.39-.776.495-1.191.238-.12-.072-2.727-1.621-6.267-.379-.266.091-.553.046-.783-.096z" }));

// node_modules/naive-ui/es/result/src/500.js
var __default2 = h3("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" }, h3("path", { fill: "#FFCC4D", d: "M36 18c0 9.941-8.059 18-18 18-9.94 0-18-8.059-18-18C0 8.06 8.06 0 18 0c9.941 0 18 8.06 18 18" }), h3("ellipse", { fill: "#664500", cx: "18", cy: "27", rx: "5", ry: "6" }), h3("path", { fill: "#664500", d: "M5.999 11c-.208 0-.419-.065-.599-.2-.442-.331-.531-.958-.2-1.4C8.462 5.05 12.816 5 13 5c.552 0 1 .448 1 1 0 .551-.445.998-.996 1-.155.002-3.568.086-6.204 3.6-.196.262-.497.4-.801.4zm24.002 0c-.305 0-.604-.138-.801-.4-2.64-3.521-6.061-3.598-6.206-3.6-.55-.006-.994-.456-.991-1.005C22.006 5.444 22.45 5 23 5c.184 0 4.537.05 7.8 4.4.332.442.242 1.069-.2 1.4-.18.135-.39.2-.599.2zm-16.087 4.5l1.793-1.793c.391-.391.391-1.023 0-1.414s-1.023-.391-1.414 0L12.5 14.086l-1.793-1.793c-.391-.391-1.023-.391-1.414 0s-.391 1.023 0 1.414l1.793 1.793-1.793 1.793c-.391.391-.391 1.023 0 1.414.195.195.451.293.707.293s.512-.098.707-.293l1.793-1.793 1.793 1.793c.195.195.451.293.707.293s.512-.098.707-.293c.391-.391.391-1.023 0-1.414L13.914 15.5zm11 0l1.793-1.793c.391-.391.391-1.023 0-1.414s-1.023-.391-1.414 0L23.5 14.086l-1.793-1.793c-.391-.391-1.023-.391-1.414 0s-.391 1.023 0 1.414l1.793 1.793-1.793 1.793c-.391.391-.391 1.023 0 1.414.195.195.451.293.707.293s.512-.098.707-.293l1.793-1.793 1.793 1.793c.195.195.451.293.707.293s.512-.098.707-.293c.391-.391.391-1.023 0-1.414L24.914 15.5z" }));

// node_modules/naive-ui/es/result/src/418.js
var __default3 = h3("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" }, h3("ellipse", { fill: "#292F33", cx: "18", cy: "26", rx: "18", ry: "10" }), h3("ellipse", { fill: "#66757F", cx: "18", cy: "24", rx: "18", ry: "10" }), h3("path", { fill: "#E1E8ED", d: "M18 31C3.042 31 1 16 1 12h34c0 2-1.958 19-17 19z" }), h3("path", { fill: "#77B255", d: "M35 12.056c0 5.216-7.611 9.444-17 9.444S1 17.271 1 12.056C1 6.84 8.611 3.611 18 3.611s17 3.229 17 8.445z" }), h3("ellipse", { fill: "#A6D388", cx: "18", cy: "13", rx: "15", ry: "7" }), h3("path", { d: "M21 17c-.256 0-.512-.098-.707-.293-2.337-2.337-2.376-4.885-.125-8.262.739-1.109.9-2.246.478-3.377-.461-1.236-1.438-1.996-1.731-2.077-.553 0-.958-.443-.958-.996 0-.552.491-.995 1.043-.995.997 0 2.395 1.153 3.183 2.625 1.034 1.933.91 4.039-.351 5.929-1.961 2.942-1.531 4.332-.125 5.738.391.391.391 1.023 0 1.414-.195.196-.451.294-.707.294zm-6-2c-.256 0-.512-.098-.707-.293-2.337-2.337-2.376-4.885-.125-8.262.727-1.091.893-2.083.494-2.947-.444-.961-1.431-1.469-1.684-1.499-.552 0-.989-.447-.989-1 0-.552.458-1 1.011-1 .997 0 2.585.974 3.36 2.423.481.899 1.052 2.761-.528 5.131-1.961 2.942-1.531 4.332-.125 5.738.391.391.391 1.023 0 1.414-.195.197-.451.295-.707.295z", fill: "#5C913B" }));

// node_modules/naive-ui/es/result/src/403.js
var __default4 = h3("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" }, h3("path", { fill: "#EF9645", d: "M15.5 2.965c1.381 0 2.5 1.119 2.5 2.5v.005L20.5.465c1.381 0 2.5 1.119 2.5 2.5V4.25l2.5-1.535c1.381 0 2.5 1.119 2.5 2.5V8.75L29 18H15.458L15.5 2.965z" }), h3("path", { fill: "#FFDC5D", d: "M4.625 16.219c1.381-.611 3.354.208 4.75 2.188.917 1.3 1.187 3.151 2.391 3.344.46.073 1.234-.313 1.234-1.397V4.5s0-2 2-2 2 2 2 2v11.633c0-.029 1-.064 1-.082V2s0-2 2-2 2 2 2 2v14.053c0 .017 1 .041 1 .069V4.25s0-2 2-2 2 2 2 2v12.638c0 .118 1 .251 1 .398V8.75s0-2 2-2 2 2 2 2V24c0 6.627-5.373 12-12 12-4.775 0-8.06-2.598-9.896-5.292C8.547 28.423 8.096 26.051 8 25.334c0 0-.123-1.479-1.156-2.865-1.469-1.969-2.5-3.156-3.125-3.866-.317-.359-.625-1.707.906-2.384z" }));

// node_modules/naive-ui/es/result/src/styles/index.cssr.js
var index_cssr_default19 = cB("result", `
 color: var(--n-text-color);
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier);
`, [cB("result-icon", `
 display: flex;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `, [cE("status-image", `
 font-size: var(--n-icon-size);
 width: 1em;
 height: 1em;
 `), cB("base-icon", `
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), cB("result-content", {
  marginTop: "24px"
}), cB("result-footer", `
 margin-top: 24px;
 text-align: center;
 `), cB("result-header", [cE("title", `
 margin-top: 16px;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 text-align: center;
 color: var(--n-title-text-color);
 font-size: var(--n-title-font-size);
 `), cE("description", `
 margin-top: 4px;
 text-align: center;
 font-size: var(--n-font-size);
 `)])]);

// node_modules/naive-ui/es/result/src/Result.js
var iconMap = {
  403: __default4,
  404: __default,
  418: __default3,
  500: __default2,
  info: h3(Info_default, null),
  success: h3(Success_default, null),
  warning: h3(Warning_default, null),
  error: h3(Error_default, null)
};
var resultProps = Object.assign(Object.assign({}, use_theme_default.props), { size: {
  type: String,
  default: "medium"
}, status: {
  type: String,
  default: "info"
}, title: String, description: String });
var Result_default = defineComponent({
  name: "Result",
  props: resultProps,
  setup(props) {
    const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
    const themeRef = use_theme_default("Result", "-result", index_cssr_default19, light_default63, props, mergedClsPrefixRef);
    const cssVarsRef = computed2(() => {
      const { size: size3, status } = props;
      const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut5 }, self: { textColor, lineHeight: lineHeight3, titleTextColor, titleFontWeight, [createKey("iconColor", status)]: iconColor, [createKey("fontSize", size3)]: fontSize2, [createKey("titleFontSize", size3)]: titleFontSize, [createKey("iconSize", size3)]: iconSize } } = themeRef.value;
      return {
        "--n-bezier": cubicBezierEaseInOut5,
        "--n-font-size": fontSize2,
        "--n-icon-size": iconSize,
        "--n-line-height": lineHeight3,
        "--n-text-color": textColor,
        "--n-title-font-size": titleFontSize,
        "--n-title-font-weight": titleFontWeight,
        "--n-title-text-color": titleTextColor,
        "--n-icon-color": iconColor || ""
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("result", computed2(() => {
      const { size: size3, status } = props;
      let hash = "";
      if (size3) {
        hash += size3[0];
      }
      if (status) {
        hash += status[0];
      }
      return hash;
    }), cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    var _a3;
    const { status, $slots, mergedClsPrefix, onRender } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return h3("div", { class: [`${mergedClsPrefix}-result`, this.themeClass], style: this.cssVars }, h3("div", { class: `${mergedClsPrefix}-result-icon` }, ((_a3 = $slots.icon) === null || _a3 === void 0 ? void 0 : _a3.call($slots)) || h3(Icon_default, { clsPrefix: mergedClsPrefix }, { default: () => iconMap[status] })), h3("div", { class: `${mergedClsPrefix}-result-header` }, this.title ? h3("div", { class: `${mergedClsPrefix}-result-header__title` }, this.title) : null, this.description ? h3("div", { class: `${mergedClsPrefix}-result-header__description` }, this.description) : null), $slots.default && h3("div", { class: `${mergedClsPrefix}-result-content` }, $slots), $slots.footer && h3("div", { class: `${mergedClsPrefix}-result-footer` }, $slots.footer()));
  }
});

// node_modules/naive-ui/es/skeleton/styles/dark.js
var skeletonDark = {
  name: "Skeleton",
  common: dark_default,
  self(vars) {
    const { heightSmall, heightMedium, heightLarge, borderRadius } = vars;
    return {
      color: "rgba(255, 255, 255, 0.12)",
      colorEnd: "rgba(255, 255, 255, 0.18)",
      borderRadius,
      heightSmall,
      heightMedium,
      heightLarge
    };
  }
};

// node_modules/naive-ui/es/skeleton/styles/light.js
var self77 = (vars) => {
  const { heightSmall, heightMedium, heightLarge, borderRadius } = vars;
  return {
    color: "#eee",
    colorEnd: "#ddd",
    borderRadius,
    heightSmall,
    heightMedium,
    heightLarge
  };
};
var skeletonLight = {
  name: "Skeleton",
  common: light_default,
  self: self77
};

// node_modules/naive-ui/es/timeline/src/styles/index.cssr.js
var lineHeight2 = 1.25;
var index_cssr_default20 = cB("timeline", `
 position: relative;
 width: 100%;
 display: flex;
 flex-direction: column;
 line-height: ${lineHeight2};
`, [cM("horizontal", `
 flex-direction: row;
 `, [c3(">", [cB("timeline-item", `
 flex-shrink: 0;
 padding-right: 40px;
 `, [cM("dashed-line-type", [c3(">", [cB("timeline-item-timeline", [cE("line", `
 background-image: linear-gradient(90deg, var(--n-color-start), var(--n-color-start) 50%, transparent 50%, transparent 100%);
 background-size: 10px 1px;
 `)])])]), c3(">", [cB("timeline-item-content", `
 margin-top: calc(var(--n-icon-size) + 12px);
 `, [c3(">", [cE("meta", `
 margin-top: 6px;
 margin-bottom: unset;
 `)])]), cB("timeline-item-timeline", `
 width: 100%;
 height: calc(var(--n-icon-size) + 12px);
 `, [cE("line", `
 left: var(--n-icon-size);
 top: calc(var(--n-icon-size) / 2 - 1px);
 right: 0px;
 width: unset;
 height: 2px;
 `)])])])])]), cM("right-placement", [cB("timeline-item", [cB("timeline-item-content", `
 text-align: right;
 margin-right: calc(var(--n-icon-size) + 12px);
 `), cB("timeline-item-timeline", `
 width: var(--n-icon-size);
 right: 0;
 `)])]), cM("left-placement", [cB("timeline-item", [cB("timeline-item-content", `
 margin-left: calc(var(--n-icon-size) + 12px);
 `), cB("timeline-item-timeline", `
 left: 0;
 `)])]), cB("timeline-item", `
 position: relative;
 `, [c3("&:last-child", [cB("timeline-item-timeline", [cE("line", `
 display: none;
 `)]), cB("timeline-item-content", [cE("meta", `
 margin-bottom: 0;
 `)])]), cB("timeline-item-content", [cE("title", `
 margin: var(--n-title-margin);
 font-size: var(--n-title-font-size);
 transition: color .3s var(--n-bezier);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cE("content", `
 transition: color .3s var(--n-bezier);
 font-size: var(--n-content-font-size);
 color: var(--n-content-text-color);
 `), cE("meta", `
 transition: color .3s var(--n-bezier);
 font-size: 12px;
 margin-top: 6px;
 margin-bottom: 20px;
 color: var(--n-meta-text-color);
 `)]), cM("dashed-line-type", [cB("timeline-item-timeline", [cE("line", `
 --n-color-start: var(--n-line-color);
 transition: --n-color-start .3s var(--n-bezier);
 background-color: transparent;
 background-image: linear-gradient(180deg, var(--n-color-start), var(--n-color-start) 50%, transparent 50%, transparent 100%);
 background-size: 1px 10px;
 `)])]), cB("timeline-item-timeline", `
 width: calc(var(--n-icon-size) + 12px);
 position: absolute;
 top: calc(var(--n-title-font-size) * ${lineHeight2} / 2 - var(--n-icon-size) / 2);
 height: 100%;
 `, [cE("circle", `
 border: var(--n-circle-border);
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 border-radius: var(--n-icon-size);
 box-sizing: border-box;
 `), cE("icon", `
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 display: flex;
 align-items: center;
 justify-content: center;
 `), cE("line", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 top: var(--n-icon-size);
 left: calc(var(--n-icon-size) / 2 - 1px);
 bottom: 0px;
 width: 2px;
 background-color: var(--n-line-color);
 `)])])]);

// node_modules/naive-ui/es/timeline/src/Timeline.js
var timelineProps = Object.assign(Object.assign({}, use_theme_default.props), { horizontal: Boolean, itemPlacement: {
  type: String,
  default: "left"
}, size: {
  type: String,
  default: "medium"
}, iconSize: Number });
var timelineInjectionKey = createInjectionKey("n-timeline");
var Timeline_default = defineComponent({
  name: "Timeline",
  props: timelineProps,
  setup(props, { slots }) {
    const { mergedClsPrefixRef } = useConfig(props);
    const themeRef = use_theme_default("Timeline", "-timeline", index_cssr_default20, light_default72, props, mergedClsPrefixRef);
    provide(timelineInjectionKey, {
      props,
      mergedThemeRef: themeRef,
      mergedClsPrefixRef
    });
    return () => {
      const { value: mergedClsPrefix } = mergedClsPrefixRef;
      return h3("div", { class: [
        `${mergedClsPrefix}-timeline`,
        props.horizontal && `${mergedClsPrefix}-timeline--horizontal`,
        `${mergedClsPrefix}-timeline--${props.size}-size`,
        !props.horizontal && `${mergedClsPrefix}-timeline--${props.itemPlacement}-placement`
      ] }, slots);
    };
  }
});

// node_modules/naive-ui/es/timeline/src/TimelineItem.js
var timelineItemProps = {
  time: [String, Number],
  title: String,
  content: String,
  color: String,
  lineType: {
    type: String,
    default: "default"
  },
  type: {
    type: String,
    default: "default"
  }
};
var TimelineItem_default = defineComponent({
  name: "TimelineItem",
  props: timelineItemProps,
  setup(props) {
    const NTimeline = inject(timelineInjectionKey);
    if (!NTimeline) {
      throwError("timeline-item", "`n-timeline-item` must be placed inside `n-timeline`.");
    }
    useHoudini();
    const { inlineThemeDisabled } = useConfig();
    const cssVarsRef = computed2(() => {
      const { props: { size: size3, iconSize: iconSizeProp }, mergedThemeRef } = NTimeline;
      const { type } = props;
      const { self: { titleTextColor, contentTextColor, metaTextColor, lineColor, titleFontWeight, contentFontSize, [createKey("iconSize", size3)]: iconSize, [createKey("titleMargin", size3)]: titleMargin, [createKey("titleFontSize", size3)]: titleFontSize, [createKey("circleBorder", type)]: circleBorder, [createKey("iconColor", type)]: iconColor }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut5 } } = mergedThemeRef.value;
      return {
        "--n-bezier": cubicBezierEaseInOut5,
        "--n-circle-border": circleBorder,
        "--n-icon-color": iconColor,
        "--n-content-font-size": contentFontSize,
        "--n-content-text-color": contentTextColor,
        "--n-line-color": lineColor,
        "--n-meta-text-color": metaTextColor,
        "--n-title-font-size": titleFontSize,
        "--n-title-font-weight": titleFontWeight,
        "--n-title-margin": titleMargin,
        "--n-title-text-color": titleTextColor,
        "--n-icon-size": formatLength(iconSizeProp) || iconSize
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("timeline-item", computed2(() => {
      const { props: { size: size3, iconSize: iconSizeProp } } = NTimeline;
      const { type } = props;
      return `${size3[0]}${iconSizeProp || "a"}${type[0]}`;
    }), cssVarsRef, NTimeline.props) : void 0;
    return {
      mergedClsPrefix: NTimeline.mergedClsPrefixRef,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const { mergedClsPrefix, color: color2, onRender, $slots } = this;
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return h3("div", { class: [
      `${mergedClsPrefix}-timeline-item`,
      this.themeClass,
      `${mergedClsPrefix}-timeline-item--${this.type}-type`,
      `${mergedClsPrefix}-timeline-item--${this.lineType}-line-type`
    ], style: this.cssVars }, h3("div", { class: `${mergedClsPrefix}-timeline-item-timeline` }, h3("div", { class: `${mergedClsPrefix}-timeline-item-timeline__line` }), resolveWrappedSlot($slots.icon, (children2) => {
      return children2 ? h3("div", { class: `${mergedClsPrefix}-timeline-item-timeline__icon`, style: { color: color2 } }, children2) : h3("div", { class: `${mergedClsPrefix}-timeline-item-timeline__circle`, style: { borderColor: color2 } });
    })), h3("div", { class: `${mergedClsPrefix}-timeline-item-content` }, resolveWrappedSlot($slots.header, (children2) => {
      const mergedChildren = children2 || this.title;
      if (mergedChildren) {
        return h3("div", { class: `${mergedClsPrefix}-timeline-item-content__title` }, children2 || this.title);
      }
      return null;
    }), h3("div", { class: `${mergedClsPrefix}-timeline-item-content__content` }, resolveSlot($slots.default, () => [this.content])), h3("div", { class: `${mergedClsPrefix}-timeline-item-content__meta` }, resolveSlot($slots.footer, () => [this.time]))));
  }
});

// node_modules/naive-ui/es/equation/styles/light.js
var self78 = () => ({});
var equationLight = {
  name: "Equation",
  common: light_default,
  self: self78
};
var light_default81 = equationLight;

// node_modules/naive-ui/es/equation/styles/dark.js
var equationDark = {
  name: "Equation",
  common: dark_default,
  self: self78
};
var dark_default81 = equationDark;

// node_modules/naive-ui/es/themes/dark.js
var darkTheme = {
  name: "dark",
  common: dark_default,
  Alert: dark_default8,
  Anchor: dark_default9,
  AutoComplete: dark_default11,
  Avatar: dark_default12,
  AvatarGroup: dark_default13,
  BackTop: dark_default14,
  Badge: dark_default15,
  Breadcrumb: dark_default16,
  Button: dark_default17,
  ButtonGroup: dark_default52,
  Calendar: dark_default18,
  Card: dark_default20,
  Carousel: dark_default21,
  Cascader: dark_default23,
  Checkbox: dark_default22,
  Code: dark_default24,
  Collapse: dark_default25,
  CollapseTransition: dark_default26,
  ColorPicker: dark_default19,
  DataTable: dark_default34,
  DatePicker: dark_default37,
  Descriptions: dark_default38,
  Dialog: dark_default39,
  Divider: dark_default41,
  Drawer: dark_default42,
  Dropdown: dark_default33,
  DynamicInput: dark_default43,
  DynamicTags: dark_default45,
  Element: dark_default46,
  Empty: dark_default2,
  Ellipsis: dark_default31,
  Equation: dark_default81,
  Form: dark_default47,
  GradientText: dark_default48,
  Icon: dark_default35,
  IconWrapper: dark_default49,
  Image: imageDark,
  Input: dark_default10,
  InputNumber: dark_default53,
  LegacyTransfer: dark_default80,
  Layout: dark_default54,
  List: dark_default55,
  LoadingBar: dark_default56,
  Log: dark_default57,
  Menu: dark_default59,
  Mention: dark_default58,
  Message: dark_default51,
  Modal: dark_default40,
  Notification: dark_default50,
  PageHeader: pageHeaderDark,
  Pagination: dark_default29,
  Popconfirm: dark_default60,
  Popover: dark_default5,
  Popselect: dark_default27,
  Progress: dark_default61,
  Radio: dark_default32,
  Rate: dark_default62,
  Result: dark_default63,
  Row: dark_default79,
  Scrollbar: dark_default3,
  Select: dark_default28,
  Skeleton: skeletonDark,
  Slider: dark_default64,
  Space: dark_default44,
  Spin: dark_default65,
  Statistic: dark_default66,
  Steps: dark_default67,
  Switch: dark_default68,
  Table: dark_default69,
  Tabs: dark_default70,
  Tag: dark_default6,
  Thing: dark_default71,
  TimePicker: dark_default36,
  Timeline: dark_default72,
  Tooltip: dark_default30,
  Transfer: dark_default73,
  Tree: dark_default74,
  TreeSelect: dark_default75,
  Typography: dark_default76,
  Upload: dark_default77,
  Watermark: dark_default78
};

// node_modules/naive-ui/es/themes/light.js
var lightTheme = {
  name: "light",
  common: light_default,
  Alert: light_default8,
  Anchor: light_default9,
  AutoComplete: light_default11,
  Avatar: light_default12,
  AvatarGroup: light_default13,
  BackTop: light_default14,
  Badge: light_default15,
  Breadcrumb: light_default16,
  Button: light_default17,
  ButtonGroup: light_default52,
  Calendar: light_default18,
  Card: light_default20,
  Carousel: light_default21,
  Cascader: light_default23,
  Checkbox: light_default22,
  Code: light_default24,
  Collapse: light_default25,
  CollapseTransition: light_default26,
  ColorPicker: light_default19,
  DataTable: light_default34,
  DatePicker: light_default37,
  Descriptions: light_default38,
  Dialog: light_default39,
  Divider: light_default41,
  Drawer: light_default42,
  Dropdown: light_default33,
  DynamicInput: light_default43,
  DynamicTags: light_default45,
  Element: light_default46,
  Empty: light_default2,
  Equation: light_default81,
  Ellipsis: light_default31,
  Form: light_default47,
  GradientText: light_default48,
  Icon: light_default35,
  IconWrapper: light_default49,
  Image: imageLight,
  Input: light_default10,
  InputNumber: light_default53,
  Layout: light_default54,
  LegacyTransfer: light_default80,
  List: light_default55,
  LoadingBar: light_default56,
  Log: light_default57,
  Menu: light_default59,
  Mention: light_default58,
  Message: light_default51,
  Modal: light_default40,
  Notification: light_default50,
  PageHeader: pageHeaderLight,
  Pagination: light_default29,
  Popconfirm: light_default60,
  Popover: light_default5,
  Popselect: light_default27,
  Progress: light_default61,
  Radio: light_default32,
  Rate: light_default62,
  Row: light_default79,
  Result: light_default63,
  Scrollbar: light_default3,
  Skeleton: skeletonLight,
  Select: light_default28,
  Slider: light_default64,
  Space: light_default44,
  Spin: light_default65,
  Statistic: light_default66,
  Steps: light_default67,
  Switch: light_default68,
  Table: light_default69,
  Tabs: light_default70,
  Tag: light_default6,
  Thing: light_default71,
  TimePicker: light_default36,
  Timeline: light_default72,
  Tooltip: light_default30,
  Transfer: light_default73,
  Tree: light_default74,
  TreeSelect: light_default75,
  Typography: light_default76,
  Upload: light_default77,
  Watermark: light_default78
};

// src/utils/constants.ts
var MAX_TIME_SINCE_CREATION = 5e3;
var checkInDefaultPath = "Journal/Habit";
var checkInList = [
  {
    filename: "Get up",
    content: "[[Get up]] and sit in [[meditation]]",
    time: "07:00"
  },
  {
    filename: "\u65E5\u8BB0",
    content: "[[\u65E5\u8BB0|Journal]]",
    time: "07:30"
  },
  {
    path: checkInDefaultPath,
    filename: "Review",
    content: "[[Review]]",
    time: "07:30"
  },
  {
    path: checkInDefaultPath,
    filename: "Breakfast",
    content: "[[Breakfast]]",
    time: "08:00"
  },
  {
    path: checkInDefaultPath,
    filename: "leave for work",
    content: "[[leave for work]]",
    time: "09:00"
  },
  {
    path: checkInDefaultPath,
    filename: "Launch",
    content: "[[Launch]] and take a break",
    time: "12:30"
  },
  {
    path: checkInDefaultPath,
    filename: "Dinner",
    content: "[[Dinner]] ",
    time: "18:00"
  },
  {
    path: checkInDefaultPath,
    filename: "Go through today",
    content: "[[Go through today]]",
    time: "22:30"
  },
  {
    path: checkInDefaultPath,
    filename: "Plan for tomorrow",
    content: "[[Plan for tomorrow]]",
    time: "22:30"
  },
  {
    path: checkInDefaultPath,
    filename: "End the day",
    content: "[[End the day]]",
    time: "23:00"
  }
];
var colorSchema = [
  { fg: "#293845", bg: "#61c0bf" },
  { fg: "#293845", bg: "#bbded6" },
  { fg: "#293845", bg: "#fae3d9" },
  { fg: "#293845", bg: "#ffb6b9" },
  { fg: "#293845", bg: "#ffaaa5" },
  { fg: "#293845", bg: "#ffd3b6" },
  { fg: "#293845", bg: "#dcedc1" },
  { fg: "#293845", bg: "#a8e6cf" }
];
var getTheDay = () => {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth() + 1;
  const date = now.getDate();
  const theDay = `${year}-${month.toString().padStart(2, "0")}-${date.toString().padStart(2, "0")}`;
  return theDay;
};
var pomodoroDB = "pomodoro";
var customSnippetPath = "awesome-brain-manager";

// sfc-script:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/PomodoroListView.vue?type=script
var PomodoroListView_default = /* @__PURE__ */ defineComponent({
  __name: "PomodoroListView",
  props: {
    pomodoroList: { type: Array, required: true }
  },
  setup(__props, { expose }) {
    expose();
    const props = __props;
    const getRandomStyle = () => {
      const color2 = colorSchema[Math.floor(Math.random() * colorSchema.length)];
      return `background-color: ${color2.bg};color: ${color2.fg};`;
    };
    const __returned__ = { getRandomStyle, props, get NEllipsis() {
      return Ellipsis_default;
    }, get NList() {
      return List_default;
    }, get NListItem() {
      return ListItem_default;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});

// sfc-template:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/PomodoroListView.vue?type=template
function render3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NList"], {
    id: "pomodoroList",
    "show-divider": false
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.pomodoroList, (pomodoro) => {
        return openBlock(), createBlock($setup["NListItem"], {
          key: pomodoro.timestamp,
          style: normalizeStyle($setup.getRandomStyle()),
          bordered: ""
        }, {
          default: withCtx(() => [
            createVNode($setup["NEllipsis"], null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(pomodoro.task), 1)
              ]),
              _: 2
            }, 1024)
          ]),
          _: 2
        }, 1032, ["style"]);
      }), 128))
    ]),
    _: 1
  });
}

// src/ui/PomodoroListView.vue
PomodoroListView_default.render = render3;
PomodoroListView_default.__file = "src/ui/PomodoroListView.vue";
var PomodoroListView_default2 = PomodoroListView_default;

// sfc-script:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/CalendarView.vue?type=script
var CalendarView_default = /* @__PURE__ */ defineComponent({
  __name: "CalendarView",
  props: {
    allPomodoro: { type: Array, required: true }
  },
  setup(__props, { expose }) {
    expose();
    const props = __props;
    const { allPomodoro } = toRefs(props);
    const message = useMessage();
    const value = ref(addDays(Date.now(), 0).valueOf());
    const handleUpdateValue = (_, { year, month, date }) => {
      message.success(`${year}-${month}-${date}`);
    };
    const isDateDisabled = (timestamp) => {
      return false;
    };
    const getPomodoro = (year, month, date) => {
      const theDay = `${year}-${month.toString().padStart(2, "0")}-${date.toString().padStart(2, "0")}`;
      return allPomodoro.value.filter((pomodoro) => {
        return pomodoro.start.startsWith(theDay);
      });
    };
    const __returned__ = { props, allPomodoro, message, value, handleUpdateValue, isDateDisabled, getPomodoro, get NCalendar() {
      return Calendar_default;
    }, PomodoroListView: PomodoroListView_default2 };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});

// sfc-template:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/CalendarView.vue?type=template
var _hoisted_1 = { id: "calendarContainerInSelf" };
function render4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createVNode($setup["NCalendar"], {
      value: $setup.value,
      "onUpdate:value": [
        _cache[0] || (_cache[0] = ($event) => $setup.value = $event),
        $setup.handleUpdateValue
      ],
      "is-date-disabled": $setup.isDateDisabled
    }, {
      default: withCtx(({ year, month, date }) => [
        createTextVNode(toDisplayString(year) + " ", 1),
        createVNode($setup["PomodoroListView"], {
          "pomodoro-list": $setup.getPomodoro(year, month, date)
        }, null, 8, ["pomodoro-list"])
      ]),
      _: 1
    }, 8, ["value"])
  ]);
}

// src/ui/CalendarView.vue
CalendarView_default.render = render4;
CalendarView_default.__file = "src/ui/CalendarView.vue";
CalendarView_default.__scopeId = "data-v-fa20c457";
var CalendarView_default2 = CalendarView_default;

// sfc-script:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/OverView.vue?type=script
var import_moment4 = __toESM(require_moment());
var OverView_default = /* @__PURE__ */ defineComponent({
  __name: "OverView",
  props: {
    allPomodoro: { type: Array, required: true }
  },
  setup(__props, { expose }) {
    expose();
    const props = __props;
    const { allPomodoro } = toRefs(props);
    const countPomodoro = (pomodoroList, dimension) => {
      const theDay = getTheDay();
      const pomodoroTheDay = pomodoroList.filter((pomodoro) => pomodoro.start.startsWith(theDay));
      const pomodoroTimeTotal = pomodoroList.reduce((a4, b2) => a4 + parseFloat(b2.spend), 0);
      const pomodoroTimeTheDay = pomodoroTheDay.reduce((a4, b2) => a4 + parseFloat(b2.spend), 0);
      const todayDuration = import_moment4.default.duration(pomodoroTimeTheDay, "milliseconds");
      const totayDuration = import_moment4.default.duration(pomodoroTimeTotal, "milliseconds");
      switch (dimension) {
        case "todayNum":
          return pomodoroTheDay.length;
        case "todayTime":
          return import_moment4.default.utc(todayDuration.asMilliseconds()).format("HH:mm:ss");
        case "totalNum":
          return pomodoroList.length;
        case "totalTime":
          return import_moment4.default.utc(totayDuration.asMilliseconds()).format("HH:mm:ss");
        default:
          return "";
      }
    };
    const __returned__ = { props, allPomodoro, countPomodoro, get NCard() {
      return Card_default;
    }, get NGrid() {
      return Grid_default;
    }, get NGridItem() {
      return GridItem_default;
    }, get t() {
      return i18n_default2;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});

// sfc-template:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/OverView.vue?type=template
function render5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NGrid"], {
    cols: "1 320:2 640:4",
    responsive: "self"
  }, {
    default: withCtx(() => [
      createVNode($setup["NGridItem"], null, {
        default: withCtx(() => [
          createVNode($setup["NCard"], {
            title: $setup.t.info.todayNum,
            "content-style": "font-size: 16px;"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($setup.countPomodoro($setup.allPomodoro, "todayNum")), 1)
            ]),
            _: 1
          }, 8, ["title"])
        ]),
        _: 1
      }),
      createVNode($setup["NGridItem"], null, {
        default: withCtx(() => [
          createVNode($setup["NCard"], {
            title: $setup.t.info.todayTime,
            "content-style": "font-size: 16px;"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($setup.countPomodoro($setup.allPomodoro, "todayTime")), 1)
            ]),
            _: 1
          }, 8, ["title"])
        ]),
        _: 1
      }),
      createVNode($setup["NGridItem"], null, {
        default: withCtx(() => [
          createVNode($setup["NCard"], {
            title: $setup.t.info.totalNum,
            "content-style": "font-size: 16px;"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($setup.countPomodoro($setup.allPomodoro, "totalNum")), 1)
            ]),
            _: 1
          }, 8, ["title"])
        ]),
        _: 1
      }),
      createVNode($setup["NGridItem"], null, {
        default: withCtx(() => [
          createVNode($setup["NCard"], {
            title: $setup.t.info.totalTime,
            "content-style": "font-size: 16px;"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($setup.countPomodoro($setup.allPomodoro, "totalTime")), 1)
            ]),
            _: 1
          }, 8, ["title"])
        ]),
        _: 1
      })
    ]),
    _: 1
  });
}

// src/ui/OverView.vue
OverView_default.render = render5;
OverView_default.__file = "src/ui/OverView.vue";
var OverView_default2 = OverView_default;

// node_modules/vue3-radial-progress/dist/RadialProgressBar.esm.js
function randomString() {
  return Math.random().toString(16).substring(2);
}
var script = defineComponent({
  props: {
    diameter: {
      type: Number,
      required: false,
      default: 200
    },
    totalSteps: {
      type: Number,
      required: true,
      default: 10
    },
    completedSteps: {
      type: Number,
      required: true,
      default: 0
    },
    startColor: {
      type: String,
      required: false,
      default: "#00C58E"
    },
    stopColor: {
      type: String,
      required: false,
      default: "#00E0A1"
    },
    innerStrokeColor: {
      type: String,
      required: false,
      default: "#2F495E"
    },
    strokeWidth: {
      type: Number,
      required: false,
      default: 10
    },
    innerStrokeWidth: {
      type: Number,
      required: false,
      default: 10
    },
    strokeLinecap: {
      type: String,
      required: false,
      default: "round"
    },
    animateSpeed: {
      type: Number,
      required: false,
      default: 1e3
    },
    fps: {
      type: Number,
      required: false,
      default: 60
    },
    timingFunc: {
      type: String,
      required: false,
      default: "linear"
    },
    isClockwise: {
      type: Boolean,
      required: false,
      default: true
    }
  },
  setup(props) {
    const gradient = reactive({
      fx: 0.99,
      fy: 0.5,
      cx: 0.5,
      cy: 0.5,
      r: 0.65
    });
    const radialGradientId = `rg-${randomString()}`;
    const strokeDashoffset = ref(0);
    const currentAngle = ref(0);
    const gradientAnimation = ref(null);
    const radius = computed2(() => props.diameter / 2);
    const innerCircleDiameter = computed2(() => props.diameter - props.innerStrokeWidth * 2);
    const circumference = computed2(() => Math.PI * innerCircleDiameter.value);
    const stepSize = computed2(() => props.totalSteps === 0 ? 0 : 100 / props.totalSteps);
    const finishedPercentage = computed2(() => stepSize.value * props.completedSteps);
    const circleSlice = computed2(() => 2 * Math.PI / props.totalSteps);
    const animationIncrements = computed2(() => 100 / props.fps);
    const totalPoints = computed2(() => props.animateSpeed / animationIncrements.value);
    const animateSlice = computed2(() => circleSlice.value / totalPoints.value);
    const innerCircleRadius = computed2(() => innerCircleDiameter.value / 2);
    const containerStyle = computed2(() => ({
      height: `${props.diameter}px`,
      width: `${props.diameter}px`
    }));
    const progressStyle = computed2(() => ({
      height: `${props.diameter}px`,
      width: `${props.diameter}px`,
      strokeWidth: `${props.strokeWidth}px`,
      strokeDashoffset: strokeDashoffset.value,
      transition: `stroke-dashoffset ${props.animateSpeed}ms ${props.timingFunc}`
    }));
    const strokeStyle = computed2(() => ({
      height: `${props.diameter}px`,
      width: `${props.diameter}px`,
      strokeWidth: `${props.innerStrokeWidth}px`
    }));
    const innerCircleStyle = computed2(() => ({
      width: `${innerCircleDiameter.value}px`
    }));
    watch(() => [props.diameter, props.totalSteps, props.completedSteps, props.strokeWidth], changeProgress, {
      immediate: true
    });
    function getPointOfCircle(angle) {
      const radius2 = 0.5;
      const x2 = radius2 + radius2 * Math.cos(angle);
      const y3 = radius2 + radius2 * Math.sin(angle);
      return {
        x: x2,
        y: y3
      };
    }
    function gotoPoint() {
      const point = getPointOfCircle(currentAngle.value);
      if (point.x && point.y) {
        gradient.fx = point.x;
        gradient.fy = point.y;
      }
    }
    function direction() {
      return props.isClockwise ? 1 : -1;
    }
    function changeProgress() {
      strokeDashoffset.value = (100 - finishedPercentage.value) / 100 * circumference.value * direction();
      if (gradientAnimation.value) {
        clearInterval(gradientAnimation.value);
      }
      const angleOffset = (props.completedSteps - 1) * circleSlice.value;
      let i3 = (currentAngle.value - angleOffset) / animateSlice.value;
      const incrementer = Math.abs(i3 - totalPoints.value) / totalPoints.value;
      const isMoveForward = i3 < totalPoints.value;
      gradientAnimation.value = setInterval(() => {
        if (isMoveForward && i3 >= totalPoints.value || !isMoveForward && i3 < totalPoints.value) {
          gradientAnimation.value && clearInterval(gradientAnimation.value);
          return;
        }
        currentAngle.value = angleOffset + animateSlice.value * i3;
        gotoPoint();
        i3 += isMoveForward ? incrementer : -incrementer;
      }, animationIncrements.value);
    }
    return {
      gradientAnimation,
      innerCircleRadius,
      radialGradientId,
      strokeDashoffset,
      innerCircleStyle,
      containerStyle,
      circumference,
      progressStyle,
      currentAngle,
      strokeStyle,
      gradient,
      radius
    };
  }
});
var _hoisted_12 = ["width", "height"];
var _hoisted_2 = ["id", "fx", "fy", "cx", "cy", "r"];
var _hoisted_3 = ["stop-color"];
var _hoisted_4 = ["stop-color"];
var _hoisted_5 = ["r", "cx", "cy", "stroke", "stroke-dasharray", "stroke-linecap"];
var _hoisted_6 = ["transform", "r", "cx", "cy", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap"];
function render6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "vrp__wrapper",
    style: normalizeStyle(_ctx.containerStyle)
  }, [createBaseVNode("div", {
    class: "vrp__inner",
    style: normalizeStyle(_ctx.innerCircleStyle)
  }, [renderSlot(_ctx.$slots, "default")], 4), (openBlock(), createElementBlock("svg", {
    width: _ctx.diameter,
    height: _ctx.diameter,
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, [createBaseVNode("defs", null, [createBaseVNode("radialGradient", {
    id: _ctx.radialGradientId,
    fx: _ctx.gradient.fx,
    fy: _ctx.gradient.fy,
    cx: _ctx.gradient.cx,
    cy: _ctx.gradient.cy,
    r: _ctx.gradient.r
  }, [createBaseVNode("stop", {
    offset: "30%",
    "stop-color": _ctx.startColor
  }, null, 8, _hoisted_3), createBaseVNode("stop", {
    offset: "100%",
    "stop-color": _ctx.stopColor
  }, null, 8, _hoisted_4)], 8, _hoisted_2)]), createBaseVNode("circle", {
    r: _ctx.innerCircleRadius,
    cx: _ctx.radius,
    cy: _ctx.radius,
    fill: "transparent",
    stroke: _ctx.innerStrokeColor,
    "stroke-dasharray": _ctx.circumference,
    "stroke-dashoffset": "0",
    "stroke-linecap": _ctx.strokeLinecap,
    style: normalizeStyle(_ctx.strokeStyle)
  }, null, 12, _hoisted_5), createBaseVNode("circle", {
    transform: "rotate(270, " + _ctx.radius + "," + _ctx.radius + ")",
    r: _ctx.innerCircleRadius,
    cx: _ctx.radius,
    cy: _ctx.radius,
    fill: "transparent",
    stroke: `url('#${_ctx.radialGradientId}')`,
    "stroke-dasharray": _ctx.circumference,
    "stroke-dashoffset": _ctx.circumference,
    "stroke-linecap": _ctx.strokeLinecap,
    style: normalizeStyle(_ctx.progressStyle)
  }, null, 12, _hoisted_6)], 8, _hoisted_12))], 4);
}
function styleInject(css, ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style2 = document.createElement("style");
  style2.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style2, head.firstChild);
    } else {
      head.appendChild(style2);
    }
  } else {
    head.appendChild(style2);
  }
  if (style2.styleSheet) {
    style2.styleSheet.cssText = css;
  } else {
    style2.appendChild(document.createTextNode(css));
  }
}
var css_248z = "\n.vrp__wrapper[data-v-6a0cf1f6] {\r\n  position: relative;\n}\n.vrp__inner[data-v-6a0cf1f6] {\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  border-radius: 50%;\r\n  margin: 0 auto;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\n}\r\n";
styleInject(css_248z);
script.render = render6;
script.__scopeId = "data-v-6a0cf1f6";
var entry_esm = /* @__PURE__ */ (() => {
  const installable = script;
  installable.install = (app2) => {
    app2.component("RadialProgressBar", installable);
  };
  return installable;
})();

// sfc-script:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/ClockView.vue?type=script
var import_moment5 = __toESM(require_moment());
var ClockView_default = /* @__PURE__ */ defineComponent({
  __name: "ClockView",
  props: {
    currentPomodoro: { type: null, required: true }
  },
  setup(__props, { expose }) {
    expose();
    const props = __props;
    const { currentPomodoro } = toRefs(props);
    const time2 = ref("");
    const currentSpend = ref(0);
    const expectedTime = ref(0);
    let timerID;
    function updateTime() {
      const pomodoro = currentPomodoro.value;
      if (!pomodoro) {
        return;
      }
      currentSpend.value = (0, import_moment5.default)().valueOf() - parseInt(pomodoro.lastactive) + parseInt(pomodoro.spend);
      expectedTime.value = parseInt(pomodoro.expectedTime);
      const leftTime = import_moment5.default.duration(expectedTime.value - currentSpend.value, "milliseconds");
      time2.value = import_moment5.default.utc(leftTime.asMilliseconds()).format("HH:mm:ss");
    }
    onMounted(async () => {
      timerID = window.setInterval(updateTime, 1e3);
      updateTime();
    });
    onUnmounted(() => {
      clearInterval(timerID);
    });
    const __returned__ = { props, currentPomodoro, time: time2, currentSpend, expectedTime, get timerID() {
      return timerID;
    }, set timerID(v) {
      timerID = v;
    }, updateTime, get RadialProgress() {
      return entry_esm;
    }, get NResult() {
      return Result_default;
    }, get NSpace() {
      return Space_default;
    }, get t() {
      return i18n_default2;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});

// sfc-template:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/ClockView.vue?type=template
var _hoisted_13 = { style: { "margin": "15px auto" } };
var _hoisted_22 = { class: "radialTimeText" };
function render7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_13, [
    createVNode($setup["NSpace"], { justify: "space-around" }, {
      default: withCtx(() => [
        $setup.currentPomodoro ? (openBlock(), createBlock($setup["RadialProgress"], {
          key: 0,
          "start-color": "#4772fa",
          "stop-color": "#4772fa",
          "inner-stroke-color": "#ebebeb",
          "stroke-width": 5,
          "inner-stroke-width": 5,
          diameter: 200,
          "completed-steps": $setup.currentSpend,
          "total-steps": $setup.expectedTime
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_22, toDisplayString($setup.time), 1)
          ]),
          _: 1
        }, 8, ["completed-steps", "total-steps"])) : (openBlock(), createBlock($setup["NResult"], {
          key: 1,
          status: "418",
          title: $setup.t.info.noDoingTask,
          description: $setup.t.info.haveABreak
        }, null, 8, ["title", "description"]))
      ]),
      _: 1
    })
  ]);
}

// src/ui/ClockView.vue
ClockView_default.render = render7;
ClockView_default.__file = "src/ui/ClockView.vue";
ClockView_default.__scopeId = "data-v-8dea1342";
var ClockView_default2 = ClockView_default;

// node_modules/@vicons/ionicons5/es/Airplane.js
var _hoisted_14 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 512 512"
};
var _hoisted_23 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M186.62 464H160a16 16 0 0 1-14.57-22.6l64.46-142.25L113.1 297l-35.3 42.77C71.07 348.23 65.7 352 52 352H34.08a17.66 17.66 0 0 1-14.7-7.06c-2.38-3.21-4.72-8.65-2.44-16.41l19.82-71c.15-.53.33-1.06.53-1.58a.38.38 0 0 0 0-.15a14.82 14.82 0 0 1-.53-1.59l-19.84-71.45c-2.15-7.61.2-12.93 2.56-16.06a16.83 16.83 0 0 1 13.6-6.7H52c10.23 0 20.16 4.59 26 12l34.57 42.05l97.32-1.44l-64.44-142A16 16 0 0 1 160 48h26.91a25 25 0 0 1 19.35 9.8l125.05 152l57.77-1.52c4.23-.23 15.95-.31 18.66-.31C463 208 496 225.94 496 256c0 9.46-3.78 27-29.07 38.16c-14.93 6.6-34.85 9.94-59.21 9.94c-2.68 0-14.37-.08-18.66-.31l-57.76-1.54l-125.36 152a25 25 0 0 1-19.32 9.75z",
  fill: "currentColor"
}, null, -1);
var _hoisted_32 = [_hoisted_23];
var Airplane_default = defineComponent({
  name: "Airplane",
  render: function render8(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_14, _hoisted_32);
  }
});

// node_modules/@vicons/ionicons5/es/RadioButtonOffOutline.js
var _hoisted_15 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 512 512"
};
var _hoisted_24 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M448 256c0-106-86-192-192-192S64 150 64 256s86 192 192 192s192-86 192-192z",
  fill: "none",
  stroke: "currentColor",
  "stroke-miterlimit": "10",
  "stroke-width": "32"
}, null, -1);
var _hoisted_33 = [_hoisted_24];
var RadioButtonOffOutline_default = defineComponent({
  name: "RadioButtonOffOutline",
  render: function render9(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_15, _hoisted_33);
  }
});

// sfc-script:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/TimeLine.vue?type=script
var import_moment7 = __toESM(require_moment());

// src/schemas/spaces.ts
var vaultSchema = {
  uniques: ["path"],
  cols: ["path", "parent", "created", "sticker", "color", "folder", "rank"],
  rows: []
};
var spaceSchema = {
  uniques: ["name"],
  cols: ["name", "sticker", "color", "pinned", "sort", "def", "rank"],
  rows: []
};
var spaceItemsSchema = {
  uniques: [],
  cols: ["space", "path", "rank"],
  rows: []
};
var pomodoroSchema = {
  uniques: ["timestamp"],
  cols: [
    "timestamp",
    "task",
    "createTime",
    "start",
    "expectedTime",
    "lastactive",
    "breaknum",
    "end",
    "spend",
    "status",
    "tags"
  ],
  rows: []
};

// src/utils/promotodo.ts
var import_moment6 = __toESM(require_moment());

// src/utils/db/db.ts
var import_obsidian7 = require("obsidian");

// src/utils/sanitize.ts
var sanitizeSQLStatement = (name2) => {
  return name2 == null ? void 0 : name2.replace(/'/g, `''`);
};

// src/utils/tree.ts
var uniq = (a4) => [...new Set(a4)];

// src/utils/db/db.ts
var getDBFile = async (path) => {
  if (!await app.vault.adapter.exists((0, import_obsidian7.normalizePath)(path))) {
    return null;
  }
  const file = await app.vault.adapter.readBinary((0, import_obsidian7.normalizePath)(path));
  return file;
};
var getDB = async (sqlJS, path) => {
  const buf = await getDBFile(path);
  if (buf) {
    return new sqlJS.Database(new Uint8Array(buf));
  }
  return new sqlJS.Database();
};
var saveDBAndKeepAlive = (db, path) => {
  const results = saveDBFile(path, db.export().buffer);
  return results;
};
var saveDBFile = async (path, binary) => {
  const file = app.vault.adapter.writeBinary((0, import_obsidian7.normalizePath)(path), binary);
  return file;
};
var dbResultsToDBTables = (res) => {
  return res.reduce((p2, c6, i3) => [
    ...p2,
    {
      cols: c6.columns,
      rows: c6 ? c6.values.map((r) => c6.columns.reduce((prev, curr, index2) => ({ ...prev, [curr]: r[index2] }), {})) : []
    }
  ], []);
};
var updateDBConditionally = (db, tables, condition) => {
  const sqlstr = Object.keys(tables).map((t3) => {
    const tableFields = tables[t3].cols;
    const rowsQuery = tables[t3].rows.reduce((prev, curr) => {
      return `${prev} UPDATE "${t3}" SET ${tableFields.map((c6) => {
        var _a3;
        return `${c6}='${(_a3 = sanitizeSQLStatement(curr == null ? void 0 : curr[c6])) != null ? _a3 : ""}'`;
      }).join(", ")} WHERE ${condition};`;
    }, "");
    return rowsQuery;
  }).join("; ");
  try {
    logger_default.log(sqlstr);
    db.exec(sqlstr);
  } catch (e3) {
    logger_default.log(e3);
  }
};
var selectDB = (db, table, condition, fields) => {
  const fieldsStr = fields != null ? fields : "*";
  const sqlstr = condition ? `SELECT ${fieldsStr} FROM "${table}" WHERE ${condition};` : `SELECT ${fieldsStr} FROM ${table};`;
  let tables;
  try {
    tables = dbResultsToDBTables(db.exec(sqlstr));
  } catch (e3) {
    return null;
  }
  if (tables.length == 1)
    return tables[0];
  return null;
};
var deleteFromDB = (db, table, condition) => {
  const sqlstr = `DELETE FROM "${table}" WHERE ${condition};`;
  try {
    db.exec(sqlstr);
  } catch (e3) {
    logger_default.log(e3);
  }
};
var insertIntoDB = (db, tables) => {
  const sqlstr = Object.keys(tables).map((t3) => {
    const tableFields = tables[t3].cols;
    const rowsQuery = tables[t3].rows.reduce((prev, curr) => {
      return `${prev} INSERT INTO "${t3}" VALUES (${tableFields.map((c6) => {
        var _a3;
        return `'${(_a3 = sanitizeSQLStatement(curr == null ? void 0 : curr[c6])) != null ? _a3 : ""}'`;
      }).join(", ")});`;
    }, "");
    return rowsQuery;
  }).join("; ");
  try {
    db.exec(`BEGIN TRANSACTION; ${sqlstr} COMMIT;`);
  } catch (e3) {
    logger_default.log(e3);
  }
};
var replaceDB = (db, tables) => {
  const sqlstr = Object.keys(tables).map((t3) => {
    const tableFields = tables[t3].cols;
    const fieldQuery = uniq(tableFields).map((f) => `'${sanitizeSQLStatement(f)}' char`).join(", ");
    const rowsQuery = tables[t3].rows.reduce((prev, curr) => {
      return `${prev} REPLACE INTO "${t3}" VALUES (${tableFields.map((c6) => {
        var _a3;
        return `'${(_a3 = sanitizeSQLStatement(curr == null ? void 0 : curr[c6])) != null ? _a3 : ""}'`;
      }).join(", ")});`;
    }, "");
    const idxQuery = tables[t3].uniques.filter((f) => f).reduce((p2, c6) => {
      return `${p2} CREATE UNIQUE INDEX IF NOT EXISTS idx_${t3}_${c6.replace(/,/g, "_")} ON ${t3}(${c6});`;
    }, "");
    const insertQuery = `CREATE TABLE IF NOT EXISTS "${t3}" (${fieldQuery}); ${idxQuery} BEGIN TRANSACTION; ${rowsQuery} COMMIT;`;
    return `DROP TABLE IF EXISTS "${t3}"; ${fieldQuery.length > 0 ? insertQuery : ""}`;
  }).join("; ");
  try {
    db.exec(sqlstr);
  } catch (e3) {
    logger_default.log(e3);
  }
};

// src/utils/promotodo.ts
var initiateDB = (db) => {
  replaceDB(db, {
    vault: vaultSchema,
    spaces: spaceSchema,
    spaceItems: spaceItemsSchema,
    pomodoro: pomodoroSchema
  });
};
var PomodoroStatus = class {
  constructor(pomodoro) {
    this.pomodoro = pomodoro;
  }
  getState() {
    return this.pomodoro.status;
  }
  setState(state) {
    this.pomodoro.status = state;
  }
  setEnd() {
    this.pomodoro.end = (0, import_moment6.default)().format("YYYY-MM-DD HH:mm:ss");
  }
  getRealSpend() {
    const oldSpend = parseInt(this.pomodoro.spend);
    if (!this.pomodoro.lastactive) {
      return 0;
    }
    const lastTime2 = (0, import_moment6.default)(parseInt(this.pomodoro.lastactive)).valueOf();
    const range2 = (0, import_moment6.default)().valueOf() - lastTime2;
    const spend = oldSpend + range2;
    return spend;
  }
  setSpend() {
    this.pomodoro.spend = this.getRealSpend().toString();
  }
  isOutTime() {
    return this.getRealSpend() >= parseInt(this.pomodoro.expectedTime);
  }
  setBreakNum() {
    this.pomodoro.breaknum = (parseInt(this.pomodoro.breaknum) + 1).toString();
  }
  setStart() {
    this.pomodoro.start = (0, import_moment6.default)().format("YYYY-MM-DD HH:mm:ss");
    this.pomodoro.lastactive = (0, import_moment6.default)().valueOf().toString();
  }
  changeState(targetStatus) {
    const oldStatus = this.getState();
    if ([targetStatus, "cancelled", "done"].contains(oldStatus)) {
      return false;
    }
    return this[targetStatus + "Fun"](targetStatus);
  }
  getPomodoro() {
    return this.pomodoro;
  }
  ingFun(targetStatus) {
    const currentStatus = this.getState();
    if (["done", "cancelled", "ing"].contains(currentStatus)) {
      return false;
    } else {
      logger_default.log("\u5F00\u59CB\u4EFB\u52A1");
      this.setStart();
      this.setState(targetStatus);
      return true;
    }
  }
  doneFun(targetStatus) {
    const currentStatus = this.getState();
    if (["cancelled", "break", "todo", "break"].contains(currentStatus)) {
      return false;
    } else {
      logger_default.log("\u5B8C\u6210\u4EFB\u52A1");
      this.setEnd();
      this.setSpend();
      this.setState(targetStatus);
      return true;
    }
  }
  todoFun(targetStatus) {
    logger_default.log("\u52A0\u5165\u4EFB\u52A1");
    this.setState(targetStatus);
    return true;
  }
  cancelledFun(targetStatus) {
    const oldStatus = this.getState();
    if (["done", "cancelled"].contains(oldStatus)) {
      return false;
    } else {
      logger_default.log("\u653E\u5F03\u4EFB\u52A1");
      this.setSpend();
      this.setEnd();
      this.setState(targetStatus);
      return true;
    }
  }
  breakFun(targetStatus) {
    const oldStatus = this.getState();
    if (["done", "cancelled", "todo", "break"].contains(oldStatus)) {
      return false;
    } else {
      logger_default.log("\u6682\u505C\u4EFB\u52A1");
      this.setSpend();
      this.setBreakNum();
      this.setState(targetStatus);
      return true;
    }
  }
};

// sfc-script:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/TimeLine.vue?type=script
var TimeLine_default = /* @__PURE__ */ defineComponent({
  __name: "TimeLine",
  props: {
    pomodoroList: { type: Array, required: true },
    plugin: { type: null, required: true }
  },
  setup(__props, { expose }) {
    expose();
    const props = __props;
    const { pomodoroList, plugin: plugin3 } = toRefs(props);
    const message = useMessage();
    const getOptions = (currentStatus) => {
      return [
        {
          label: i18n_default2.info.startTask,
          key: "ing",
          show: !["done", "cancelled", "ing"].contains(currentStatus)
        },
        {
          label: i18n_default2.info.stopTask,
          key: "break",
          show: !["done", "cancelled", "todo", "break"].contains(currentStatus)
        },
        {
          label: i18n_default2.info.finishTask,
          key: "done",
          show: !["done", "cancelled", "todo", "break"].contains(currentStatus)
        },
        {
          label: i18n_default2.info.cancelTask,
          key: "cancelled",
          show: !["done", "cancelled"].contains(currentStatus)
        },
        {
          label: i18n_default2.info.deleteTask,
          key: "deleted"
        }
      ];
    };
    const handleSelect = (targetStatus, pomodoro) => {
      if (targetStatus != "deleted") {
        const ps = new PomodoroStatus(pomodoro);
        if (targetStatus == "ing") {
          const ingPomodoro = pomodoroList.value.find((item) => item.status === "ing");
          if (ingPomodoro) {
            message.error(`${i18n_default2.info.handleThisFirst + ingPomodoro.task}`);
            return;
          }
        }
        const changed = ps.changeState(targetStatus);
        if (changed) {
          plugin3.value.updatePomodoro(pomodoro);
        }
      } else {
        plugin3.value.deletePomodoro(pomodoro);
      }
    };
    const statusTypeMap = {
      ing: "info",
      done: "success",
      todo: "default",
      cancelled: "error",
      break: "warning"
    };
    const getType2 = (status) => {
      return statusTypeMap[status] || "info";
    };
    onUpdated(() => {
    });
    const __returned__ = { props, pomodoroList, plugin: plugin3, message, getOptions, handleSelect, statusTypeMap, getType: getType2, get NDropdown() {
      return Dropdown_default;
    }, get NEmpty() {
      return Empty_default2;
    }, get NIcon() {
      return NIcon;
    }, get NSpace() {
      return Space_default;
    }, get NTag() {
      return Tag_default;
    }, get NTimeline() {
      return Timeline_default;
    }, get NTimelineItem() {
      return TimelineItem_default;
    }, get Airplane() {
      return Airplane_default;
    }, get RadioButtonOffOutline() {
      return RadioButtonOffOutline_default;
    }, get moment() {
      return import_moment7.default;
    }, get t() {
      return i18n_default2;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});

// sfc-template:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/TimeLine.vue?type=template
var _hoisted_16 = { style: { "padding": "10px 5px", "max-height": "200px", "overflow": "auto" } };
var _hoisted_25 = { key: 0 };
var _hoisted_34 = { key: 1 };
var _hoisted_42 = { key: 2 };
function render10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_16, [
    createCommentVNode(" horizontal "),
    $setup.pomodoroList.length != 0 ? (openBlock(), createBlock($setup["NTimeline"], { key: 0 }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList($setup.pomodoroList.filter((item) => item.createTime.startsWith($setup.moment().format("YYYY-MM-DD"))), (pomodoro) => {
          return openBlock(), createBlock($setup["NTimelineItem"], {
            key: pomodoro.timestamp,
            type: $setup.getType(pomodoro.status)
          }, {
            icon: withCtx(() => [
              createVNode($setup["NDropdown"], {
                trigger: "hover",
                placement: "bottom-start",
                options: $setup.getOptions(pomodoro.status),
                onSelect: ($event) => $setup.handleSelect($event, pomodoro)
              }, {
                default: withCtx(() => [
                  createVNode($setup["NIcon"], { size: "20" }, {
                    default: withCtx(() => [
                      createVNode($setup["RadioButtonOffOutline"])
                    ]),
                    _: 1
                  })
                ]),
                _: 2
              }, 1032, ["options", "onSelect"])
            ]),
            header: withCtx(() => [
              pomodoro.start ? (openBlock(), createElementBlock("span", _hoisted_25, toDisplayString($setup.moment(pomodoro.start).format("HH:mm")), 1)) : createCommentVNode("v-if", true),
              pomodoro.start && pomodoro.end ? (openBlock(), createElementBlock("span", _hoisted_34, " ~ ")) : createCommentVNode("v-if", true),
              pomodoro.end ? (openBlock(), createElementBlock("span", _hoisted_42, toDisplayString($setup.moment(pomodoro.end).format("HH:mm")), 1)) : createCommentVNode("v-if", true),
              createBaseVNode("span", null, toDisplayString(" " + pomodoro.task), 1)
            ]),
            footer: withCtx(() => [
              createVNode($setup["NSpace"], null, {
                default: withCtx(() => [
                  createVNode($setup["NTag"], {
                    bordered: false,
                    size: "small",
                    type: $setup.getType(pomodoro.status)
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(pomodoro.status.toUpperCase()), 1)
                    ]),
                    _: 2
                  }, 1032, ["type"]),
                  parseInt(pomodoro.spend) != 0 ? (openBlock(), createBlock($setup["NTag"], {
                    key: 0,
                    size: "small",
                    bordered: false,
                    type: "info"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(" \u23F3 " + toDisplayString(pomodoro.spend), 1)
                    ]),
                    _: 2
                  }, 1024)) : createCommentVNode("v-if", true),
                  parseInt(pomodoro.breaknum) != 0 ? (openBlock(), createBlock($setup["NTag"], {
                    key: 1,
                    size: "small",
                    bordered: false,
                    type: "error"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(" \u23F8\uFE0F " + toDisplayString(pomodoro.breaknum), 1)
                    ]),
                    _: 2
                  }, 1024)) : createCommentVNode("v-if", true)
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1032, ["type"]);
        }), 128))
      ]),
      _: 1
    })) : (openBlock(), createBlock($setup["NEmpty"], {
      key: 1,
      description: $setup.t.info.noTimeLine
    }, {
      icon: withCtx(() => [
        createVNode($setup["NIcon"], null, {
          default: withCtx(() => [
            createVNode($setup["Airplane"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["description"]))
  ]);
}

// src/ui/TimeLine.vue
TimeLine_default.render = render10;
TimeLine_default.__file = "src/ui/TimeLine.vue";
var TimeLine_default2 = TimeLine_default;

// src/ui/Title.tsx
var Title_default = defineComponent({
  setup() {
    return () => createVNode(A, null, null);
  }
});
var A = defineComponent({
  setup() {
    return () => createVNode(Fragment, null, [i18n_default2.info.Pomodoro]);
  }
});

// node_modules/@kurkle/color/dist/color.esm.js
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l2, h6) => Math.max(Math.min(v, h6), l2);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex2 = [..."0123456789ABCDEF"];
var h1 = (b2) => hex2[b2 & 15];
var h22 = (b2) => hex2[(b2 & 240) >> 4] + hex2[b2 & 15];
var eq2 = (b2) => (b2 & 240) >> 4 === (b2 & 15);
var isShort = (v) => eq2(v.r) && eq2(v.g) && eq2(v.b) && eq2(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a4, f) => a4 < 255 ? f(a4) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h22;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h6, s4, l2) {
  const a4 = s4 * Math.min(l2, 1 - l2);
  const f = (n2, k2 = (n2 + h6 / 30) % 12) => l2 - a4 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h6, s4, v) {
  const f = (n2, k2 = (n2 + h6 / 60) % 6) => v - v * s4 * Math.max(Math.min(k2, 4 - k2, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h6, w3, b2) {
  const rgb = hsl2rgbn(h6, 1, 0.5);
  let i3;
  if (w3 + b2 > 1) {
    i3 = 1 / (w3 + b2);
    w3 *= i3;
    b2 *= i3;
  }
  for (i3 = 0; i3 < 3; i3++) {
    rgb[i3] *= 1 - w3 - b2;
    rgb[i3] += w3;
  }
  return rgb;
}
function hueValue(r, g, b2, d4, max) {
  if (r === max) {
    return (g - b2) / d4 + (g < b2 ? 6 : 0);
  }
  if (g === max) {
    return (b2 - r) / d4 + 2;
  }
  return (r - g) / d4 + 4;
}
function rgb2hsl2(v) {
  const range2 = 255;
  const r = v.r / range2;
  const g = v.g / range2;
  const b2 = v.b / range2;
  const max = Math.max(r, g, b2);
  const min = Math.min(r, g, b2);
  const l2 = (max + min) / 2;
  let h6, s4, d4;
  if (max !== min) {
    d4 = max - min;
    s4 = l2 > 0.5 ? d4 / (2 - max - min) : d4 / (max + min);
    h6 = hueValue(r, g, b2, d4, max);
    h6 = h6 * 60 + 0.5;
  }
  return [h6 | 0, s4 || 0, l2];
}
function calln(f, a4, b2, c6) {
  return (Array.isArray(a4) ? f(a4[0], a4[1], a4[2]) : f(a4, b2, c6)).map(n2b);
}
function hsl2rgb2(h6, s4, l2) {
  return calln(hsl2rgbn, h6, s4, l2);
}
function hwb2rgb(h6, w3, b2) {
  return calln(hwb2rgbn, h6, w3, b2);
}
function hsv2rgb2(h6, s4, v) {
  return calln(hsv2rgbn, h6, s4, v);
}
function hue(h6) {
  return (h6 % 360 + 360) % 360;
}
function hueParse(str) {
  const m3 = HUE_RE.exec(str);
  let a4 = 255;
  let v;
  if (!m3) {
    return;
  }
  if (m3[5] !== v) {
    a4 = m3[6] ? p2b(+m3[5]) : n2b(+m3[5]);
  }
  const h6 = hue(+m3[2]);
  const p1 = +m3[3] / 100;
  const p2 = +m3[4] / 100;
  if (m3[1] === "hwb") {
    v = hwb2rgb(h6, p1, p2);
  } else if (m3[1] === "hsv") {
    v = hsv2rgb2(h6, p1, p2);
  } else {
    v = hsl2rgb2(h6, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a: a4
  };
}
function rotate(v, deg) {
  var h6 = rgb2hsl2(v);
  h6[0] = hue(h6[0] + deg);
  h6 = hsl2rgb2(h6);
  v.r = h6[0];
  v.g = h6[1];
  v.b = h6[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a4 = rgb2hsl2(v);
  const h6 = a4[0];
  const s4 = n2p(a4[1]);
  const l2 = n2p(a4[2]);
  return v.a < 255 ? `hsla(${h6}, ${s4}%, ${l2}%, ${b2n(v.a)})` : `hsl(${h6}, ${s4}%, ${l2}%)`;
}
var map2 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys2 = Object.keys(names$1);
  const tkeys = Object.keys(map2);
  let i3, j, k2, ok, nk;
  for (i3 = 0; i3 < keys2.length; i3++) {
    ok = nk = keys2[i3];
    for (j = 0; j < tkeys.length; j++) {
      k2 = tkeys[j];
      nk = nk.replace(k2, map2[k2]);
    }
    k2 = parseInt(names$1[ok], 16);
    unpacked[nk] = [k2 >> 16 & 255, k2 >> 8 & 255, k2 & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a4 = names[str.toLowerCase()];
  return a4 && {
    r: a4[0],
    g: a4[1],
    b: a4[2],
    a: a4.length === 4 ? a4[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m3 = RGB_RE.exec(str);
  let a4 = 255;
  let r, g, b2;
  if (!m3) {
    return;
  }
  if (m3[7] !== r) {
    const v = +m3[7];
    a4 = m3[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m3[1];
  g = +m3[3];
  b2 = +m3[5];
  r = 255 & (m3[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m3[4] ? p2b(g) : lim(g, 0, 255));
  b2 = 255 & (m3[6] ? p2b(b2) : lim(b2, 0, 255));
  return {
    r,
    g,
    b: b2,
    a: a4
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t3) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b2 = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t3 * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t3 * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b2 + t3 * (from(b2n(rgb2.b)) - b2))),
    a: rgb1.a + t3 * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i3, ratio) {
  if (v) {
    let tmp = rgb2hsl2(v);
    tmp[i3] = Math.max(0, Math.min(tmp[i3] + tmp[i3] * ratio, i3 === 0 ? 360 : 1));
    tmp = hsl2rgb2(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c22 = color2.rgb;
      let w22;
      const p2 = weight === w22 ? 0.5 : weight;
      const w3 = 2 * p2 - 1;
      const a4 = c1.a - c22.a;
      const w1 = ((w3 * a4 === -1 ? w3 : (w3 + a4) / (1 + w3 * a4)) + 1) / 2;
      w22 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w22 * c22.r + 0.5;
      c1.g = 255 & w1 * c1.g + w22 * c22.g + 0.5;
      c1.b = 255 & w1 * c1.b + w22 * c22.b + 0.5;
      c1.a = p2 * c1.a + (1 - p2) * c22.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t3) {
    if (color2) {
      this._rgb = interpolate(this._rgb, color2._rgb, t3);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a4) {
    this._rgb.a = n2b(a4);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};

// node_modules/chart.js/dist/chunks/helpers.segment.js
function noop() {
}
var uid2 = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray4(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject3(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i3, len, keys2;
  if (isArray4(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i3 = len - 1; i3 >= 0; i3--) {
        fn.call(thisArg, loopable[i3], i3);
      }
    } else {
      for (i3 = 0; i3 < len; i3++) {
        fn.call(thisArg, loopable[i3], i3);
      }
    }
  } else if (isObject3(loopable)) {
    keys2 = Object.keys(loopable);
    len = keys2.length;
    for (i3 = 0; i3 < len; i3++) {
      fn.call(thisArg, loopable[keys2[i3]], keys2[i3]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i3, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i3 = 0, ilen = a0.length; i3 < ilen; ++i3) {
    v0 = a0[i3];
    v1 = a1[i3];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone2(source) {
  if (isArray4(source)) {
    return source.map(clone2);
  }
  if (isObject3(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys2 = Object.keys(source);
    const klen = keys2.length;
    let k2 = 0;
    for (; k2 < klen; ++k2) {
      target[keys2[k2]] = clone2(source[keys2[k2]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject3(tval) && isObject3(sval)) {
    merge3(tval, sval, options);
  } else {
    target[key] = clone2(sval);
  }
}
function merge3(target, source, options) {
  const sources = isArray4(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject3(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i3 = 0; i3 < ilen; ++i3) {
    current = sources[i3];
    if (!isObject3(current)) {
      continue;
    }
    const keys2 = Object.keys(current);
    for (let k2 = 0, klen = keys2.length; k2 < klen; ++k2) {
      merger(keys2[k2], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge3(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject3(tval) && isObject3(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone2(sval);
  }
}
var keyResolvers = {
  "": (v) => v,
  x: (o2) => o2.x,
  y: (o2) => o2.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys2 = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys2.push(tmp);
      tmp = "";
    }
  }
  return keys2;
}
function _getKeyResolver(key) {
  const keys2 = _splitKey(key);
  return (obj) => {
    for (const k2 of keys2) {
      if (k2 === "") {
        break;
      }
      obj = obj && obj[k2];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction3 = (value) => typeof value === "function";
var setsEqual = (a4, b2) => {
  if (a4.size !== b2.size) {
    return false;
  }
  for (const item of a4) {
    if (!b2.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e3) {
  return e3.type === "mouseup" || e3.type === "click" || e3.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY3 = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x2, y3, epsilon) {
  return Math.abs(x2 - y3) < epsilon;
}
function niceNum(range2) {
  const roundedRange = Math.round(range2);
  range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
  const niceRange = Math.pow(10, Math.floor(log10(range2)));
  const fraction = range2 / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i3;
  for (i3 = 1; i3 < sqrt; i3++) {
    if (value % i3 === 0) {
      result.push(i3);
      result.push(value / i3);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a4, b2) => a4 - b2).pop();
  return result;
}
function isNumber2(n2) {
  return !isNaN(parseFloat(n2)) && isFinite(n2);
}
function almostWhole(x2, epsilon) {
  const rounded = Math.round(x2);
  return rounded - epsilon <= x2 && rounded + epsilon >= x2;
}
function _setMinAndMaxByKey(array, target, property2) {
  let i3, ilen, value;
  for (i3 = 0, ilen = array.length; i3 < ilen; i3++) {
    value = array[i3][property2];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x2) {
  if (!isNumberFinite(x2)) {
    return;
  }
  let e3 = 1;
  let p2 = 0;
  while (Math.round(x2 * e3) / e3 !== x2) {
    e3 *= 10;
    p2++;
  }
  return p2;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a4, b2) {
  return (a4 - b2 + PITAU) % TAU - PI;
}
function _normalizeAngle(a4) {
  return (a4 % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a4 = _normalizeAngle(angle);
  const s4 = _normalizeAngle(start);
  const e3 = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s4 - a4);
  const angleToEnd = _normalizeAngle(e3 - a4);
  const startToAngle = _normalizeAngle(a4 - s4);
  const endToAngle = _normalizeAngle(a4 - e3);
  return a4 === s4 || a4 === e3 || sameAngleIsFullCircle && s4 === e3 || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
  const ti = table[index2][key];
  return ti < value || ti === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base3 = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base3.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set3 = /* @__PURE__ */ new Set();
  let i3, ilen;
  for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
    set3.add(items[i3]);
  }
  if (set3.size === ilen) {
    return items;
  }
  return Array.from(set3);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {
    start,
    count
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t3) => t3 === 0 || t3 === 1;
var elasticIn = (t3, s4, p2) => -(Math.pow(2, 10 * (t3 -= 1)) * Math.sin((t3 - s4) * TAU / p2));
var elasticOut = (t3, s4, p2) => Math.pow(2, -10 * t3) * Math.sin((t3 - s4) * TAU / p2) + 1;
var effects = {
  linear: (t3) => t3,
  easeInQuad: (t3) => t3 * t3,
  easeOutQuad: (t3) => -t3 * (t3 - 2),
  easeInOutQuad: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 : -0.5 * (--t3 * (t3 - 2) - 1),
  easeInCubic: (t3) => t3 * t3 * t3,
  easeOutCubic: (t3) => (t3 -= 1) * t3 * t3 + 1,
  easeInOutCubic: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 : 0.5 * ((t3 -= 2) * t3 * t3 + 2),
  easeInQuart: (t3) => t3 * t3 * t3 * t3,
  easeOutQuart: (t3) => -((t3 -= 1) * t3 * t3 * t3 - 1),
  easeInOutQuart: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 * t3 : -0.5 * ((t3 -= 2) * t3 * t3 * t3 - 2),
  easeInQuint: (t3) => t3 * t3 * t3 * t3 * t3,
  easeOutQuint: (t3) => (t3 -= 1) * t3 * t3 * t3 * t3 + 1,
  easeInOutQuint: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 * t3 * t3 : 0.5 * ((t3 -= 2) * t3 * t3 * t3 * t3 + 2),
  easeInSine: (t3) => -Math.cos(t3 * HALF_PI) + 1,
  easeOutSine: (t3) => Math.sin(t3 * HALF_PI),
  easeInOutSine: (t3) => -0.5 * (Math.cos(PI * t3) - 1),
  easeInExpo: (t3) => t3 === 0 ? 0 : Math.pow(2, 10 * (t3 - 1)),
  easeOutExpo: (t3) => t3 === 1 ? 1 : -Math.pow(2, -10 * t3) + 1,
  easeInOutExpo: (t3) => atEdge(t3) ? t3 : t3 < 0.5 ? 0.5 * Math.pow(2, 10 * (t3 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t3 * 2 - 1)) + 2),
  easeInCirc: (t3) => t3 >= 1 ? t3 : -(Math.sqrt(1 - t3 * t3) - 1),
  easeOutCirc: (t3) => Math.sqrt(1 - (t3 -= 1) * t3),
  easeInOutCirc: (t3) => (t3 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t3 * t3) - 1) : 0.5 * (Math.sqrt(1 - (t3 -= 2) * t3) + 1),
  easeInElastic: (t3) => atEdge(t3) ? t3 : elasticIn(t3, 0.075, 0.3),
  easeOutElastic: (t3) => atEdge(t3) ? t3 : elasticOut(t3, 0.075, 0.3),
  easeInOutElastic(t3) {
    const s4 = 0.1125;
    const p2 = 0.45;
    return atEdge(t3) ? t3 : t3 < 0.5 ? 0.5 * elasticIn(t3 * 2, s4, p2) : 0.5 + 0.5 * elasticOut(t3 * 2 - 1, s4, p2);
  },
  easeInBack(t3) {
    const s4 = 1.70158;
    return t3 * t3 * ((s4 + 1) * t3 - s4);
  },
  easeOutBack(t3) {
    const s4 = 1.70158;
    return (t3 -= 1) * t3 * ((s4 + 1) * t3 + s4) + 1;
  },
  easeInOutBack(t3) {
    let s4 = 1.70158;
    if ((t3 /= 0.5) < 1) {
      return 0.5 * (t3 * t3 * (((s4 *= 1.525) + 1) * t3 - s4));
    }
    return 0.5 * ((t3 -= 2) * t3 * (((s4 *= 1.525) + 1) * t3 + s4) + 2);
  },
  easeInBounce: (t3) => 1 - effects.easeOutBounce(1 - t3),
  easeOutBounce(t3) {
    const m3 = 7.5625;
    const d4 = 2.75;
    if (t3 < 1 / d4) {
      return m3 * t3 * t3;
    }
    if (t3 < 2 / d4) {
      return m3 * (t3 -= 1.5 / d4) * t3 + 0.75;
    }
    if (t3 < 2.5 / d4) {
      return m3 * (t3 -= 2.25 / d4) * t3 + 0.9375;
    }
    return m3 * (t3 -= 2.625 / d4) * t3 + 0.984375;
  },
  easeInOutBounce: (t3) => t3 < 0.5 ? effects.easeInBounce(t3 * 2) * 0.5 : effects.easeOutBounce(t3 * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults3) {
  defaults3.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults3.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name2) => name2 !== "onProgress" && name2 !== "onComplete" && name2 !== "fn"
  });
  defaults3.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults3.describe("animations", {
    _fallback: "animation"
  });
  defaults3.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults3) {
  defaults3.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale3, options) {
  options = options || {};
  const cacheKey = locale3 + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale3, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale3, options) {
  return getNumberFormat(locale3, options).format(num);
}
var formatters3 = {
  values(value) {
    return isArray4(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale3 = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale3, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks.length) {
      return formatters3.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters: formatters3
};
function applyScaleDefaults(defaults3) {
  defaults3.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults3.route("scale.ticks", "color", "", "color");
  defaults3.route("scale.grid", "color", "", "borderColor");
  defaults3.route("scale.border", "color", "", "borderColor");
  defaults3.route("scale.title", "color", "", "color");
  defaults3.describe("scale", {
    _fallback: false,
    _scriptable: (name2) => !name2.startsWith("before") && !name2.startsWith("after") && name2 !== "callback" && name2 !== "parser",
    _indexable: (name2) => name2 !== "borderDash" && name2 !== "tickBorderDash" && name2 !== "dash"
  });
  defaults3.describe("scales", {
    _fallback: "scale"
  });
  defaults3.describe("scale.ticks", {
    _scriptable: (name2) => name2 !== "backdropPadding" && name2 !== "callback",
    _indexable: (name2) => name2 !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys2 = key.split(".");
  for (let i3 = 0, n2 = keys2.length; i3 < n2; ++i3) {
    const k2 = keys2[i3];
    node = node[k2] || (node[k2] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set2(root2, scope, values) {
  if (typeof scope === "string") {
    return merge3(getScope$1(root2, scope), values);
  }
  return merge3(getScope$1(root2, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx3, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx3, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx3, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set2(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set2(descriptors, scope, values);
  }
  override(scope, values) {
    return set2(overrides, scope, values);
  }
  route(scope, name2, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name2;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name2],
        writable: true
      },
      [name2]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject3(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply2) => apply2(this));
  }
};
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name2) => !name2.startsWith("on"),
  _indexable: (name2) => name2 !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx3, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx3.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx3, font, arrayOfThings, cache2) {
  cache2 = cache2 || {};
  let data = cache2.data = cache2.data || {};
  let gc = cache2.garbageCollect = cache2.garbageCollect || [];
  if (cache2.font !== font) {
    data = cache2.data = {};
    gc = cache2.garbageCollect = [];
    cache2.font = font;
  }
  ctx3.save();
  ctx3.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i3, j, jlen, thing, nestedThing;
  for (i3 = 0; i3 < ilen; i3++) {
    thing = arrayOfThings[i3];
    if (thing !== void 0 && thing !== null && isArray4(thing) !== true) {
      longest = _measureText(ctx3, data, gc, longest, thing);
    } else if (isArray4(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray4(nestedThing)) {
          longest = _measureText(ctx3, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx3.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i3 = 0; i3 < gcLen; i3++) {
      delete data[gc[i3]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio2 = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio2) / devicePixelRatio2 + halfWidth;
}
function clearCanvas(canvas2, ctx3) {
  ctx3 = ctx3 || canvas2.getContext("2d");
  ctx3.save();
  ctx3.resetTransform();
  ctx3.clearRect(0, 0, canvas2.width, canvas2.height);
  ctx3.restore();
}
function drawPoint(ctx3, options, x2, y3) {
  drawPointLegend(ctx3, options, x2, y3, null);
}
function drawPointLegend(ctx3, options, x2, y3, w3) {
  let type, xOffset, yOffset, size3, cornerRadius, width, xOffsetW, yOffsetW;
  const style2 = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style2 && typeof style2 === "object") {
    type = style2.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx3.save();
      ctx3.translate(x2, y3);
      ctx3.rotate(rad);
      ctx3.drawImage(style2, -style2.width / 2, -style2.height / 2, style2.width, style2.height);
      ctx3.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx3.beginPath();
  switch (style2) {
    default:
      if (w3) {
        ctx3.ellipse(x2, y3, w3 / 2, radius, 0, 0, TAU);
      } else {
        ctx3.arc(x2, y3, radius, 0, TAU);
      }
      ctx3.closePath();
      break;
    case "triangle":
      width = w3 ? w3 / 2 : radius;
      ctx3.moveTo(x2 + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx3.lineTo(x2 + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx3.lineTo(x2 + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
      ctx3.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size3 = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size3;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w3 ? w3 / 2 - cornerRadius : size3);
      yOffset = Math.sin(rad + QUARTER_PI) * size3;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w3 ? w3 / 2 - cornerRadius : size3);
      ctx3.arc(x2 - xOffsetW, y3 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx3.arc(x2 + yOffsetW, y3 - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx3.arc(x2 + xOffsetW, y3 + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx3.arc(x2 - yOffsetW, y3 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx3.closePath();
      break;
    case "rect":
      if (!rotation) {
        size3 = Math.SQRT1_2 * radius;
        width = w3 ? w3 / 2 : size3;
        ctx3.rect(x2 - width, y3 - size3, 2 * width, 2 * size3);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w3 ? w3 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w3 ? w3 / 2 : radius);
      ctx3.moveTo(x2 - xOffsetW, y3 - yOffset);
      ctx3.lineTo(x2 + yOffsetW, y3 - xOffset);
      ctx3.lineTo(x2 + xOffsetW, y3 + yOffset);
      ctx3.lineTo(x2 - yOffsetW, y3 + xOffset);
      ctx3.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w3 ? w3 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w3 ? w3 / 2 : radius);
      ctx3.moveTo(x2 - xOffsetW, y3 - yOffset);
      ctx3.lineTo(x2 + xOffsetW, y3 + yOffset);
      ctx3.moveTo(x2 + yOffsetW, y3 - xOffset);
      ctx3.lineTo(x2 - yOffsetW, y3 + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w3 ? w3 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w3 ? w3 / 2 : radius);
      ctx3.moveTo(x2 - xOffsetW, y3 - yOffset);
      ctx3.lineTo(x2 + xOffsetW, y3 + yOffset);
      ctx3.moveTo(x2 + yOffsetW, y3 - xOffset);
      ctx3.lineTo(x2 - yOffsetW, y3 + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w3 ? w3 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w3 ? w3 / 2 : radius);
      ctx3.moveTo(x2 - xOffsetW, y3 - yOffset);
      ctx3.lineTo(x2 + xOffsetW, y3 + yOffset);
      ctx3.moveTo(x2 + yOffsetW, y3 - xOffset);
      ctx3.lineTo(x2 - yOffsetW, y3 + xOffset);
      break;
    case "line":
      xOffset = w3 ? w3 / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx3.moveTo(x2 - xOffset, y3 - yOffset);
      ctx3.lineTo(x2 + xOffset, y3 + yOffset);
      break;
    case "dash":
      ctx3.moveTo(x2, y3);
      ctx3.lineTo(x2 + Math.cos(rad) * (w3 ? w3 / 2 : radius), y3 + Math.sin(rad) * radius);
      break;
    case false:
      ctx3.closePath();
      break;
  }
  ctx3.fill();
  if (options.borderWidth > 0) {
    ctx3.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx3, area) {
  ctx3.save();
  ctx3.beginPath();
  ctx3.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx3.clip();
}
function unclipArea(ctx3) {
  ctx3.restore();
}
function _steppedLineTo(ctx3, previous, target, flip, mode) {
  if (!previous) {
    return ctx3.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx3.lineTo(midpoint, previous.y);
    ctx3.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx3.lineTo(previous.x, target.y);
  } else {
    ctx3.lineTo(target.x, previous.y);
  }
  ctx3.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx3, previous, target, flip) {
  if (!previous) {
    return ctx3.lineTo(target.x, target.y);
  }
  ctx3.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function renderText(ctx3, text2, x2, y3, font, opts = {}) {
  const lines = isArray4(text2) ? text2 : [
    text2
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i3, line;
  ctx3.save();
  ctx3.font = font.string;
  setRenderOpts(ctx3, opts);
  for (i3 = 0; i3 < lines.length; ++i3) {
    line = lines[i3];
    if (opts.backdrop) {
      drawBackdrop(ctx3, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx3.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx3.lineWidth = opts.strokeWidth;
      }
      ctx3.strokeText(line, x2, y3, opts.maxWidth);
    }
    ctx3.fillText(line, x2, y3, opts.maxWidth);
    decorateText(ctx3, x2, y3, line, opts);
    y3 += font.lineHeight;
  }
  ctx3.restore();
}
function setRenderOpts(ctx3, opts) {
  if (opts.translation) {
    ctx3.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx3.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx3.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx3.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx3.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx3, x2, y3, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx3.measureText(line);
    const left = x2 - metrics.actualBoundingBoxLeft;
    const right = x2 + metrics.actualBoundingBoxRight;
    const top = y3 - metrics.actualBoundingBoxAscent;
    const bottom = y3 + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx3.strokeStyle = ctx3.fillStyle;
    ctx3.beginPath();
    ctx3.lineWidth = opts.decorationWidth || 2;
    ctx3.moveTo(left, yDecoration);
    ctx3.lineTo(right, yDecoration);
    ctx3.stroke();
  }
}
function drawBackdrop(ctx3, opts) {
  const oldColor = ctx3.fillStyle;
  ctx3.fillStyle = opts.color;
  ctx3.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx3.fillStyle = oldColor;
}
function addRoundedRectPath(ctx3, rect) {
  const { x: x2, y: y3, w: w3, h: h6, radius } = rect;
  ctx3.arc(x2 + radius.topLeft, y3 + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx3.lineTo(x2, y3 + h6 - radius.bottomLeft);
  ctx3.arc(x2 + radius.bottomLeft, y3 + h6 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx3.lineTo(x2 + w3 - radius.bottomRight, y3 + h6);
  ctx3.arc(x2 + w3 - radius.bottomRight, y3 + h6 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx3.lineTo(x2 + w3, y3 + radius.topRight);
  ctx3.arc(x2 + w3 - radius.topRight, y3 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx3.lineTo(x2 + radius.topLeft, y3);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size3) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size3 * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size3 * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject3(props);
  const keys2 = objProps ? Object.keys(props) : props;
  const read = isObject3(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys2) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size3 = valueOrDefault(options.size, fallback.size);
  if (typeof size3 === "string") {
    size3 = parseInt(size3, 10);
  }
  let style2 = valueOrDefault(options.style, fallback.style);
  if (style2 && !("" + style2).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style2 + '"');
    style2 = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size3),
    size: size3,
    style: style2,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i3, ilen, value;
  for (i3 = 0, ilen = inputs.length; i3 < ilen; ++i3) {
    value = inputs[i3];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray4(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add3) => beginAtZero && value === 0 ? 0 : value + add3;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes2 = [
  ""
], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve("_fallback", scopes);
  }
  const cache2 = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes2, rootScopes, fallback)
  };
  return new Proxy(cache2, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes2, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache2 = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx3) => _attachContext(proxy, ctx3, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache2, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults3 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults3.scriptable, _indexable = defaults3.indexable, _allKeys = defaults3.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction3(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction3(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix3, name2) => prefix3 ? prefix3 + _capitalize(name2) : name2;
var needsSubResolver = (prop, value) => isObject3(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors3 } = target;
  let value = _proxy[prop];
  if (isFunction3(value) && descriptors3.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray4(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors3.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors3);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors3 } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject3(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s4) => s4 !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors3));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction3(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set3, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set3.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set3 = /* @__PURE__ */ new Set();
  set3.add(value);
  let key = addScopesFromKey(set3, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set3, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set3), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set3, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set3, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray4(target) && isObject3(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes2, scopes, proxy) {
  let value;
  for (const prefix3 of prefixes2) {
    value = _resolve(readKey(prefix3, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys2 = target._keys;
  if (!keys2) {
    keys2 = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys2;
}
function resolveKeysFromAllScopes(scopes) {
  const set3 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k2) => !k2.startsWith("_"))) {
      set3.add(key);
    }
  }
  return Array.from(set3);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i3, ilen, index2, item;
  for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
    index2 = i3 + start;
    item = data[index2];
    parsed[i3] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i3) => i3 < points.length && !points[i3].skip && points[i3];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t3) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t3 * s01;
  const fb = t3 * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i3 = 0; i3 < pointsLen - 1; ++i3) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i3 + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i3], 0, EPSILON)) {
      mK[i3] = mK[i3 + 1] = 0;
      continue;
    }
    alphaK = mK[i3] / deltaK[i3];
    betaK = mK[i3 + 1] / deltaK[i3];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i3] = alphaK * tauK * deltaK[i3];
    mK[i3 + 1] = betaK * tauK * deltaK[i3];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i3 = 0; i3 < pointsLen; ++i3) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i3 + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i3];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i3];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i3, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i3 = 0; i3 < pointsLen; ++i3) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i3 + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i3] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i3] = !pointBefore ? deltaK[i3] : !pointAfter ? deltaK[i3 - 1] : sign(deltaK[i3 - 1]) !== sign(deltaK[i3]) ? 0 : (deltaK[i3 - 1] + deltaK[i3]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i3, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i3 = 0, ilen = points.length; i3 < ilen; ++i3) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i3 < ilen - 1 && _isPointInArea(points[i3 + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i3];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop2, indexAxis) {
  let i3, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop2 ? points[points.length - 1] : points[0];
    for (i3 = 0, ilen = points.length; i3 < ilen; ++i3) {
      point = points[i3];
      controlPoints = splineCurve(prev, point, points[Math.min(i3 + 1, ilen - (loop2 ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle2 = (element2) => element2.ownerDocument.defaultView.getComputedStyle(element2, null);
function getStyle(el, property2) {
  return getComputedStyle2(el).getPropertyValue(property2);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style2, suffix2) {
  const result = {};
  suffix2 = suffix2 ? "-" + suffix2 : "";
  for (let i3 = 0; i3 < 4; i3++) {
    const pos = positions[i3];
    result[pos] = parseFloat(styles[style2 + "-" + pos + suffix2]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x2, y3, target) => (x2 > 0 || y3 > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e3, canvas2) {
  const touches = e3.touches;
  const source = touches && touches.length ? touches[0] : e3;
  const { offsetX, offsetY } = source;
  let box = false;
  let x2, y3;
  if (useOffsetPos(offsetX, offsetY, e3.target)) {
    x2 = offsetX;
    y3 = offsetY;
  } else {
    const rect = canvas2.getBoundingClientRect();
    x2 = source.clientX - rect.left;
    y3 = source.clientY - rect.top;
    box = true;
  }
  return {
    x: x2,
    y: y3,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas: canvas2, currentDevicePixelRatio } = chart;
  const style2 = getComputedStyle2(canvas2);
  const borderBox = style2.boxSizing === "border-box";
  const paddings = getPositionedStyle(style2, "padding");
  const borders = getPositionedStyle(style2, "border", "width");
  const { x: x2, y: y3, box } = getCanvasPosition(event, canvas2);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x2 - xOffset) / width * canvas2.width / currentDevicePixelRatio),
    y: Math.round((y3 - yOffset) / height * canvas2.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas2, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas2);
    if (!container) {
      width = canvas2.clientWidth;
      height = canvas2.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle2(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY3,
    maxHeight: maxHeight || INFINITY3
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas2, bbWidth, bbHeight, aspectRatio) {
  const style2 = getComputedStyle2(canvas2);
  const margins = getPositionedStyle(style2, "margin");
  const maxWidth = parseMaxStyle(style2.maxWidth, canvas2, "clientWidth") || INFINITY3;
  const maxHeight = parseMaxStyle(style2.maxHeight, canvas2, "clientHeight") || INFINITY3;
  const containerSize = getContainerSize(canvas2, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style2.boxSizing === "content-box") {
    const borders = getPositionedStyle(style2, "border", "width");
    const paddings = getPositionedStyle(style2, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas2 = chart.canvas;
  if (canvas2.style && (forceStyle || !canvas2.style.height && !canvas2.style.width)) {
    canvas2.style.height = `${chart.height}px`;
    canvas2.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas2.height !== deviceHeight || canvas2.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas2.height = deviceHeight;
    canvas2.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e3) {
  }
  return passiveSupported;
}();
function readUsedSize(element2, property2) {
  const value = getStyle(element2, property2);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t3, mode) {
  return {
    x: p1.x + t3 * (p2.x - p1.x),
    y: p1.y + t3 * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t3, mode) {
  return {
    x: p1.x + t3 * (p2.x - p1.x),
    y: mode === "middle" ? t3 < 0.5 ? p1.y : p2.y : mode === "after" ? t3 < 1 ? p1.y : p2.y : t3 > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t3, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a4 = _pointInLine(p1, cp1, t3);
  const b2 = _pointInLine(cp1, cp2, t3);
  const c6 = _pointInLine(cp2, p2, t3);
  const d4 = _pointInLine(a4, b2, t3);
  const e3 = _pointInLine(b2, c6, t3);
  return _pointInLine(d4, e3, t3);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x2) {
      return rectX + rectX + width - x2;
    },
    setWidth(w3) {
      width = w3;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x2, value) {
      return x2 - value;
    },
    leftForLtr(x2, itemWidth) {
      return x2 - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x2) {
      return x2;
    },
    setWidth(w3) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x2, value) {
      return x2 + value;
    },
    leftForLtr(x2, _itemWidth) {
      return x2;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx3, direction) {
  let style2, original;
  if (direction === "ltr" || direction === "rtl") {
    style2 = ctx3.canvas.style;
    original = [
      style2.getPropertyValue("direction"),
      style2.getPropertyPriority("direction")
    ];
    style2.setProperty("direction", direction, "important");
    ctx3.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx3, original) {
  if (original !== void 0) {
    delete ctx3.prevTextDirection;
    ctx3.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property2) {
  if (property2 === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a4, b2) => a4 - b2,
    normalize: (x2) => x2
  };
}
function normalizeSegment({ start, end, count, loop: loop2, style: style2 }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop2 && (end - start + 1) % count === 0,
    style: style2
  };
}
function getSegment(segment, points, bounds) {
  const { property: property2, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property2);
  const count = points.length;
  let { start, end, loop: loop2 } = segment;
  let i3, ilen;
  if (loop2) {
    start += count;
    end += count;
    for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
      if (!between(normalize(points[start % count][property2]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {
    start,
    end,
    loop: loop2,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property: property2, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property2);
  const { start, end, loop: loop2, style: style2 } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i3 = start, prev = start; i3 <= end; ++i3) {
    point = points[i3 % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property2]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i3 : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i3,
        loop: loop2,
        count,
        style: style2
      }));
      subStart = null;
    }
    prev = i3;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop: loop2,
      count,
      style: style2
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i3 = 0; i3 < segments.length; i3++) {
    const sub = _boundSegment(segments[i3], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop2, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop2 && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop2) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start,
    end
  };
}
function solidSegments(points, start, max, loop2) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop2 = false;
        result.push({
          start: start % count,
          end: (end - 1) % count,
          loop: loop2
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start % count,
      end: last % count,
      loop: loop2
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop2 = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop2, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start,
        end,
        loop: loop2
      }
    ], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i3 = start;
  function addStyle(s4, e3, l2, st) {
    const dir = spanGaps ? -1 : 1;
    if (s4 === e3) {
      return;
    }
    s4 += count;
    while (points[s4 % count].skip) {
      s4 -= dir;
    }
    while (points[e3 % count].skip) {
      e3 += dir;
    }
    if (s4 % count !== e3 % count) {
      result.push({
        start: s4 % count,
        end: e3 % count,
        loop: l2,
        style: st
      });
      prevStyle = st;
      start = e3 % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style2;
    for (i3 = start + 1; i3 <= segment.end; i3++) {
      const pt = points[i3 % count];
      style2 = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i3 - 1) % count,
        p1DataIndex: i3 % count,
        datasetIndex
      })));
      if (styleChanged(style2, prevStyle)) {
        addStyle(start, i3 - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style2;
    }
    if (start < i3 - 1) {
      addStyle(start, i3 - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style2, prevStyle) {
  return prevStyle && JSON.stringify(style2) !== JSON.stringify(prevStyle);
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks2 = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks2.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i3 = items.length - 1;
      let draw2 = false;
      let item;
      for (; i3 >= 0; --i3) {
        item = items[i3];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i3] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i3 = items.length - 1;
    for (; i3 >= 0; --i3) {
      items[i3].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop2 = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop2 || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop2 && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i3 = 0; i3 < promises.length; i3++) {
      promises[i3][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject3(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject3(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray4(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i3;
    for (i3 = props.length - 1; i3 >= 0; --i3) {
      const prop = props[i3];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys2 = Object.keys(properties);
  for (let i3 = 0; i3 < keys2.length; i3++) {
    const anim = animations[keys2[i3]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x2 = scaleClip(xScale, allowedOverflow);
  const y3 = scaleClip(yScale, allowedOverflow);
  return {
    top: y3.end,
    right: x2.end,
    bottom: y3.start,
    left: x2.start
  };
}
function toClip(value) {
  let t3, r, b2, l2;
  if (isObject3(value)) {
    t3 = value.top;
    r = value.right;
    b2 = value.bottom;
    l2 = value.left;
  } else {
    t3 = r = b2 = l2 = value;
  }
  return {
    top: t3,
    right: r,
    bottom: b2,
    left: l2,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys2 = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i3, ilen;
  for (i3 = 0, ilen = metasets.length; i3 < ilen; ++i3) {
    keys2.push(metasets[i3].index);
  }
  return keys2;
}
function applyStack(stack3, value, dsIndex, options = {}) {
  const keys2 = stack3.keys;
  const singleMode = options.mode === "single";
  let i3, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i3 = 0, ilen = keys2.length; i3 < ilen; ++i3) {
    datasetIndex = +keys2[i3];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack3.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys2 = Object.keys(data);
  const adata = new Array(keys2.length);
  let i3, ilen, key;
  for (i3 = 0, ilen = keys2.length; i3 < ilen; ++i3) {
    key = keys2[i3];
    adata[i3] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack3, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack3[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack3;
  for (let i3 = 0; i3 < ilen; ++i3) {
    const item = parsed[i3];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack3 = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack3[datasetIndex] = value;
    stack3._top = getLastIndexInStack(stack3, vScale, true, meta.type);
    stack3._bottom = getLastIndexInStack(stack3, vScale, false, meta.type);
    const visualValues = stack3._visualValues || (stack3._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element2) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element: element2,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x2, y3, r) => axis === "x" ? x2 : axis === "r" ? r : y3;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject3(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i3, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray4(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject3(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i3 = 0; i3 < count; ++i3) {
        meta._parsed[i3 + start] = cur = parsed[i3];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i3, ilen, index2;
    for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
      index2 = i3 + start;
      parsed[i3] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i3, ilen, index2, item;
    for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
      index2 = i3 + start;
      item = data[index2];
      parsed[i3] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i3, ilen, index2, item;
    for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
      index2 = i3 + start;
      item = data[index2];
      parsed[i3] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack3 = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack3, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range2, scale, parsed, stack3) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack3 && parsed._stacks[scale.axis];
    if (stack3 && values) {
      stack3.values = values;
      value = applyStack(stack3, parsedValue, this._cachedMeta.index);
    }
    range2.min = Math.min(range2.min, value);
    range2.max = Math.max(range2.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack3 = createStack(canStack, meta, this.chart);
    const range2 = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i3, parsed;
    function _skip() {
      parsed = _parsed[i3];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i3 = 0; i3 < ilen; ++i3) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range2, scale, parsed, stack3);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i3 = ilen - 1; i3 >= 0; --i3) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range2, scale, parsed, stack3);
        break;
      }
    }
    return range2;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i3, ilen, value;
    for (i3 = 0, ilen = parsed.length; i3 < ilen; ++i3) {
      value = parsed[i3][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx3 = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i3;
    if (meta.dataset) {
      meta.dataset.draw(ctx3, area, start, count);
    }
    for (i3 = start; i3 < start + count; ++i3) {
      const element2 = elements2[i3];
      if (element2.hidden) {
        continue;
      }
      if (element2.active && drawActiveElementsOnTop) {
        active.push(element2);
      } else {
        element2.draw(ctx3, area);
      }
    }
    for (i3 = 0; i3 < active.length; ++i3) {
      active[i3].draw(ctx3, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element2 = this._cachedMeta.data[index2];
      context = element2.$context || (element2.$context = createDataContext(this.getContext(), index2, element2));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache2 = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache2[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes2 = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active, mode);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes2);
    if (values.$shared) {
      values.$shared = sharing;
      cache2[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache2 = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache2[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache2[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element2, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element2, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element2, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element2, index2, mode, active) {
    element2.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element2, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element2, datasetIndex, index2) {
    this._setStyle(element2, index2, "active", false);
  }
  setHoverStyle(element2, datasetIndex, index2) {
    this._setStyle(element2, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element2 = this._cachedMeta.dataset;
    if (element2) {
      this._setStyle(element2, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element2 = this._cachedMeta.dataset;
    if (element2) {
      this._setStyle(element2, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i3;
    const move2 = (arr) => {
      arr.length += count;
      for (i3 = arr.length - 1; i3 >= end; i3--) {
        arr[i3] = arr[i3 - count];
      }
    };
    move2(data);
    for (i3 = start; i3 < end; ++i3) {
      data[i3] = new this.dataElementType();
    }
    if (this._parsing) {
      move2(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element2, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i3 = 0, ilen = visibleMetas.length; i3 < ilen; i3++) {
      values = values.concat(visibleMetas[i3].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a4, b2) => a4 - b2));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i3, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i3 = 0, ilen = values.length; i3 < ilen; ++i3) {
    curr = scale.getPixelForValue(values[i3]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i3 = 0, ilen = scale.ticks.length; i3 < ilen; ++i3) {
    curr = scale.getPixelForTick(i3);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size3, ratio;
  if (isNullOrUndef(thickness)) {
    size3 = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size3 = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size3 / stackCount,
    ratio,
    start: ruler.pixels[index2] - size3 / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent2 = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent2;
  const size3 = Math.abs(next - prev) / 2 * percent2;
  return {
    chunk: size3 / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i3) {
  const startValue = vScale.parse(entry[0], i3);
  const endValue = vScale.parse(entry[1], i3);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i3) {
  if (isArray4(entry)) {
    parseFloatBar(entry, item, vScale, i3);
  } else {
    item[vScale.axis] = vScale.parse(entry, i3);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i3, ilen, item, entry;
  for (i3 = start, ilen = start + count; i3 < ilen; ++i3) {
    entry = data[i3];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i3], i3);
    parsed.push(parseValue(entry, item, vScale, i3));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size3, vScale, actualBase) {
  if (size3 !== 0) {
    return sign(size3);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack3, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack3) {
    properties.enableBorderRadius = true;
    if ((stack3._top || 0) === index2) {
      edge = top;
    } else if ((stack3._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a4, b2, reverse) {
  if (reverse) {
    edge = swap(edge, a4, b2);
    edge = startEnd(edge, b2, a4);
  } else {
    edge = startEnd(edge, a4, b2);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i3, ilen, item, obj;
    for (i3 = start, ilen = start + count; i3 < ilen; ++i3) {
      obj = data[i3];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i3);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i3));
    }
    return parsed;
  }
  updateRangeFromParsed(range2, scale, parsed, stack3) {
    super.updateRangeFromParsed(range2, scale, parsed, stack3);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range2.min = Math.min(range2.min, custom.min);
      range2.max = Math.max(range2.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base3 = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i3 = start; i3 < start + count; i3++) {
      const parsed = this.getParsed(i3);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base: base3,
        head: base3
      } : this._calculateBarValuePixels(i3);
      const ipixels = this._calculateBarIndexPixels(i3, ruler);
      const stack3 = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack3 || isFloatBar(parsed._custom) || index2 === stack3._top || index2 === stack3._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i3, bars[i3].active ? "active" : mode);
      }
      const options = properties.options || bars[i3].options;
      setBorderSkipped(properties, options, stack3, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i3], i3, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name2, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name2 !== void 0 ? stacks.indexOf(name2) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i3, ilen;
    for (i3 = 0, ilen = meta.data.length; i3 < ilen; ++i3) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i3)[iScale.axis], i3));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size3;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base3 = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base3;
    }
    size3 = head - base3;
    if (Math.abs(size3) < minBarLength) {
      size3 = barSign(size3, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base3 -= size3 / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base3 = Math.max(Math.min(base3, max), min);
      head = base3 + size3;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base3);
      }
    }
    if (base3 === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size3) * vScale.getLineWidthForValue(actualBase) / 2;
      base3 += halfGrid;
      size3 -= halfGrid;
    }
    return {
      size: size3,
      base: base3,
      head,
      center: head + size3 / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size3;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
      size3 = Math.min(maxBarThickness, range2.chunk * range2.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size3 = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size3 / 2,
      head: center + size3 / 2,
      center,
      size: size3
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i3 = 0;
    for (; i3 < ilen; ++i3) {
      if (this.getParsed(i3)[vScale.axis] !== null) {
        rects[i3].draw(this._ctx);
      }
    }
  }
};
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i3 = 0; i3 < parsed.length; i3++) {
      parsed[i3]._custom = this.resolveDataElementOptions(i3 + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i3 = 0; i3 < parsed.length; i3++) {
      const item = data[start + i3];
      parsed[i3]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i3 + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i3 = 0; i3 < parsed.length; i3++) {
      const item = data[start + i3];
      parsed[i3]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i3 + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i3 = data.length - 1; i3 >= 0; --i3) {
      max = Math.max(max, data[i3].size(this.resolveDataElementOptions(i3)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x2 = xScale.getLabelForValue(parsed.x);
    const y3 = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index2] || "",
      value: "(" + x2 + ", " + y3 + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i3 = start; i3 < start + count; i3++) {
      const point = points[i3];
      const parsed = !reset && this.getParsed(i3);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i3, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i3, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
__publicField(BubbleController, "id", "bubble");
__publicField(BubbleController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
});
__publicField(BubbleController, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a4, b2) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a4, a4 * cutout, b2, b2 * cutout);
    const calcMin = (angle, a4, b2) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a4, a4 * cutout, b2, b2 * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i4) => +data[i4];
      if (isObject3(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i4) => +resolveObjectKey(data[i4], key);
      }
      let i3, ilen;
      for (i3 = start, ilen = start + count; i3 < ilen; ++i3) {
        meta._parsed[i3] = getter(i3);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i3 = 0; i3 < this.chart.data.datasets.length; ++i3) {
      if (this.chart.isDatasetVisible(i3) && this.chart.getDatasetMeta(i3).type === this._type) {
        const controller = this.chart.getDatasetMeta(i3).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i3, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i3) || meta._parsed[i3] === null || meta.data[i3].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i3] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i3;
    for (i3 = 0; i3 < start; ++i3) {
      startAngle += this._circumference(i3, reset);
    }
    for (i3 = start; i3 < start + count; ++i3) {
      const circumference = this._circumference(i3, reset);
      const arc = arcs[i3];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i3, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i3, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i3;
    for (i3 = 0; i3 < metaData.length; i3++) {
      const value = meta._parsed[i3];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i3) && !metaData[i3].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i3, ilen, meta, controller, options;
    if (!arcs) {
      for (i3 = 0, ilen = chart.data.datasets.length; i3 < ilen; ++i3) {
        if (chart.isDatasetVisible(i3)) {
          meta = chart.getDatasetMeta(i3);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i3 = 0, ilen = arcs.length; i3 < ilen; ++i3) {
      options = controller.resolveDataElementOptions(i3);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i3 = 0, ilen = arcs.length; i3 < ilen; ++i3) {
      const options = this.resolveDataElementOptions(i3);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i3 = 0; i3 < datasetIndex; ++i3) {
      if (this.chart.isDatasetVisible(i3)) {
        ringWeightOffset += this._getRingWeight(i3);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name2) => name2 !== "spacing",
  _indexable: (name2) => name2 !== "spacing"
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i3) => {
              const meta = chart.getDatasetMeta(0);
              const style2 = meta.controller.getStyle(i3);
              return {
                text: label,
                fillStyle: style2.backgroundColor,
                strokeStyle: style2.borderColor,
                fontColor: color2,
                lineWidth: style2.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i3),
                index: i3
              };
            });
          }
          return [];
        }
      },
      onClick(e3, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber2(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i3 = 0; i3 < pointsCount; ++i3) {
      const point = points[i3];
      const properties = directUpdate ? point : {};
      if (i3 < start || i3 >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i3);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i3);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i3);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i3 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i3];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i3, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i3, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range2 = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element2, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range2.min) {
          range2.min = parsed;
        }
        if (parsed > range2.max) {
          range2.max = parsed;
        }
      }
    });
    return range2;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i3;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i3 = 0; i3 < start; ++i3) {
      angle += this._computeAngle(i3, mode, defaultAngle);
    }
    for (i3 = start; i3 < start + count; i3++) {
      const arc = arcs[i3];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i3, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i3) ? scale.getDistanceFromCenterForValue(this.getParsed(i3).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i3, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i3, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element2, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
};
__publicField(PolarAreaController, "id", "polarArea");
__publicField(PolarAreaController, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
});
__publicField(PolarAreaController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i3) => {
              const meta = chart.getDatasetMeta(0);
              const style2 = meta.controller.getStyle(i3);
              return {
                text: label,
                fillStyle: style2.backgroundColor,
                strokeStyle: style2.borderColor,
                fontColor: color2,
                lineWidth: style2.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i3),
                index: i3
              };
            });
          }
          return [];
        }
      },
      onClick(e3, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
});
var PieController = class extends DoughnutController {
};
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
var RadarController = class extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i3 = start; i3 < start + count; i3++) {
      const point = points[i3];
      const options = this.resolveDataElementOptions(i3, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i3, this.getParsed(i3).r);
      const x2 = reset ? scale.xCenter : pointPosition.x;
      const y3 = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x: x2,
        y: y3,
        angle: pointPosition.angle,
        skip: isNaN(x2) || isNaN(y3),
        options
      };
      this.updateElement(point, i3, properties, mode);
    }
  }
};
__publicField(RadarController, "id", "radar");
__publicField(RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
var ScatterController = class extends DatasetController {
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x2 = xScale.getLabelForValue(parsed.x);
    const y3 = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index2] || "",
      value: "(" + x2 + ", " + y3 + ")"
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber2(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i3 = start; i3 < start + count; ++i3) {
      const point = points[i3];
      const parsed = this.getParsed(i3);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i3);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i3);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i3 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i3];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i3, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i3, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i3 = data.length - 1; i3 >= 0; --i3) {
        max = Math.max(max, data[i3].size(this.resolveDataElementOptions(i3)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
};
__publicField(ScatterController, "id", "scatter");
__publicField(ScatterController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
});
__publicField(ScatterController, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PolarAreaController,
  PieController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class {
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  constructor(options) {
    this.options = options || {};
  }
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range2 = typeof el.getRange === "function" && el.getRange(axis);
      if (range2) {
        const start = lookupMethod(data, axis, value - range2);
        const end = lookupMethod(data, axis, value + range2);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i3 = 0, ilen = metasets.length; i3 < ilen; ++i3) {
    const { index: index2, data } = metasets[i3];
    const { lo, hi } = binarySearch(metasets[i3], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element2 = data[j];
      if (!element2.skip) {
        handler(element2, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element2, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element2, chart.chartArea, 0)) {
      return;
    }
    if (element2.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element2, datasetIndex, index2) {
    const { startAngle, endAngle } = element2.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element2, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element2, datasetIndex, index2) {
    const inRange2 = element2.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element2.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element: element2,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element2, datasetIndex, index2) => {
    if (element2[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element2.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e3, options, useFinalPosition) {
      const position = getRelativePosition(e3, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element2 = meta.data[index2];
        if (element2 && !element2.skip) {
          elements2.push({
            element: element2,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements2;
    },
    dataset(chart, e3, options, useFinalPosition) {
      const position = getRelativePosition(e3, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i3 = 0; i3 < data.length; ++i3) {
          items.push({
            element: data[i3],
            datasetIndex,
            index: i3
          });
        }
      }
      return items;
    },
    point(chart, e3, options, useFinalPosition) {
      const position = getRelativePosition(e3, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e3, options, useFinalPosition) {
      const position = getRelativePosition(e3, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e3, options, useFinalPosition) {
      const position = getRelativePosition(e3, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e3, options, useFinalPosition) {
      const position = getRelativePosition(e3, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a4, b2) => {
    const v0 = reverse ? b2 : a4;
    const v1 = reverse ? a4 : b2;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i3, ilen, box, pos, stack3, stackWeight;
  for (i3 = 0, ilen = (boxes || []).length; i3 < ilen; ++i3) {
    box = boxes[i3];
    ({ position: pos, options: { stack: stack3, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i3,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack3 && pos + stack3,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack: stack3, pos, stackWeight } = wrap;
    if (!stack3 || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack3] || (stacks[stack3] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i3, ilen, layout;
  for (i3 = 0, ilen = layouts2.length; i3 < ilen; ++i3) {
    layout = layouts2[i3];
    const { fullSize } = layout.box;
    const stack3 = stacks[layout.stack];
    const factor = stack3 && layout.stackWeight / stack3.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a4, b2) {
  return Math.max(maxPadding[a4], chartArea[a4]) + Math.max(maxPadding[b2], chartArea[b2]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject3(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack3 = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack3.size = Math.max(stack3.size, layout.horizontal ? box.height : box.width);
    layout.size = stack3.size / stack3.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i3, ilen, layout, box, refit, changed;
  for (i3 = 0, ilen = boxes.length, refit = 0; i3 < ilen; ++i3) {
    layout = boxes[i3];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x: x2, y: y3 } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack3 = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack3.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack3.size || box.height;
      if (defined(stack3.start)) {
        y3 = stack3.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y3, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack3.placed, y3, width, height);
      }
      stack3.start = y3;
      stack3.placed += width;
      y3 = box.bottom;
    } else {
      const height1 = chartArea.h * weight;
      const width1 = stack3.size || box.width;
      if (defined(stack3.start)) {
        x2 = stack3.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x2, userPadding.top, width1, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x2, chartArea.top + stack3.placed, width1, height1);
      }
      stack3.start = x2;
      stack3.placed += height1;
      x2 = box.right;
    }
  }
  chartArea.x = x2;
  chartArea.y = y3;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas2, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element2, width, height, aspectRatio) {
    width = Math.max(0, width || element2.width);
    height = height || element2.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas2) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas2, aspectRatio) {
  const style2 = canvas2.style;
  const renderHeight = canvas2.getAttribute("height");
  const renderWidth = canvas2.getAttribute("width");
  canvas2[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style2.display,
        height: style2.height,
        width: style2.width
      }
    }
  };
  style2.display = style2.display || "block";
  style2.boxSizing = style2.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas2, "width");
    if (displayWidth !== void 0) {
      canvas2.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas2.style.height === "") {
      canvas2.height = canvas2.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas2, "height");
      if (displayHeight !== void 0) {
        canvas2.height = displayHeight;
      }
    }
  }
  return canvas2;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x: x2, y: y3 } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x2 !== void 0 ? x2 : null,
    y: y3 !== void 0 ? y3 : null
  };
}
function nodeListContains(nodeList, canvas2) {
  for (const node of nodeList) {
    if (node === canvas2 || node.contains(canvas2)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas2 = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger3 = false;
    for (const entry of entries) {
      trigger3 = trigger3 || nodeListContains(entry.addedNodes, canvas2);
      trigger3 = trigger3 && !nodeListContains(entry.removedNodes, canvas2);
    }
    if (trigger3) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas2 = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger3 = false;
    for (const entry of entries) {
      trigger3 = trigger3 || nodeListContains(entry.removedNodes, canvas2);
      trigger3 = trigger3 && !nodeListContains(entry.addedNodes, canvas2);
    }
    if (trigger3) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas2 = chart.canvas;
  const container = canvas2 && _getParentNode(canvas2);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w3 = container.clientWidth;
    listener(width, height);
    if (w3 < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas2 = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas2, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas2, aspectRatio) {
    const context = canvas2 && canvas2.getContext && canvas2.getContext("2d");
    if (context && context.canvas === canvas2) {
      initCanvas(canvas2, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas2 = context.canvas;
    if (!canvas2[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas2[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas2.removeAttribute(prop);
      } else {
        canvas2.setAttribute(prop, value);
      }
    });
    const style2 = initial.style || {};
    Object.keys(style2).forEach((key) => {
      canvas2.style[key] = style2[key];
    });
    canvas2.width = canvas2.width;
    delete canvas2[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas2, width, height, aspectRatio) {
    return getMaximumSize(canvas2, width, height, aspectRatio);
  }
  isAttached(canvas2) {
    const container = _getParentNode(canvas2);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas2) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas2 instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element2 = class {
  constructor() {
    __publicField(this, "active", false);
  }
  tooltipPosition(useFinalPosition) {
    const { x: x2, y: y3 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x: x2,
      y: y3
    };
  }
  hasValue() {
    return isNumber2(this.x) && isNumber2(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element2, "defaults", {});
__publicField(Element2, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i3, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i3 = 0, ilen = numMajorIndices - 1; i3 < ilen; i3++) {
      skip(ticks, newTicks, spacing, majorIndices[i3], majorIndices[i3 + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i3 = 0, ilen = factors.length - 1; i3 < ilen; i3++) {
    const factor = factors[i3];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i3, ilen;
  for (i3 = 0, ilen = ticks.length; i3 < ilen; i3++) {
    if (ticks[i3].major) {
      result.push(i3);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i3;
  spacing = Math.ceil(spacing);
  for (i3 = 0; i3 < ticks.length; i3++) {
    if (i3 === next) {
      newTicks.push(ticks[i3]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i3, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i3 = Math.max(start, 0); i3 < end; i3++) {
    if (i3 === next) {
      newTicks.push(ticks[i3]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i3, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i3 = 1; i3 < len; ++i3) {
    if (arr[i3] - arr[i3 - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i3 = 0;
  for (; i3 < len; i3 += increment) {
    result.push(arr[Math.floor(i3)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache2) => {
    const gc = cache2.gc;
    const gcLen = gc.length / 2;
    let i3;
    if (gcLen > length) {
      for (i3 = 0; i3 < gcLen; ++i3) {
        delete cache2.data[gc[i3]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray4(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick2) {
  return createContext(parent, {
    tick: tick2,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject3(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject3(position)) {
      const positionAxisID1 = Object.keys(position)[0];
      const value1 = position[positionAxisID1];
      titleX = scales2[positionAxisID1].getPixelForValue(value1) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class extends Element2 {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range2;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i3 = 0, ilen = metas.length; i3 < ilen; ++i3) {
      range2 = metas[i3].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range2.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range2.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name2) {
    this.chart.notifyPlugins(name2, this.getContext());
    callback(this.options[name2], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i3, ilen, tick2;
    for (i3 = 0, ilen = ticks.length; i3 < ilen; i3++) {
      tick2 = ticks[i3];
      tick2.label = callback(tickOpts.callback, [
        tick2.value,
        i3,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i3, ilen;
    for (i3 = 0, ilen = ticks.length; i3 < ilen; i3++) {
      if (isNullOrUndef(ticks[i3].label)) {
        ticks.splice(i3, 1);
        ilen--;
        i3--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const { ctx: ctx3, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i3, j, jlen, label, tickFont, fontString, cache2, lineHeight3, width, height, nestedLabel;
    for (i3 = 0; i3 < length; ++i3) {
      label = ticks[i3].label;
      tickFont = this._resolveTickFontOptions(i3);
      ctx3.font = fontString = tickFont.string;
      cache2 = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight3 = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray4(label)) {
        width = _measureText(ctx3, cache2.data, cache2.gc, width, label);
        height = lineHeight3;
      } else if (isArray4(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray4(nestedLabel)) {
            width = _measureText(ctx3, cache2.data, cache2.gc, width, nestedLabel);
            height += lineHeight3;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick2 = ticks[index2];
      return tick2.$context || (tick2.$context = createTickContext(this.getContext(), index2, tick2));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w3 = labelSizes ? labelSizes.widest.width + padding : 0;
    const h6 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h6 * cos > w3 * sin ? w3 / cos : h6 / sin : h6 * sin < w3 * cos ? h6 / cos : w3 / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i3, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y22;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y22 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y22 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject3(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y22 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject3(position)) {
        const positionAxisID1 = Object.keys(position)[0];
        const value1 = position[positionAxisID1];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID1].getPixelForValue(value1));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i3 = 0; i3 < ticksLength; i3 += step) {
      const context = this.getContext(i3);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i3, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y22 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2: y22,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i3, ilen, tick2, label, x2, y3, textAlign, pixel, font, lineHeight3, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y3 = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y3 = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x2 = ret.x;
    } else if (position === "right") {
      const ret1 = this._getYAxisLabelAlignment(tl);
      textAlign = ret1.textAlign;
      x2 = ret1.x;
    } else if (axis === "x") {
      if (position === "center") {
        y3 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject3(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y3 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x2 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject3(position)) {
        const positionAxisID1 = Object.keys(position)[0];
        const value1 = position[positionAxisID1];
        x2 = this.chart.scales[positionAxisID1].getPixelForValue(value1);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i3 = 0, ilen = ticks.length; i3 < ilen; ++i3) {
      tick2 = ticks[i3];
      label = tick2.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i3));
      pixel = this.getPixelForTick(i3) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i3);
      lineHeight3 = font.lineHeight;
      lineCount = isArray4(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x2 = pixel;
        if (textAlign === "inner") {
          if (i3 === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i3 === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight3 + lineHeight3 / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight3 + lineHeight3;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight3 / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight3 / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight3;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight3;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x2 += lineHeight3 / 2 * Math.sin(rotation);
        }
      } else {
        y3 = pixel;
        textOffset = (1 - lineCount) * lineHeight3 / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i3];
        const width = labelSizes.widths[i3];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x2,
            y3
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x2;
    if (position === "left") {
      if (mirror) {
        x2 = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 += widest;
        }
      } else {
        x2 = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x2 = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 -= widest;
        }
      } else {
        x2 = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x: x2
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx: ctx3, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx3.save();
      ctx3.fillStyle = backgroundColor;
      ctx3.fillRect(left, top, width, height);
      ctx3.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t3) => t3.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx3 = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i3, ilen;
    const drawLine = (p1, p2, style2) => {
      if (!style2.width || !style2.color) {
        return;
      }
      ctx3.save();
      ctx3.lineWidth = style2.width;
      ctx3.strokeStyle = style2.color;
      ctx3.setLineDash(style2.borderDash || []);
      ctx3.lineDashOffset = style2.borderDashOffset;
      ctx3.beginPath();
      ctx3.moveTo(p1.x, p1.y);
      ctx3.lineTo(p2.x, p2.y);
      ctx3.stroke();
      ctx3.restore();
    };
    if (grid.display) {
      for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
        const item = items[i3];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx: ctx3, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y22;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y22 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y22 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx3.save();
    ctx3.lineWidth = borderOpts.width;
    ctx3.strokeStyle = borderOpts.color;
    ctx3.beginPath();
    ctx3.moveTo(x1, y1);
    ctx3.lineTo(x2, y22);
    ctx3.stroke();
    ctx3.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx3 = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx3, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y3 = item.textOffset;
      renderText(ctx3, label, 0, y3, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx3);
    }
  }
  drawTitle() {
    const { ctx: ctx3, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject3(position)) {
      offset += padding.bottom;
      if (isArray4(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx3, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i3, ilen;
    for (i3 = 0, ilen = metas.length; i3 < ilen; ++i3) {
      const meta = metas[i3];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize2 = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize2;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge3(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property2) => {
    const propertyParts = property2.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property2].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element2, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i3 = 0; i3 < this._typedRegistries.length; i3++) {
      const reg = this._typedRegistries[i3];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter2) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors3 = filter2 ? this._descriptors(chart).filter(filter2) : this._descriptors(chart);
    const result = this._notify(descriptors3, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors3, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors3, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors3) {
      const plugin3 = descriptor.plugin;
      const method = plugin3[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin3) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors3 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors3;
  }
  _createDescriptors(chart, all3) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all3 ? [] : createDescriptors(chart, plugins2, options, all3);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors3 = this._cache;
    const diff = (a4, b2) => a4.filter((x2) => !b2.some((y3) => x2.plugin.id === y3.plugin.id));
    this._notify(diff(previousDescriptors, descriptors3), chart, "stop");
    this._notify(diff(descriptors3, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys2 = Object.keys(registry.plugins.items);
  for (let i3 = 0; i3 < keys2.length; i3++) {
    plugins2.push(registry.getPlugin(keys2[i3]));
  }
  const local = config.plugins || [];
  for (let i1 = 0; i1 < local.length; i1++) {
    const plugin3 = local[i1];
    if (plugins2.indexOf(plugin3) === -1) {
      plugins2.push(plugin3);
      localIds[plugin3.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options, all3) {
  if (!all3 && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all3) {
  const result = [];
  const context = chart.getContext();
  for (const plugin3 of plugins2) {
    const id = plugin3.id;
    const opts = getOpts(options[id], all3);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin: plugin3,
      options: pluginOpts(chart.config, {
        plugin: plugin3,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin: plugin3, local }, opts, context) {
  const keys2 = config.pluginScopeKeys(plugin3);
  const scopes = config.getOptionScopes(opts, keys2);
  if (local && plugin3.defaults) {
    scopes.push(plugin3.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, scaleOptions) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
  id = scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.length > 1 && determineAxis(id[0].toLowerCase(), scaleOptions);
  if (id) {
    return id;
  }
  throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`);
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject3(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys2 = keyCache.get(cacheKey);
  if (!keys2) {
    keys2 = generate();
    keyCache.set(cacheKey, keys2);
    keysCached.add(keys2);
  }
  return keys2;
}
var addIfFound = (set3, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set3.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin3) {
    const id = plugin3.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin3.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache2 = _scopeCache.get(mainScope);
    if (!cache2 || resetCache) {
      cache2 = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache2);
    }
    return cache2;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache2 = this._cachedScopes(mainScope, resetCache);
    const cached = cache2.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys2) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys2.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys2.forEach((key) => addIfFound(scopes, options, key));
      keys2.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys2.forEach((key) => addIfFound(scopes, defaults, key));
      keys2.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache2.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes2 = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes2);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction3(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes2 = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes2);
    return isObject3(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes2) {
  let cache2 = resolverCache.get(scopes);
  if (!cache2) {
    cache2 = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache2);
  }
  const cacheKey = prefixes2.join();
  let cached = cache2.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes2);
    cached = {
      resolver,
      subPrefixes: prefixes2.filter((p2) => !p2.toLowerCase().includes("hover"))
    };
    cache2.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject3(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction3(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction3(value) || hasFunction(value)) || indexable && isArray4(value)) {
      return true;
    }
  }
  return false;
}
var version2 = "4.2.0";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a4, b2) {
    return a4[l1] === b2[l1] ? a4[l2] - b2[l2] : a4[l1] - b2[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas2 = getCanvas(key);
  return Object.values(instances).filter((c6) => c6.canvas === canvas2).pop();
};
function moveNumericKeys(obj, start, move2) {
  const keys2 = Object.keys(obj);
  for (const key of keys2) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move2 > 0 || intKey > start) {
        obj[intKey + move2] = value;
      }
    }
  }
}
function determineLastEvent(e3, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e3.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e3;
}
function getDatasetArea(meta) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: xScale.left,
      right: xScale.right,
      top: yScale.top,
      bottom: yScale.bottom
    };
  }
}
var Chart = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas2 = context && context.canvas;
    const height = canvas2 && canvas2.height;
    const width = canvas2 && canvas2.width;
    this.id = uid2();
    this.ctx = context;
    this.canvas = canvas2;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas2) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas2 = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas2, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a4, b2) => a4.index - b2.index);
    if (numMeta > numData) {
      for (let i3 = numData; i3 < numMeta; ++i3) {
        this._destroyDatasetMeta(i3);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x2) => x2 === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i3, ilen;
    this._removeUnreferencedMetasets();
    for (i3 = 0, ilen = datasets.length; i3 < ilen; i3++) {
      const dataset = datasets[i3];
      let meta = this.getDatasetMeta(i3);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i3);
        meta = this.getDatasetMeta(i3);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i3;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i3);
      if (meta.controller) {
        meta.controller.updateIndex(i3);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i3);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i3 = 0, ilen = this.data.datasets.length; i3 < ilen; i3++) {
      const { controller } = this.getDatasetMeta(i3);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move2 = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move2);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c6) => c6[0] === idx).map((c6, i3) => i3 + "," + c6.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i3 = 1; i3 < datasetCount; i3++) {
      if (!setsEqual(changeSet, makeSet(i3))) {
        return;
      }
    }
    return Array.from(changeSet).map((c6) => c6.split(",")).map((a4) => ({
      method: a4[1],
      start: +a4[2],
      count: +a4[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i3 = 0, ilen = this.data.datasets.length; i3 < ilen; ++i3) {
      this.getDatasetMeta(i3).controller.configure();
    }
    for (let i1 = 0, ilen1 = this.data.datasets.length; i1 < ilen1; ++i1) {
      this._updateDataset(i1, isFunction3(mode) ? mode({
        datasetIndex: i1
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i3;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i3 = 0; i3 < layers.length && layers[i3].z <= 0; ++i3) {
      layers[i3].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i3 < layers.length; ++i3) {
      layers[i3].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i3, ilen;
    for (i3 = 0, ilen = metasets.length; i3 < ilen; ++i3) {
      const meta = metasets[i3];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i3 = metasets.length - 1; i3 >= 0; --i3) {
      this._drawDataset(metasets[i3]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx3 = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta) || this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx3, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx3);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e3, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e3, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x2) => x2 && x2._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx3) => ctx3.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i3, ilen;
    this.stop();
    animator.remove(this);
    for (i3 = 0, ilen = this.data.datasets.length; i3 < ilen; ++i3) {
      this._destroyDatasetMeta(i3);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: canvas2, ctx: ctx3 } = this;
    this._stop();
    this.config.clearCache();
    if (canvas2) {
      this.unbindEvents();
      clearCanvas(canvas2, ctx3);
      this.platform.releaseContext(ctx3);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e3, x2, y3) => {
      e3.offsetX = x2;
      e3.offsetY = y3;
      this._eventHandler(e3);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix3 = enabled ? "set" : "remove";
    let meta, item, i3, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix3 + "DatasetHoverStyle"]();
    }
    for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
      item = items[i3];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix3 + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter2) {
    return this._plugins.notify(this, hook, args, filter2);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p2) => p2.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a4, b2) => a4.filter((x2) => !b2.some((y3) => x2.datasetIndex === y3.datasetIndex && x2.index === y3.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e3, replay) {
    const args = {
      event: e3,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e3)
    };
    const eventFilter = (plugin3) => (plugin3.options.events || this.options.events).includes(e3.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e3, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e3, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e3, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e3);
    const lastEvent = determineLastEvent(e3, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e3,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e3,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e3, lastActive, inChartArea, useFinalPosition) {
    if (e3.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e3, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version2);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx3, element2, endAngle) {
  const { startAngle, pixelMargin, x: x2, y: y3, outerRadius, innerRadius } = element2;
  let angleMargin = pixelMargin / outerRadius;
  ctx3.beginPath();
  ctx3.arc(x2, y3, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx3.arc(x2, y3, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx3.arc(x2, y3, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx3.closePath();
  ctx3.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o2 = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o2.outerStart),
    outerEnd: computeOuterLimit(o2.outerEnd),
    innerStart: _limitValue(o2.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o2.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x2, y3) {
  return {
    x: x2 + r * Math.cos(theta),
    y: y3 + r * Math.sin(theta)
  };
}
function pathArc(ctx3, element2, offset, spacing, end, circular) {
  const { x: x2, y: y3, startAngle: start, pixelMargin, innerRadius: innerR } = element2;
  const outerRadius = Math.max(element2.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element2, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx3.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx3.arc(x2, y3, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx3.arc(x2, y3, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x2, y3);
      ctx3.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x2, y3);
    ctx3.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter1 = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x2, y3);
      ctx3.arc(pCenter1.x, pCenter1.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx3.arc(x2, y3, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx3.arc(x2, y3, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter2 = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x2, y3);
      ctx3.arc(pCenter2.x, pCenter2.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x2, y3);
    ctx3.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter3 = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x2, y3);
      ctx3.arc(pCenter3.x, pCenter3.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx3.moveTo(x2, y3);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x2;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y3;
    ctx3.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x2;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y3;
    ctx3.lineTo(outerEndX, outerEndY);
  }
  ctx3.closePath();
}
function drawArc(ctx3, element2, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element2;
  let endAngle = element2.endAngle;
  if (fullCircles) {
    pathArc(ctx3, element2, offset, spacing, endAngle, circular);
    for (let i3 = 0; i3 < fullCircles; ++i3) {
      ctx3.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx3, element2, offset, spacing, endAngle, circular);
  ctx3.fill();
  return endAngle;
}
function drawBorder(ctx3, element2, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element2;
  const { borderWidth, borderJoinStyle } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx3.lineWidth = borderWidth * 2;
    ctx3.lineJoin = borderJoinStyle || "round";
  } else {
    ctx3.lineWidth = borderWidth;
    ctx3.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element2.endAngle;
  if (fullCircles) {
    pathArc(ctx3, element2, offset, spacing, endAngle, circular);
    for (let i3 = 0; i3 < fullCircles; ++i3) {
      ctx3.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx3, element2, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx3, element2, offset, spacing, endAngle, circular);
    ctx3.stroke();
  }
}
var ArcElement = class extends Element2 {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y3, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x2 + Math.cos(halfAngle) * halfRadius,
      y: y3 + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx3) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx3.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx3.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx3.fillStyle = options.backgroundColor;
    ctx3.strokeStyle = options.borderColor;
    drawArc(ctx3, this, radiusOffset, spacing, circular);
    drawBorder(ctx3, this, radiusOffset, spacing, circular);
    ctx3.restore();
  }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
function setStyle2(ctx3, options, style2 = options) {
  ctx3.lineCap = valueOrDefault(style2.borderCapStyle, options.borderCapStyle);
  ctx3.setLineDash(valueOrDefault(style2.borderDash, options.borderDash));
  ctx3.lineDashOffset = valueOrDefault(style2.borderDashOffset, options.borderDashOffset);
  ctx3.lineJoin = valueOrDefault(style2.borderJoinStyle, options.borderJoinStyle);
  ctx3.lineWidth = valueOrDefault(style2.borderWidth, options.borderWidth);
  ctx3.strokeStyle = valueOrDefault(style2.borderColor, options.borderColor);
}
function lineTo(ctx3, previous, target) {
  ctx3.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx3, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop: loop2, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move: move2 = true, reverse } = params || {};
  let i3, point, prev;
  for (i3 = 0; i3 <= ilen; ++i3) {
    point = points[(start + (reverse ? ilen - i3 : i3)) % count];
    if (point.skip) {
      continue;
    } else if (move2) {
      ctx3.moveTo(point.x, point.y);
      move2 = false;
    } else {
      lineMethod(ctx3, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop2) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx3, prev, point, reverse, options.stepped);
  }
  return !!loop2;
}
function fastPathSegment(ctx3, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move: move2 = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i3, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx3.lineTo(avgX, maxY);
      ctx3.lineTo(avgX, minY);
      ctx3.lineTo(avgX, lastY);
    }
  };
  if (move2) {
    point = points[pointIndex(0)];
    ctx3.moveTo(point.x, point.y);
  }
  for (i3 = 0; i3 <= ilen; ++i3) {
    point = points[pointIndex(i3)];
    if (point.skip) {
      continue;
    }
    const x2 = point.x;
    const y3 = point.y;
    const truncX = x2 | 0;
    if (truncX === prevX) {
      if (y3 < minY) {
        minY = y3;
      } else if (y3 > maxY) {
        maxY = y3;
      }
      avgX = (countX * avgX + x2) / ++countX;
    } else {
      drawX();
      ctx3.lineTo(x2, y3);
      prevX = truncX;
      countX = 0;
      minY = maxY = y3;
    }
    lastY = y3;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx3, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle2(ctx3, line.options);
  ctx3.stroke(path);
}
function strokePathDirect(ctx3, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle2(ctx3, options, segment.style);
    ctx3.beginPath();
    if (segmentMethod(ctx3, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx3.closePath();
    }
    ctx3.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx3, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx3, line, start, count);
  } else {
    strokePathDirect(ctx3, line, start, count);
  }
}
var LineElement = class extends Element2 {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop2 = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop2, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property2) {
    const options = this.options;
    const value = point[property2];
    const points = this.points;
    const segments = _boundSegments(this, {
      property: property2,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i3, ilen;
    for (i3 = 0, ilen = segments.length; i3 < ilen; ++i3) {
      const { start, end } = segments[i3];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t3 = Math.abs((value - p1[property2]) / (p2[property2] - p1[property2]));
      const interpolated = _interpolate(p1, p2, t3, options.stepped);
      interpolated[property2] = point[property2];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx3, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx3, this, segment, params);
  }
  path(ctx3, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop2 = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop2 &= segmentMethod(ctx3, this, segment, {
        start,
        end: start + count - 1
      });
    }
    return !!loop2;
  }
  draw(ctx3, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx3.save();
      draw(ctx3, this, start, count);
      ctx3.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name2) => name2 !== "borderDash" && name2 !== "fill"
});
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element2 {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x: x2, y: y3 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x2, 2) + Math.pow(mouseY - y3, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y3 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x: x2,
      y: y3
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx3, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx3.strokeStyle = options.borderColor;
    ctx3.lineWidth = options.borderWidth;
    ctx3.fillStyle = options.backgroundColor;
    drawPoint(ctx3, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
__publicField(PointElement, "id", "point");
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x: x2, y: y3, base: base3, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x2, base3);
    right = Math.max(x2, base3);
    top = y3 - half;
    bottom = y3 + half;
  } else {
    half = width / 2;
    left = x2 - half;
    right = x2 + half;
    top = Math.min(y3, base3);
    bottom = Math.max(y3, base3);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o2 = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o2.top, 0, maxH),
    r: skipOrLimit(skip2.right, o2.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o2.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o2.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o2 = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject3(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o2.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o2.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o2.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o2.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x2, y3, useFinalPosition) {
  const skipX = x2 === null;
  const skipY = y3 === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x2, bounds.left, bounds.right)) && (skipY || _isBetween(y3, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx3, rect) {
  ctx3.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x2 = rect.x !== refRect.x ? -amount : 0;
  const y3 = rect.y !== refRect.y ? -amount : 0;
  const w3 = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x2;
  const h6 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y3;
  return {
    x: rect.x + x2,
    y: rect.y + y3,
    w: rect.w + w3,
    h: rect.h + h6,
    radius: rect.radius
  };
}
var BarElement = class extends Element2 {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx3) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx3.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx3.beginPath();
      addRectPath(ctx3, inflateRect(outer, inflateAmount, inner));
      ctx3.clip();
      addRectPath(ctx3, inflateRect(inner, -inflateAmount, outer));
      ctx3.fillStyle = borderColor;
      ctx3.fill("evenodd");
    }
    ctx3.beginPath();
    addRectPath(ctx3, inflateRect(inner, inflateAmount));
    ctx3.fillStyle = backgroundColor;
    ctx3.fill();
    ctx3.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y3, base: base3, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x2 + base3) / 2 : x2,
      y: horizontal ? y3 : (y3 + base3) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  LineElement,
  PointElement,
  BarElement
});
var BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
];
var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i3) {
  return BORDER_COLORS[i3 % BORDER_COLORS.length];
}
function getBackgroundColor(i3) {
  return BACKGROUND_COLORS[i3 % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i3) {
  dataset.borderColor = getBorderColor(i3);
  dataset.backgroundColor = getBackgroundColor(i3);
  return ++i3;
}
function colorizeDoughnutDataset(dataset, i3) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i3++));
  return i3;
}
function colorizePolarAreaDataset(dataset, i3) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i3++));
  return i3;
}
function getColorizer(chart) {
  let i3 = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i3 = colorizeDoughnutDataset(dataset, i3);
    } else if (controller instanceof PolarAreaController) {
      i3 = colorizePolarAreaDataset(dataset, i3);
    } else if (controller) {
      i3 = colorizeDefaultDataset(dataset, i3);
    }
  };
}
function containsColorsDefinitions(descriptors3) {
  let k2;
  for (k2 in descriptors3) {
    if (descriptors3[k2].borderColor || descriptors3[k2].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a4 = start;
  let i3, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a4];
  for (i3 = 0; i3 < samples - 2; i3++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i3 + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i3 + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i3 * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i3 + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a4];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a4 = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i3, point, x2, y3, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i3 = start; i3 < start + count; ++i3) {
    point = data[i3];
    x2 = (point.x - xMin) / dx * availableWidth;
    y3 = point.y;
    const truncX = x2 | 0;
    if (truncX === prevX) {
      if (y3 < minY) {
        minY = y3;
        minIndex = i3;
      } else if (y3 > maxY) {
        maxY = y3;
        maxIndex = i3;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i3 - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i3 > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y3;
      minIndex = maxIndex = startIndex = i3;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {
    start,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d4) {
            this._data = d4;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property2) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property2, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property2, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property2]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property2]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property2, first, last, loop2) {
  if (loop2) {
    return;
  }
  let start = first[property2];
  let end = last[property2];
  if (property2 === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {
    property: property2,
    start,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const { x: x2 = null, y: y3 = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y3 !== null) {
      points.push({
        x: first.x,
        y: y3
      });
      points.push({
        x: last.x,
        y: y3
      });
    } else if (x2 !== null) {
      points.push({
        x: x2,
        y: first.y
      });
      points.push({
        x: x2,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a4, b2, prop, fn) {
  if (a4 && b2) {
    return fn(a4[prop], b2[prop]);
  }
  return a4 ? a4[prop] : b2 ? b2[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray4(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [
    index2
  ];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject3(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject3(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject3(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));
  for (let i3 = 0; i3 < segments.length; i3++) {
    const segment = segments[i3];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i3 = 0; i3 < metas.length; i3++) {
    const meta = metas[i3];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property2) {
  const point = line.interpolate(sourcePoint, property2);
  if (!point) {
    return {};
  }
  const pointValue = point[property2];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i3 = 0; i3 < segments.length; i3++) {
    const segment = segments[i3];
    const firstValue = linePoints[segment.start][property2];
    const lastValue = linePoints[segment.end][property2];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx3, bounds, opts) {
    const { x: x2, y: y3, radius } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx3.arc(x2, y3, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x: x2, y: y3, radius } = this;
    const angle = point.angle;
    return {
      x: x2 + Math.cos(angle) * radius,
      y: y3 + Math.sin(angle) * radius,
      angle
    };
  }
};
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i3 = 0; i3 < length; ++i3) {
    target.push(scale.getPointPositionForValue(i3, value));
  }
  return target;
}
function _drawfill(ctx3, source, area) {
  const target = _getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx3, area);
    doFill(ctx3, {
      line,
      target,
      above,
      below,
      area,
      scale,
      axis
    });
    unclipArea(ctx3);
  }
}
function doFill(ctx3, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property2 = line._loop ? "angle" : cfg.axis;
  ctx3.save();
  if (property2 === "x" && below !== above) {
    clipVertical(ctx3, target, area.top);
    fill(ctx3, {
      line,
      target,
      color: above,
      scale,
      property: property2
    });
    ctx3.restore();
    ctx3.save();
    clipVertical(ctx3, target, area.bottom);
  }
  fill(ctx3, {
    line,
    target,
    color: below,
    scale,
    property: property2
  });
  ctx3.restore();
}
function clipVertical(ctx3, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx3.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx3.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx3.lineTo(firstPoint.x, clipY);
      ctx3.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx3, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx3.closePath();
    } else {
      ctx3.lineTo(lastPoint.x, clipY);
    }
  }
  ctx3.lineTo(target.first().x, clipY);
  ctx3.closePath();
  ctx3.clip();
}
function fill(ctx3, cfg) {
  const { line, target, property: property2, color: color2, scale } = cfg;
  const segments = _segments(line, target, property2);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx3.save();
    ctx3.fillStyle = backgroundColor;
    clipBounds(ctx3, scale, notShape && _getBounds(property2, start, end));
    ctx3.beginPath();
    const lineLoop = !!line.pathSegment(ctx3, src);
    let loop2;
    if (notShape) {
      if (lineLoop) {
        ctx3.closePath();
      } else {
        interpolatedLineTo(ctx3, target, end, property2);
      }
      const targetLoop = !!target.pathSegment(ctx3, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop2 = lineLoop && targetLoop;
      if (!loop2) {
        interpolatedLineTo(ctx3, target, start, property2);
      }
    }
    ctx3.closePath();
    ctx3.fill(loop2 ? "evenodd" : "nonzero");
    ctx3.restore();
  }
}
function clipBounds(ctx3, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property: property2, start, end } = bounds || {};
  if (property2 === "x") {
    ctx3.beginPath();
    ctx3.rect(start, top, end - start, bottom - top);
    ctx3.clip();
  }
}
function interpolatedLineTo(ctx3, target, point, property2) {
  const interpolatedPoint = target.interpolate(point, property2);
  if (interpolatedPoint) {
    ctx3.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i3, line, source;
    for (i3 = 0; i3 < count; ++i3) {
      meta = chart.getDatasetMeta(i3);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i3),
          index: i3,
          fill: _decodeFill(line, i3, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i3 = 0; i3 < count; ++i3) {
      source = sources[i3];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i3, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i3 = metasets.length - 1; i3 >= 0; --i3) {
      const source = metasets[i3].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i3 = metasets.length - 1; i3 >= 0; --i3) {
      const source = metasets[i3].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize2) => {
  let { boxHeight = fontSize2, boxWidth = fontSize2 } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize2);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize2);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize2, boxHeight)
  };
};
var itemsEqual = (a4, b2) => a4 !== null && b2 !== null && a4.datasetIndex === b2.datasetIndex && a4.index === b2.index;
var Legend = class extends Element2 {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a4, b2) => labelOpts.sort(a4, b2, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx: ctx3 } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize2 = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize2);
    let width, height;
    ctx3.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize2, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize2, boxWidth, itemHeight) {
    const { ctx: ctx3, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight3 = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx3.textAlign = "left";
    ctx3.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight3;
    this.legendItems.forEach((legendItem, i3) => {
      const itemWidth = boxWidth + fontSize2 / 2 + ctx3.measureText(legendItem.text).width;
      if (i3 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight3;
        lineWidths[lineWidths.length - (i3 > 0 ? 0 : 1)] = 0;
        top += lineHeight3;
        row++;
      }
      hitboxes[i3] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx: ctx3, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i3) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx3, legendItem, _itemHeight);
      if (i3 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i3] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox1 of hitboxes) {
        if (hitbox1.col !== col) {
          col = hitbox1.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox1.top = top;
        hitbox1.left += this.left + padding;
        hitbox1.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox1.left), hitbox1.width);
        top += hitbox1.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx3 = this.ctx;
      clipArea(ctx3, this);
      this._draw();
      unclipArea(ctx3);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx: ctx3 } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize2 = labelFont.size;
    const halfFontSize = fontSize2 / 2;
    let cursor;
    this.drawTitle();
    ctx3.textAlign = rtlHelper.textAlign("left");
    ctx3.textBaseline = "middle";
    ctx3.lineWidth = 0.5;
    ctx3.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize2);
    const drawLegendBox = function(x2, y3, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx3.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx3.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx3.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx3.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx3.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx3.lineWidth = lineWidth;
      ctx3.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx3.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x2, boxWidth / 2);
        const centerY = y3 + halfFontSize;
        drawPointLegend(ctx3, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y3 + Math.max((fontSize2 - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x2, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx3.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx3, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx3.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx3.fill();
        if (lineWidth !== 0) {
          ctx3.stroke();
        }
      }
      ctx3.restore();
    };
    const fillText = function(x2, y3, legendItem) {
      renderText(ctx3, legendItem.text, x2, y3 + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight3 = itemHeight + padding;
    this.legendItems.forEach((legendItem, i3) => {
      ctx3.strokeStyle = legendItem.fontColor;
      ctx3.fillStyle = legendItem.fontColor;
      const textWidth = ctx3.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x2 = cursor.x;
      let y3 = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i3 > 0 && x2 + width + padding > this.right) {
          y3 = cursor.y += lineHeight3;
          cursor.line++;
          x2 = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i3 > 0 && y3 + lineHeight3 > this.bottom) {
        x2 = cursor.x = x2 + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y3 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x2);
      drawLegendBox(realX, y3, legendItem);
      x2 = _textX(textAlign, x2 + boxWidth + halfFontSize, isHorizontal ? x2 + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x2), y3, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);
      } else {
        cursor.y += lineHeight3;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx3 = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y3;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y3 = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size3) => Math.max(acc, size3.height), 0);
      y3 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x2 = _alignStartEnd(position, left, left + maxWidth);
    ctx3.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx3.textBaseline = "middle";
    ctx3.strokeStyle = titleOpts.color;
    ctx3.fillStyle = titleOpts.color;
    ctx3.font = titleFont.string;
    renderText(ctx3, titleOpts.text, x2, y3, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x2, y3) {
    let i3, hitBox, lh;
    if (_isBetween(x2, this.left, this.right) && _isBetween(y3, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i3 = 0; i3 < lh.length; ++i3) {
        hitBox = lh[i3];
        if (_isBetween(x2, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y3, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i3];
        }
      }
    }
    return null;
  }
  handleEvent(e3) {
    const opts = this.options;
    if (!isListened(e3.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e3.x, e3.y);
    if (e3.type === "mousemove" || e3.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e3,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e3,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e3,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx3, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx3);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx3) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a4, b2) => a4.length > b2.length ? a4 : b2);
  }
  return boxWidth + labelFont.size / 2 + ctx3.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e3, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx3) => ctx3.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style2 = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style2.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style2.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style2.borderCapStyle,
            lineDash: style2.borderDash,
            lineDashOffset: style2.borderDashOffset,
            lineJoin: style2.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style2.borderColor,
            pointStyle: pointStyle || style2.pointStyle,
            rotation: style2.rotation,
            textAlign: textAlign || style2.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style2.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx3) => ctx3.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name2) => !name2.startsWith("on"),
    labels: {
      _scriptable: (name2) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name2)
    }
  }
};
var Title = class extends Element2 {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray4(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx3 = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight3 = fontOpts.lineHeight;
    const offset = lineHeight3 / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx3, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map3 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map3.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map3.get(chart));
    map3.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map3.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i3, len;
    let x2 = 0;
    let y3 = 0;
    let count = 0;
    for (i3 = 0, len = items.length; i3 < len; ++i3) {
      const el = items[i3].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x2 += pos.x;
        y3 += pos.y;
        ++count;
      }
    }
    return {
      x: x2 / count,
      y: y3 / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x2 = eventPosition.x;
    let y3 = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i3, len, nearestElement;
    for (i3 = 0, len = items.length; i3 < len; ++i3) {
      const el = items[i3].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d4 = distanceBetweenPoints(eventPosition, center);
        if (d4 < minDistance) {
          minDistance = d4;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x2 = tp.x;
      y3 = tp.y;
    }
    return {
      x: x2,
      y: y3
    };
  }
};
function pushOrConcat(base3, toPush) {
  if (toPush) {
    if (isArray4(toPush)) {
      Array.prototype.push.apply(base3, toPush);
    } else {
      base3.push(toPush);
    }
  }
  return base3;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element: element2, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element: element2
  };
}
function getTooltipSize(tooltip, options) {
  const ctx3 = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx3.measureText(line).width + widthPadding);
  };
  ctx3.save();
  ctx3.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx3.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx3.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx3.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size3) {
  const { y: y3, height } = size3;
  if (y3 < height / 2) {
    return "top";
  } else if (y3 > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size3) {
  const { x: x2, width } = size3;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x2 + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x2 - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size3, yAlign) {
  const { x: x2, width } = size3;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x2 <= (left + right) / 2 ? "left" : "right";
  } else if (x2 <= width / 2) {
    xAlign = "left";
  } else if (x2 >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size3)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size3) {
  const yAlign = size3.yAlign || options.yAlign || determineYAlign(chart, size3);
  return {
    xAlign: size3.xAlign || options.xAlign || determineXAlign(chart, options, size3, yAlign),
    yAlign
  };
}
function alignX(size3, xAlign) {
  let { x: x2, width } = size3;
  if (xAlign === "right") {
    x2 -= width;
  } else if (xAlign === "center") {
    x2 -= width / 2;
  }
  return x2;
}
function alignY(size3, yAlign, paddingAndSize) {
  let { y: y3, height } = size3;
  if (yAlign === "top") {
    y3 += paddingAndSize;
  } else if (yAlign === "bottom") {
    y3 -= height + paddingAndSize;
  } else {
    y3 -= height / 2;
  }
  return y3;
}
function getBackgroundPoint(options, size3, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x2 = alignX(size3, xAlign);
  const y3 = alignY(size3, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x2 += paddingAndSize;
    } else if (xAlign === "right") {
      x2 -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x2 -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x2 += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x2, 0, chart.width - size3.width),
    y: _limitValue(y3, 0, chart.height - size3.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks2, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks2.override(override) : callbacks2;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks2, name2, ctx3, arg) {
  const result = callbacks2[name2].call(ctx3, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name2].call(ctx3, arg);
  }
  return result;
}
var Tooltip = class extends Element2 {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks: callbacks2 } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks2, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks2, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks2, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks: callbacks2 } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks2, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks: callbacks2 } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks2, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks2, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks2, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i3, len;
    for (i3 = 0, len = active.length; i3 < len; ++i3) {
      tooltipItems.push(createTooltipItem(this.chart, active[i3]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element2, index2, array) => options.filter(element2, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a4, b2) => options.itemSort(a4, b2, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size3 = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size3);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size3.width,
        height: size3.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx3, size3, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size3, options);
    ctx3.lineTo(caretPosition.x1, caretPosition.y1);
    ctx3.lineTo(caretPosition.x2, caretPosition.y2);
    ctx3.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size3, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size3;
    let x1, x2, x3, y1, y22, y3;
    if (yAlign === "center") {
      y22 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y22 + caretSize;
        y3 = y22 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y22 - caretSize;
        y3 = y22 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y22 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y22 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2: y22,
      y3
    };
  }
  drawTitle(pt, ctx3, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i3;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx3.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx3.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx3.fillStyle = options.titleColor;
      ctx3.font = titleFont.string;
      for (i3 = 0; i3 < length; ++i3) {
        ctx3.fillText(title[i3], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i3 + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx3, pt, i3, rtlHelper, options) {
    const labelColors = this.labelColors[i3];
    const labelPointStyle = this.labelPointStyles[i3];
    const { boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx3.strokeStyle = options.multiKeyBackground;
      ctx3.fillStyle = options.multiKeyBackground;
      drawPoint(ctx3, drawOptions, centerX, centerY);
      ctx3.strokeStyle = labelColors.borderColor;
      ctx3.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx3, drawOptions, centerX, centerY);
    } else {
      ctx3.lineWidth = isObject3(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
      ctx3.strokeStyle = labelColors.borderColor;
      ctx3.setLineDash(labelColors.borderDash || []);
      ctx3.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx3.beginPath();
        ctx3.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx3, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx3.fill();
        ctx3.stroke();
        ctx3.fillStyle = labelColors.backgroundColor;
        ctx3.beginPath();
        addRoundedRectPath(ctx3, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx3.fill();
      } else {
        ctx3.fillStyle = options.multiKeyBackground;
        ctx3.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx3.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx3.fillStyle = labelColors.backgroundColor;
        ctx3.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx3.fillStyle = this.labelTextColors[i3];
  }
  drawBody(pt, ctx3, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx3.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i3, j, ilen, jlen;
    ctx3.textAlign = bodyAlign;
    ctx3.textBaseline = "middle";
    ctx3.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx3.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i3 = 0, ilen = body.length; i3 < ilen; ++i3) {
      bodyItem = body[i3];
      textColor = this.labelTextColors[i3];
      ctx3.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx3, pt, i3, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx3, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i3;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx3.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx3.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx3.fillStyle = options.footerColor;
      ctx3.font = footerFont.string;
      for (i3 = 0; i3 < length; ++i3) {
        ctx3.fillText(footer[i3], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx3, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x: x2, y: y3 } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx3.fillStyle = options.backgroundColor;
    ctx3.strokeStyle = options.borderColor;
    ctx3.lineWidth = options.borderWidth;
    ctx3.beginPath();
    ctx3.moveTo(x2 + topLeft, y3);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx3, tooltipSize, options);
    }
    ctx3.lineTo(x2 + width - topRight, y3);
    ctx3.quadraticCurveTo(x2 + width, y3, x2 + width, y3 + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx3, tooltipSize, options);
    }
    ctx3.lineTo(x2 + width, y3 + height - bottomRight);
    ctx3.quadraticCurveTo(x2 + width, y3 + height, x2 + width - bottomRight, y3 + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx3, tooltipSize, options);
    }
    ctx3.lineTo(x2 + bottomLeft, y3 + height);
    ctx3.quadraticCurveTo(x2, y3 + height, x2, y3 + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx3, tooltipSize, options);
    }
    ctx3.lineTo(x2, y3 + topLeft);
    ctx3.quadraticCurveTo(x2, y3, x2 + topLeft, y3);
    ctx3.closePath();
    ctx3.fill();
    if (options.borderWidth > 0) {
      ctx3.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size3 = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size3.width;
        this.height = size3.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx3) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx3.save();
      ctx3.globalAlpha = opacity;
      this.drawBackground(pt, ctx3, tooltipSize, options);
      overrideTextDirection(ctx3, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx3, options);
      this.drawBody(pt, ctx3, options);
      this.drawFooter(pt, ctx3, options);
      restoreTextDirection(ctx3, options.textDirection);
      ctx3.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e3, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e3, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e3);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e3.x,
          y: e3.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e3, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e3.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e3, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e3) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e3);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx3, opts) => opts.bodyFont.size,
    boxWidth: (ctx3, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name2) => name2 !== "filter" && name2 !== "itemSort" && name2 !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({
      value: Math.round((niceMin + j * spacing) * factor) / factor
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var log10Floor = (v) => Math.floor(log10(v));
var changeExponent = (v, m3) => Math.pow(10, log10Floor(v) + m3);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range2 = max - min;
  let rangeExp = log10Floor(range2);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base3 = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base3) * precision) / precision;
  const offset = Math.floor((min - base3) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base3 + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base3 + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx3, font, label) {
  label = isArray4(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx3, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size3, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size3 / 2,
      end: pos + size3 / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size3,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size3
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i3 = 0; i3 < valueCount; i3++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i3));
    padding[i3] = opts.padding;
    const pointPosition = scale.getPointPosition(i3, scale.drawingArea + padding[i3], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i3]);
    labelSizes[i3] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i3) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x2 = 0;
  let y3 = 0;
  if (hLimits.start < orig.l) {
    x2 = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x2);
  } else if (hLimits.end > orig.r) {
    x2 = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x2);
  }
  if (vLimits.start < orig.t) {
    y3 = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y3);
  } else if (vLimits.end > orig.b) {
    y3 = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y3);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i3 = 0; i3 < valueCount; i3++) {
    const pointLabelPosition = scale.getPointPosition(i3, outerDistance + extra + padding[i3], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size3 = labelSizes[i3];
    const y3 = yForAngle(pointLabelPosition.y, size3.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size3.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y: y3,
      textAlign,
      left,
      top: y3,
      right: left + size3.w,
      bottom: y3 + size3.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x2, w3, align) {
  if (align === "right") {
    x2 -= w3;
  } else if (align === "center") {
    x2 -= w3 / 2;
  }
  return x2;
}
function yForAngle(y3, h6, angle) {
  if (angle === 90 || angle === 270) {
    y3 -= h6 / 2;
  } else if (angle > 270 || angle < 90) {
    y3 -= h6;
  }
  return y3;
}
function drawPointLabels(scale, labelCount) {
  const { ctx: ctx3, options: { pointLabels } } = scale;
  for (let i3 = labelCount - 1; i3 >= 0; i3--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i3));
    const plFont = toFont(optsAtIndex.font);
    const { x: x2, y: y3, textAlign, left, top, right, bottom } = scale._pointLabelItems[i3];
    const { backdropColor } = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx3.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx3.beginPath();
        addRoundedRectPath(ctx3, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx3.fill();
      } else {
        ctx3.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
    renderText(ctx3, scale._pointLabels[i3], x2, y3 + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx: ctx3 } = scale;
  if (circular) {
    ctx3.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx3.moveTo(pointPosition.x, pointPosition.y);
    for (let i3 = 1; i3 < labelCount; i3++) {
      pointPosition = scale.getPointPosition(i3, radius);
      ctx3.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx3 = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx3.save();
  ctx3.strokeStyle = color2;
  ctx3.lineWidth = lineWidth;
  ctx3.setLineDash(borderOpts.dash);
  ctx3.lineDashOffset = borderOpts.dashOffset;
  ctx3.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx3.closePath();
  ctx3.stroke();
  ctx3.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w3 = this.width = this.maxWidth - padding.width;
    const h6 = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w3 / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h6 / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w3, h6) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i3) => this.chart.getDataVisibility(i3));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx3 = this.ctx;
      ctx3.save();
      ctx3.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx3.closePath();
      ctx3.fillStyle = backgroundColor;
      ctx3.fill();
      ctx3.restore();
    }
  }
  drawGrid() {
    const ctx3 = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i3, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick2, index2) => {
        if (index2 !== 0) {
          offset = this.getDistanceFromCenterForValue(tick2.value);
          const context = this.getContext(index2);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx3.save();
      for (i3 = labelCount - 1; i3 >= 0; i3--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i3));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx3.lineWidth = lineWidth;
        ctx3.strokeStyle = color2;
        ctx3.setLineDash(optsAtIndex.borderDash);
        ctx3.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i3, offset);
        ctx3.beginPath();
        ctx3.moveTo(this.xCenter, this.yCenter);
        ctx3.lineTo(position.x, position.y);
        ctx3.stroke();
      }
      ctx3.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx3 = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx3.save();
    ctx3.translate(this.xCenter, this.yCenter);
    ctx3.rotate(startAngle);
    ctx3.textAlign = "center";
    ctx3.textBaseline = "middle";
    this.ticks.forEach((tick2, index2) => {
      if (index2 === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx3.font = tickFont.string;
        width = ctx3.measureText(tick2.label).width;
        ctx3.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx3.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx3, tick2.label, 0, -offset, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx3.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a4, b2) {
  return a4 - b2;
}
function parse2(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber2(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i3 = UNITS.indexOf(minUnit); i3 < ilen - 1; ++i3) {
    const interval = INTERVALS[UNITS[i3]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i3];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i3 = UNITS.length - 1; i3 >= UNITS.indexOf(minUnit); i3--) {
    const unit = UNITS[i3];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i3 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i3 < ilen; ++i3) {
    if (INTERVALS[UNITS[i3]].common) {
      return UNITS[i3];
    }
  }
}
function addTick(ticks, time2, timestamps) {
  if (!timestamps) {
    ticks[time2] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time2);
    const timestamp = timestamps[lo] >= time2 ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map4, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map4[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map4 = {};
  const ilen = values.length;
  let i3, value;
  for (i3 = 0; i3 < ilen; ++i3) {
    value = values[i3];
    map4[value] = i3;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map4, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time2 = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time2.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time2.parser,
      round: time2.round,
      isoWeekday: time2.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse2(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick2) => +tick2.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber2(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time2, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time2 = first, count = 0; time2 < max; time2 = +adapter.add(time2, stepSize, minor), count++) {
      addTick(ticks, time2, timestamps);
    }
    if (time2 === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time2, timestamps);
    }
    return Object.keys(ticks).sort((a4, b2) => a4 - b2).map((x2) => +x2);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format2) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format2 || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time2, index2, ticks, format2) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time2,
        index2,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick2 = ticks[index2];
    const major = majorUnit && majorFormat && tick2 && tick2.major;
    return this._adapter.format(time2, format2 || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i3, ilen, tick2;
    for (i3 = 0, ilen = ticks.length; i3 < ilen; ++i3) {
      tick2 = ticks[i3];
      tick2.label = this._tickFormatFunction(tick2.value, i3, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format2);
    const size3 = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size3.w : this.height / size3.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i3, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i3 = 0, ilen = metas.length; i3 < ilen; ++i3) {
      timestamps = timestamps.concat(metas[i3].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i3, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i3 = 0, ilen = labels.length; i3 < ilen; ++i3) {
      timestamps.push(parse2(this, labels[i3]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i3, ilen, prev, curr, next;
    for (i3 = 0, ilen = timestamps.length; i3 < ilen; ++i3) {
      curr = timestamps[i3];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
      next = items[i3 + 1];
      prev = items[i3 - 1];
      curr = items[i3];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i3 / (ilen - 1)
        });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// node_modules/chart.js/auto/auto.js
Chart.register(...registerables);
var auto_default = Chart;

// sfc-script:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/DoughnutChart.vue?type=script
var DoughnutChart_default = /* @__PURE__ */ defineComponent({
  __name: "DoughnutChart",
  props: {
    allPomodoro: {
      type: Array,
      required: true
    }
  },
  setup(__props, {
    expose
  }) {
    expose();
    const props = __props;
    const {
      allPomodoro
    } = toRefs(props);
    const doughnutChart = ref(null);
    let labels = [];
    let dateSet = [];
    const setDataSet = (raw) => {
      const res = {
        [i18n_default2.info.noTag]: 0
      };
      raw.forEach((pomodoro) => {
        var _a3;
        if (!pomodoro.tags) {
          res[i18n_default2.info.noTag]++;
        } else {
          (_a3 = pomodoro.tags) == null ? void 0 : _a3.split(",").forEach((tag) => {
            if (res[tag] == void 0) {
              res[tag] = 1;
            } else {
              res[tag]++;
            }
          });
        }
      });
      labels = Object.keys(res);
      dateSet = Object.keys(res).map((key) => res[key]);
    };
    let chart;
    onMounted(async () => {
      setDataSet(allPomodoro.value);
      var data = {
        labels,
        datasets: [{
          label: i18n_default2.info.taskType,
          backgroundColor: ["rgb(255, 99, 132)", "rgb(54, 162, 235)", "rgb(255, 205, 86)", "rgb(244, 67, 54)", "rgb(103, 58, 183)", "rgb(3, 169, 244)", "rgb(0, 188, 212)", "rgb(139, 195, 74)", "rgb(233, 30, 99)", "rgb(156, 39, 176)", "rgb(0, 150, 136)", "rgb(255, 152, 0)", "rgb(76, 175, 80)"],
          hoverBorderColor: "rgba(255,99,132,1)",
          hoverOffset: 4,
          data: dateSet
        }]
      };
      var options = {
        maintainAspectRatio: false,
        responsive: true,
        scales: {
          y: {
            stacked: true,
            grid: {
              display: true,
              color: "rgba(255,99,132,0.2)"
            }
          },
          x: {
            grid: {
              display: true
            }
          }
        }
      };
      chart = new auto_default(doughnutChart.value, {
        type: "doughnut",
        options,
        data
      });
    });
    onUpdated(() => {
      setDataSet(allPomodoro.value);
      chart.data.labels = labels;
      chart.data.datasets[0].data = dateSet;
      chart.update();
    });
    const __returned__ = {
      props,
      allPomodoro,
      doughnutChart,
      get labels() {
        return labels;
      },
      set labels(v) {
        labels = v;
      },
      get dateSet() {
        return dateSet;
      },
      set dateSet(v) {
        dateSet = v;
      },
      setDataSet,
      get chart() {
        return chart;
      },
      set chart(v) {
        chart = v;
      }
    };
    Object.defineProperty(__returned__, "__isScriptSetup", {
      enumerable: false,
      value: true
    });
    return __returned__;
  }
});

// sfc-template:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/DoughnutChart.vue?type=template
var _hoisted_17 = {
  id: "doughnutChartContainer",
  style: { "position": "relative" }
};
var _hoisted_26 = {
  id: "doughnutChart",
  ref: "doughnutChart"
};
function render11(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_17, [
    createBaseVNode("canvas", _hoisted_26, null, 512)
  ]);
}

// src/ui/DoughnutChart.vue
DoughnutChart_default.render = render11;
DoughnutChart_default.__file = "src/ui/DoughnutChart.vue";
var DoughnutChart_default2 = DoughnutChart_default;

// sfc-script:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/LineChart.vue?type=script
var LineChart_default = /* @__PURE__ */ defineComponent({
  __name: "LineChart",
  props: {
    allPomodoro: {
      type: Array,
      required: true
    }
  },
  setup(__props, {
    expose
  }) {
    expose();
    const props = __props;
    const {
      allPomodoro
    } = toRefs(props);
    const lineChart = ref(null);
    const todayStart = ref([]);
    const todayDone = ref([]);
    const labels = ["00:00", "01:00", "02:00", "03:00", "04:00", "05:00", "06:00", "07:00", "08:00", "09:00", "10:00", "11:00", "12:00", "13:00", "14:00", "15:00", "16:00", "17:00", "18:00", "19:00", "20:00", "21:00", "22:00", "23:00"];
    const setDataSet = (raw) => {
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth() + 1;
      const date = now.getDate();
      const theDay = `${year}-${month.toString().padStart(2, "0")}-${date.toString().padStart(2, "0")}`;
      const data = raw.filter((pomodoro) => pomodoro.start.startsWith(theDay));
      const todayStartVal = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      const todayDoneVal = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      data.map((pomodoro) => {
        labels.forEach((timeStart, index2) => {
          const hour = timeStart.split(":")[0];
          if (pomodoro.start.split(" ")[1].startsWith(hour)) {
            todayStartVal[index2]++;
            if (pomodoro.status === "done") {
              todayDoneVal[index2]++;
            }
            return;
          }
        });
      });
      todayStart.value = todayStartVal;
      todayDone.value = todayDoneVal;
    };
    let chart;
    onMounted(async () => {
      setDataSet(allPomodoro.value);
      var data = {
        labels,
        datasets: [{
          label: i18n_default2.info.planNum,
          fill: false,
          backgroundColor: "rgb(54, 162, 235)",
          borderColor: "rgba(54, 162, 235, 0.6)",
          data: todayStart.value
        }, {
          label: i18n_default2.info.finishNum,
          backgroundColor: "rgb(255, 99, 132)",
          borderColor: "rgba(255, 99, 132, 0.6)",
          data: todayDone.value,
          fill: true
        }]
      };
      var options = {
        maintainAspectRatio: false,
        responsive: true,
        interaction: {
          intersect: false
        }
      };
      chart = new auto_default(lineChart.value, {
        type: "line",
        options,
        data
      });
    });
    onUpdated(() => {
      setDataSet(allPomodoro.value);
      chart.data.datasets[0].data = todayStart.value;
      chart.data.datasets[1].data = todayDone.value;
      chart.update();
    });
    const __returned__ = {
      props,
      allPomodoro,
      lineChart,
      todayStart,
      todayDone,
      labels,
      setDataSet,
      get chart() {
        return chart;
      },
      set chart(v) {
        chart = v;
      }
    };
    Object.defineProperty(__returned__, "__isScriptSetup", {
      enumerable: false,
      value: true
    });
    return __returned__;
  }
});

// sfc-template:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/LineChart.vue?type=template
var _hoisted_18 = {
  id: "lineChartContainer",
  style: { "position": "relative" }
};
var _hoisted_27 = {
  id: "lineChart",
  ref: "lineChart"
};
function render12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_18, [
    createBaseVNode("canvas", _hoisted_27, null, 512)
  ]);
}

// src/ui/LineChart.vue
LineChart_default.render = render12;
LineChart_default.__file = "src/ui/LineChart.vue";
var LineChart_default2 = LineChart_default;

// sfc-script:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/PomodoroHistory.vue?type=script
var PomodoroHistory_default = /* @__PURE__ */ defineComponent({
  __name: "PomodoroHistory",
  props: {
    plugin: {
      type: null,
      required: true
    }
  },
  setup(__props, {
    expose
  }) {
    expose();
    const props = __props;
    let theme = ref(darkTheme);
    let locale3 = ref(zhCN_default);
    let dateLocale = ref(zhCN_default2);
    let language = window.localStorage.getItem("language") || "en";
    if (window.app.getTheme() === "obsidian") {
      theme.value = darkTheme;
    } else if (window.app.getTheme() === "moonstone") {
      theme.value = lightTheme;
    } else {
      theme.value = lightTheme;
    }
    if (language === "zh") {
      locale3.value = zhCN_default;
      dateLocale.value = zhCN_default2;
    } else {
      locale3.value = enUS_default;
      dateLocale.value = enUS_default2;
    }
    const lightThemeOverrides = {};
    const darkThemeOverrides = {};
    let H1Title = () => createVNode("h1", null, [createVNode(Title_default, null, null)]);
    const {
      plugin: plugin3
    } = toRefs(props);
    const history = ref([]);
    const currentPomodoro = ref(null);
    const updateData = async () => {
      var _a3;
      history.value = await ((_a3 = selectDB(plugin3.value.spaceDBInstance(), pomodoroDB)) == null ? void 0 : _a3.rows) || [];
      currentPomodoro.value = history.value.filter((pomodoro) => pomodoro.status === "ing")[0] || null;
    };
    onMounted(async () => {
      updateData();
    });
    addEventListener(eventTypes.pomodoroChange, updateData);
    const __returned__ = {
      get theme() {
        return theme;
      },
      set theme(v) {
        theme = v;
      },
      get locale() {
        return locale3;
      },
      set locale(v) {
        locale3 = v;
      },
      get dateLocale() {
        return dateLocale;
      },
      set dateLocale(v) {
        dateLocale = v;
      },
      get language() {
        return language;
      },
      set language(v) {
        language = v;
      },
      lightThemeOverrides,
      darkThemeOverrides,
      props,
      get H1Title() {
        return H1Title;
      },
      set H1Title(v) {
        H1Title = v;
      },
      plugin: plugin3,
      history,
      currentPomodoro,
      updateData,
      get NConfigProvider() {
        return ConfigProvider_default;
      },
      get NMessageProvider() {
        return MessageProvider_default;
      },
      get NSpace() {
        return Space_default;
      },
      get NGrid() {
        return Grid_default;
      },
      get NGridItem() {
        return GridItem_default;
      },
      CalendarView: CalendarView_default2,
      OverView: OverView_default2,
      ClockView: ClockView_default2,
      TimeLine: TimeLine_default2,
      DoughnutChart: DoughnutChart_default2,
      LineChart: LineChart_default2
    };
    Object.defineProperty(__returned__, "__isScriptSetup", {
      enumerable: false,
      value: true
    });
    return __returned__;
  }
});

// sfc-template:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/ui/PomodoroHistory.vue?type=template
var _hoisted_19 = { id: "historyViewContainer" };
function render13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NConfigProvider"], {
    theme: $setup.theme,
    "theme-overrides": $setup.theme.name === "light" ? $setup.lightThemeOverrides : $setup.darkThemeOverrides,
    locale: $setup.locale,
    "date-locale": $setup.dateLocale,
    breakpoints: { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, xxl: 1920 }
  }, {
    default: withCtx(() => [
      createVNode($setup["NMessageProvider"], null, {
        default: withCtx(() => [
          createVNode($setup["NSpace"], { vertical: "" }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_19, [
                createVNode($setup["H1Title"]),
                createCommentVNode(" <Title></Title> "),
                createVNode($setup["OverView"], { "all-pomodoro": $setup.history }, null, 8, ["all-pomodoro"]),
                createVNode($setup["ClockView"], { "current-pomodoro": $setup.currentPomodoro }, null, 8, ["current-pomodoro"]),
                createVNode($setup["TimeLine"], {
                  plugin: $setup.plugin,
                  "pomodoro-list": $setup.history
                }, null, 8, ["plugin", "pomodoro-list"]),
                createCommentVNode(" #BUG https://www.naiveui.com/zh-CN/os-theme/components/grid#layout-shift-disabled.vue "),
                createVNode($setup["NGrid"], {
                  cols: "1 1024:2",
                  responsive: "self"
                }, {
                  default: withCtx(() => [
                    createVNode($setup["NGridItem"], null, {
                      default: withCtx(() => [
                        createVNode($setup["DoughnutChart"], { "all-pomodoro": $setup.history }, null, 8, ["all-pomodoro"])
                      ]),
                      _: 1
                    }),
                    createVNode($setup["NGridItem"], null, {
                      default: withCtx(() => [
                        createVNode($setup["LineChart"], { "all-pomodoro": $setup.history }, null, 8, ["all-pomodoro"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode($setup["NGrid"], {
                  cols: "1",
                  "layout-shift-disabled": true
                }, {
                  default: withCtx(() => [
                    createVNode($setup["NGridItem"], { span: "1" }, {
                      default: withCtx(() => [
                        createVNode($setup["CalendarView"], { "all-pomodoro": $setup.history }, null, 8, ["all-pomodoro"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  }, 8, ["theme", "theme-overrides", "locale", "date-locale"]);
}

// src/ui/PomodoroHistory.vue
PomodoroHistory_default.render = render13;
PomodoroHistory_default.__file = "src/ui/PomodoroHistory.vue";
PomodoroHistory_default.__scopeId = "data-v-81d758ef";
var PomodoroHistory_default2 = PomodoroHistory_default;

// src/ui/view/PomodoroHistoryView.ts
var POMODORO_HISTORY_VIEW = "pomodoro-history-view";
var PomodoroHistoryView = class extends import_obsidian8.ItemView {
  constructor(leaf, plugin3) {
    super(leaf);
    this.plugin = plugin3;
  }
  getViewType() {
    return POMODORO_HISTORY_VIEW;
  }
  getDisplayText() {
    return i18n_default2.info.Pomodoro;
  }
  getIcon() {
    return "clock";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("div", {
      cls: "my-plugin-view",
      attr: {
        id: "awesome-brain-manager-pomodoro-history-view"
      }
    }, (el) => {
      this.vueapp = createApp(PomodoroHistory_default2, {
        plugin: this.plugin
      });
      this.vueapp.mount(el);
    });
  }
  async onClose() {
    this.vueapp.unmount();
  }
};

// src/render/Emoji.ts
var import_obsidian9 = require("obsidian");
var _Emoji = class extends import_obsidian9.MarkdownRenderChild {
  constructor(containerEl, text2) {
    super(containerEl);
    this.text = text2;
  }
  onload() {
    var _a3;
    const emojiEl = this.containerEl.createSpan({
      text: (_a3 = _Emoji.ALL_EMOJIS[this.text]) != null ? _a3 : this.text
    });
    this.containerEl.replaceWith(emojiEl);
  }
};
var Emoji = _Emoji;
Emoji.ALL_EMOJIS = {
  ":+1:": "\u{1F44D}",
  ":sunglasses:": "\u{1F60E}",
  ":smile:": "\u{1F604}"
};
function codeEmoji(el, ctx3) {
  const codeblocks = el.querySelectorAll("code");
  for (let index2 = 0; index2 < codeblocks.length; index2++) {
    const codeblock = codeblocks.item(index2);
    const text2 = codeblock.innerText.trim();
    const isEmoji = text2[0] === ":" && text2[text2.length - 1] === ":";
    if (isEmoji) {
      ctx3.addChild(new Emoji(codeblock, text2));
    }
  }
}

// src/render/Tag.ts
function buildTagRules(tag) {
  return [
    `body.tag-pill-outlined .cm-s-obsidian:not([class="markdown-source-view cm-s-obsidian mod-cm6"]) span.cm-hashtag.cm-meta.cm-hashtag-end:is(.cm-tag-important,.cm-tag-complete,.cm-tag-ideas,.cm-tag-${tag.type},.cm-tag-weeklynote,.cm-tag-dailynote,.cm-tag-inprogress):not(.cm-formatting-hashtag) {
        border-top: var(--tag-border-width) solid var(--tag1);
        border-bottom: var(--tag-border-width) solid var(--tag1);
    }`,
    `body:not(.tag-default) .tag[href ^="#${tag.type}"]:not(.token) {
        background-color: var(--tag-${tag.type}-bg) !important;
        font-weight: 600;
        font-family: ${tag.font.fontFamily} !important;
        color: ${tag.color} !important;
        filter: hue-rotate(0) !important;
    }`,
    `body:not(.tag-default) .tag[href^="#${tag.type}"]::after {
        content: ' \u{1F6A9}';
        font-size: var(--font-size-emoji-after-tag);
    }`,
    `body:not(.tag-default) .cm-s-obsidian:not([class="markdown-source-view cm-s-obsidian mod-cm6"]) span.cm-tag-${tag.type}:not(.cm-formatting-hashtag)::after {
        content: ' \u{1F6A9}';
    }`,
    `body:not(.tag-default) .cm-s-obsidian:not([class="markdown-source-view cm-s-obsidian mod-cm6"]) span.cm-hashtag.cm-meta.cm-hashtag-end.cm-tag-${tag.type}:not(.cm-formatting-hashtag) {
        font-family: ${tag.font.fontFamily} !important;
        font-weight: 600;
        background-color: ${tag.bgColor} !important;
        color: ${tag.color} !important;
        font-size: ${tag.font.size};
        filter: hue-rotate(0) !important;
    }`,
    `body:not(.tag-default) .cm-s-obsidian:not([class="markdown-source-view cm-s-obsidian mod-cm6"]) .cm-formatting.cm-formatting-hashtag.cm-hashtag.cm-hashtag-begin.cm-meta.cm-tag-${tag.type} {
        font-weight: 600;
        font-family: ${tag.font.fontFamily} !important;
        display: inline;
        color: ${tag.color} !important;
        background-color: ${tag.bgColor} !important;
        filter: hue-rotate(0) !important;
        --callout-icon: ${tag.icon.name};  /* Icon name from the Obsidian Icon Set */
    }`
  ];
}

// src/ui/reminder.ts
var import_obsidian12 = require("obsidian");
var import_electron = __toESM(require("electron"));

// node_modules/svelte/internal/index.mjs
function noop2() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a4, b2) {
  return a4 != a4 ? b2 == b2 : a4 !== b2 || (a4 && typeof a4 === "object" || typeof a4 === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i3 = 0; i3 < iterations.length; i3 += 1) {
    if (iterations[i3])
      iterations[i3].d(detaching);
  }
}
function element(name2) {
  return document.createElement(name2);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function select_option(select, value) {
  for (let i3 = 0; i3 < select.options.length; i3 += 1) {
    const option = select.options[i3];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function select_value(select) {
  const selected_option = select.querySelector(":checked") || select.options[0];
  return selected_option && selected_option.__value;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i3 = 0; i3 < render_callbacks.length; i3 += 1) {
      const callback2 = render_callbacks[i3];
      if (!seen_callbacks.has(callback2)) {
        seen_callbacks.add(callback2);
        callback2();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback2) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback2) {
        if (detach2)
          block.d(1);
        callback2();
      }
    });
    block.o(local);
  } else if (callback2) {
    callback2();
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i3) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i3 / 31 | 0] |= 1 << i3 % 31;
}
function init2(component, options, instance4, create_fragment4, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop2,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance4 ? instance4(component, options.props || {}, (i3, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i3], $$.ctx[i3] = value)) {
      if (!$$.skip_bound && $$.bound[i3])
        $$.bound[i3](value);
      if (ready)
        make_dirty(component, i3);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment4 ? create_fragment4($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop2;
    }
    $on(type, callback2) {
      if (!is_function(callback2)) {
        return noop2;
      }
      const callbacks2 = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks2.push(callback2);
      return () => {
        const index2 = callbacks2.indexOf(callback2);
        if (index2 !== -1)
          callbacks2.splice(index2, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop2;
  }
  $on(type, callback2) {
    if (!is_function(callback2)) {
      return noop2;
    }
    const callbacks2 = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks2.push(callback2);
    return () => {
      const index2 = callbacks2.indexOf(callback2);
      if (index2 !== -1)
        callbacks2.splice(index2, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/ui/components/Icon.svelte
var import_obsidian10 = require("obsidian");
function create_fragment(ctx3) {
  let span_1;
  return {
    c() {
      span_1 = element("span");
      attr(span_1, "class", "icon svelte-1gcidq0");
    },
    m(target, anchor) {
      insert(target, span_1, anchor);
      ctx3[3](span_1);
    },
    p: noop2,
    i: noop2,
    o: noop2,
    d(detaching) {
      if (detaching)
        detach(span_1);
      ctx3[3](null);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { icon = "" } = $$props;
  let { size: size3 = 16 } = $$props;
  let span;
  onMount(() => {
    (0, import_obsidian10.setIcon)(span, icon, size3);
  });
  function span_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      span = $$value;
      $$invalidate(0, span);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
    if ("size" in $$props2)
      $$invalidate(2, size3 = $$props2.size);
  };
  return [span, icon, size3, span_1_binding];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init2(this, options, instance, create_fragment, safe_not_equal, { icon: 1, size: 2 });
  }
};
var Icon_default2 = Icon;

// src/ui/components/Markdown.svelte
var import_obsidian11 = require("obsidian");
function create_fragment2(ctx3) {
  let span1;
  let span0;
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      attr(span0, "class", "reminder-markdown");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, span0);
      ctx3[4](span0);
    },
    p: noop2,
    i: noop2,
    o: noop2,
    d(detaching) {
      if (detaching)
        detach(span1);
      ctx3[4](null);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { component } = $$props;
  let { sourcePath } = $$props;
  let { markdown } = $$props;
  let span;
  afterUpdate(() => {
    span.empty();
    import_obsidian11.MarkdownRenderer.renderMarkdown(markdown, span, sourcePath, component);
    span.childNodes.forEach((n2) => {
      if (n2 instanceof HTMLElement) {
        n2.style.display = "inline";
      }
    });
  });
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      span = $$value;
      $$invalidate(0, span);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("component" in $$props2)
      $$invalidate(1, component = $$props2.component);
    if ("sourcePath" in $$props2)
      $$invalidate(2, sourcePath = $$props2.sourcePath);
    if ("markdown" in $$props2)
      $$invalidate(3, markdown = $$props2.markdown);
  };
  return [span, component, sourcePath, markdown, span0_binding];
}
var Markdown = class extends SvelteComponent {
  constructor(options) {
    super();
    init2(this, options, instance2, create_fragment2, safe_not_equal, { component: 1, sourcePath: 2, markdown: 3 });
  }
};
var Markdown_default = Markdown;

// src/ui/components/Reminder.svelte
function get_each_context(ctx3, list, i3) {
  const child_ctx = ctx3.slice();
  child_ctx[10] = list[i3];
  child_ctx[12] = i3;
  return child_ctx;
}
function create_each_block(ctx3) {
  let option;
  let t_value = ctx3[10].label + "";
  let t3;
  let option_value_value;
  let option_selected_value;
  return {
    c() {
      option = element("option");
      t3 = text(t_value);
      option.__value = option_value_value = ctx3[12];
      option.value = option.__value;
      option.selected = option_selected_value = ctx3[6] === ctx3[12];
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t3);
    },
    p(ctx4, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx4[10].label + ""))
        set_data(t3, t_value);
      if (dirty & 64 && option_selected_value !== (option_selected_value = ctx4[6] === ctx4[12])) {
        option.selected = option_selected_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment3(ctx3) {
  let main;
  let h12;
  let markdown;
  let t0;
  let span;
  let icon0;
  let t1;
  let t2_value = ctx3[0].file + "";
  let t22;
  let t3;
  let div;
  let button0;
  let icon1;
  let t4;
  let t5;
  let button1;
  let icon2;
  let t6;
  let t7;
  let select;
  let option;
  let current;
  let mounted;
  let dispose;
  markdown = new Markdown_default({
    props: {
      markdown: ctx3[0].title,
      sourcePath: ctx3[0].file,
      component: ctx3[1]
    }
  });
  icon0 = new Icon_default2({ props: { icon: "link" } });
  icon1 = new Icon_default2({ props: { icon: "check-small" } });
  icon2 = new Icon_default2({ props: { icon: "minus-with-circle" } });
  let each_value = ctx3[5];
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block(get_each_context(ctx3, each_value, i3));
  }
  return {
    c() {
      main = element("main");
      h12 = element("h1");
      create_component(markdown.$$.fragment);
      t0 = space();
      span = element("span");
      create_component(icon0.$$.fragment);
      t1 = space();
      t22 = text(t2_value);
      t3 = space();
      div = element("div");
      button0 = element("button");
      create_component(icon1.$$.fragment);
      t4 = text(" Mark as Done");
      t5 = space();
      button1 = element("button");
      create_component(icon2.$$.fragment);
      t6 = text(" Mute");
      t7 = space();
      select = element("select");
      option = element("option");
      option.textContent = "Remind Me Later";
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      attr(span, "class", "reminder-file svelte-ero3m8");
      attr(button0, "class", "mod-cta");
      option.selected = true;
      option.disabled = true;
      option.hidden = true;
      option.__value = "Remind Me Later";
      option.value = option.__value;
      attr(select, "class", "dropdown later-select svelte-ero3m8");
      if (ctx3[6] === void 0)
        add_render_callback(() => ctx3[9].call(select));
      attr(div, "class", "reminder-actions svelte-ero3m8");
      attr(main, "class", "svelte-ero3m8");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, h12);
      mount_component(markdown, h12, null);
      append(main, t0);
      append(main, span);
      mount_component(icon0, span, null);
      append(span, t1);
      append(span, t22);
      append(main, t3);
      append(main, div);
      append(div, button0);
      mount_component(icon1, button0, null);
      append(button0, t4);
      append(div, t5);
      append(div, button1);
      mount_component(icon2, button1, null);
      append(button1, t6);
      append(div, t7);
      append(div, select);
      append(select, option);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].m(select, null);
      }
      select_option(select, ctx3[6]);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span, "keydown", function() {
            if (is_function(ctx3[3]))
              ctx3[3].apply(this, arguments);
          }),
          listen(span, "click", function() {
            if (is_function(ctx3[3]))
              ctx3[3].apply(this, arguments);
          }),
          listen(button0, "click", function() {
            if (is_function(ctx3[2]))
              ctx3[2].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(ctx3[4]))
              ctx3[4].apply(this, arguments);
          }),
          listen(select, "change", ctx3[9]),
          listen(select, "change", ctx3[7])
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx3 = new_ctx;
      const markdown_changes = {};
      if (dirty & 1)
        markdown_changes.markdown = ctx3[0].title;
      if (dirty & 1)
        markdown_changes.sourcePath = ctx3[0].file;
      if (dirty & 2)
        markdown_changes.component = ctx3[1];
      markdown.$set(markdown_changes);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx3[0].file + ""))
        set_data(t22, t2_value);
      if (dirty & 96) {
        each_value = ctx3[5];
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context(ctx3, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
          } else {
            each_blocks[i3] = create_each_block(child_ctx);
            each_blocks[i3].c();
            each_blocks[i3].m(select, null);
          }
        }
        for (; i3 < each_blocks.length; i3 += 1) {
          each_blocks[i3].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 64) {
        select_option(select, ctx3[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(markdown.$$.fragment, local);
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(markdown.$$.fragment, local);
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main);
      destroy_component(markdown);
      destroy_component(icon0);
      destroy_component(icon1);
      destroy_component(icon2);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { reminder } = $$props;
  let { component } = $$props;
  let { onRemindMeLater } = $$props;
  let { onDone } = $$props;
  let { onOpenFile } = $$props;
  let { onMute } = $$props;
  let selectedIndex;
  let { laters = [] } = $$props;
  function remindMeLater() {
    const selected = laters[selectedIndex];
    if (selected == null) {
      return;
    }
    onRemindMeLater(selected.later());
  }
  function select_change_handler() {
    selectedIndex = select_value(this);
    $$invalidate(6, selectedIndex);
  }
  $$self.$$set = ($$props2) => {
    if ("reminder" in $$props2)
      $$invalidate(0, reminder = $$props2.reminder);
    if ("component" in $$props2)
      $$invalidate(1, component = $$props2.component);
    if ("onRemindMeLater" in $$props2)
      $$invalidate(8, onRemindMeLater = $$props2.onRemindMeLater);
    if ("onDone" in $$props2)
      $$invalidate(2, onDone = $$props2.onDone);
    if ("onOpenFile" in $$props2)
      $$invalidate(3, onOpenFile = $$props2.onOpenFile);
    if ("onMute" in $$props2)
      $$invalidate(4, onMute = $$props2.onMute);
    if ("laters" in $$props2)
      $$invalidate(5, laters = $$props2.laters);
  };
  return [
    reminder,
    component,
    onDone,
    onOpenFile,
    onMute,
    laters,
    selectedIndex,
    remindMeLater,
    onRemindMeLater,
    select_change_handler
  ];
}
var Reminder2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init2(this, options, instance3, create_fragment3, safe_not_equal, {
      reminder: 0,
      component: 1,
      onRemindMeLater: 8,
      onDone: 2,
      onOpenFile: 3,
      onMute: 4,
      laters: 5
    });
  }
};
var Reminder_default = Reminder2;

// src/ui/reminder.ts
var ReminderModal = class {
  constructor(app2, useSystemNotification, laters) {
    this.app = app2;
    this.useSystemNotification = useSystemNotification;
    this.laters = laters;
  }
  show(reminder, onRemindMeLater, onDone, onMute, onOpenFile) {
    if (!this.isSystemNotification()) {
      this.showBuiltinReminder(reminder, onRemindMeLater, onDone, onMute, onOpenFile);
    } else {
      const Notification = import_electron.default.remote.Notification;
      const n2 = new Notification({
        title: "Obsidian Reminder",
        body: reminder.title
      });
      n2.on("click", () => {
        n2.close();
        this.showBuiltinReminder(reminder, onRemindMeLater, onDone, onMute, onOpenFile);
      });
      n2.on("close", () => {
        onMute();
      });
      {
        const laters = SETTINGS.laters.value;
        n2.on("action", (_, index2) => {
          if (index2 === 0) {
            onDone();
            return;
          }
          const later = laters[index2 - 1];
          onRemindMeLater(later.later());
        });
        const actions = [{ type: "button", text: "Mark as Done" }];
        laters.forEach((later) => {
          actions.push({ type: "button", text: later.label });
        });
        n2.actions = actions;
      }
      n2.show();
    }
  }
  showBuiltinReminder(reminder, onRemindMeLater, onDone, onCancel, onOpenFile) {
    new NotificationModal(this.app, this.laters.value, reminder, onRemindMeLater, onDone, onCancel, onOpenFile).open();
  }
  isSystemNotification() {
    if (this.isMobile()) {
      return false;
    }
    return this.useSystemNotification.value;
  }
  isMobile() {
    return import_electron.default === void 0;
  }
};
var NotificationModal = class extends import_obsidian12.Modal {
  constructor(app2, laters, reminder, onRemindMeLater, onDone, onCancel, onOpenFile) {
    super(app2);
    this.laters = laters;
    this.reminder = reminder;
    this.onRemindMeLater = onRemindMeLater;
    this.onDone = onDone;
    this.onCancel = onCancel;
    this.onOpenFile = onOpenFile;
    this.canceled = true;
  }
  onOpen() {
    this.reminder.beingDisplayed = true;
    const { contentEl } = this;
    new Reminder_default({
      target: contentEl,
      props: {
        reminder: this.reminder,
        laters: this.laters,
        component: this,
        onRemindMeLater: (time2) => {
          this.onRemindMeLater(time2);
          this.canceled = false;
          this.close();
        },
        onDone: () => {
          this.canceled = false;
          this.onDone();
          this.close();
        },
        onOpenFile: () => {
          this.canceled = true;
          this.onOpenFile();
          this.close();
        },
        onMute: () => {
          this.canceled = true;
          this.close();
        }
      }
    });
  }
  onClose() {
    this.reminder.beingDisplayed = false;
    const { contentEl } = this;
    contentEl.empty();
    if (this.canceled) {
      this.onCancel();
    }
  }
};

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString: toString2 } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache2) => (thing) => {
  const str = toString2.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray: isArray5 } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer2(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction4(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString2 = typeOfTest("string");
var isFunction4 = typeOfTest("function");
var isNumber3 = typeOfTest("number");
var isObject4 = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject3 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate2 = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject4(val) && isFunction4(val.pipe);
var isFormData = (thing) => {
  const pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString2.call(thing) === pattern || isFunction4(thing.toString) && thing.toString() === pattern);
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i3;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray5(obj)) {
    for (i3 = 0, l2 = obj.length; i3 < l2; i3++) {
      fn.call(null, obj[i3], i3, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i3 = 0; i3 < len; i3++) {
      key = keys2[i3];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function merge4() {
  const result = {};
  const assignValue2 = (val, key) => {
    if (isPlainObject3(result[key]) && isPlainObject3(val)) {
      result[key] = merge4(result[key], val);
    } else if (isPlainObject3(val)) {
      result[key] = merge4({}, val);
    } else if (isArray5(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  };
  for (let i3 = 0, l2 = arguments.length; i3 < l2; i3++) {
    arguments[i3] && forEach(arguments[i3], assignValue2);
  }
  return result;
}
var extend2 = (a4, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction4(val)) {
      a4[key] = bind(val, thisArg);
    } else {
      a4[key] = val;
    }
  }, { allOwnKeys });
  return a4;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors3) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors3);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i3;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i3 = props.length;
    while (i3-- > 0) {
      prop = props[i3];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray3 = (thing) => {
  if (!thing)
    return null;
  if (isArray5(thing))
    return thing;
  let i3 = thing.length;
  if (!isNumber3(i3))
    return null;
  const arr = new Array(i3);
  while (i3-- > 0) {
    arr[i3] = thing[i3];
  }
  return arr;
};
var isTypedArray2 = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(/[_-\s]([a-z\d])(\w*)/g, function replacer2(m3, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};
var hasOwnProperty14 = (({ hasOwnProperty: hasOwnProperty15 }) => (obj, prop) => hasOwnProperty15.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors3 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors3, (descriptor, name2) => {
    if (reducer(descriptor, name2, obj) !== false) {
      reducedDescriptors[name2] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    const value = obj[name2];
    if (!isFunction4(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not read-only method '" + name2 + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray5(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop3 = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var utils_default = {
  isArray: isArray5,
  isArrayBuffer,
  isBuffer: isBuffer2,
  isFormData,
  isArrayBufferView,
  isString: isString2,
  isNumber: isNumber3,
  isBoolean,
  isObject: isObject4,
  isPlainObject: isPlainObject3,
  isUndefined,
  isDate: isDate2,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction4,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray2,
  isFileList,
  forEach,
  merge: merge4,
  extend: extend2,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray3,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty14,
  hasOwnProp: hasOwnProperty14,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop3,
  toFiniteNumber
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request3, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request3 && (this.request = request3);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors2 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code) => {
  descriptors2[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors2);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request3, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request3, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/env/classes/FormData.js
var import_form_data = __toESM(require_browser2(), 1);
var FormData_default = import_form_data.default;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each2(token, i3) {
    token = removeBrackets(token);
    return !dots && i3 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function isSpecCompliant(thing) {
  return thing && utils_default.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
}
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined2(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && isSpecCompliant(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]") && (arr = utils_default.toArray(value)))) {
        key = removeBrackets(key);
        arr.forEach(function each2(el, index2) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]", convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack3 = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack3.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack3.push(value);
    utils_default.forEach(value, function each2(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(formData, el, utils_default.isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack3.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match3) {
    return charMap[match3];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append2(name2, value) {
  this._pairs.push([name2, value]);
};
prototype2.toString = function toString3(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h6) {
      if (h6 !== null) {
        fn(h6);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default2 = FormData;

// node_modules/axios/lib/platform/browser/index.js
var isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default2,
    Blob
  },
  isStandardBrowserEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new browser_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (browser_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name2) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name2).map((match3) => {
    return match3[0] === "[]" ? "" : match3[1] || match3[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i3;
  const len = keys2.length;
  let key;
  for (i3 = 0; i3 < len; i3++) {
    key = keys2[i3];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name2 = path[index2++];
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path.length;
    name2 = !name2 && utils_default.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils_default.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index2);
    if (result && utils_default.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/core/settle.js
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError_default("Request failed with status code " + response.status, [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = browser_default.isStandardBrowserEnv ? function standardBrowserEnv() {
  return {
    write: function write(name2, value, expires, path, domain, secure) {
      const cookie = [];
      cookie.push(name2 + "=" + encodeURIComponent(value));
      if (utils_default.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils_default.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils_default.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read(name2) {
      const match3 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match3 ? decodeURIComponent(match3[3]) : null;
    },
    remove: function remove2(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write() {
    },
    read: function read() {
      return null;
    },
    remove: function remove2() {
    }
  };
}();

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = browser_default.isStandardBrowserEnv ? function standardBrowserEnv2() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement("a");
  let originURL;
  function resolveURL(url) {
    let href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin(requestURL) {
    const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin() {
    return true;
  };
}();

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request3) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request3);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match3 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match3 && match3[1] || "";
}

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i3;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i3 = line.indexOf(":");
    key = line.substring(0, i3).trim().toLowerCase();
    val = line.substring(i3 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
var $defaults = Symbol("defaults");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match3;
  while (match3 = tokensRE.exec(str)) {
    tokens[match3[1]] = match3[2];
  }
  return tokens;
}
function matchHeaderValue(context, value, header, filter2) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w3, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
function findKey2(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i3 = keys2.length;
  let _key;
  while (i3-- > 0) {
    _key = keys2[i3];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
function AxiosHeaders(headers, defaults3) {
  headers && this.set(headers);
  this[$defaults] = defaults3 || null;
}
Object.assign(AxiosHeaders.prototype, {
  set: function(header, valueOrRewrite, rewrite) {
    const self79 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = findKey2(self79, lHeader);
      if (key && _rewrite !== true && (self79[key] === false || _rewrite === false)) {
        return;
      }
      self79[key || _header] = normalizeValue(_value);
    }
    if (utils_default.isPlainObject(header)) {
      utils_default.forEach(header, (_value, _header) => {
        setHeader(_value, _header, valueOrRewrite);
      });
    } else {
      setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  },
  get: function(header, parser) {
    header = normalizeHeader(header);
    if (!header)
      return void 0;
    const key = findKey2(this, header);
    if (key) {
      const value = this[key];
      if (!parser) {
        return value;
      }
      if (parser === true) {
        return parseTokens(value);
      }
      if (utils_default.isFunction(parser)) {
        return parser.call(this, value, key);
      }
      if (utils_default.isRegExp(parser)) {
        return parser.exec(value);
      }
      throw new TypeError("parser must be boolean|regexp|function");
    }
  },
  has: function(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = findKey2(this, header);
      return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  },
  delete: function(header, matcher) {
    const self79 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = findKey2(self79, _header);
        if (key && (!matcher || matchHeaderValue(self79, self79[key], key, matcher))) {
          delete self79[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  },
  clear: function() {
    return Object.keys(this).forEach(this.delete.bind(this));
  },
  normalize: function(format2) {
    const self79 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = findKey2(headers, header);
      if (key) {
        self79[key] = normalizeValue(value);
        delete self79[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self79[header];
      }
      self79[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  },
  toJSON: function(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(Object.assign({}, this[$defaults] || null, this), (value, header) => {
      if (value == null || value === false)
        return;
      obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value;
    });
    return obj;
  }
});
Object.assign(AxiosHeaders, {
  from: function(thing) {
    if (utils_default.isString(thing)) {
      return new this(parseHeaders_default(thing));
    }
    return thing instanceof this ? thing : new this(thing);
  },
  accessor: function(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
});
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
utils_default.freezeMethods(AxiosHeaders.prototype);
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i3 = tail;
    let bytesCount = 0;
    while (i3 !== head) {
      bytesCount += bytes[i3++];
      i3 = i3 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e3) => {
    const loaded = e3.loaded;
    const total = e3.lengthComputable ? e3.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange2 = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange2 ? (total - loaded) / rate : void 0
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils_default.isFormData(requestData) && browser_default.isStandardBrowserEnv) {
      requestHeaders.setContentType(false);
    }
    let request3 = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request3.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request3.timeout = config.timeout;
    function onloadend() {
      if (!request3) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from("getAllResponseHeaders" in request3 && request3.getAllResponseHeaders());
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request3.responseText : request3.response;
      const response = {
        data: responseData,
        status: request3.status,
        statusText: request3.statusText,
        headers: responseHeaders,
        config,
        request: request3
      };
      settle(function _resolve2(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request3 = null;
    }
    if ("onloadend" in request3) {
      request3.onloadend = onloadend;
    } else {
      request3.onreadystatechange = function handleLoad() {
        if (!request3 || request3.readyState !== 4) {
          return;
        }
        if (request3.status === 0 && !(request3.responseURL && request3.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request3.onabort = function handleAbort() {
      if (!request3) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request3));
      request3 = null;
    };
    request3.onerror = function handleError2() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request3));
      request3 = null;
    };
    request3.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(timeoutErrorMessage, transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, request3));
      request3 = null;
    };
    if (browser_default.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin_default(fullPath)) && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request3) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request3.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request3.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request3.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request3.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request3.upload) {
      request3.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request3) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request3) : cancel);
        request3.abort();
        request3 = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && browser_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request3.send(requestData || null);
  });
}

// node_modules/axios/lib/adapters/index.js
var adapters2 = {
  http: xhrAdapter,
  xhr: xhrAdapter
};
var adapters_default = {
  getAdapter: (nameOrAdapter) => {
    if (utils_default.isString(nameOrAdapter)) {
      const adapter = adapters2[nameOrAdapter];
      if (!nameOrAdapter) {
        throw Error(utils_default.hasOwnProp(nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Can not resolve adapter '${nameOrAdapter}'`);
      }
      return adapter;
    }
    if (!utils_default.isFunction(nameOrAdapter)) {
      throw new TypeError("adapter is not a function");
    }
    return nameOrAdapter;
  },
  adapters: adapters2
};

// node_modules/axios/lib/defaults/index.js
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function getDefaultAdapter() {
  let adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = adapters_default.getAdapter("xhr");
  } else if (typeof process !== "undefined" && utils_default.kindOf(process) === "process") {
    adapter = adapters_default.getAdapter("http");
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e3) {
      if (e3.name !== "SyntaxError") {
        throw e3;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults2 = {
  transitional: transitional_default,
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(isFileList2 ? { "files[]": data } : data, _FormData && new _FormData(), this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults2.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e3) {
        if (strictJSONParsing) {
          if (e3.name === "SyntaxError") {
            throw AxiosError_default.from(e3, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e3;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: browser_default.classes.FormData,
    Blob: browser_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils_default.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults2.headers[method] = {};
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults2.headers[method] = utils_default.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_default = defaults2;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default();
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(config, config.transformRequest);
  const adapter = config.adapter || defaults_default.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge(target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop) {
    if (!utils_default.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils_default.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils_default.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils_default.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils_default.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  const mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "beforeRedirect": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils_default.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge5 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge5(prop);
    utils_default.isUndefined(configValue) && merge5 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.1.3";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i3) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i3 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version3, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")), AxiosError_default.ERR_DEPRECATED);
    }
    if (version3 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version3 + " and will be removed in the near future"));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i3 = keys2.length;
  while (i3-- > 0) {
    const opt = keys2[i3];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer !== void 0) {
      validator_default.assertOptions(paramsSerializer, {
        encode: validators2.function,
        serialize: validators2.function
      }, true);
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    const defaultHeaders = config.headers && utils_default.merge(config.headers.common, config.headers[config.method]);
    defaultHeaders && utils_default.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    config.headers = new AxiosHeaders_default(config.headers, defaultHeaders);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i3 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i3 < len) {
        promise = promise.then(chain[i3++], chain[i3++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i3 = 0;
    while (i3 < len) {
      const onFulfilled = requestInterceptorChain[i3++];
      const onRejected = requestInterceptorChain[i3++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i3 = 0;
    len = responseInterceptorChain.length;
    while (i3 < len) {
      promise = promise.then(responseInterceptorChain[i3++], responseInterceptorChain[i3++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i3 = token._listeners.length;
      while (i3-- > 0) {
        token._listeners[i3](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve2;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve2 = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve2);
      };
      return promise;
    };
    executor(function cancel(message, config, request3) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request3);
      resolvePromise(token.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c6) {
      cancel = c6;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback2) {
  return function wrap(arr) {
    return callback2.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance4 = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance4, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance4, context, null, { allOwnKeys: true });
  instance4.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance4;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.formToJSON = (thing) => {
  return formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
};
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2
} = axios_default;
var axios_default2 = axios_default;

// src/utils/request.ts
var import_obsidian13 = require("obsidian");
var createAxiosByinterceptors = (config) => {
  const instance4 = axios_default2.create({
    ...config
  });
  instance4.interceptors.request.use(function(config2) {
    return config2;
  }, function(error) {
    return Promise.reject(error);
  });
  instance4.interceptors.response.use(function(response) {
    return response;
  }, function(error) {
    var _a3, _b2;
    logger_default.error(error);
    logger_default.error(((_b2 = (_a3 = error == null ? void 0 : error.response) == null ? void 0 : _a3.data) == null ? void 0 : _b2.message) || "\u670D\u52A1\u7AEF\u5F02\u5E38");
    return Promise.reject(error);
  });
  return instance4;
};
var request2 = createAxiosByinterceptors();
function notify2(msg2, config) {
  logger_default.error(msg2);
  let auth = config.NTFY_AUTH;
  if (!auth) {
    auth = process.env.NTFY_AUTH;
  }
  logger_default.error(auth);
  if (auth) {
    axios_default2.post("https://ntfy.ihave.cool/test", "msg", {
      headers: {
        Authorization: `Basic ${auth}`
      }
    }).then((res) => new import_obsidian13.Notice("Ntfy sent the message successfully")).catch((error) => new import_obsidian13.Notice("Please check the ntfy configuration first"));
  } else {
    new import_obsidian13.Notice("Please configure ntfy first");
  }
}

// src/utils/file.ts
var import_obsidian14 = require("obsidian");
var obsidian = __toESM(require("obsidian"));
async function getNotePath(directory, filename) {
  if (!filename.endsWith(".md")) {
    filename += ".md";
  }
  const path = obsidian.normalizePath(join(directory, filename));
  await ensureFolderExists(path);
  return path;
}
function join(...partSegments) {
  let parts = [];
  for (let i22 = 0, l2 = partSegments.length; i22 < l2; i22++) {
    parts = parts.concat(partSegments[i22].split("/"));
  }
  const newParts = [];
  for (let i22 = 0, l2 = parts.length; i22 < l2; i22++) {
    const part = parts[i22];
    if (!part || part === ".")
      continue;
    else
      newParts.push(part);
  }
  if (parts[0] === "")
    newParts.unshift();
  return newParts.join("/");
}
async function ensureFolderExists(path) {
  const dirs = path.replace(/\\/g, "/").split("/");
  dirs.pop();
  if (dirs.length) {
    const dir = join(...dirs);
    if (!window.app.vault.getAbstractFileByPath(dir)) {
      await window.app.vault.createFolder(dir);
    }
  }
}
async function getAllFiles(folders, ignorePath, ext, files) {
  const ignoreMatch = ignorePath.find((item) => folders.path.startsWith(item));
  if (!ignoreMatch) {
    const children2 = await app.fileManager.vault.fileMap[folders.path].children;
    if (!children2) {
      files.push(folders);
    } else {
      for (let index2 = 0; index2 < children2.length; index2++) {
        const element2 = children2[index2];
        if (element2.children && element2.children.length != 0) {
          await getAllFiles(element2, ignorePath, ext, files);
        } else if (ext && ext.length > 0) {
          console.log(ext, element2.extension, ext.contains(element2.extension));
          if (element2.extension && ext.contains(element2.extension)) {
            files.push(element2);
          }
        } else {
          files.push(element2);
        }
      }
    }
  }
  return files;
}
function getCleanTitle(msg2) {
  if (msg2) {
    return msg2.trim();
  }
  const count = (msg2.match(/-/g) || []).length;
  let nameTitle = msg2;
  if (nameTitle.length > 1) {
    nameTitle = nameTitle.trim();
  }
  if (count == 0) {
    if (msg2.includes("Untitled")) {
      console.log("Untitled so returning empty space");
      return " ";
    } else {
      console.log("No Dash so returning trimmed:", msg2);
      return nameTitle.trim();
    }
  } else if (count == 1) {
    console.log("Dash detected in:", msg2);
    nameTitle = nameTitle.split("-").slice(1);
    nameTitle = nameTitle[0];
    return nameTitle.trim();
  } else if (count > 1) {
    const dateType = /(\d{4})([-])(\d{2})([-])(\d{2})/;
    const isMatch = dateType.test(msg2);
    if (isMatch && count == 2) {
      console.log("Date detected! No other dash, return as is", msg2);
      return nameTitle.trim();
    } else {
      console.log("Just front snippets with extra dash or date but also more dash", msg2);
      nameTitle = nameTitle.split("-").slice(1);
      nameTitle = nameTitle.join("-");
      return nameTitle.trim();
    }
  } else {
    console.log("Logic Error");
  }
}

// src/utils/common.ts
function getTaskContentFromTask(task) {
  task = task.replace(/[✅🔁⏳📅🔼⏫🔽] .*/u, "");
  return task.replace(/ #\w*/g, "");
}
function getTagsFromTask(task) {
  var _a3;
  return ((_a3 = task.match(/ #\w*/g)) == null ? void 0 : _a3.map((tag) => tag.split(" #")[1])) || [];
}

// src/utils/content.ts
async function insertAfterHandler(targetString, formatted, fileContent) {
  const targetRegex = new RegExp(`s*${await escapeRegExp(targetString)}s*`);
  const fileContentLines = getLinesInString(fileContent);
  const targetPosition = fileContentLines.findIndex((line) => targetRegex.test(line));
  const targetNotFound = targetPosition === -1;
  if (targetNotFound) {
    logger_default.log("unable to find insert after line in file.");
  }
  const nextHeaderPositionAfterTargetPosition = fileContentLines.slice(targetPosition + 1).findIndex((line) => /^#+ |---/.test(line));
  const foundNextHeader = nextHeaderPositionAfterTargetPosition !== -1;
  if (foundNextHeader) {
    let endOfSectionIndex = -1;
    for (let i3 = nextHeaderPositionAfterTargetPosition + targetPosition; i3 > targetPosition; i3--) {
      const lineIsNewline = /^[\s\n ]*$/.test(fileContentLines[i3]);
      if (!lineIsNewline) {
        endOfSectionIndex = i3;
        break;
      }
    }
    if (endOfSectionIndex == -1)
      endOfSectionIndex = targetPosition;
    return await insertTextAfterPositionInBody(formatted, fileContent, endOfSectionIndex, foundNextHeader);
  } else {
    return await insertTextAfterPositionInBody(formatted, fileContent, fileContentLines.length - 1, foundNextHeader);
  }
}
async function escapeRegExp(text2) {
  return await text2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function getLinesInString(input) {
  const lines = [];
  let tempString = input;
  while (tempString.contains("\n")) {
    const lineEndIndex = tempString.indexOf("\n");
    lines.push(tempString.slice(0, lineEndIndex));
    tempString = tempString.slice(lineEndIndex + 1);
  }
  lines.push(tempString);
  return lines;
}
async function insertTextAfterPositionInBody(text2, body, pos, found) {
  if (pos === -1) {
    return {
      content: `${body}
${text2}`,
      posNum: -1
    };
  }
  const splitContent = body.split("\n");
  if (found) {
    const pre = splitContent.slice(0, pos + 1).join("\n");
    const post = splitContent.slice(pos + 1).join("\n");
    return {
      content: `${pre}
${text2}
${post}`,
      posNum: pos
    };
  } else {
    const pre = splitContent.slice(0, pos + 1).join("\n");
    const post = splitContent.slice(pos + 1).join("\n");
    if (/[\s\S]*?/g.test(post)) {
      return {
        content: `${pre}
${text2}`,
        posNum: pos
      };
    } else {
      return {
        content: `${pre}${text2}
${post}`,
        posNum: pos
      };
    }
  }
}
async function setBanner(filepath, oldBanner, newBanner) {
  const fileContents = await app.vault.adapter.read(filepath);
  let originalLine = `banner: '${oldBanner}'`;
  if (!fileContents.contains(originalLine)) {
    originalLine = `banner: "${oldBanner}"`;
  }
  const newContent = fileContents.replace(originalLine, `banner: '${newBanner}'`);
  await app.vault.adapter.write(filepath, newContent);
  return true;
}

// src/utils/genBanner.ts
var searchPicture = async (source, keyword) => {
  const res = await new Promise((resolve2, reject) => {
    request2.get(`https://api.ihave.cool/gen_image/from_keyword?origin=${source}&keyword=${keyword}`).then((res2) => {
      logger_default.log(res2);
      resolve2(res2);
    }).catch((error) => reject(error));
  });
  if (res.status === 200 && (res == null ? void 0 : res.data)) {
    return res.data;
  } else {
    return "";
  }
};
var getLocalRandom = async (title, path) => {
  const allImages = await getAllFiles(path, [], ["png", "jpg", "jpeg", "svg", "gif", "bmp", "webp"], []);
  const randomImage = allImages[Math.floor(Math.random() * allImages.length)];
  if (!randomImage) {
    return "";
  } else {
    return randomImage.path;
  }
};

// wasm-binary:/home/runner/work/awesome-brain-manager/awesome-brain-manager/src/utils/db/sqljs/sql-wasm.wasm
var sql_wasm_default = __toBinary("AGFzbQEAAAABrQRHYAJ/fwF/YAF/AX9gA39/fwBgAX8AYAN/f38Bf2ACf38AYAR/f39/AX9gBX9/f39/AX9gBH9/f38AYAZ/f39/f38Bf2AFf39/f38AYAJ/fgF/YAR/f39+AX9gBn9/f39/fwBgB39/f39/f38Bf2AAAX9gAXwBfGABfgF/YAJ/fgBgA39/fgF/YAJ/fwF+YAAAYAF/AX5gBH9+f38Bf2AHf39/f39/fwBgCX9/f39/f39/fwF/YAh/f39/f39/fwF/YAN/fn8Bf2ACf3wAYAV/fn5+fgBgCX9/f39/f39/fwBgBX9/f39+AGAFf39+f38Bf2ADf39+AGADf35/AGADf35+AX9gAAF8YAF/AXxgBH9+fn8AYAh/f39/f39/fwBgBH5+fn4Bf2ALf39/f39/f39/f38AYAN8fH8BfGACfHwBfGAEf39+fwBgBn9/f35/fwF/YAF+AX5gBX9+f39/AX9gAn9+AX5gBn9/f39/fgF/YAR/f39/AX5gAn5+AXxgCH9+fn9/f39/AX9gAn58AX9gC39/f39/f39/f39/AX9gAnx/AXxgAXwBf2ACfH8Bf2AHf39/f35/fwF+YAl/fn9+fn5+f38Bf2AEf39/fgBgAnx+AX9gCn9/f39/f39/f38Bf2ADf398AX9gB39/f39/fHwAYAF8AX5gBX9+fn5/AX9gCH9/fn5+f39/AX9gBH9+f38AYA1/f39/f39/f39/f39/AGACf38BfALNASIBYQFhAAgBYQFiAAQBYQFjAAEBYQFkACQBYQFlACQBYQFmAAEBYQFnAAQBYQFoAAABYQFpAAABYQFqAAUBYQFrAAcBYQFsAAQBYQFtAAABYQFuAAIBYQFvAAYBYQFwAAQBYQFxAA8BYQFyAAYBYQFzAAEBYQF0AAYBYQF1AAYBYQF2AAYBYQF3AAkBYQF4AAkBYQF5AAQBYQF6AAABYQFBAAABYQFCAAABYQFDAAEBYQFEAAYBYQFFAAABYQFGAAABYQFHAAABYQFIAAYDkw+RDwYDBwQCBQQBBQEEAQUBAAEBDgUGBAkFBQEEBAECCAULAQECBQEABAMAEQMAAAMlBAYABgALARMDAAAcAQUWAQcDEgIABQMGAQAGAgILCAQEAQAABBEBCAYMAAQAAgEFBQwFAQQAAAIKAwQCCwEAEgUBAgMABAAB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CEUgAXINACAFKAKQAiAFIAUoAhAgA2ooAgAgBCAIEQYAIQELIAJBAWohAgwBCwsgACABNgIkQQFB5QAgARshAgwBCyABIQIgACwAlAFBAE4NACAAEOMGIQILIAUgAjYCQCAAKAIAIAAoAiQQogFBB0cNACAAQQc2AiQgAkEHIAAsAJQBQQBOGyECCyAFKAJIIAJxCyIBQRFHDQEgFUEyRgRAQREPCyAAKAIgIQUjAEEQayIDJAAgABDnCSEBAkAgACgCACICIAFBfyAALQCUASAAIANBDGpBABDJBCIIBEAgCEEHRw0BIAIQTwwBCyADKAIMIQQjAEHwAWsiASQAIAEgBEHwARAlIQkgBCAAQfABECUhAiAAIAlB8AEQJSEBIAIoAgghByACIAEoAgg2AgggASAHNgIIIAIoAgQhByACIAEoAgQ2AgQgASAHNgIEIAIoAsQBIQcgAiABKALEATYCxAEgASAHNgLEASACKALIASEHIAIgASgCyAE2AsgBIAEgBzYCyAEgASACKALgATYC4AEgASACLQCUAToAlAEgAUGgAWogAkGgAWpBJBAlGiABIAEoArQBQQFqNgK0ASAJQfABaiQAQQAhAQNAIAQuARAgAUoEQCABQShsIgIgACgCZGogBCgCZCACahDdCSABQQFqIQEMAQsLIARBADYCJCAEEJgCGgsgA0EQaiQAAkAgCARAIAwoAqACECshASAMIAAoAnwQJyAMLQBXDQEgACAMIAEQWjYCfCAAIAwgCBCiASIANgIkIAAPCyAVQQFqIRUgABA6GiAFQQBIDQEgAEH+AToAkwEMAQsLQQchASAAQQc2AiQgAEEANgJ8CyABC2MBAn8gACgCECIDIAJqIgQgACgCCE8EQCAAIAIQtwYiAkEASgRAIAAoAgQgACgCEGogASACECUaIAAgACgCECACajYCEAsPCyACBEAgACAENgIQIAAoAgQgA2ogASACECUaCwspACAAIAFBCHRBgID8B3EgAUEYdHIgAUEIdkGA/gNxIAFBGHZycjYAAAs9AQF/IAAtABMiAUUEQCAAIAAoAixBAWoiADYCLCAADwsgACABQQFrIgE6ABMgACABQf8BcUECdGooApgBC3EBAX8gACgCCCICLgEQQQBOBEACfyAAKAIIIQIgAUEATARAIAIQYiACQQA2AghBAAwBCyAC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ACgCWCABKAIIQShsaiIALQARQZABcQRAIAAQYiAAQQQ7ARAgAA8LIABBBDsBECAAC3ABA38jAEEQayIEJABB7PUDKAIABEAgBCACNgIMIwBB8AFrIgMkACADQdgBaiIFQQAgA0HSAUEAEJoBIAUgASACELsDQez1AygCACEBQfD1AygCACAAIAUQxQEgARECACADQfABaiQACyAEQRBqJAALCgAgACgCACgCFAsNACAAKAIAIAGsEJABC80BAQN/IAEEQCABQQhqIQIDQCABKAIAIARKBEAgAigCBCIDBEAgACADEF4LIAAgAigCCBAnIAIoAgwiAwRAIAAgAxBeCyACLwAlIgNBAnEEfyAAIAIoAjgQJyACLwAlBSADC0EEcQRAIAAgAigCOBA5CyAAIAIoAhAQ0wEgAigCFCIDBEAgACADEGYLIAIoAiwhAwJAIAItACZBBHEEQCAAIAMQ7QEMAQsgA0UNACAAIAMQLgsgAkFAayECIARBAWohBAwBCwsgACABEF4LCxUAIAAgASACIAMgACgCACgCCBEMAAs/AQF+AkAgACkDECICIAApAwhaBEAgAEEBEMoDDQEgACkDECECCyAAIAJCAXw3AxAgACgCBCACp2ogAToAAAsL4gEBAX8DQAJAIAAoAgRBgMAQcQRAIABBDGohAAwBCwJ/IAAtAAAiAUGwAUYEQCAALQACIQELAkACQAJAAkACQAJAIAFBsQFrDgICAQALIAFBigFHBEACQCABQacBaw4DAAUABAsgACgCLCIBRQ0EIAEgAC4BIBC8BAwGCyAAKAIUKAIcQQhqIQAMBgsgACgCDCgCFCgCHCAALgEgQQR0akEIaiEADAULIAAoAhRBCGohAAwECyABQSRGDQELIAAtAAEMAQsgACgCCEEAENEEC0EYdEEYdQ8LIAAoAgAhAAwACwALZQEBfyABEJ4BIQMCQCAALQAXRSADRXINACADLQAAQbABRg0AIAMQygVFDQAgAkEANgIAIAAgA0F/EMkFDwsgAiAAEEYiASAAIAMgARDvASIDRwR/IAAgARBAQQAFIAELNgIAIAMLNwEBfyABQQBIBEAgACgCbEEBayEBC0HwpwQhAiAAKAIALQBXBH9B8KcEBSAAKAJoIAFBFGxqCwt7AQN/AkAgAUEASA0AIAAoAhxBIHFFDQAgACgCBCEEA0Ag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KAIkIAIQNjYCJCADIAAgASgCKCACEHA2AiggAyAAIAEoAiwgAhA2NgIsIAMgACABKAIwIAIQcDYCMCABLQAAIQUgAyAENgI4IAMgBToAACADQQA2AjQgACABKAI8IAIQNiEEIANCADcCCCADIAQ2AjwgASgCBCEEIANCfzcCFCADIARBX3E2AgQgAyABLwECOwECIAAgASgCQBDnCyEEIANBADYCRCADIAQ2AkAgASgCSCEHIwBBEGsiBSQAIAVBADYCDCAFQQxqIQQDQAJAIAdFDQAgBCAAQQAgBxDlCyIENgIAIARFDQAgBEEkaiEEIAcoAiQhBwwBCwsgBSgCDCEEIAVBEGokACADIAQ2AkgCQCABKAJEBEAgAC0AVwRAIAMgASgCEDYCEAwCCyMAQSBrIgQkACAEQQA2AgwgBEHAADYCCCAEQcEANgIEIAQgAzYCGCAEQQA2AgAgBCADEGoaIARBIGokAAsgAC0AVyEEIAMgASgCEDYCECAERQ0CCyADQQA2AjggACADEGYLIAYoAgwhACAGQRBqJAAgAA8LIAggAzYCACABKAI0IQEgA0E0aiEIIAMhBAwACwALeQEBfyABBH8gAkUEQCABDwsgACgCACEDAkAgASgCBEGBgICAAnFBgICAgAJHBEAgAigCBEGBgICAAnFBgICAgAJHDQELIAAtANABQQFLDQAgACABENcHIAAgAhDXByADQZsBQeK7ARBxDwsgAEEsIAEgAhA1BSACCwu7AwEDfwJAIAFFDQACQCAABEAgACgCkAQNAQsgASABKAIYQQFrIgI2AhggAg0BCyAAIQIgASgCCCEAA0AgAARAIAAoAhQhAwJAIAIEQCACKAKQBA0BCyABLQArQQFGDQAgACgCGEEYaiAAKAIAQQAQqAEaCyACIAAQ2gQgAyEADAELCwJAAkACQAJAIAEtACsOAgABAgsgASgCMCEAA0AgAARAAkAgAgRAIAIoApAEDQELIAAoAgwhAwJAIAAoAhAiBARAIAQgAzYCDAwBCyABKAI8QThqIAMgACADGygCCCADEKgBGgsgACgCDCIDRQ0AIAMgACgCEDYCEAsgAiAAKAIcEPEDIAIgACgCIBDxAyAAKAIEIQMgAiAAECcgAyEADAELCwwCC0EAIQACQCACBEAgAigCkAQNAQtBACABEK8IGgsgASgCMARA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KAKgAiABQQEQxgULIARBEGokAAs7AQF/IAAoAgAiAi0AV0UEQCACIAAoAmggAUEUbGoiACwAASAAKAIQEIwEIABBADYCECAAQbgBOwEACwvCAQEBfwJAIAAoAgAtAFcNACABLQAEQYABcQ0AIwBBIGsiAyQAIANBxwA2AgQgAyAANgIAIAAtABYEQCADQQA2AgwgA0HIADYCCCADIAEQahoLIANBADsBFCADQT82AgwgA0HJADYCCCADIAEQahogA0EgaiQAIAAoAiQNACAAIAEgAhDaCyAAKAIkDQAjAEEgayICJAAgAkHKADYCDCACQTI2AgggAkHHADYCBCACIAA2AgAgAiABEGoaIAJBIGokAAsLRQEBfyAAKAIAQgwQjQEiAwRAIAMgACgCgAE2AgAgACADNgKAASADIAE2AgggAyACNgIEIAIPCyAAKAIAIAIgAREFAEEACw8AQQ4gAEGN6AAQiAVBDgsUAQF/EOwBBH9BAAUgACABEMgBCwtIAQF/IABBASABdCICIAAoApgBcjYCmAECQCABQQFGDQAgACgCACgCECABQQR0aigCBC0ACUUNACAAIAAoApwBIAJyNgKcAQsLHQEBfxDsAQR/QQAFIAAgAUEAIAFBAEobrRDIAQsLZQEDfyACRQRAQQAPCwJAIAAtAAAiA0UNAANAAkAgAS0AACIFRQ0AIAJBAWsiAkUgAyAFR3INACABQQFqIQEgAC0AASEDIABBAWohACADDQEMAgsLIAMhBAsgBEH/AXEgAS0AAGsLcgECfwJAIAAoAgAgACgCDGoiAkEATARAQQEhAiAALQAQQRBxRQ0BC0EHIQEgACACQQEQvwMNAEEAIQEgACgCCCAAKAIMakEAIAAoAgAQKBogACAAKAIMIAAoAgBqNgIMIAAgAC8BEEH/8wNxOwEQCyABC8kKAgV/D34jAEHgAGsiBSQAIARC////////P4MhDCACIASFQoCAgICAgICAgH+DIQogAkL///////8/gyINQiCIIQ4gBEIwiKdB//8BcSEHAkACQCACQjCIp0H//wFxIglB//8Ba0GCgH5PBEAgB0H//wFrQYGAfksNAQsgAVAgAkL///////////8AgyILQoCAgICAgMD//wBUIAtCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhCgwCCyADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEKIAMhAQwCCyABIAtCgICAgICAwP//AIWEUARAIAIgA4RQBEBCgICAgICA4P//ACEKQgAhAQwDCyAKQoCAgICAgMD//wCEIQpCACEBDAILIAMgAkKAgICAgIDA//8AhYRQBEAgASALhCECQgAhASACUARAQoCAgICAgOD//wAhCgwDCyAKQoCAgICAgMD//wCEIQoMAgsgASALhFAEQEIAIQEMAgsgAiADhFAEQEIAIQEMAgsgC0L///////8/WARAIAVB0ABqIAEgDSABIA0gDVAiBht5IAZBBnStfKciBkEPaxCpAUEQIAZrIQYgBSkDWCINQiCIIQ4gBSkDUCEBCyACQv///////z9WDQAgBUFAayADIAwgAyAMIAxQIggbeSAIQQZ0rXynIghBD2sQqQEgBiAIa0EQaiEGIAUpA0ghDCAFKQNAIQMLIANCD4YiC0KAgP7/D4MiAiABQiCIIgR+IhAgC0IgiCITIAFC/////w+DIgF+fCIPQiCGIhEgASACfnwiCyARVK0gAiANQv////8PgyINfiIVIAQgE358IhEgDEIPhiISIANCMYiEQv////8PgyIDIAF+fCIUIA8gEFStQiCGIA9CIIiEfCIPIAIgDkKAgASEIgx+IhYgDSATfnwiDiASQiCIQoCAgIAIhCICIAF+fCIQIAMgBH58IhJCIIZ8Ihd8IQEgByAJaiAGakH//wBrIQYCQCACIAR+IhggDCATfnwiBCAYVK0gBCAEIAMgDX58IgRWrXwgAiAMfnwgBCAEIBEgFVStIBEgFFatfHwiBFatfCADIAx+IgMgAiANfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgAiAQIBJWrSAOIBZUrSAOIBBWrXx8QiCGIBJCIIiEfCICVq18IAIgAiAPIBRUrSAPIBdWrXx8IgJWrXwiBEKAgICAgIDAAINQRQRAIAZBAWohBgwBCyALQj+IIQMgBEIBhiACQj+IhCEEIAJCAYYgAUI/iIQhAiALQgGGIQsgAyABQgGGhCEBCyAGQf//AU4EQCAKQoCAgICAgMD//wCEIQpCACEBDAELAn4gBkEATARAQQEgBmsiB0GAAU8EQEIAIQEM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IAhBFGxqIgEuARIgAhAkGiABLgEQIgFBAEgNISAAKAIEIAFB//8DcUEMbGotAAVBxQBHDSEgBkHXACACECwaDCELIAEtAARBIHEEQCAAIAEoAgwgAhDvASEDAn8gASgCLCIABEAgACABLgEgELwEDAELIAEtAAELIgBBGHRBGHVBwgBIDSIgBkHgACADQQFBACAAQf8BcUEBdEHc+AJqQX8QMxoMIgsgASgCHCIFQQBIBEAgACgCNCIDQQBIBEAgAS8BICIEQRB0QRB1IghBAEgEQCADQX9zIQMMJAsgASgCLCIFIAgQhwEgA2shAyAFKAIEIARBDGxqIgEvAQoiBEHgAHEEQCAEQYACcQRAIAcgASgCADYCACAAQeDcASAHECZBACEDDCULIAEgBEGAAnIiAjsBCiABIARBgAFxBH8gACAFIAEgAxDQByABLwEKBSACC0H//ANxOwEKDCQLIAEtAAVBxQBHDSMgBkHRACADIAIQIhogBkHXACACECwaDCILIANBAWshBQsgAS0AAiEDIAAoAgggASgCLCAFIAEuASAgAhCJAQJAIANFDQAgACgCCEF/EIYBIgAtAABB3gBHDQAgACADOwECCyACIQMgASgCLA0hIAEtAAFBxQBHDSEgBkHXACADECwaDCELIAAgAUEAIAIQ+QsMHwsgBkHHACABELsEIAIQIhoMHgsgBiABKAIIQQAgAhDPBwwdCyAGIAIgASgCCBCwARoMHAsgBkHNACABKAIIQQJqIgAQMUEBayIBQQJtIAJBACAGKAIAIAAgARCTCEF6EDMaDBsLIAZBzgAgAS4BICACECIaIAEoAggtAAFFDRogACgC4AEiACABLgEgEOAJIQEgAEEANgIAIAYgAUF/EIgBDBoLIAEoAhwhAwwaCyACIAAgASgCDCACEO8BIgBHBEAgBkHRACAAIAIQIhoLIAZB2AAgAiABKAIIQQAQ0QQQIhoMGAtBNUE0IAVBLUYbIQVBASEIQYABDAELQQALIQsgASgCDCIDEP4BBEAjAEEQayIDJAAgASgCECEGIAAoAgghBCABKAIMIg0QkgEhCiAAEDIhCAJAIAAoAiQNACABKAIEIQEgBhCSASAKRwRAIABB6vMAQQAQJgwBCyABQQp2QQFxIREgACANEPULIRIgACAGEPULIRMgBEHHAEEBIAIQIhpBNUE2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IQQDQAJAIAAgBEsEQCAELQAAQTBGDQELQQAhAgNAAkAgAiAEaiIIIABPIgkNACAILQAAIghBMGtB/wFxQQlLDQAgAiAFaiECIApCCn4gCK1C/wGDfEIwfSEKDAELCyABQv///////////wBCgICAgICAgICAfyAHGyAKQgAgCn0gBxsgCkIAUxs3AwACfyACRQRAQX8gAyAERg0BGgsgBiAGDQAaIAYgCQ0AGiACIQMDQEEBIAMgBGotAABBwOoBai0AAEEBcUUNARogBCADIAVqIgNqIABJDQALQQALIQMCQCACIAVBE2wiBkkNAEEBIQAgAiAGTQRAQQAhAEEAIQIDQCACIABBEUtyRQRAIAQgACAFbGosAAAgAEHXuAFqLAAAa0EKbCECIABBAWohAAwBCwsgAgR/IAIFIAQgBUESbGosAABBOGsLIgBBAEgNAQsgAUL///////////8AQoCAgICAgICAgH8gBxs3AwBBAkEDIAMgBxsgABshAwsgAw8LIAQgBWohBAwACwALpwECA38BfgJAIAAtAABBMEcNACAALQABQSByQfgARw0AQQIhAgNAIAIiA0EBaiECIAAgA2otAAAiBEEwRg0ACyADIQIDQCAEQcDqAWotAABBCHEEQCAEQRh0QRh1EIcCrSAFQgSGfCEFIAAgAkEBaiICai0AACEEDAELCyABIAU3AwBBAiACIANrQRBKQQF0IAAgAmotAAAbDwsgACABIAAQMUEBEPUCC40DAQR/AkACQCAABEAgAUEBayECAkADQCAAKAIAQaEfTwRAIAAoAggiAUUNAiACIAIgAW4iAyABbGshAiAAIANBAnRqIgNBDGooAgAiAA0BIAMgARCBBCIANgIMIAANAQwFCwsgACACQQN2aiIAQQxqIAAtAAxBASACQQdxdHI6AABBAA8LIAJBAWohBAJAIABBDGoiAyACQf0AcCIBQQJ0aigCACICBEADQCACIARGBEBBAA8LIANBACABQQFqIgEgAUH8AEsbIgFBAnRqKAIAIgINAAsgACgCBCICQT5JDQEMAwsgACgCBCICQfwATw0CCyAAIAJBAWo2AgQgAyABQQJ0aiAENgIAC0EADwtBACEBQQBC9AMQjQEiAkUNACACIANB9AMQJSEFIANBAEH0AxAoGiAAIAAoAgBB/ABqQf0AbjYCCCAAIAQQ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IAAoAiAQXgsgACAAKAIUIAGsEI0BIgE2AiALIAFFBEAgABBiIABBADYCGCAAQQA2AghBBw8LIAAgACgCFCABEKsCNgIYAkAgAkUNACAAKAIIIgFFDQAgACgCICABIAAoAgwQJRoLIAAgAC8BECIBQYAgcQR/IAAoAgggACgCJBEDACAALwEQBSABC0H/nwJxOwEQIAAgACgCIDYCCEEAC9MDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC////////v//DAFYNAEIAIQIgA0IwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACEIgIgBUGB9wBrEKkBIAQgACACQYH4ACAFaxD/AiAEKQMIQgSGIAQpAwAiAEI8iIQhAiAEKQMQIAQpAxiEQgBSrSAAQv//////////D4OEIgBCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAAQoCAgICAgICACFINACACQgGDIAJ8IQILIARBIGokACACIAFCgICAgICAgICAf4OEvwvTAQIBfwJ+QX8hBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNACAAIAKEIAUgBoSEUARAQQAPCyABIAODQgBZBEAgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAvMAQEGfxC7ASAAEPcBIAAtABhBAXEEQCAALQCxAUUhBAsgBEUhBgNAIAMgACgCFE5FBEAgACgCECAD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AkAgASgCECICBH8gAgUgASgCDCEDIAFBACABMwE0QgF8EI0BIgI2AhAgAkUNAUEAIQIDQCACIAEvATRPRQRAAn8gASgCBCACQQF0ai8BACIAQRB0QRB1IgRBAE4EQCADKAIEIABBDGxqLQAFDAELQcQAIARBf0YNABogASgCKCACQQR0aigCCBCEAQshACABKAIQIAJqIABBGHRBGHUiAEHBACAAQcEAShsiAEHDACAAQcMASRs6AAAgAkEBaiECDAELCyABKAIQIAJqQQA6AAAgASgCEAsPCyAAEE9BAAsOACAAIAEQhgEgAjYCDAvJAQECfwJAAkAgACgCAC0AIUHAAHFFDQAgAS0AKw0AAkAgAkUEQEEBIQQgARCPAw0DIAEoAjBBAEchBQwBCyABQTBqIQBBASEEA0AgACgCACIABEAgASAAIAIgAxCTCwRAQQEhBSAEQQIgASgCACAAKAIIEFMbIQQLIABBBGohAAwBCwsgARCPAyEAA0AgAEUNAQJAIAEgACACIAMQpgdFDQBBASEFIAAtABpFDQBBAg8LIAAoAgwhAAwACwALIAUNAQtBACEECyAEC6UDAQl/An8CQAJAIAEoAjhFBEAgACgCACgCECgCHCIHBH8gBygCMEEARwVBAAtFDQELIAAtAJcBRQ0BC0EAIARFDQEaIARBADYCAEEADwsgAyEJIwBBEGsiCCQAAkACQCAAIgMgASIHEM8LIgFFDQACQCADKAIALQAiQQRxDQAgBygCOCIGRQ0AIAEgBkYNASABIQADQCAAIgUoAiAiAEEAIAAgBkcbDQALIAVBADYCIAtB35gBQeaYASACQYABRhshCkEAIQUgAkH/AEYhCyACQYEBRyEMIAEhAANAAkACQCAALQAIIgYgAkcNACAAKAIQIAkQpQdFDQAgBSAALQAJciEFDAELIAZBlgFGBEAgACACOgAIQQJBASAHLQArQQFHIg0bIQYgCyANckUEQCAIIAo2AgAgA0GZKSAIECZBASEGCyAAIAY6AAkgBSAGciEFDAELIAAtAApFIAxyIAZB/wBHcg0AIAMoAnQNACAFIAAtAAlyIQULIAAoAiAiAA0ACwwBC0EAIQELIAQEQCAEIAU2AgALIAhBEGokACABQQAgBRsLCyoBAX9BqpYBIQEgAEGHAWsiAEECTQR/IABBAnRB1K4DaigC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AiABQQZqNgIMAn8gF0EXRgRAQaYBIAJBDGoQ0ARBFkYNARoLQTsLIQUgAkEQaiQAIAUMAgsgESAaNgIsIBEgATYCKCARIBFBKGo2AiAgAEHx3wEgEUEgahAmDAMLIwBBEGsiAiQAIAIgAUEGajYCDEE7IQUgAkEMahDQBEE7RgRAQaQBQTsgAkEMahDQBEEYRhshBQsgAkEQaiQAIAULIhc2AuwJCyAAIBo2AsgBIAAgATYCxAEgESAAKQLEATcDGCMAQSBrIhQkACARQTBqIhIoAgQhBCASKAIALwEAIQICQANAIBdB//8DcSEFIAJB//8DcSIGQb8ETQR/IAZBAXRBkJwCai8BACEHAn8CQANAIAcgBSICaiIFQQF0QZClAmovAQAgAkYNASACQQF0QfCVAmovAQAiBQ0ACyACQf//A3FFIAdB5QBqIgJBAXRBkKUCai8BAEHlAEdyRQRAIAJBAXRB8MgCagwCCyAGQQF0QeDpAmoMAQsgBUEBdEHwyAJqCy8BAAUgBgtB//8DcSIFQdsJTwRAAkAgBUGVjwJqLQAADQAgEigCACASKAK4CUkNACASEJIIDAMLIBQgESkCGDcDAEEAIQJBACEGQQAhCkEAIQhBACEHQQAhCyMAQbABayINJAAgEigCACEDAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBUHbCWsiHQ7WAgABAgMEBQUFBgYHCAkKCwwNDgwPEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqDCssLS4vMDEyMzQ1Njc4DDk6FjscPD0+PwxAQUA4QkNEOQxFRkdISUpLTE1MTk9QUVJTDFRVVldYFllaW1lcXV5fYGFYYmNkZWZnaGlqa2xtbmFvcFRxcnN0dXZ3eHZUcXl6eXt8fX55enl6f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAThDjwGQAZEBkgGTAZQBlAGVAZYBlwGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaMBowGjAaMBowGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrQGuAa8BsAE5sQGwATmyAbMBtAG1AbYBtwG4AbkBenmOAnlUugG7AVS8Ab0BvgG/AVS8AcABwQEMOcIBwwHEAXp5xQHGAccByAHJAVhYygHLAcwBzQHOAc8BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gG+Ad8B4AHhAeIB0QHSAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHwAfAB8QHxAfIB8wH0AfUB9gH3AY4C+AH5AfoB+wH8Af0BjgL+Af8BgAKBAgWOAoICjgKCAoMCggKEAoUChgKGAocCiAKJAo4CigKLAowCjQKOAgsgBEEBOgDPAQyNAgsgBEECOgDPAQyMAgtBACEFAkAgBC0AEg0AIAQoAgAhBiAEAn8gBCgCJARAQQcgBi0AVw0BGgwCCwJAAkAgBCgCCCICDQBB5QAgBi0AsQENAhogBBBCIgINACAEQQE2AgxBACECDAELAkAgBC0AlQFFDQAgBCgChAEiBygCYEUNACACQdMAEFUaIAJBIyAHKAJcECwhCCAHKAJkIQkDQCAHKAJgIAVKBEAgAkHeACAHKAJcIAUgBSAJahAkGiAFQQFqIQUMAQsLIAJB1AAgCSAFECIaIAJBJiAHKAJcIAhBAWoQIhogAiAIECoLIAJBxgAQVRogBi0AVw0AIAQoAlRFBEAgBCgCREUNAQtBACEFIAJBABAqA0ACQCAEKAJUIAV2QQFxRQ0AIAIgBRDkASACQQIgBSAEKAJQIAV2QQFxIAYoAhAgBUEEdGooAgwiBygCACAHKAIEEDcaIAYtALEBDQAgAkEBEDgLIAVBAWoiBSAGKAIUSA0AC0EAIQUDQCAEKALUASAFSgRAIAJBqgFBAEEAQQAgBiAEKAKEAiAFQQJ0aigCABC3AUF1EDMaIAVBAWohBQwBCwtBACEFIARBADYC1AFBACEGIAQoAgghCANAIAQoAmggBkoEQCAIQakBIAQoAmwgBkEEdGoiBygCACAHKAIEIActAAggBygCDEF/EDMaIAZBAWohBgwBCwsgBEHwAGohCCAEKAIIIQkgBCgCACEKA0ACQCAIKAIAIghFDQAgCCgCDCEHIARBACAIKAIIIgYgCigCECAGQQR0aigCDCgCSEHwABDQASAJIAdBAWsiCyAIKAIEKAIAELABGiAJQQxBsPkCEM8CIgZFDQAgBiAHNgIIIAYgBzYCSCAGQUBrIAs2AgAgBiAHNgI0IAYgB0ECaiILNgIMIAYgCzYClAEgBiAHNgJ8IAYgBzYCcCAGIAdBAWo2AlggBkEQOwE+IAYgBzYC0AEgBiAHNgKQASAEKAIoDQEgBEEBNgIoDAELCwJAIAQoAkQiBkUNACAEQQA6ABcDQCAFIAYoAgBODQEgBiAFQQR0aiIHKAIUIghBAEoEQCAEIAcoAgggCBBtCyAFQQFqIQUMAAsACwJAIAQtAJUBRQ0AIAQoAoQBIgUoAmAiBkUNACACQfYAIAUoAlwgBhAiGgsgAkEBEFsaC0EBIAQoAiQNABogAiAEENoJQeUACzYCDAsMiwILIANBCGsoAgAhBSAEKAIAIQYCQCAEQRZBu5YBQQBBABBhDQAgBBBCIgJFDQACQCAFQQdGDQBBAkEBIAVBCUYbIQdBACEFA0AgBSAGKAIUTg0BIAJBAiAFAn8gBigCECAFQQR0aigCBCIIBEBBACAIELMJDQEaCyAHCxAiGiACIAUQ5AEgBUEBaiEFDAALAAsgAkEBEFUaCwyKAgsgA0EHNgIQDIkCCyADIAMvAQI2AgQMiAILAkAgBEEWQaqYAUHNjQEgA0EKay8BAEEMRiICG0EAQQAQYQ0AIAQQQiIFRQ0AIAVBAUEBIAIQIhoLDIcCCyAEQQAgA0EEahD1BQyGAgsgBEEBIANBBGoQ9QUMhQILIARBAiADQQRqEPUFDIQCCyAEIANBCGsgA0EEaiADQSxrKAIAQQBBACADQRRrKAIAEPQFDIMCCyAEEI8IDIICCyADQQA2AhAMgQILIANBFGtBATYCAAyAAgsgAyAEKAIALQCxAUU2AgQM/wELIAQgA0EUayADQQhrIAMoAgRBABDzBQz+AQsgBEEAQQBBACADKAIEEPMFIAQoAgAgAygCBBBmDP0BCyADQQA2AhAM/AELIANBFGsiAiADKAIEIAIoAgByNgIADPsBCyADKAIEIQICQCADKAIIIgVBBUcNACACQd7vAEEFEEgNACADQQhrQYAFNgIADPsBCyADQQhrQQA2AgAgDSACNgIEIA0gBTYCACAEQcUsIA0QJgz6AQsgAygCBCECIAMCfwJAIAMoAggiBUEGRw0AIAJB9hhBBhBIDQBBgIAEDAELIA0gAjYCFCANIAU2AhAgBEHFLCANQRBqECZBAAs2AgQM+QELIA0gA0EIaykCADcDKCANIAMpAgQ3AyAgDUEoaiEJIA1BIGohBiMAQSBrIgokAAJAIAQoAuwBIghFDQAgBCgCACIMKAKAASAILgEiTARAIAogCCgCADYCECAEQfUvIApBEGoQJgwBCyAELQDQAUEBTQRAIAkQ9AcLAn8CQAJAAkACQCAGKAIEIgVBEEkNACAGKAIAIgcgBUEGayICakGiGkEGEEgNAQNAIAIiBUUNAyAHIAVBAWsiAmotAABBwOoBai0AAEEBcQ0ACyAGIAU2AgQgBUEJSQ0AIAcgBUEJayICakHL8wBBCRBIDQEDQCACIgVFDQMgByAFQQFrIgJqLQAAQcDqAWotAABBAXENAAsgBiAFNgIECyAFQQNJDQILIAYQ9AcgBigCACEOIAYoAgQhBUEBIQdBACECA0BBwQAgAkEGRg0DGgJAIAUgAkGE/AJqLQAARw0AIA4gAkECdEGg/ANqKAIAIAUQSA0AQQAhBSAGQQA2AgRBBUEBIAJB+////wdxQQFGGyEHIAJBBHRBEGohCyACQYr8AmotAAAMBAsgAkEBaiECDAALAAtBACEFIAZBADYCBAtBASEHQcEACyEPIAwgBUEAR60gCSgCBCIOrSAFrXx8QgF8EI0BIhBFDQAgBC0A0AFBAk8EQCAEIBAgCRDyARoLQQAhAiAQIAkoAgAgDhAlIgkgDmpBADoAACAJEK0CIAkQ5AIhECAILgEiIg5BACAOQQBKGyEWIAgoAgQhFSAOrCEkAkACQANAIAIgFkcEQAJAIBUgAkEMbGoiDi0AByAQRw0AIAkgDigCABAwDQAgCiAJNgIAIARBsDwgChAmDAMLIAJBAWohAgwBCwsgDCAVICRCDH5CDHwQuQEiDg0BCyAMIAkQJwwBCyAIIA42AgQgDiAILgEiIgxBDGxqIgJCADcCBCACIAk2AgAgAiAQOgAHAkAgBUUEQCACIAc6AAYgAiACLQAEQQ9xIAtyOgAEDAELIAUgCRAxIAlqQQFqIAYoAgAgBRAlIgZqQQA6AAAgBhCtAiAGIAIQ0QQhDyACIAIvAQpBBHI7AQoLIA4gDEEMbGogDzoABSAIIAgvASJBAWo7ASIgCCAILwEkQQFqOwEkIARBADYCTAsgCkEgaiQADPgBCyADQgA3AhAM9wELIANBJGsiAiADKAIEIAMoAghqIAIoAgRrNgIIDPYBCyADQTxrIgIgAygCBCADKAIIaiACKAIEazYCCAz1AQsgA0EMayICIAMoAgggAygCBGogAigCBGs2AggM9AELIAMgFCgCADYCEAzzAQsgAyAUKQIANwIQDPIBCyAEIAMpAgQ3AkgM8QELIAQgAygCBCADQQxrIgIoAgQiBSAFIAIoAghqEO0DDPABCyAEIANBCGsoAgAgA0EUaygCAEEBaiADKAIEEO0DDO8BCyAEIAMoAgQgA0EUaygCACADQQxrIgIoAgQgAigCCGoQ7QMM7gELIAQgBEGtASADKAIEQQAQNSADQRRrKAIAIANBDGsiAigCBCACKAIIahDtAwztAQsgDSADKQIENwMwIARB9QAgDUEwahCDAiICBEAgAhDPBBoLIAQgAiADKAIEIgIgAiADKAIIahDtAwzsAQsgAygCBCEGAkAgBCgC7AEiBUUNACAFLgEiIgJBAEwNACAFKAIEIAJB//8DcUEMbGpBDGsiAiACLQAEQfABcSAGQQ9xcjoABCAFIAUoAhxBgBByNgIcIAItAApBCHFFDQAgBUEIaiECA0AgAigCACICRQ0BIAIoAgQuAQAgBS4BIkEBa0YEQCACIAIvADdBCHI7ADcLIAJBFGohAgwACwALDOsBCyAEQQAgA0EIaygCACADKAIEIANBFGsoAgAQjggM6gELIARBAEEAQQBBACADKAIEQQBBAEEAQQBBARDsAwzpAQsgBCADQQhrKAIAIANBFGsoAgAgAygCBBCNCAzoAQsgBEEAIANBFGsgA0EIaygCACADKAIEEIwIDOcBCyAEIAMoAgQQiwgM5gELIANBBGohAgJAIAQoAuwBIgVFDQAgBC0A0AFBAUsNACAFLgEiIQggBCgCACIHIAIQdCIGRQ0AAkAgBCAGEOUDRQ0AIAcgCEEBayIIQQxsIgkgBSgCBGogBhDuByAFQQhqIQIDQCACKAIAIgJFDQEgAigCBC4BACAIRgRAIAIoAiAgBSgCBCAJahCoAjYCAAsgAkEUaiECDAALAAsgByAGECcLDOUBCyAEIANBCGsoAgBBABCKCAzkAQsgBCADQRRrKAIAIANBBGoQiggM4wELIANBATYCBAziAQsgA0EANgIQDOEBCyADQQhrIgIgAygCBCACKAIAIAMoAghBf3NxcjYCAAzgAQsgA0EIa0IANwIADN8BCyADQRRrQgA3AgAM3gELIANBGGsiAkH/ATYCCCACIAMoAgQ2AgQM3QELIANBGGsiAkGA/gM2AgggAiADKAIEQQh0NgIEDNwBCyADQQhrQQg2AgAM2wELIANBCGtBCTYCAAzaAQsgA0EKNgIEDNkBCyADQQc2AgQM2AELIANBCGtBADYCAAzXAQsgA0EUa0EANgIADNYBCyADQQhrIAMoAgQ2AgAM1QELIANBCGtBATYCAAzUAQsgA0EIa0EANgIADNMBCyAEQQA2AkwM0gELIAQgA0EgaygCACADKAIEIANBFGsoAgBBABCOCAzRAQsgBEEAQQBBACADQRRrKAIAIAMoAgRBAEEAQQBBAEEBEOwDDNABCyAEIANBFGsoAgAgA0EgaygCACADQQhrKAIAEI0IDM8BCyAEIANBxABrKAIAIANBIGsgA0EUaygCACADQQhrKAIAEIwIIAQgAygCBBCLCAzOAQsgA0ELNgIQDM0BCyADQRRrIAMoAgQ2AgAMzAELIANBBDYCBAzLAQsgA0EFNgIEDMoBCyAEIAMoAgRBACADQQhrKAIAEIkIDMkBCyADQdwAayELIANBLGshAiADQSBrIQogA0EUaygCACEJIAMoAgQhBSADQdAAaygCACEIIANBOGsoAgAhDCMAQdAAayIGJAAgBkEANgIMIAQoAgAhBwJAIAQuAcwBQQBKBEAgBEGpGkEAECYMAQsgBCACIAogCEEBQQAgDBD0BSAEKALsASIIRQ0AIAQoAiQNACAIIAgoAhxBgARyNgIcIAQgAiAKIAZBDGoQvgIaIAZBEGoiAiAEIAcgCCgCPBBOQZIOIAYoAgwQxQQgAkEEaiAFEGoNACAFIAUoAgRBgICAAXI2AgQCQCAELQDQAUEBSwRAIAUhAkEAIQUMAQsgByAFQQEQ0QEhAgsgCCACNgIsIAcgCUEBEHAhAiAIQQI6ACsgCCACNgIQIActAFcNACAEKQLEASIkpyICQQAgJEIgiKcgAi0AAEE7RhtqIAsoAgAiCGshAgNAIAggAkEBayICaiIKLQAAQcDqAWotAABBAXENAAsgBkEBNgJMIAYgCjYCSCAEQQAgBkHIAGpBAEEAEPMFCyAHIAUQZiAELQDQAUECTwRAIAQgCRDsBwsgByAJEDkgBkHQAGokAAzIAQsgBCADKAIEQQEgA0EIaygCABCJCAzHAQsgDUH48gIoAgA2AqgBIA1B8PICKQIANwOgASANQejyAikCADcDmAEgDUHg8gIpAgA3A5ABIAQgAygCBCANQZABahCLARogBCgCACADKAIEEGYMxgELIANBFGsgBCADKAIEIANBCGsoAgAQiAg2AgAMxQELIANBIGsgBCADKAIEIANBCGsoAgAQiAg2AgAMxAELIAMoAgQiAgRAIAQgAhDOBAsgAyACNgIEDMMBCyADQRRrIgYoAgAhAgJAAkAgAygCBCIFRQ0AIAUoAjQEQCANQQA2ApQBIAQgBRDOBCAEQQAgBEEAQQBBACANQZABaiAFQQAQggJBAEEAQQBBAEEAQQAQtgEiBUUNAQsgA0EIayIHKAIAIQggBSACNgI0IAUgCDoAACACBEAgAiACKAIEQf93cTYCBAsgBSAFKAIEQf93cTYCBCAHKAIAQYcBRg0BIARBAToAFgwBCyAEKAIAIAIQZkEAIQULIAYgBTYCAAzCAQsgAyADLwECNgIEDMEBCyADQQhrQYcBNgIADMABCyADQdwAayAEIANBxABrKAIAIANBOGsoAgAgA0EsaygCACADQSBrKAIAIANBFGsoAgAgA0EIaygCACADQdAAaygCACADKAIEELYBNgIADL8BCyADQegAayAEIANB0ABrKAIAIANBxABrKAIAIANBOGsoAgAgA0EsaygCACADQSBrKAIAIANBCGsoAgAgA0HcAGsoAgAgAygCBBC2ASICNgIAIAIEQCACIANBFGsoAgA2AkgMvwELIAQoAgAgA0EUaygCABCFBgy+AQsgA0EgayAEIANBCGsoAgBBAEEAQQBBAEEAQYAEQQAQtgE2AgAMvQELIANBLGsiBigCACEFIAQgA0EIaygCAEEAQQBBAEEAQQBBgAxBABC2ASECIAUEQCAFIAUoAgRB/3dxNgIECwJAIAJFBEAgBSECDAELIAIgBTYCNCACQYcBOgAACyAGIAI2AgAMvAELIANBATYCBAy7AQsgA0ECNgIEDLoBCyADQQA2AhAMuQELIANBLGsiAiAEIAIoAgAgA0EUaygCABA7IgU2AgAgAygCCARAIAQgBSADQQRqQQEQ5gIgAigCACEFCyADQSBrKAIAIQYgA0EIaygCACEHAkAgBUUNACAFIAUoAgBBAWtBBHRqIgIoAgwNACACIAQoAgAgBiAHEOcFNgIMIAIgAi8AEUH8/wNxQQFyOwARCwy4AQsgBCgCAEG0AUEAEHEhAiADQRRrIgUgBCAFKAIAIAIQOzYCAAy3AQsgBEG0AUEAQQAQNSECIA0gA0EUaykCADcDOCAEQY0BIARBOyANQThqEIMCIAIQNSECIANBLGsiBSAEIAUoAgAgAhA7NgIADLYBCyADQQhrIAMpAgQ3AgAMtQELIANBADYCEAy0AQsgA0EIayADKAIEIgI2AgAgAhCHCAyzAQsgA0EIaygCACICRQ2yASACKAIAIgVBAEwNsgEgBUEGdCACakEUayADKAIEOgAADLIBCyADQSxrIgIgBCACKAIAIANBIGsgA0EUayADQQhrQQAgA0EEahCCAjYCAAyxAQsgA0E4ayICIAQgAigCACADQSxrIANBIGsgA0EUa0EAIANBBGoQggIiAjYCACAEIAIgA0EIaxDyBQywAQsgA0HQAGsiAiAEIAIoAgAgA0HEAGsgA0E4ayADQQhrQQAgA0EEahCCAiICNgIAIAQgAiADQSBrKAIAEIYIDK8BCyADQThrIgIgBCACKAIAQQBBACADQQhrIANBIGsoAgAgA0EEahCCAjYCAAyuAQsCQCADQThrIgIoAgAiBQ0AIANBBGsoAgANACADKAIEDQAgAygCCA0AIAIgA0EgaygCADYCAAyuAQsgA0EgayIGKAIAIgcoAgBBAUYEQCACIAQgBUEAQQAgA0EIa0EAIANBBGoQggIiBTYCACAFBEAgBSAFKAIAQQFrIgdBBnRqIgggBigCACICKAIQNgIQIAggAigCDDYCDCAIIAIoAhwiCDYCHAJAIAhFDQAgCC0ABUEIcUUNACAFIAdBBnRqIgggCC8ALUGAwAByOwAtCyACLQAtQQRxBEAgBSAHQQZ0aiIFQUBrIAJBQGsiBygCADYCACAHQQA2AgAgAiACLwAtQfv/A3E7AC0gBSAFLwAtQQRyOwAtCyACQQA2AhwgAkIANwIMCyAEKAIAIAYoAgAQgQEMrgELIAcQhwggBEEAIAYoAgBBAEEAQQBBAEGAEEEAELYBIQUgAiAEIAIoAgBBAEEAIANBCGsgBSADQQRqEIICNgIADK0BCyADQgA3AhAMrAELIARBACADQQRqIgJBABDAASIFRSAELQDQAUECSXJFBEAgBCAFKAIQIAIQ8gEaCyACIAU2AgAMqwELIARBACADQRRrIgUgA0EEaiIGEMABIgJFIAQtANABQQJJckUEQCAEIAIoAhAgBhDyARoLIAUgAjYCAAyqAQsgAyAEQQAgA0EEakEAEMABNgIEDKkBCyADQRRrIgIgBEEAIAIgA0EEahDAATYCAAyoAQsgA0EsayICIARBACACIANBFGsQwAEiBTYCACAFRQ2nASAEKAIAIANBBGoQdCEFIAIoAgAgBTYCFAynAQsgA0EUayICIARBACACQQAQwAEiBTYCACAFRQ2mASAEKAIAIANBBGoQdCEFIAIoAgAgBTYCFAymAQsgA0EBNgIEDKUBCyADQQhrIgIgBCACQQBBABDxBTYCAAykAQsgA0EUayICIAQgAiADQQhrQQAQ8QU2AgAMowELIANBIGsiAiAEIAIgA0EUayADQQhrEPEFNgIADKIBCyADQQxrIgJBADYCCCACIAMoAgQ2AgQMoQELIANBJGsiAkEANgIEIAIgA0EIaygCADYCCAygAQsgA0IANwIQDJ8BCyADQRRrIAMpAgQ3AgAMngELIANBCGtCgICAgBA3AgAMnQELIANBFGsgAygCBDYCAAycAQsgA0EsayICIAQgAigCACADQRRrKAIAEDsiAjYCACACIANBCGsoAgAgAygCBBDwBQybAQsgA0EUayICIARBACACKAIAEDsiAjYCACACIANBCGsoAgAgAygCBBDwBQyaAQsgA0EANgIEDJkBCyADQQE2AgQMmAELIANBfzYCEAyXAQsgA0EIa0EANgIADJYBCyADQQhrQQE2AgAMlQELIANBADYCEAyUAQsgA0EIayADKAIENgIADJMBCyADQQhrIARBlAEgAygCBEEAEDU2AgAMkgELIANBIGsgBEGUASADQRRrKAIAIAMoAgQQNTYCAAyRAQsgA0EgayAEQZQBIAMoAgQgA0EUaygCABA1NgIADJABCyAEIANBFGsiAigCACADQQhrEPIFIAQgAigCACADKAIEEO8FDI8BCyAEIAMoAgQQzQQgA0EIa0EANgIADI4BCyAEIAMoAgQQzQQgA0EgayADQRRrKAIANgIADI0BCyAEIANBOGsiAigCACADQSxrEPIFIAQgA0EUayIGKAIAQaMREIUIAkAgA0EIaygCACIFRQRAIAIoAgAhBQwBCyAFKAIAQQJOBEAgBEEAIAVBAEEAQQBBAEGAEEEAELYBIQUgDUIANwOQASAEQQBBAEEAIA1BkAFqIAVBABCCAiEFCyACIAQgAigCACAFEIQIIgU2AgALIAQgBSAGKAIAIAMoAgQgA0HEAGsoAgBBABDuBQyMAQsgA0EsayICIAQgAigCACADKAIEEDsiAjYCACAEIAIgA0EUa0EBEOYCDIsBCyADQcQAayICIAQgAigCACADQSBrKAIAIAMoAgQQgwg2AgAMigELIAQgBEEAIAMoAgQQOyICIANBFGsiBUEBEOYCIAUgAjYCAAyJAQsgA0EsayAEQQAgA0EgaygCACADKAIEEIMINgIADIgBCyAEIANBIGsoAgAgA0EIaygCACADQRRrKAIAIANBOGsoAgAgAygCBBDtBQyHAQsgBCADQSxrKAIAQQAgA0EgaygCACADQcQAaygCAEEAEO0FDIYBCyADQQA2AhAMhQELIANBCGtBADYCACAEIAMoAgQQzQQMhAELIANBgAFrIAQoAgAgA0HcAGsoAgAgA0HEAGsoAgAgA0EUaygCACADQQhrKAIAIAMoAgQQ6wM2AgAMgwELIANB3ABrIAQoAgAgA0E4aygCACADQSBrKAIAQQBBACADKAIEEOsDNgIADIIBCyADQSxrIAQoAgBBAEEAQQBBAEEAEOsDNgIADIEBCyADQdAAayAEKAIAQQBBACADQRRrKAIAIANBCGsoAgBBABDrAzYCAAyAAQsgBCADKAIEEM0EDH8LIANBADYCEAx+CyADQRRrIANBCGsoAgA2AgAMfQsgA0EUayICIAQgAigCACADQQRqEOwFNgIADHwLIAMgBEEAIANBBGoQ7AU2AgQMewsgA0EUayADQQhrKAIANgIADHoLIA0gAykCBDcDQCADIARBOyANQUBrEIMCNgIEDHkLIA0gA0EUayICKQIANwNQIARBOyANQdAAahCDAiEFIA0gAykCBDcDSCACIARBjQEgBSAEQTsgDUHIAGoQgwIQNTYCAAx4CyANIANBLGsiBSkCADcDaCAEQTsgDUHoAGoQgwIhAiANIANBFGspAgA3A2AgBEE7IA1B4ABqEIMCIQYgDSADKQIENwNYIARBjQEgBiAEQTsgDUHYAGoQgwIQNSEGIAQtANABQQJPBEAgBEEAIAIQowELIAUgBEGNASACIAYQNTYCAAx3CyADLwECIQIgDSADKQIENwNwIAMgBCACIA1B8ABqEIMCNgIEDHYLIAQoAgBBmwEgA0EEakEBEHkiAgRAIAIgAygCBCAEKALoAWs2AiQLIAMgAjYCBAx1CwJAIAMoAgQiAi0AAEEjRgRAIAItAAFBOmtBdUsNAQsgAygCCCEHIA0gAykCBDcDeCADIARBnAEgDUH4AGoQgwIiCTYCBCMAQRBrIgokAAJAIAlFDQAgBCgCACELAkACQCAJKAIIIgIwAAEiJFAEQCAEIAQvAcwBQQFqIgU7AcwBDAELAkACQCACLQAAQT9GBEAgB0ECRgR+ICRCMH0FIAJBAWogCkEIaiAHQQFrQQEQ9QJBAEchBiAKKQMICyIkQgBXIAZyICQgCygCnAEiBaxVcg0EICSnQRB0QRB1IgUgBC4BzAFMDQEgBCAFOwHMASAEKALgASEGDAILIAQoAuABIgYgAiAHEN4JIgVB//8DcQ0CIAQgBC8BzAFBAWoiBTsBzAEMAQsgBCgC4AEiBiAFEOAJDQELIAQCfyACIQggBUEQdEEQdSEQAkAgBiICIAsgAiAHQQRtQQNqIgysIAIEfiACKAIEIg4gDGoiDyACKAIAIgZMBEAgAiEGDAILIAasQgGGBUIKC3wiJEIChhC5ASIGRQ0BGgJ/IAIEQCAGKAIEDAELIAZBAjYCBEECCyEOIAYgJD4CACAMIA5qIQ8LIAYgDkECdGoiAiAQNgIAIAIgDDYCBCAGIA82AgQgAkEIaiAIIAcQJSAHakEAOgAAIAYLNgLgAQsgCSAFOwEgIAsoApwBIAVBEHRBEHVODQEgBEHTKkEAECYgBCgCACAJEPgCDAELIAogBTYCACAEQbf7ACAKECYgBCgCACAJEPgCCyAKQRBqJAAMdQsgDSADKQIEIiQ3A5ABIAQtABJFBEAgDSANQZABajYCgAEgBEGawgAgDUGAAWoQJiADQQA2AgQMdQsgAyAEQbABQQBBABA1IgI2AgQgAkUNdCAkp0EBaiACQRxqENACGgx0CyADQRRrIgIgBCACKAIAIANBBGpBARCCCDYCAAxzCyADQThrIAQoAgBBJCADQQhrQQEQeSICNgIAIAQoAgAgAiADQSBrKAIAQQAQgQgMcgsgA0EsayICIAQgA0EIaygCACACIANBFGsoAgAQngI2AgAMcQsgA0EgayICIARBACACQQAQngI2AgAMcAsgBCAEIANBFGsoAgAgA0E4ayICIANBIGsoAgAQngIiBSADKAIEEIAIIAIgBTYCAAxvCyAEIARBACADQSxrIgJBABCeAiIFIAMoAgQQgAggAiAFNgIADG4LIAMgBEEAIANBBGpBABCeAjYCBAxtCyAEIANBIGsoAgAgA0EIaygCABA7IQIgA0EsayIGIARBsQFBAEEAEDUiBTYCACAFBEAgBSACNgIUIAIoAgBFDW0gBigCACIFIAUoAgQgAigCCCgCBEGIhIACcXI2AgQMbQsgBCgCACACEDkMbAsgA0EUayICIAQgAigCACADKAIEENIBNgIADGsLIANBFGsiAiAEIANBCmsvAQAgAigCACADKAIEEDU2AgAMagsgA0EMayICIAMpAgQiJDcCBCACICRCIIinQYCAgIB4cjYCCAxpCyADQQRrIgIgAigCACIGQf////8HcTYCACADQRRrIgIgBCAEIARBACADKAIEEDsgAigCABA7IANBCGtBABCeAiIFNgIAIAZBAEgEQCACIARBEyAFQQAQNSIFNgIACyAFRQ1oIAUgBSgCBEGAAnI2AgQMaAsgA0EcayICIAIoAgAiBkH/////B3E2AgAgA0EsayICIAQgBCAE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AyAFENQGCyAGQfABaiQAC0gBAn8CfyABQR9NBEAgACgCBCECIAAMAQsgAUEgayEBIABBBGoLKAIAIQMgACACIAF2NgIEIAAgAkEgIAFrdCADIAF2cjYCAAtCAQJ/AkAgAEUNAAJAIAAvARAiA0GCBHFBggRHDQAgAC0AEiABRw0AIAAoAggPCyADQQFxDQAgACABEO4JIQILIAILzAkCBH4EfyMAQfAAayIKJAAgBEL///////////8AgyEFAkACQCABUCIJIAJC////////////AIMiBkKAgICAgIDA//8AfUKAgICAgIDAgIB/VCAGUBtFBEAgA0IAUiAFQoCAgICAgMD//wB9IghCgICAgICAwICAf1YgCEKAgICAgIDAgIB/URsNAQsgCSAGQoCAgICAgMD//wBUIAZCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhBCABIQMMAgsgA1AgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQQMAgsgASAGQoCAgICAgMD//wCFhFAEQEKAgICAgIDg//8AIAIgASADhSACIASFQoCAgICAgICAgH+FhFAiCRshBEIAIAEgCRshAwwCCyADIAVCgICAgICAwP//AIWEUA0BIAEgBoRQBEAgAyAFhEIAUg0CIAEgA4MhAyACIASDIQQMAgsgAyAFhFBFDQAgASEDIAIhBAwBCyADIAEgASADVCAFIAZWIAUgBlEbIgwbIQUgBCACIAwbIghC////////P4MhBiACIAQgDBsiB0IwiKdB//8BcSELIAhCMIinQf//AXEiCUUEQCAKQeAAaiAFIAYgBSAGIAZQIgkbeSAJQQZ0rXynIglBD2sQqQEgCikDaCEGIAopA2AhBUEQIAlrIQkLIAEgAyAMGyEDIAdC////////P4MhBCALRQRAIApB0ABqIAMgBCADIAQgBFAiCxt5IAtBBnStfKciC0EPaxCpAUEQIAtrIQsgCikDWCEEIAopA1AhAwsgBEIDhiADQj2IhEKAgICAgICABIQhAiAGQgOGIAVCPYiEIQQgA0IDhiEBIAcgCIUhAwJAIAkgC0YNACAJIAtrIgtB/wBLBEBCACECQgEhAQwBCyAKQUBrIAEgAkGAASALaxCpASAKQTBqIAEgAiALEP8CIAopAzAgCikD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KAIAIgE2AgwgASADNgIIIAIgAzYCCCADIgIoAgghAwsgAkEANgIICyAEQQFqIQQMAAsACwNAIAMEQCADKAIIIQEgAxAjIAEhAwwBCwsgCCECCyAJECMMAwUgBCgCDCEEDAELAAsACyAKQQJHDQIgBiACKAIMIgg2AgggBiACKAIQIgM2AgQgAkIANwIMIAhBADYCCCADQQA2AggCQCAGQQhqIAFBAWsiARCbBSIFBH8gAwUgBkEEaiABEJsFIgVFDQEgBigCBAsQjgIgBigCCBCOAgwBCyACIAYoAggiATYCDCABIAI2AgggAiAGKAIEIgE2AhAgASACNgIIQQAhBQsgBQ0AQQAhBQwBCyACEI4CQQAhAgsgACACNgIAIAZBEGokACAFC+ABAQN/IwBBEGsiAyQAAkACQANAIAENASAAKAKAAiACSgRAQQAgACAAKAKYAiACQX8Q9QYiASABQeUARhshASACQQFqIQIMAQsLIAAQpARBACEBIAAtAO0BRQ0BIAAoAjBB/wFHDQEgACgCNEUNAUEAIQIgA0EANgIMIABBFiADQQxqQQAQUiIBDQEgAygCDCIBQQFBAhB1GgJAAkACQCABEENB5ABrDgIAAQILQQggAUEAEL8BIgIgAkEBRhshAgsgACACNgIwCyABEDohAQwBCyAAEKQECyADQRBqJAAgAQuYAQEDfyABLQAHRQRAQQAPCwJAAkAgARDCCiICDQAgASgCACIDIAMoAjhBAWo2AjggASgCDEEBIAEpAyAQWBogAUEAOgAHIAEoAgwQQyECIAMgAygCOEEBazYCOCACQeQARg0BIAEoAgwQOiICDQAgASgCACgCKA0BIAFBAToABkGLAiECCyAABEAgACACENgBCyACIQQLIAQLGQAgACABIAIQ1AoiAEUEQEEADwsgACgCCAuEBAICfwR+IwBBEGsiByQAIAcgAygCACIINgIMAkAgCEUEQEIBIQlCf0IBIAAbIQsgASACaiECQQAhAANAIAEgAkkEQCAHIAEgBxClASABaiIANgIIIAcpAwAhDEEAIAdBCGoQ6gEgCSAMfiAKfCEKIAcoAgghAQNAAkAgASACTw0AIAEtAAANACABQQFqIQEMAQsLIAcgATYCCCALIQkMAQsLIAUgAiAAazYCACADIAA2AgAgBCAKNwMADAELIwBBEGsiCCQA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hUKAgICAgICAgIB/gyENIARCMIinQf//AXEhCAJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAhB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiDEKAgICAgIDA//8AVCAMQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQ0MAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhDSADIQEMAgsgASAMQoCAgICAgMD//wCFhFAEQCADIAJCgICAgICAwP//AIWEUARAQgAhAUKAgICAgIDg//8AIQ0MAwsgDUKAgICAgIDA//8AhCENQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAQgAhAQwCCyABIAyEUARAQoCAgICAgOD//wAgDSACIAOEUBshDUIAIQEMAgsgAiADhFAEQCANQoCAgICAgMD//wCEIQ1CACEBDAILIAxC////////P1gEQCAFQcACaiABIAogASAKIApQIgYbeSAGQQZ0rXynIgZBD2sQqQFBECAGayEGIAUpA8gCIQogBSkDwAIhAQsgAkL///////8/Vg0AIAVBsAJqIAMgCyADIAsgC1AiBxt5IAdBBnStfKciB0EPaxCpASAGIAdqQRBrIQYgBSkDuAIhCyAFKQOwAiEDCyAFQaACaiALQoCAgICAgMAAhCISQg+GIANCMYiEIgJCAEKAgICAsOa8gvUAIAJ9IgRCABCkASAFQZACakIAIAUpA6gCfUIAIARCABCkASAFQYACaiAFKQOYAkIBhiAFKQOQAkI/iIQiBEIAIAJCABCkASAFQfABaiAEQgBCACAFKQOIAn1CABCkASAFQeABaiAFKQP4AUIBhiAFKQPwAUI/iIQiBEIAIAJCABCkASAFQdABaiAEQgBCACAFKQPoAX1CABCkASAFQcABaiAFKQPYAUIBhiAFKQPQAUI/iIQiBEIAIAJCABCkASAFQbABaiAEQgBCACAFKQPIAX1CABCkASAFQaABaiACQgAgBSkDuAFCAYYgBSkDsAFCP4iEQgF9IgJCABCkASAFQZABaiADQg+GQgAgAkIAEKQBIAVB8ABqIAJCAEIAIAUpA6gBIAUpA6ABIgwgBSkDmAF8IgQgDFStfCAEQgFWrXx9QgAQpAEgBUGAAWpCASAEfUIAIAJCABCkASAGIAkgCGtqIQYCfyAFKQNwIhNCAYYiDiAFKQOIASIPQgGGIAUpA4ABQj+IhHwiEELn7AB9IhRCIIgiAiAKQoCAgICAgMAAhCIVQgGGIhZCIIgiBH4iESABQgGGIgxCIIgiCyAQIBRWrSAOIBBWrSAFKQN4QgGGIBNCP4iEIA9CP4h8fHxCAX0iE0IgiCIQfnwiDiARVK0gDiAOIBNC/////w+DIhMgAUI/iCIXIApCAYaEQv////8PgyIKfnwiDlatfCAEIBB+fCAEIBN+IhEgCiAQfnwiDyARVK1CIIYgD0IgiIR8IA4gDiAPQiCGfCIOVq18IA4gDiAUQv////8PgyIUIAp+IhEgAiALfnwiDyARVK0gDyAPIBMgDEL+////D4MiEX58Ig9WrXx8Ig5WrXwgDiAEIBR+IhggECARfnwiBCACIAp+fCIKIAsgE358IhBCIIggCiAQVq0gBCAYVK0gBCAKVq18fEIghoR8IgQgDlStfCAEIA8gAiARfiICIAsgFH58IgtCIIggAiALVq1CIIaEfCICIA9UrSACIBBCIIZ8IAJUrXx8IgIgBFStfCIEQv////////8AWARAIBYgF4QhFSAFQdAAaiACIAQgAyASEKQBIAFCMYYgBSkDWH0gBSkDUCIBQgBSrX0hCkIAIAF9IQsgBkH+/wBqDAELIAVB4ABqIARCP4YgAkIBiIQiAiAEQgGIIgQgAyASEKQBIAFCMIYgBSkDaH0gBSkDYCIMQgBSrX0hCkIAIAx9IQsgASEMIAZB//8AagsiBkH//wFOBEAgDUKAgICAgIDA//8AhCENQgAhAQwBCwJ+IAZBAEoEQCAKQgGGIAtCP4iEIQogBEL///////8/gyAGrUIwhoQhDCALQgGGDAELIAZBj39MBEBCACEBDAILIAVBQGsgAiAEQQEgBmsQ/wIgBUEwaiAMIBUgBkHwAGoQqQEgBUEgaiADIBIgBSkDQCICIAUpA0giDBCkASAFKQM4IAUpAyhCAYYgBSkDICIBQj+IhH0gBSkDMCIEIAFCAYYiAVStfSEKIAQgAX0LIQQgBUEQaiADIBJCA0IAEKQBIAUgAyASQgVCABCkASAMIAIgAiADIAJCAYMiASAEfCIDVCAKIAEgA1atfCIBIBJWIAEgElEbrXwiAlatfCIEIAIgAiAEQoCAgICAgMD//wBUIAMgBSkDEFYgASAFKQMYIgRWIAEgBFEbca18IgJWrXwiBCACIARCgICAgICAwP//AFQgAyAFKQMAViABIAUpAwgiA1YgASADURtxrXwiASACVK18IA2EIQ0LIAAgATcDACAAIA03AwggBUHQAmokAAvbAQIBfwJ+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNACAAIAKEIAUgBoSEUARAQQAPCyABIAODQgBZBEBBfyEEIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPC0F/IQQgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAECzUAIAAtABFBkAFxBEAgABCHBQsgACgCGARAIAAoAhQgACgCIBBeIABBADYCGAsgAEEANgIIC5gEAwN8An4CfwJ8AkAgAL0iBEI0iKdB/w9xIgZByQdrQT9JBEAgBiEHDAELIAZByAdNBEAgAEQAAAAAAADwP6APCyAGQYkISQ0ARAAAAAAAAAAAIARCgICAgICAgHhRDQEaIAZB/w9GBEAgAEQAAAAAAADwP6APCyAEQgBTBEBEAAAAAAAAABAQ/wkPC0QAAAAAAAAAcBD/CQ8LQYC3AysDACAAokGItwMrAwAiAaAiAiABoSIBQZi3AysDAKIgAUGQtwMrAwCiIACgoCIBIAGiIgAgAKIgAUG4twMrAwCiQbC3AysDAKCiIAAgAUGotwMrAwCiQaC3AysDAKCiIAK9IgWnQQR0QfAPcSIGQfC3A2orAwAgAaCgoCEAIAZB+LcDaikDACAFQi2GfCEEIAdFBEACfCAFQoCAgIAIg1AEQCAEQoCAgICAgICIP32/IgEgAKIgAaBEAAAAAAAAAH+iDAELIwBBEGshByAEQoCAgICAgIDwP3y/IgIgAKIiASACoCIDRAAAAAAAAPA/YwR8IAdCgICAgICAgAg3AwggByAHKwMIRAAAAAAAABAAojkDCEQAAAAAAAAAACADRAAAAAAAAPA/oCIAIAEgAiADoaAgA0QAAAAAAADwPyAAoaCgoEQAAAAAAADwv6AiACAARAAAAAAAAAAAYRsFIAMLRAAAAAAAABAAogsPCyAEvyIBIACiIAGgCws0AQF/IAAEQCAAKAIIEPgBIAAoAgAiAQRAIAEQ4AYLIAAoAgQiAQRAIAEQ4AYLIAAQ+AELC38CAn8CfgJAIABBABBHIgFFDQAgASgCOCICRQ0AIAFBADYCPCACQaMDIAEQgwogASgCOBCCCiABKAI4EPgBIAEpAzBQBEAgASkDACEDIAEpAygiBEIBUQRAIAAgAxBjDwsgACADuSAEuaMQXA8LIAAgASsDCCABKQMouaMQXAsLOAECfwNAAkAgAEF/Rg0AIAAtAAAiAkUNACABQQFqIQEgAkGwtANqLQAAIABqQQFqIQAMAQsLIAELgwEBA38gACgCJCECIAAoAgAhAQJAIAAoAnwEQCABIAEtAFhBAWo6AFgQuwEgASgCoAIiA0UEQCABIAEQ4wIiAzYCoAILIAMgACgCfEF/EMYFELoBIAEgAS0AWEEBazoAWAwBCyABKAKgAiIARQ0AIAAQYgsgAUF/NgJEIAEgAjYCQCACC7gBAQN/IAAoAgghAyAAKAIQIAFBAnRqIAI2AgACQAJAAkAgAyABQQxsaiIDLQAAQQZrDgIAAQILQQEhAgNAIAIgAygCBEsNAiAAIAEgAmogARDkBiADIAJBDGxqENwBIAJqIQIMAAsACyADQQxqIQRBASECA0AgAiADKAIESw0BIAAoAhAgASACaiIFQQJ0aiABNgIAIAAgBUEBaiABEOQGIAQgAkEMbGoQ3AEgAmpBAWohAgwACwALC4cBAgJ/AXwjAEEQayICJAACQAJAIAAoAgBBAkgNACAAKAJIIgNFDQAgACABIAMRAAAhAAwBCyAAIAJBCGogACgCQBEAACEAIAECfiACKwMIRAAAAABwmZRBoiIEmUQAAAAAAADgQ2MEQCAEsAwBC0KAgICAgICAgIB/CzcDAAsgAkEQaiQAIAALaQIBfwF+IwBBEGsiBCQAAkAgASkDCCABKQMQIACsfFgEQCABIAAQygMNAQsgBCADNgIMIAAgASgCBCABKAIQaiACIAMQgwkaIAEgASgCBCABKQMQIgWnahA9rCAFfDcDEAsgBEEQaiQAC48BAQJ/IwBBEGsiAyQAAkAgAkUEQCABQSQQgwEMAQsgACABIAAoAjAgAkECdGooAgAiBBDnBiAAKAIoIgAgBEEMbGoiBC0AAEEGRgRAIAMgBCgCCDYCAEEeIAFBnYoBIAMQ5gYMAQsgASAAIAJBDGxqIgAtAAFBBnZBAXFBDGwgAGpBDGsQiQoLIANBEGokAAtJAQF/IAAoAggiAQRAIAEgACgCACgCDCgCEBEBABogAEEANgIICyAAKAIEECMgAEIANwIMIABBADYCBCAAQgA3AhQgAEIANwIcCzMBAX8gASABKAIIQQFrIgI2AgggAkUEQCABKAIQIgIEQCABKAIMIAIRAwALIAAgARAnCwsrAQF/IAEoAhQiAgRAIAIgAigCHEGAgAFyNgIcIAAgAhDTASABQQA2AhQLC5sBAgR/AX4jAEEQayIGJAACQCABKAIAIgVFBEAgACABEK0KIgANASABKAIAIQULQYsCIQAgBUEAEMkBIQcgBUEAEIwCIgFFDQAgByABIAEgB2oiBSAGQQhqEJoFIghIIAYpAwgiCUIAV3INACACIAk3AwAgAwRAIAMgASAIajYCAAtBACEAIARFDQAgBCAFNgIACyAGQRBqJAAgAAt4AQF/QQEhAgJAAkACQAJAAkACQAJAIAFB7ABrDggBBAUEBQQEAQALIAFB4QBrDgMAAQQCCyAAKAIEDwsgACgCCCAAKAIEQR9qQSBtbA8LIAFB+QBGDQILIAAoAgQgACgCCGxBA2whAgsgAg8LIAAoAgggACgCBGwLhgECAn8CfiMAQRBrIgMkACADIAAoAgAiBDYCDAJAIARFDQAgAyABKQMAIgU3AwAgAqwhBgNAIAMoAgwhAgJAIAUgBlMEQCACLQAAQQJPDQFCfyEFQQAhAgsgASAFNwMAIAAgAjYCAAwCCyADQQxqIAMQoAQgAykDACEFDAALAAsgA0EQaiQACwkAIAAoAhgQIwtRACAAQQhqQQBBKBAoGiAAIAI2AgQgACABNgIAIAFFBEAgAEEBNgIIQQAPCyAAIAEtAAAEfyABQQFqIABBEGoQpQFBAWoFQQELNgIIIAAQlgULawAgAqwgBHwgBEIDhnwiBCADrHwgBEIDhnwiBCAFrHwgBEIDhnwiBCAGrHwgBEIDhnwhBEEAIQIgAUEAIAFBAEobIQEDQCABIAJGRQRAIAAgAmowAAAgBEIJfnwhBCACQQFqIQIMAQsLIAQLuAEBAn8jAEEgayIJJAACQCAAQQsgCUEcakEAEFIiCg0AIAkoAhwiAEEBIAEQWBogAEECIAIQdRogAEEDIAMQWBogAEEEIAQQWBoCQCAGUARAIABBBSAFEFgaDAELIAkgBjcDCCAJIAU3AwBB0O4AIAkQSiICRQRAQQchCgwCCyAAQQUgAkF/QQMQ4QkaCyAAQQYgByAIQQAQ0QIaIAAQQxogABA6IQogAEEGEPoCGgsgCUEgaiQAIAoLnwQCCH8CfiMAQRBrIgYkAAJAAkACQAJAAkAgASgCACIFRQRAIAAoAugBIQgMAQsgBSgCICEEIAMgBSgCECIJIAUoAhQgAiADEKEEIgprIgdBAEwEQEGLAiEDDAULIAqsIgwQzQEgBCAHamogB60iDRDNAWoiCyAAKALoASIISgR/IAkNASAFIAsQVyIANgIkIABFDQIgBSgCEAUgCQsEQCAFKAIkIARqIAwQbiAEaiEECyAFKAIkIARqIA0QbiAEaiIAIAUoAiRqIAIgCmogBxAlGiAFIAAgB2o2AiAgBSAFKAIMQQFqNgIMIAUoAhwhBCADIAUoAhhKBEAgBCADQQF0IgAQ5QEiBEUNAiAFIAQ2AhwgBSAANgIYCyAFIAQ2AhAgBCACIAMQJRogBSADNgIUQQAhAwwECyAGIAhBKGoQVyIENgIMIARFDQAgBEIANwIAIARBCzYCICAEQgA3AhggBEIANwIQIARCADcCCCAEIARBKGo2AiQgBUUNASAGIAUoAgA2AgggACAGQQhqIAIgAxDyBiEDIAYoAgghACAFKAIARQRAIAUgADYCAAsgBSAENgIEIAUoAgghAiAEIAA2AgAgBCACNgIIIAQgBSgCHDYCHCAEIAUoAhg2AhggBUEANgIcDAILQQchAwwCCyAEIAQ2AgggACAGQQxqIAIgAxDyBiEDIAYoAgwhBAsgASAENgIACyAGQRBqJAAgAwtLAQN/IAAoAgAhAQNAIAEsAAAiA0EwSCADQTlLciACQcqZs+YASnJFBEAgAUEBaiEBIAJBCmwgA2pBMGshAgwBCwsgACABNgIAIAILGwAgACgCLEUEQEEADwsgASAAKAIYQQFqEL8BC4QPAg1/Bn4jAEHgAGsiCCQAIAhBADYCXCAIQQA2AlggCEIANwMIAkAgACABIAIgA0EAQQBBAUEAIAhBEGoQyAMiBA0AIAgoAhQiBkUNACAIAn8CQCADQX9GDQAjAEEQayIFJAAgAEEPIAVBDGpBABBSIgRFBEAgBSgCDCIEQQEgACABIAJBABCRAhBYGiAEQQIgACABIAJB/wcQkQIQWBogBBBDQeQARgRAIAggBEEAEJkBNwMICyAEEDohBAsgBUEQaiQAIAQNAiADQX5HDQACQCAGQQFHDQAgCCgCECgCACgCOA0AQeUAIQQMAwsgCEIANwNQIAhCADcDSCAIKQMIIhUhEkEDDAELIAAgASACIANBAWoiCRCRAiESQQAhBSMAQRBrIgQkAAJAIABBCCAEQQxqQQAQUiIGDQAgBCgCDCIGQQEgACABIAIgCRCRAhBYGiAGEENB5ABGBEAgBkEAEL8BIQULIAYQOiIGDQBBACEGIAggBUEQTgR/IAAgASACIAkQ9QYhBkEABSAFCzYCXAsgBEEQaiQAIAYiBA0BIAhCADcDUCAIQgA3A0hBAUEBQQMgCCkDCCIVIBJZGyADQX9GGws2AlQgACAIQRBqIAhByABqEKUEIQQDQAJAAkACQCAEDQAgACAIQRBqEMcDIgRB5ABGDQEgBA0AIANBf0cEQCAIKAIQIQYgCCgCFCEJQQAhB0EAIQQjAEEQayIFJAAgBUEANgIMA0AgBCAHIAlOckUEQCAAIAYgB0ECdGooAgAQmgohBCAHQQFqIQcMAQsLAkAgBA0AAkAgA0F+RgRAIABBGiAFQQxqQQAQUiIEDQIgBSgCDCIHQQEgACABIAJBABCRAhBYGiAHQQIgACABIAJB/wcQkQIQWBoMAQsgAEEQIAVBDGpBABBSIgQNASAFKAIMIgdBASAAIAEgAiADEJECEFgaCyAHEEMaIAcQOiEECyAFQRBqJAAgBCAIKAJYIgdFcg0FDAMLIAgoAlgiBw0CQQAhB0EAIQQMBAsgCCgCWCEHDAMLIAgoAjghDCAIKAI8IQcgCCgCQCEPIAgoAkQhDSMAQRBrIg4kAAJAIAgoAlgiBkUEQEEHIQVBwAAQVyIGRQ0BIAggBkEAQcAAECgiBDYCWCAEIAAoAugBEFciCTYCMCAJRQ0BIAQgACgC6AE2AiggAEEKIA5BDGpBABBSIgUNASAOKAIMIgUQQ0HkAEYEQCAEIAVBABCZASIRNwMIIAQgETcDEAsgBRA6IgUNAQsgBigCLCEJQYsCIQUgByAGKAIYIAYoAhwgDCAHEKEEIgtrIgRBAEwNACALrBDNASEKIAStEM0BIAogDawiExDNASANaiIQIARqamohCgJAIAlBAEwNACAAKALoASAJIApqTg0AIAYpAxAiEUL///////////8AUQ0BIAYgEUIBfDcDECAAIBEgBigCMCAJENcCIgUNASAAIAAoAjRBAWo2AjQgACAGIAwgC0EBahDyBiIFDQFBACEJIAZBADYCHCAHrBDNASAHIBBqakEBaiEKIAchBEEAIQsLIAYgBikDOCAKrHw3AzggBigCMCEFAkAgBigCKCAKSARAIAUgChDlASIFRQ0BIAYgCjYCKCAGIAU2AjALIAUgCWogC6wQbiAJaiIFIAYoAjBqIASsEG4hCSAFIAlqIgUgBigCMGogCyAMaiAEECUaIAQgBWoiBCAGKAIwaiATEG4hBSAEIAVqIgQgBigCMGogDyANECUaIAYgBCANajYCLAJAIAcgBigCIEwEQCAGKAIYIQUMAQsgBigCJCAHQQF0IgQQ5QEiBUUNASAGIAU2AiQgBiAENgIgIAYgBTYCGAsgBSAMIAcQJRogBiAHNgIcQQAhBQwBC0EHIQULIA5BEGokACAFIQQMAQsLIAgoAlwhCSMAQRBrIgEkAAJAIAcoAgAEQCABQgA3AwggAUEANgIEIAFBADYCACAHIAcpAxAiFkIBfDcDECAAIBYgBygCMCAHKAIsENcCIgINASAHKAIAIQIgBykDCCEUIAcpAxAhEUEBIQYDQAJAIAIoAgBFBEAgAiAGIBQQlwohBCABIBFCAX03AwggASACKAIgIARrNgIAIAEgBCACKAIkajYCBEEAIQQMAQsgAkEIaiEKQQAhBCARIRMDQCAKKAIAIgVFIARyRQRAIAVBBGohCiAAIBMgBSAGIBQQlwoiBCAFKAIkaiAFKAIgIARrENcCIQQgFCAFKAIMQQFqrHwhFCATQgF8IRMMAQsLIAQNACAGQQFqIQYgAigCACECIBEhFCATIREMAQsLIAQiAg0BIAAgEiAJIAcpAwggFiABKQMIIAcpAzggASgCBCABKAIAEPEGIQIMAQsgACASIAlCAEIAQgAgBykDOCAHKAIwIAcoAiwQ8QYhAgsgACAAKAI0QQFqNgI0IAFBEGokACACIgQNACADQX9HBEBBACEEIBIgFVkNAQsgACASIAcpAzgQmwohBAsgBwRAIAcoAjAQIyAHKAIkECMgBygCABCYCiAHECMLIAhBEGoQiAMgCEHgAGokACAEC/QCAQh/IwBBIGsiBSQAIAVBADYCHCAFQQA2AhggBUEANgIUIAVBADYCDAJAIAJFBEAgBEEANgIADAELIAAoAiQiBigCACEJIAYgASACQX8gBUEIahDYAiIGDQAgCSgCFCELIAUoAgghCkEAIQFBACECA0ACQCACDQAgCiAFQRBqIAVBDGogBUEcaiAFQRhqIAVBFGogCxEJACICDQBBASECIAEgBSgCFCIHQQFqIAEgB0obIQEgB0EASA0AIAUoAhAiCEUNACAFKAIMIgxBAEwNAEEBIQYgACADIAcgACgChAJBBGogCCAMEJYKIQIDQCACDQIgBiAAKAKAAk4NAkEAIQIgACgChAIgBkEYbGoiBygCACIIIAUoAgxMBEAgACADIAUoAhQgB0EEaiAFKAIQIAgQlgohAgsgBkEBaiEGDAALAAsLIAogCSgCEBEBABogBCAEKAIAIAFqNgIAQQAgAiACQeUARhshBgsgBUEgaiQAIAYLbgIBfwF+AkACQAJAIAApA5ACIgUgA1UNACADIAVRBEAgACgCnAJFDQELIAAoApgCIAJHDQAgACgCjAIgACgCiAJMDQELIAAQnAUiBA0BCyAAIAE2ApwCIAAgAjYCmAIgACADNwOQAkEAIQQLIAQLlgUCDX8DfiMAQRBrIgUkACAFIAEoAgAiAjYCDCACRQRAAkAgACgCHEUNACAFQQAgABCdBSICNgIMIAINACMAQSBrIgMkAAJAIAAoAhxFDQAgAEEcaiEIIAAoAgAiCSgCJCIMKAIAIQsgACgCDEEAEJkBIREDQCAJNAIYIRAgBCECAkADQCAPIBBZIAJyDQEgCSgCICAPp2otAAAEQCAPQgF8IQ9BACECDAELCyAAKAIMIA9CAXwiEKcQiwIhAiADQQA2AhggDCAAKAIUIAJBfyADQRhqENgCIQQgAygCGCEKA0AgBEUEQCADQQA2AhAgA0EANgIMIANBADYCCCADQQA2AgQgAyAKIANBFGogA0EQaiADQQxqIANBCGogA0EEaiALKAIUEQkAIgQ2AhwgCCECA0AgAigCACICRSAEcg0CIAIoAgAhBkEAIQQCQCACKAIEIgcgCSgCGEggDyAHrVJxDQAgBigCDEEAIAMoAgQiDRsNACAGKAIEIgcgAygCECIORwRAIAYoAghFIAcgDk5yDQELIAMoAhQgBigCACAHEFENACACQQxqIBEgDyANrCADQRxqEKQKGiADKAIcIQQLIAJBCGohAgwACwALCyAKBEAgCiALKAIQEQEAGgsgBEHlAEYEQCADQQA2AhxBACEECyAQIQ8MAQsLA0AgCCgCACICRSAEcg0BIAIoAgwEfyACQQxqQgAQogQFQQALIQQgAkEIaiEIDAALAAsgA0EgaiQAIAUgBDYCDAsgACAAKAIQIAVBDGoQggMhBCAAQRxqIQADQCAAKAIAIgAEQCAAKAIMECMgAEEANgIMIABBCGohAAwBCwsgASAFKAIMIgI2AgAgBEUhBAsgBUEQaiQAIAJFIARxCzYBAX8gAUUEQEEADwsgACgCACICQQFqIAGsEG4hASACQQE6AAAgACACIAFBAWoiAGo2AgAgAAsXAQF/IAAgARDjASICRQRAIAAQIwsgAgu1AQEEfwJAAkAgAUUNACACKAIADQAgASgCAEEFRgRAIAEoAhQiBSgCQCIERQ0CIARBACAEQQBKGyEGA0ACQCABIAMgBkcEfyAFIANBGGxqKAJYDQEgAwUgBgsgBEY6ACIMBAsgA0EBaiEDDAALAAsgACABKAIMIAIQ+wYgACABKAIQIAIQ+wYgASABKAIMLQAiBH8gASgCEC0AIkEARwVBAAs6ACILDwsgAiAAQQEgBRCuCjYCAAsLACAAEIgDIAAQIwtDAQJ/IwBBEGsiAiQAIAEoAgwhAyACIAEpAxA3AwAgACADQZymASACEPsBIAAoAgBFBEAgAUEBOgDtAQsgAkEQaiQAC+0BAQV/A0AgACwAACEEQQAhAgJAA0AgAg0BAkACQAJAIARBIkYgBEEnRnINACAAIQIgBEHbAEYNASAEQeAARg0AIAQNAkEADwsgACECA0AgAiIDQQFqIQIgAy0AASIFRQ0DIAUgBEH/AXEiBkcNACADQQJqIQIgBiADLQACRg0ACwwCCwNAAkAgAiIDQQFqIQIgAy0AASIFQd0ARg0AIAUNAQsLIANBAmogAiAFGyECDAELIAQQ/wYEQANAIAIsAAEhAyACQQFqIQIgAxD/Bg0ADAILAAsLIABBAWohAAwBCwsgASACIABrNgIAIAALIQEBf0EBIQEgAEGAAXEEf0EBBSAAQdCqA2otAABBAEcLC54BAQJ/IAAtABEiAUEGRgRAIAAoAiwaDwsgAUECTwR/AkAgACgC6AEEQCAAQQJBfxCBCSIBIAAgAC0AFEEAEPsDIAEbIQIMAQsgACgCRCgCAEEAIAFBAkcbRQRAIABBAEEAEPsDIQIgAC0ADyABQQNJcg0BIABBBjoAESAAQQQ2AiwgABD1BA8LIABBABCACSECCyAAIAIQ/AMFQQALGguYAQECfyAALQAIBEAgACgCACIBKALcAUUEQCABIAAoAgwiATYC3AEgARA6GiAAQQA2AgwLIABBADoACAsgACgCDBCYARogACICKAIcIQADQCAABEAgACgCCCEBIAAoAgwQIyAAECMgASEADAELCyACQQA2AhwgAigCLBAjIAIoAlwQuQogAigCEBCOAiACQQRqQQBB3AAQKBoLcQEBfyAAKALcARCYARoDQCABQShGRQRAIAAgAUECdGooAjwQmAEaIAFBAWohAQwBCwsgACgC+AEQIyAAKALgARAjIAAoAuQBECMgACgCKBAjIAAoAiwQIyAAKAIkIgEgASgCACgCCBEBABogABAjQQALiwEBAn8jAEEQayIEJAAgACgCBCEDIAAQTAJAIAFFBEBBACECIANBAEEAENkCIgFFDQELIAAgASACEMAKGgsgAC0ACEECRgRAIAMoAgAQgAcgA0EBIARBDGpBABCsAUUEQCADIAQoAgwiARCzCiABEKMECyADQQE6ABQgAxDMCgsgABDJCiAEQRBqJAALKAAgAC0ABUUEQCAAKAIoECMgACgCNBD/BCAAQQA2AjQLIABBADYCKAunBgIKfwJ+IwBBEGsiByQAAn8gAywAACILQQBIBEAgAyAHQQxqEHMaIAcoAgwMAQsgC0H/AXELIQ8gASEOIAIhDSAFIQsgBiEMIwBBEGsiCSQAQYsCIQgCQCADIAlBCGoiARCEAyADaiICIAEQhAMgAmoiCiADIARqIhBLDQBBACECQQAhBEEAIQEDQAJAAkAgCiAQSQRAIAsgDHJFBEBBACEIDAILQQAhCCAJQQA2AgACQAJ/IARBAXEEQAJAIAosAAAiBEEASARAIAogCRBzIQQgCSgCACEIDAELIAkgBEH/AXEiCDYCAEEBIQQLIAEgCEgNAiAEIApqIQoLIAosAAAiAUEASARAIAogCUEEahBzDAELIAkgAUH/AXE2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EWtBFG1BAWo2AiBB5AAhFgyZAQsgDCAFKAIMIgFBKGxqIQsgDCAFKAIEIg5BKGxqIgYvARAiAiAMIAUoAggiCUEobGoiAy8BEHJBAXEEQCALEGIMnQELAkACQCACQRJxRQRAIAYgEkEAEKYDRQ0BDKEBCyACQYAIcUUNASAGEOcBDaABCyAGLwEQQX1xIQILAkACQCADLwEQIg1BEnFFBEAgAyASQQAQpgNFDQEMoQELIA1BgAhxRQ0BIAMQ5wENoAELIAMvARBBfXEhDQsgDCAJQShsaiIPKAIMIAwgDkEobGoiECgCDGoiCiAHKAJ4Sg2NASALIApBAmogASAJRiILEL8DDZ4BIAwgAUEobGoiASABLwEQQcDkA3FBAnI7ARAgC0UEQCABKAIIIAwgCUEobGooAgggDygCDBAlGiADIA07ARALIAEoAgggDygCDGogDCAOQShsaigCCCAQKAIMECUaIAYgAjsBECAKQX5xIAogEkEBSxsiAiABKAIIakEAOgAAIAIgASgCCGpBADoAASABIAEvARBBgARyOwEQIAEgEjoAEiABIAI2AgwMnAELIAwgBSgCBEEobGoiARDcCCEDIAwgBSgCCEEobGoiAhDcCCEKIAwgBSgCDCIJQShsaiEGAkACQCADIApxQQRxBEAgASkDACEqIAggAikDACIrNwOoAgJAAkACQAJAAkACQCAFLQAAQeoAaw4EAAECAwQLIAhBqAJqICoQ4QRFDQQMBgsCfyAIQagCaiEDAn8gKkKAgICAgICAgIB/UQRAQQEgAykDACIqQgBZDQEaIAMgKkKAgICAgICAgIB/hTcDAEEADAILIANCACAqfRDhBAsLRQ0DDAULIAgpA6gCISsCQAJAICpCAFUEQEEBIQMgK0L///////////8AICqAVQ0CICtCAEKAgICAgICAgIB/ICqAfVkNAQwCCyAqQgBZDQAgK0IAVQRAQQEhA0IAQoCAgICAgICAgH8gK4B9ICpYDQEMAgsgK0IAWQ0AQQEhAyAqQoCAgICAgICAgH9RICtCgICAgICAgICAf1FyDQFCACArfUL///////////8AQgAgKn2AVg0BCyAIICogK343A6gCQQAhAwsgA0UNAgwECyAqUA0EICpCf1EgK0KAgICAgICAgIB/UXENAyAIICsgKn83A6gCDAELICpQDQMg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bkEBaiADRwR/IBsgAyAKQQxqQQIQpwEiAkUEQCABIAMgCigCDCgCBEEAEM0LIQIgCigCDBCmAQsgASgCEAUgAwtBAWo2AhAgGUEBaiEZDAELCwJAAkAgAkHlAEYNACACDQEgASANNgIkIAEgDSABKAIQIgJrQQFqNgIgIAIgDUsNAEEAIQIgASgCKA0BIAEgASgCGBCOARCACyIDKAIANgIsIAMgATYCACABQQE2AigMAQsCQCANDQBBASENIAEoAgQiAhBMIAIoAgQiAkEANgIwIAIQoAciAkHlAEYNACACDQELIAEoAgRBASABKAIIQQFqELUEIgINACABKAIAIgIEQCACELICCyAdQQVGBEAgASgCBEECEMILIgINAQsCQCAVIBpIBEBBkPkDKAIAIQIgASgCBCgCBCgCJCEDIBMoAkAhGSATIApBDGoQtQcgDSAaIBVtIh1qQQFrIB1tIh0gHSACIANuQQFqRmshAyANrCEqIAooAgwhDUEAIQIDQCACIAMgDUtyRQRAQQAhAgJAIANBkPkDKAIAIAEoAgQoAgQoAiRuQQFqRg0AIBMgAyAKQQhqQQAQpwEiAg0AIAooAggQXSECIAooAggQpgELIANBAWohAwwBCwsgKiAVrCIsfiErIAJFBEAgE0EAQQEQsQchAgsgK0GQ+QMoAgAiAyAaaqwiKiAqICtVGyEyIAMgFWqsISoDQCACICogMllyRQRAIApBADYCCCAbICogLH+nQQFqIApBCGpBABCnASICRQRAIBkgCigCCCgCBCAVICoQeiECCyAKKAIIEKYBICogLHwhKgwBCwsgAg0BIwBBEGsiAiQAAkAgGSACQQhqELwBIgMNAEEAIQMgAikDCCArVw0AIBkgKxCSAiEDCyACQRBqJAAgAyICDQEgE0EAEK4HIQIMAQsgEyAVIBptIA1sEKYLIBNBAEEAELEHIQILIAINACABKAIEQQAQrwQiAkHlACACGyECCyAcRQRAIAEoAhhBABCxBRogASgCGEEAEK8EGgsgAUEHIAIgAkGKGEYbNgIcCyAKQRBqJAAgAQR/IAEoAhQhAyABKAIYEEwgASgCAARAIAEoAhgiAiACKAIQQQFrNgIQCyABKAIoBEAgASgCGBCOARCACyEKA0AgCiICKAIAIg1BLGohCiABIA1HDQALIAIgASgCLDYCAAsg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QCAGQQFqIANBIGoQcxogAygCIAwBCyAEQf8BcQsiBEUNAQtB/////wchBQJAIAMoAiQiBy0AAA4CAwACCwJ/IAcsAAEiBUEASARAIAdBAWogA0EcahBzGiADKAIcDAELIAVB/wFxCyIFDQILQYsCIQUMBgtBACEFCyAEIAVHDQIgA0IANwMQIANCADcDCCADQgA3AwAgAyAHIANBLGogBBD5BiIEajYCJCADIAQgBmo2AiggA0EoaiADQRBqEMQDIANBJGogA0EIahDEAyADKQMQIghCAlkEQCADKQMIIglCAVUNAgsgAygCJCEEIAMoAighBgsgAyADKAIsIgdBAWo2AixBACEFIAdBADoAACAAIAMoAiw2AgAgASAGQQFqNgIAIAIgBEEBajYCAAwDCwNAIANBLGogAyAIIAkgCCAJUxsQqgogAyADKQMAQgJ9NwMAAkAgCCAJUQRAIANBKGogA0EQahCYBSADQSRqIANBCGoQmAUMAQsgCCAJUwRAIANBKGogA0EQahCYBQwBCyADQSRqIANBCGoQmAULIAMpAxAiCEL///////////8AUiADKQMIIglC////////////AFJyDQALDAELIAQgBUgEQCADIANBLGoiBSAEEPkGIAZqNgIoIAUgA0EoahCwAgwBCyADIANBLGoiBCAFEPkGIAdqNgIkIAQgA0EkahCwAgsgAygCKCEGDAELCyADQTBqJAAgBQvxAwIDfwJ+IwBBMGsiByQAIAdCADcDKCAHQgA3AyAgB0IANwMYIAcgATYCFCAHIAM2AhAgB0EANgIIIAVBADYCACAGQQA2AgACQCACrCAErHxCEXwQSyIIRQRAQQchAQwBCyAHIAg2AgwgB0EUaiABIAJqIgJBACAHQShqEOkBIAdBEGogAyAEaiIDQQAgB0EgahDpAQJAAkADQCAHKAIUIgEgBygCECIEckUNAQJAQQBBAUF/QQAgBykDKCIKIAcpAyAiC1IbIAogC1UbIglrIAkgABsiCSAERSABRXJyRQRAIAdBDGoiASAAIAdBGGogB0EIaiAKEJkFIAEgB0EUaiAHQRBqEKsKIgENASAHQRRqIAIgACAHQShqEOkBIAdBEGogAyAAIAdBIGoQ6QEMAgtBACAEIAFBAEcgCUEASHEbRQRAIAdBDGoiASAAIAdBGGogB0EIaiAKEJkF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AzYCHEEBIQQLIAEgAzYCACACIARB9sAAQQAgAxsgARDeASACIAEoAhwQJyACIAQQogEhAiABQSBqJAAgAiEBIAYQIyAAIAFFOgDtAUEACyEAIAVBEGokACAAC5oBAQV/AkADQCAARQ0BIAAQTCAAKAIEQQhqIQQDQCAEKAIAIgMEQAJAAkAgAkUNACADLQABQQFxDQACQCADLQAADgMAAgACCyADEO4IIgRFDQEgByAEIAUbIQdBACECIAQhAUEBIQUMBAsgAxDkBCADIAE2AgQgA0EEOgAACyADEKwDIANBGGohBAwBCwsLIAdBACAFGyEGCyAGC7ICAgN/AX4gAC8BBEEBTQRAIAAoAgAiASABKAI4QQFqNgI4An8gACgCDBBDQeQARwRAIABBAToABiAAKAIMEDoMAQsgACAAKAIMQQAQmQE3AyBBAAshACABIAEoAjhBAWs2AjggAA8LIwBBEGsiASQAIAFBADYCDAJAAkAgACgCECICBEADQCAALQAHRQRAIAAoAgwQOhoLIAAgAiABQQxqEKsBIAItACAhAyAAQQE2AlggAEEBOgAHIAAgAzoABiAAIAIpAxg3AyAgA0UEQCAAIAFBDGoQ+AYNAQsLIAEoAgwiAg0CDAELIABBAToABgsgACkDICEEAkAgAC0ANEUEQEEAIQIgBCAAKQNQVQ0BDAILQQAhAiAEIAApA0hZDQELIABBAToABgsgAUEQaiQAIAILpwEBBH8jAEEQayIEJAACQCAAKAIMDQAgAEEMaiEBAkAgACgCACICKALcASIDBEAgASADNgIAIAJBADYC3AEMAQsgBCACKALgATYCAEGdowEgBBBKIgNFBEBBByEBDAILIAIgAigCOEEBajYCOCACKAIMIANBASABEMYGIQEgAiACKAI4QQFrNgI4IAMQIyABDQELIABBAToACEEAIQELIARBEGokACABCxwAAkAgAEUNACAAEPkCQQFHDQAgABBfIQELIAELhyECGX8BfiMAQYABayIIJAAgBCgCAC0AAyEXIAhBADYCbCAIQQA2AmggCEEANgJkIAQoAgQQPSEbIAQoAggQPSEMIAggA0ECdEEIayIJrSIgEEsiCjYCcAJAAkAgCkUNACAKQQAgCRAoIRMgIBBLIhVFDQAgG0EBaiEcIAxBAWohGCAVQQAgCRAoIRkgF0E0RyEa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QCACQf8DQfz6AygCABEAACICQQBIBEBBBSECQYSoBCgCACIBQRRGDQEgARD2BCIDQQVGDQEgACABEJsBIAMPCyAAIAE6ABALIAILGAAgAEEAEKIJGiAAKAIYECMgABC4BkEACwsAIAFBADYCAEEACwkAIAAQuAZBAAuPAQECfwJ/QbzwAy4BACIARQRAQYSoBEEcNgIAQX8MAQsCQAJAIABBfkoNAEHpoAwhAQJAAkACQAJAAkACQAJAIABB/wFxQQFrDgsIAAECAwQEBQUGAwcLQYCACAwIC0GAgAIMBwtBgIAEDAYLQf////8HDAULQQEMBAsQEEEQdgwDC0EADAILIAAhAQsgAQsLrwEBA38jAEGgBGsiAyQAIAMgADYCAEGABCADQRBqQfbAACADEMQBIgIQPSEAAkADQCAAQQBKBEAgACACaiEEIABBAWshACAELQAAQS9HDQEMAgsLIAItAABBL0cEQCACQS46AAALIAJBAWohBAtBACEAIARBADoAACABIAJBAEEAEKcDIgE2AgAgAUEASARAQZiyAhDiAUHZCCACQZiyAhDCASEACyADQaAEaiQAIAALdQEBfyMAQRBrIgMkACADIAI2AgAjAEEQayICJAAgAgJ+IAFBwABxRQRAQgAgAUGAgIQCcUGAgIQCRw0BGgsgAiADQQRqNgIMIAM1AgALNwMAQZx/IAAgAUGAgAJyIAIQFRB3IQAgAkEQaiQAIANBEGokACAACwQAQQALCwAgA0EANgIAQQALBgAgABBQC4YBAQV/AkAgACgCJCICRQ0AIAIoAgAiA0EgaiEEA0AgBCIFKAIAIgZBBGohBCACIAZHDQALIAUgAigCBDYCACACECMgAEEANgIkIAMgAygCHEEBayIENgIcIAQNAAJAIAFFDQAgAygCDEEASA0AIAMoAghB5PoDKAIAEQEAGgsgABClCQtBAAuPBAEIf0GKKCEEAkAgACgCJCIFRQ0AIAUoAgAiBkUNAEEBIAEgAmoiBHRBASABdCIKayEHIAZBJGohBgJAIANBAXEEQCAHIAUvAQoiCCAFLwEMIglycUUNASABIAQgASAEShshCyABIQRBASEDA0AgBCALRkUEQEEAIAMgBiAEQQJ0aigCACAIIAR2QQFxShshAyAEQQFqIQQMAQsLAkAgAwRAIABBAiABQfgAaiACEP8D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AwRAIAAtADQNASAAKAIAKAIIECNB/ZUBQQAQSiEBIAAoAgAgATYCCEEBQQcgARshAgwBCyAALQAVBEACfyAFIAUoAgBBAnStEEsiBjYCECAGRQRAIAVBAToAFEEHDAELIAVBAEEAEOQGQQALDQELAkAgAUEDRgRAQQAhAiADQQA2AgwgBCgCBBArIgFFDQMgACAEKAIEEGAiAqxCAXwQSyIENgIcIARFBEBBByECDAQLIAQgASACQQFqECUaAkACQCABLQAAQSRHBEAgAyABNgIMDAELQQAhAiAFQQAgACgCHEEBakEAIANBDGoQkwchBCADKAIMIgFFDQELIAAoAgAoAggQIyABEPAKIQEgACgCACABNgIIIAAQkQVBAUEHIAAoAgAoAggbIQIMBAsgBEUNAyAAKAIoIQIMAQsgACgCKCICIQQLIAAgBCACa0EMbSICNgIIIAAgAjYCDCAAIAQtAAAiAToAFCABQQZPBEBBACECIARBADYCCCAAIAAoAgwiBUEBaiIBIAQoAgRqNgIQIAAtABUEQCAAIAAoAigiBCAAKAIwIAVBAnRqKAIAQQxsai0AADoAFCAFRQ0DIAQgBUEBayIBQQxsai0AAUHAAHFFDQMgACABNgIMDAMLIAAgATYCDAwCCyAAIAJBAWo2AhBBACECDAELIAAQkQULIANBEGokACACCw0AIAAQkQUgABAjQQALkAIBB38jAEEQayIEQn83AgggASgCACIAQQAgAEEAShshByABKAIEIQADQCADIAdGRQRAAkAgACgCACIGQQhIDQBBASAGQQhrIgh0IQYgAC0ABUUEQCACIAZyIQIMAQsgAC0ABEECRw0AIARBCGogCEECdGogAzYCACAFIAZyIQULIABBDGohACADQQFqIQMMAQsLQRMhACACIAVBf3NxRQRAQQAhACABAn9BACAEKAIIIgJBAEgNABogAUKAgICAgICA+D83AyggASgCECIFIAJBA3RqIgJBAToABCACQQE2AgBBASAEKAIMIgRBAEgNABogBSAEQQN0aiIDQQE6AAQgA0ECNgIAQQMLNgIUCyAAC0AAIABBzMMBEIgEIgIEfyACBSAEQQwQVyIBNgIAIAFFBEBBBw8LIAFCADcCACABQQA2AgggAEECQQAQzQlBAAsLDgAgASAANAIMNwMAQQALYgACQAJAAkAC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ACEQDAILIAUgARCEAyAFaiEFIAEpAwAhECAALQDvAQRAIBIgEH0hEkIAIRAMAgsgECASfCESQgAhEAUgASgCQCABKAJEIAkgAyASIAEoAgggECAVfEICfSIQpxDwBiAUhSEUCwwACwALAAsgAUEYahCIAyAEIAU2AiwgAUHgAGokACATIBSFIRMgA0EBaiEDDAALAAsgAhA6IQMgAQRAIAEhAwwDCyADDQIgACgCJCgCACEKIARBADYCJCAEIAAoAuABNgIAAkBBrDUgBBBKIgFFBEBBByEDIARBBzYCLAwBCyAEIAAoAgwgAUF/IARBJGpBABCXAyIDNgIsIAEQIwsDQAJAIAMNACAEKAIkEENB5ABHDQBBACEDIAQoAiRBABCZASEQIAAgBCgCJBD0BiEJQQAhAQNAIAMNAiABIAAoAhhODQIgACgCICABai0AAARAIAFBAWohAUEAIQMMAQsgBCgCJCABQQFqIgIQiwIhAyAEQQA2AiAgACgCJCAJIANBfyAEQSBqENgCIQUgBCgCICEIA0AgBUUEQCAEQQA2AhggBEEANgIUIARBADYCECAEQQA2AgwgCCAEQRxqIARBGGogBEEUaiAEQRBqIARBDGogCigCFBEJACIFDQEgBCgCHCILIAQoAhgiDCAJQQAgECABIAQoAgwiDhDwBiARhSERQQEhAyAAKAKAAiINQQEgDUEBShshDQNAIAMgDUYNAiAMIAAoAoQCIANBGGxqKAIAIg9OBEAgCyAPIAkgAyAQIAEgDhDwBiARhSERCyADQQFqIQMMAAsACwsgCARAIAggCigCEBEBABoLQQAgBSAFQeUARhshAyACIQEMAAsACwsgBCgCJBCYARoMAgsgBCgCLCEBDAALAAsgBiARIBNRNgIMIARBMGokACADIQEgBigCDCECIAZBEGokACABQYsCIAEgAnIbDAILIAJBzKQBQQYQSEUEQCMAQRBrIgMkACADIAJBBmo2AgggA0EIahDzBiEGQQghAQJAIAMoAggiBC0AACIFQSxGBEBBASECIAQtAAFFDQEgAyAEQQFqNgIIIANBCGoQ8wYhASADKAIILQAAIQULQQEhAiAFIAFBAkhyDQAgA0EANgIMAkAgAC0A7QFFBEAgA0EMaiAAEP0GIAMoAgwiAg0BCyAAIAYgARC9CiECCyAAEJMCCyADQRBqJAAgAgwCC0EBIQEgA0ELSQ0AIAJByKQBQQoQSA0AIwBBEGsiASQAIAEgAkEKajYCDCABQQA2AgggAUEANgIEIABBCEEIIAFBDGoQ8wYiAiACQRBKGyACQQFGGzYCMAJAIAAtAO0BRQRAIAFBCGogABD9BiABKAIIIgINAQsgAEEXIAFBBGpBABBSIgINACABKAIEIgJBAUECEHUaIAJBAiAAKAIwEHUaIAIQQxogAhA6IQILIAFBEGokACACIQELIAELNgIMQQAhBQwCCyAEQQJ0IAJqKAIQEGlBAE4NACAHQRM2AgxBACEFDAELIAA0AhhCA4ZCCHwQSyIFRQRAIAdBBzYCDEEAIQUMAQsgBUEAIAAoAhhBAWoiCkEDdBAoIQlBACEEIwBBEGsiBiQAAkAgACgCjAINACAAQRAgBkEMakEAEFIiBA0AIAYoAgwiBEEBEPoCGiAEEEMaIAQQOiEECyAGQRBqJAAgByAENgIMIAQNAAJAIAFBAkgNACAAKAIoDQAgACgCGEECdCACaigCDCIEEC9BBUYEQCACKAIEIQQLIAQQL0EFRg0AIAIoAgAiBhAvQQVHBEAgBhBfIAQQX1ENAQsgBwJ/IAAoAgwtAFxBv+wBai0AAEEFRgRAIAAgBCAHQQhqIAkQogoMAQtBASEIIAAgAiADEKEKCyIENgIMIAQNAQsgCkECdCAJaiEEIAIoAgAiBhAvQQVHBH8gByAAIAYgB0EIaiAJEKIKIgY2AgwgBkUFQQELRSABQQJIckUEQCAAKAIYQQJ0IAJqKAIQEGkhAQJAAkAgCA0AIAcgACACIAMQoQoiBjYCDCAGRQ0AIAZBE0cNASAAKAIoDQEgB0GLAjYCDAwBCyAHIABBACABIAMpAwAQ9wYiAzYCDCADDQBBAiEDA0ACQCAAKAIYQQJqIANMBEBBACEGDAELIANBAmsiBiAAKAIgai0AAEUEQCAAIAEgAiADQQJ0aiIIKAIAECsgBiAEIAZBAnRqEPYGIgYNASAIKAIAEGAhBiAEIAAoAhhBAnRqIgggBiAIKAIAajYCAAsgA0EBaiEDDAELCyAHIAY2AgwLIAAtAO4BBEAgB0EMaiAAIAQQoAoLIAcgBygCCEEBajYCCAsgAC0A7AFFDQAgB0EMaiAAIAQgCSAHKAIIEJ8KCyAFECMgABCTAiAHKAIMIQAgB0EQaiQAIAALDgAgASAAKQMgNwMAQQALsQEBAn8CQAJAAkACQAJAAkAgAiAAKAIAIgQoAhgiA2sOAwABAgMLIAEoAgAiARCcASABQQE7ARAgASAAQY/CAEEAEOkJQQAPCyABIAApAyAQYwwCCyAAKAIQBEAgASAANAIUEGMMAgsgAyECIAQoAiwNACABQQAQgAFBAA8LQQAgABCdBSIDDQEgACgCDCIAEOQJQQFrIAJMDQAgASAAIAJBAWoQ4wkQywELQQAhAwsgAwscACAALQAGRQRAQQAPCyAAEIEHIABBAToABkEBC80JAg5/AX4jAEEwayIIJABBASEDAkAgACgCACIGKAI4DQAgAUH//wNxIgsEfyAEKAIAIQlBAQVBAAshAyABQYCABHEEQCAEIANBAnRqKAIAIQUgA0EBaiEDCyABQYCACHEEQCAEIANBAnRqKAIAIQwgA0EBaiEDCyABQYCAEHEEQCAEIANBAnRqKAIAIQoLIAAQgQcgACAMQoCAgICAgICAgH8Qwwo3A0ggACAKQv///////////wAQwwo3A1ACfyACBEAgAi0AAEHEAEYMAQsgBi0A7wELIQIgACABOwEEIAAgAjoANCALQQJPBEAgCRArIgJFBEBBByEDIAkQL0EFRw0CC0EAIQMgAEEANgIUIAUEQCAAIAUQaSIDNgIUCyAGKAIkIQ8gBigCHCEQIAYtAOwBIREgBigCGCESIAZBCGohDSMAQSBrIgUkACAAQRBqIQcjAEEwayIEJAAgBEEANgIoIARCADcDICAEIAtBAms2AhwgBCASNgIYIAQgEDYCECAEIAM2AgwgBCAPNgIIIAQgETYCFAJAIAJFBEAgB0EANgIADAELIARBCGogAiACED0gByAEQSxqELQKIgNBASADIAQoAigbIAMbIQ4LIARBMGokAAJAAkAgDiIEDQBBACEDIAcoAgBFDQEgB0EMEJsFIgQNACAHKAIAQQwQuAoiBEUNAQsgBygCABCOAiAHQQA2AgBBASEDIARBAUcEQCAEIgNBEkcNASAFQQw2AgAgDUGKwQEgBRDOAUEBIQMMAQsgBSACNgIQIA1B/IkBIAVBEGoQzgELIAVBIGokACADDQEjAEEgayIFJAAgACgCACECIAVBADYCHCAFQQA2AhggBUEANgIUIAAgACgCECAFQRhqIAVBFGogBUEc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BBCjAkUgA0EBR3JFBEAgACACKAIEEMsBDAELIAAgAxDYAQsgAUFAaxCsBAsgBCAHNgLoAiABQdACaiQAC/ECAQZ/IwBBoAJrIgEkACAAEH8hBCACKAIAEGkhAyACKAIEECshBiACKAIIEGkhBSAEKAIQIANBBHRqKAIAIQIgBCgC6AIhCCAEQQA2AugCAkAgAUEQaiACIAQgBiADQQFGEK0EIgINAAJAAkAgASgC/AEiAkUNACACLgEiIgNBAUYNACADIAVKDQELQafsBhApIQIMAQsgAUEQakEAIAVBDGwiByACKAIEaigCABCWASEDAkAgAi4BIkEBayAFSgRAIAFBEGpBACAHIAIoAgRqKAIMEJYBKAIEIQUgAygCBCECDAELIAYgAigCLGohBSADKAIEIQIDQCACLQAAIgdFIAdBLEZyDQEgAyACQQFrIgI2AgQMAAsACyABIAU2AgggASAGNgIEIAEgAiAGazYCACAAIARB4CwgARA8IgJBf0F/ED8gAhAjQQAhAgsgAUEQahCsBCAEIAg2AugCIAIEQCAAIAIQ2AELIAFBoAJqJAALmQMCB38CfiMAQbACayIBJAAgABB/IQMgAigCABArIQUgAigCBBArIQQgAigCEBBpIQcgAykDICELIAIoAhQQKyEGIAIoAhgQaSEIIAMoAugCIQkgA0EANgLoAiAFRSAERXJFBEAgAykDICEKIAgEQCADIApC/////3mDNwMgCyABQSBqIAUgAyAEIAcQrQQhBCADIAMpAyAgCkKAgICABoOENwMgAkACQCAEDQACQCALQoCAgCCDIgpCAFINACABKAKMAiIERQ0AIAQtACtBAkcNACABQQA2AhwgAUIANwIUIAFCADcCDCABQgA3AgQgASABQSBqIgU2AgAgBSAEKAIsIAEQ4AEgASgCLEEAIAEoAkQbIQQMAQsgASgClAIiBEUNASADIApQBH8gAUEgahCuBSIEDQEgASgClAIFIAQLKAIYEE4gAyAFEOcCRw0BIABBARCAAQwBCyAERSAGRXINACADEKMCDQAgACAGIAIoAgggAigCDCABQSBqEJgHCyABQSBqEKwECyADIAk2AugCIAFBsAJqJAALQAEBfwJAIAEtAABBpwFHDQAgAS0AB0EDcQ0AIAAoAhgiAigCDCABKAIsRw0AIAAoAgAgAiABQSxqEJYBGgtBAAt2AQR/QQEhAiABLwEGQaAIcQR/QQEFIAEoAiAiA0UEQEECDwsgACgCGCEEQQAhAgNAIAMoAgAgAkoEQCADIAJBBnRqIgUoAhggBCgCDEYEQCAAKAIAIAQgBSgCEBCWARoLIAJBAWohAgwBCwsgACABEL8HQQALC7kHAgl/AX4jAEHwAmsiASQAIAAQfyEGIAIoAgAQKyEDIAIoAgwQKyEIIAIoAhAQKyEHIAIoAhQQKyEKIAIoAhgQaSEEIApFIAhFIAdFcnJFBEAgBigC6AIhCyAGQQA2AugCIAYQ9wEgAUEANgJYIAFCADcDUCABQgA3A0ggBiAHIAMQfCEFIAFBADYCPCABQgA3AjQgASAFNgJUIAFB2gA2AjAgAUHbADYCLCABIAFByABqNgJAIAEgAUHgAGoiBTYCKAJAIAUgAyAGIAggBBCtBCIDDQAgBikDICIMp0GAgIAgcSEFAkACQCABKALMAiIEBEAgBC0AKyIDQQJGBEAgBQ0DIAQoAiwhAyABQQA2AiQgAUIANwIcIAFCADcCFCABQgA3AgwgASABQeAAaiIFNgIIIAMgAygCBEH///9+cTYCBCAFIAQoAiwgAUEIahDgASABKAKEAQ0CIAFBKGogBCgCLBBqGgwDCwJAIAxCgIABg1AgBUEAR3EgA0EBRnINACAEQTBqIQMDQCADKAIAIgNFDQEgAygCCCIJIAcQU0UEQCABQeAAaiABQcgAaiAJEJYBGgsgA0EEaiEDDAALAAsgByAEKAIAIgMQUw0CIAEgBDYCVCABQeAAaiABQcgAaiAFBH8gAwUgAUEoaiAEKAIQEGUaIAQoAgALEJYBGgwCCyABKALQAiIDBEAgAUHgAGogAUHIAGogAygCABCWARogBQ0CIAFBKGogASgC0AIoAiQQTRoMAgsCQCABKALUAiIEKAIEIgMgBxBTDQAgASgCVCgCPCAEKAIYRw0AIAFB4ABqIAFByABqIAMQlgEaCyAFDQEgAUHgAGoQrgUiAw0CIAFBKGogBBCaByAEQRxqIQMDQCADKAIAIgRFDQICQCAEKAIMIgNFDQAgAyAHEFMNACABQeAAaiABQcgAaiADEJYBGgtBACEDAkAgBCgCECIFRQ0AA0AgAyAFKAIATg0BIAUgA0EGdGooAhAiCSAHEFNFBEAgAUHgAGogAUHIAGogCRCWARogBCgCECEFCyADQQFqIQMMAAsACyAEQShqIQMMAAsACyABKAJsIgMNAQsgACABQcgAaiAIIApBARCZByEDCwJAAkACQCADDgICAAELIAYQowJFDQAgACACKAIMEMsBDAELIAEoAmQEQCAAQa3lASACKAIEIAIoAgggAUHgAGoQmAcMAQsgACADENgBCyABQeAAahCsBCAGIAEoAkgQrQUgBiALNgLoAgsgAUHwAmokAAsHACAAKAIwC4IBAQJ/IAAoAhghAgJAIAEtAAAiA0GnAUcEQCADQc0ARw0BIAIoAgggAS4BIEcNASAAKAIAIgAoAnggAigCDEcNASAAIAIgARCWARoMAQsgAigCCCABLgEgRw0AIAEtAAdBA3ENACACKAIMIAEoAixHDQAgACgCACACIAEQlgEaC0EACyABAX9BASECIAEvAQZBoAhxBH9BAQUgACABEL8HQQALC6EJAQx/IwBB0AJrIgEkACAAEH8hBiACKAIAECshCyACKAIMECshByACKAIQECshCCACKAIUEGkhBSACKAIYECshDCACKAIcEGkhDSACKAIgEGkhBAJAIAtFIAhFciAMRSAFQQBIcnINACAGKALoAiEOIAYQ9wEgBiAIIAcQfCIDRQ0AIAUgAy4BIk4NACADKAIEIAVBDGxqKAIAIQkgAUEANgLIAiABQgA3A8ACIAFCADcDuAIgAUF/IAUgBSADLgEgRhs2AsACIAZBADYC6AIgAUEoaiIKIAcgBiALIAQQrQQhBCABQQA2AhwgAUIANwIUIAFB2AA2AhAgAUHZADYCDCABIAM2AsQCIAEgAUG4Amo2AiAgASAKNgIIAkAgBA0AAkACQCABKAKUAiIEBEACQAJAIAQtACsOAwEEAAQLIAQoAiwiAyADKAIEQf///35xNgIEIAFBADYCNCABQShqIANBABDgAUEHIAEoAjQgBi0AVxsiBA0EIAFBCGogAxBqGgwDCyAIIAQoAgAQUyEHIAEgBDYCxAIgBw0BIAQuASIgBUoEQCABQShqIAFBuAJqIAQoAgQgBUEMbGooAgAQlgEaCyABKALAAkEASARAIAFBKGogAUG4AmogASgClAJBIGoQlgEaCyABQQhqIAEoApQCKAIQEGUaIAEoApQCQQhqIQMDQCADKAIAIgMEQCABQQhqIAMoAigQZRogA0EU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QAJAIAIgBUYNACADIAogAkECdCIIaigCACIETwRAIAcgBiAIaigCACAEEFFFDQELIAJBAWohAgwBCwsgAiAFTw0BIAQgB2ohByADIARrIgMNAAtBACEDCwJAIAFBAnFFIANFckUEQANAIAMhAUEAIQIDQCACIAVGDQMCQCAKIAJBAnQiCGooAgAiBCABTQRAIAcgASAEayIDaiAGIAhqKAIAIAQQUUUNAQsgAkEBaiECDAELC0EAIQEgAw0ADAILAAsgAyEBCyAJRQ0BIAYQIwwBCyADIQELIAAgByABQX8QPwsLFAAgACACKAIAEGkQsQlBf0EAED8LoQEBBH8gAigCABArIgEEQCAAAn8jAEEQayICJAAgAkEMahCyCSABQQBBByABQauJAUEHEEgbaiIEEDEhASACKAIMIgBBACAAQQBKGyEFQQAhAANAAkAgACAFRwRAIAQgAEECdEGwrQNqKAIAIgYgARBIDQEgASAGai0AABCABQ0BQQEhAwsgAkEQaiQAIAMMAgsgAEEBaiEADAALAAsQgAELCw0AIABBgAhBf0EAED8LzgECAn8CfiMAQTBrIgEkACABQRhqIgRBAEEAQQAgAigCABCNAiICKAIUQeQAbEHkAGoQmgEgASACQQRBCCACLQAYG2o1AgA3AxAgBEGjDiABQRBqED4DQCADIAIoAhRORQRAIAEgAigCICADQQJ0aigCAEEBaq0iBSACKAIIIgStfEIBfSAFgCIGQgJRBH5CAkIBIARBCmytIAVCC35WGwUgBgs3AwAgAUEYakGiDiABED4gA0EBaiEDDAELCyAAIAFBGGoQnQcgAUEwaiQAC44CAQN/IAIoAgAQjQIhASACKAIEEGkhAgJAIAEoAggEQCACQQAgAkEAShshBANAIAMgBEYEQANAIAIgASgCEE4NBCACQQJ0IgMgASgCIGoiBCAEKAIAQQFqNgIAIAEoAhwgA2pBATYCACACQQFqIQIMAAsABSABKAIcIANBAnRqIgUgBSgCAEEBajYCACADQQFqIQMMAQsACwALQQAhAgNAIAIgASgCEE4NASABKAIcIAJBAnRqQQE2AgAgAkEBaiECDAALAAsgASABKAIIQQFqIgI2AggCQCABKAIMIgNFDQAgAiADIAEtABgiA0EBamxNDQAgASADQQFqOgAYIAAgASgCICgCAEEA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QCACQacBaw4GAQECAgIAAgsgAS0AB0EBcUUNASADIQIDQCACKAIAIgBFDQEgAEEkaiECQQEhBCABKAIsIABHDQALDAILQQIhBCAFKAIAIgAtAFcNAQJ/AkACQCADKAIIIgIEf0EAIQADQCACKAIAIABKBEBBACACIABBBHRqKAIIIAFBfxBrRQ0EIABBAWohACADKAIIIQIMAQsLIAUoAgAFIAALIAFBABA2IgBFDQAgAC0AAEGoAUcNACAAQawBOgAACyADIAUgAygCCCAAEDsiAjYCCEF/IQBBAQwBCyADKAIIIQJBAAshBiACBEAgASABKAIEIgJBgICAwAByNgIEIAUoAgAgARAuIAFBAEE0ECgiAUGnAToAACABIAYEfyADKAIIKAIAQQFrBSAACzsBICABIAMoAgAoAjA2AhwgAygCDCEAIAEgAkGABHE2AgQgASAANgIsCyAFKAIALQBXDQELQQAhBAsgBAswAQJ/IAEgACgCGCICKAIQIgNGBEBBAA8LIAIgATYCECAAIAEQahogAiADNgIQQQELqgEBA38CQCABKAIEQYCABXENACABKAIoIgJFDQAgAS4BIiEDIAAoAgAiBCgCACEAAkAgAS0AAEGpAUYEQCACKAIcIANBFGxqKAIEIAFHDQIgACABQQAQNiIBRQ0CIAIoAhwgA0EUbGogATYCBAwBCyACKAIoIANBFGxqKAIAIAFHDQEgACABQQAQNiIBRQ0BIAIoAiggA0EUbGogATYCAAsgBCABENcHC0EAC9wGAQh/IAAoAhgiAygCCCEEIAMoAgAhBQJAAkACQAJAIAEtAABBpwFrDgMAAQADCyADKAIEIgBFDQEgACgCACIDQQAgA0EAShshAyAAQQhqIQBBASEGA0AgAiADRg0DIAEoAhwiByAAKAIoRgRAQQAhACAEKAIgIgJBACACQQBKGyEDIAQoAhwhAgJAA0AgACADRwRAIAcgAigCCEYEQCACLwEQIAEvASBGDQMLIAJBFGohAiAAQQFqIQAMAQsLIAUoAgAhAiMAQRBrIgAkACAEIAIgBCgCHCAEQSBqIABBDGoQlAs2AhwgACgCDCECIABBEGokACACIgBBAEgNACAEKAIcIABBFGxqIgMgASgCLDYCACADIAEoAhwiBzYCCCADIAEvASAiCDsBECAFIAUoAixBAWoiAjYC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QQFGDQILIAAtAABBpwFHDQAgACgCLCIARQ0AIAAtACtBAUYNAQtBACECCyACCzIAAkAgACgCACIAKAKIAkUNACABKAI0DQAgARDIBygCQCIBRQ0AIAAgASgCCDYCiAILCwMAAQsLACAAQQA7ARRBAgsmACAAKAIQKAIcQShqQdzcAEEAEKgBGiAAIAEoAgQQOSAAIAEQJwsLloQExwIAQYAIC+feATMuMzkuMwB7fQAlcy4legBhZmZpbml0eQBSZWFsQWZmaW5pdHkAYnVzeQB0ZW1wX3N0b3JlX2RpcmVjdG9yeQBub3QgYSB3cml0YWJsZSBkaXJlY3RvcnkAb3BlbkRpcmVjdG9yeQBzaHJpbmtfbWVtb3J5AG91dCBvZiBtZW1vcnkAZmFpbGVkIHRvIGFsbG9jYXRlICV1IGJ5dGVzIG9mIG1lbW9yeQBIQVZJTkcgY2xhdXNlIG9uIGEgbm9uLWFnZ3JlZ2F0ZSBxdWVyeQBJbnRDb3B5AFNDb3B5AFZEZXN0cm95AE11bHRpcGx5AHF1ZXJ5X29ubHkAdW5saWtlbHkAdGFibGUgIiVzIiBoYXMgbW9yZSB0aGFuIG9uZSBwcmltYXJ5IGtleQBmb3JlaWduIGtleQBqc29uX2dyb3VwX2FycmF5AGpzb25fYXJyYXkAanVsaWFuZGF5AGZ0czRhdXgAdW5peABzcWxpdGVfcmVuYW1lX3F1b3RlZml4AHByZWZpeABMSUtFIG9yIEdMT0IgcGF0dGVybiB0b28gY29tcGxleABoZXgAY2hhcmluZGV4AE9wZW5BdXRvaW5kZXgAYXV0b21hdGljX2luZGV4AGF1dG8taW5kZXgAb3JwaGFuIGluZGV4AERyb3BJbmRleABpZHgAUmVvcGVuSWR4AHBjeABtYXgATWVtTWF4ACUwMngAMHgAIEZST00gJyVxJy4nJXElcycgQVMgeABDUkVBVEUgVEFCTEUgeABydwBwc293AGltcGxpZXNfbm9ubnVsbF9yb3cAbm93AGludGVnZXIgb3ZlcmZsb3cAcGFyc2VyIHN0YWNrIG92ZXJmbG93AHdpbmRvdwBzaGFkb3cAUmVzdWx0Um93AElmTnVsbFJvdwBuZXcAbm8gc3VjaCB2aWV3AGNhbm5vdCBtb2RpZnkgJXMgYmVjYXVzZSBpdCBpcyBhIHZpZXcAQ2Fubm90IGFkZCBhIGNvbHVtbiB0byBhIHZpZXcAY2Fubm90IFVQU0VSVCBhIHZpZXcAUHJldgBzdGRldgAgJWxsdQAlYyV1ACUuKno6JXUARnJhZ21lbnRhdGlvbiBvZiAlZCBieXRlcyByZXBvcnRlZCBhcyAlZCBvbiBwYWdlICV1AE11bHRpcGxlIHVzZXMgZm9yIGJ5dGUgJXUgb2YgcGFnZSAldQB1bmFibGUgdG8gdXNlIGZ1bmN0aW9uICVzIGluIHRoZSByZXF1ZXN0ZWQgY29udGV4dABTb3J0ZXJOZXh0AFZOZXh0AGluY29tcGxldGUgaW5wdXQAYnVzeV90aW1lb3V0AGxvY2FsaG9zdABjYW5ub3QgZHJvcCBjb2x1bW4gIiVzIjogbm8gb3RoZXIgY29sdW1ucyBleGlzdABwZXJzaXN0AGZvcmVpZ25fa2V5X2xpc3QAaW5kZXhfbGlzdABmdW5jdGlvbl9saXN0AGNvbGxhdGlvbl9saXN0AGRhdGFiYXNlX2xpc3QAbW9kdWxlX2xpc3QAUFJBR01BIHRhYmxlX2xpc3QAcHJhZ21hX2xpc3QAc2V0IGxpc3QAVmFsdWVMaXN0AHNxbGl0ZV9yZW5hbWVfdGVzdABSb3dTZXRUZXN0AFNlcXVlbmNlVGVzdABmYXN0AExhc3QAQ2FzdABzcXJ0AFNvcnRlclNvcnQAanNvbl9pbnNlcnQASWR4SW5zZXJ0AFNvcnRlckluc2VydAByZXN0YXJ0AGNvdABCaXROb3QASWZOb3QAUGFnZWNvdW50AGZyZWVsaXN0X2NvdW50AG1heF9wYWdlX2NvdW50AFJlc2V0Q291bnQAd2FsX2F1dG9jaGVja3BvaW50AHdhbF9jaGVja3BvaW50AENoZWNrcG9pbnQAU2F2ZXBvaW50AGEgQ0hFQ0sgY29uc3RyYWludAAlc09OIENPTkZMSUNUIGNsYXVzZSBkb2VzIG5vdCBtYXRjaCBhbnkgUFJJTUFSWSBLRVkgb3IgVU5JUVVFIGNvbnN0cmFpbnQAQ3Vyc29ySGludABfY29udGVudABwYXJlbnQARElTVElOQ1QgYWdncmVnYXRlcyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgYXJndW1lbnQAY29tbWVudABBUEkgY2FsbGVkIHdpdGggZmluYWxpemVkIHByZXBhcmVkIHN0YXRlbWVudABBUEkgY2FsbGVkIHdpdGggTlVMTCBwcmVwYXJlZCBzdGF0ZW1lbnQATWF4UGdjbnQAZGVmYXVsdCB2YWx1ZSBvZiBjb2x1bW4gWyVzXSBpcyBub3QgY29uc3RhbnQATXVzdEJlSW50AENhbm5vdCBhZGQgYSBjb2x1bW4gd2l0aCBub24tY29uc3RhbnQgZGVmYXVsdABIYWx0AGxhbm9pdABzdGF0X2luaXQASW5pdABBdXRvQ29tbWl0AGFuYWx5c2lzX2xpbWl0AHNvZnRfaGVhcF9saW1pdABoYXJkX2hlYXBfbGltaXQAam91cm5hbF9zaXplX2xpbWl0AE9mZnNldExpbWl0AFNlZWtIaXQAT04gY2xhdXNlIHJlZmVyZW5jZXMgdGFibGVzIHRvIGl0cyByaWdodABTaGlmdFJpZ2h0AGhnaHQAU2hpZnRMZWZ0AE9mZnNldAByZXNldABqc29uX3NldAB0b28gbWFueSBjb2x1bW5zIGluIHJlc3VsdCBzZXQAJXIgT1JERVIgQlkgdGVybSBkb2VzIG5vdCBtYXRjaCBhbnkgY29sdW1uIGluIHRoZSByZXN1bHQgc2V0AHNuaXBwZXQAc3RhdF9nZXQAc3FsaXRlX2NvbXBpbGVvcHRpb25fZ2V0AHN0cmljdABOb0NvbmZsaWN0AGpzb25fZ3JvdXBfb2JqZWN0AGpzb25fb2JqZWN0AGpzb25fZXh0cmFjdABTdWJ0cmFjdABsc3RhdABmc3RhdAAlc19zdGF0AHRibCxpZHgsc3RhdAB1bnN1cHBvcnRlZCBmaWxlIGZvcm1hdABncm91cF9jb25jYXQAQ29uY2F0AEx0AEd0AGRlZmVyX2ZvcmVpZ25fa2V5cwBhbHdheXMAcGFyYW1ldGVycyBhcmUgbm90IGFsbG93ZWQgaW4gdmlld3MAc3RhdHVzAHN5bmNocm9ub3VzAGluZGV4ICVzIGFscmVhZHkgZXhpc3RzAG91dHB1dCBmaWxlIGFscmVhZHkgZXhpc3RzACVzICVUIGFscmVhZHkgZXhpc3RzAHRyaWdnZXIgJVQgYWxyZWFkeSBleGlzdHMATm90RXhpc3RzAGlnbm9yZV9jaGVja19jb25zdHJhaW50cwBDSEVDSyBjb25zdHJhaW50cwBleHByZXNzaW9ucyBwcm9oaWJpdGVkIGluIFBSSU1BUlkgS0VZIGFuZCBVTklRVUUgY29uc3RyYWludHMAanNvbl9vYmplY3QoKSByZXF1aXJlcyBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMAanNvbl8lcygpIG5lZWRzIGFuIG9kZCBudW1iZXIgb2YgYXJndW1lbnRzACVzX3NlZ21lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IHVzZXItZnVuY3Rpb24gZHVlIHRvIGFjdGl2ZSBzdGF0ZW1lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IGNvbGxhdGlvbiBzZXF1ZW5jZSBkdWUgdG8gYWN0aXZlIHN0YXRlbWVudHMAb2Zmc2V0cwByZXZlcnNlX3Vub3JkZXJlZF9zZWxlY3RzAGlpc3Nzc3NzAGlzcwBzZXNzAHVuY29tcHJlc3MAY2Fubm90IG9wZW4gc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IHJlbGVhc2Ugc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IGNvbW1pdCB0cmFuc2FjdGlvbiAtIFNRTCBzdGF0ZW1lbnRzIGluIHByb2dyZXNzAGNhbm5vdCBWQUNVVU0gLSBTUUwgc3RhdGVtZW50cyBpbiBwcm9ncmVzcwBhY2Nlc3MAcGFyYW1ldGVycwByZWN1cnNpdmVfdHJpZ2dlcnMAdGhlIElOREVYRUQgQlkgY2xhdXNlIGlzIG5vdCBhbGxvd2VkIG9uIFVQREFURSBvciBERUxFVEUgc3RhdGVtZW50cyB3aXRoaW4gdHJpZ2dlcnMAdGhlIE5PVCBJTkRFWEVEIGNsYXVzZSBpcyBub3QgYWxsb3dlZCBvbiBVUERBVEUgb3IgREVMRVRFIHN0YXRlbWVudHMgd2l0aGluIHRyaWdnZXJzAHF1YWxpZmllZCB0YWJsZSBuYW1lcyBhcmUgbm90IGFsbG93ZWQgb24gSU5TRVJULCBVUERBVEUsIGFuZCBERUxFVEUgc3RhdGVtZW50cyB3aXRoaW4gdHJpZ2dlcnMAQ2hpbGQgcGFnZSBkZXB0aCBkaWZmZXJzAHVuYWJsZSB0byBjbG9zZSBkdWUgdG8gdW5maW5hbGl6ZWQgc3RhdGVtZW50cyBvciB1bmZpbmlzaGVkIGJhY2t1cHMAYWNvcwBJZlBvcwBjb21waWxlX29wdGlvbnMARElTVElOQ1QgaXMgbm90IHN1cHBvcnRlZCBmb3Igd2luZG93IGZ1bmN0aW9ucwBGSUxURVIgY2xhdXNlIG1heSBvbmx5IGJlIHVzZWQgd2l0aCBhZ2dyZWdhdGUgd2luZG93IGZ1bmN0aW9ucwBub24tZGV0ZXJtaW5pc3RpYyBmdW5jdGlvbnMAaW5kZXggZXhwcmVzc2lvbnMAU0VMRUNUcyB0byB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgJXMgZG8gbm90IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHJlc3VsdCBjb2x1bW5zAHZpcnR1YWwgdGFibGVzIGNhbm5vdCB1c2UgY29tcHV0ZWQgY29sdW1ucwBnZW5lcmF0ZWQgY29sdW1ucwB0YWJsZSAlcyBoYXMgJWQgdmFsdWVzIGZvciAlZCBjb2x1bW5zAHJhZGlhbnMAYWxsIFZBTFVFUyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHRlcm1zAGVtcHR5X3Jlc3VsdF9jYWxsYmFja3MATG9hZEFuYWx5c2lzAGZsZ3MAZmxhZ3MAdmZzACVkIGNvbHVtbnMgYXNzaWduZWQgJWQgdmFsdWVzAEpTT04gY2Fubm90IGhvbGQgQkxPQiB2YWx1ZXMAZmFpbGVkIG1lbW9yeSByZXNpemUgJXUgdG8gJXUgYnl0ZXMAcGFydGlhbCBpbmRleCBXSEVSRSBjbGF1c2VzAHNob3J0X2NvbHVtbl9uYW1lcwBmdWxsX2NvbHVtbl9uYW1lcwB1bmFibGUgdG8gb3BlbiBhIHRlbXBvcmFyeSBkYXRhYmFzZSBmaWxlIGZvciBzdG9yaW5nIHRlbXBvcmFyeSB0YWJsZXMAY2Fubm90IGNyZWF0ZSB0cmlnZ2VycyBvbiB2aXJ0dWFsIHRhYmxlcwAlcyBSRVRVUk5JTkcgaXMgbm90IGF2YWlsYWJsZSBvbiB2aXJ0dWFsIHRhYmxlcwBjYW5ub3Qgam9pbiB1c2luZyBjb2x1bW4gJXMgLSBjb2x1bW4gbm90IHByZXNlbnQgaW4gYm90aCB0YWJsZXMAQVVUT0lOQ1JFTUVOVCBub3QgYWxsb3dlZCBvbiBXSVRIT1VUIFJPV0lEIHRhYmxlcwAlcyBjYW5ub3QgdXNlIHZhcmlhYmxlcwB0b28gbWFueSBTUUwgdmFyaWFibGVzAHN1YnF1ZXJpZXMAY2Fubm90IHVzZSB3aW5kb3cgZnVuY3Rpb25zIGluIHJlY3Vyc2l2ZSBxdWVyaWVzAGNvdW50X2NoYW5nZXMAdG90YWxfY2hhbmdlcwBkZWdyZWVzAFJFVFVSTklORyBtYXkgbm90IHVzZSAiVEFCTEUuKiIgd2lsZGNhcmRzAHRocmVhZHMAYWJzAC4lLipzAENSRUFURSAlcyAlLipzAENSRUFURSVzIElOREVYICUuKnMAaW52YWxpZCB1cmkgYXV0aG9yaXR5OiAlLipzAHVua25vd24gdGFibGUgb3B0aW9uOiAlLipzACUuKnMlcwAsJXMlcyVzAFNDQU4gJXMlcyVzAHNxbGl0ZV9hbHRlcnRhYl8lcwBTQ0FOICVkIENPTlNUQU5UIFJPVyVzACVRJXMAIFZJUlRVQUwgVEFCTEUgSU5ERVggJWQ6JXMAJXM6ICVzLiVzLiVzAG1pc3NpbmcgZGF0YXR5cGUgZm9yICVzLiVzAGNhbm5vdCBzdG9yZSAlcyB2YWx1ZSBpbiAlcyBjb2x1bW4gJXMuJXMAbm9uLSVzIHZhbHVlIGluICVzLiVzAE5VTEwgdmFsdWUgaW4gJXMuJXMAJXM6ICVzLiVzAG5vIHN1Y2ggdGFibGUgY29sdW1uOiAlcy4lcwAuLiVzACUuMThzLSVzACBVU0lORyBJTlRFR0VSIFBSSU1BUlkgS0VZICglcwB1c2UgRFJPUCBWSUVXIHRvIGRlbGV0ZSB2aWV3ICVzAGlsbGVnYWwgZmlyc3QgYXJndW1lbnQgdG8gJXMAbWlzdXNlIG9mIGFsaWFzZWQgd2luZG93IGZ1bmN0aW9uICVzAHRvbyBtYW55IGNvbHVtbnMgb24gJXMAdG9vIG1hbnkgY29sdW1ucyBpbiAlcwAlcyBwcm9oaWJpdGVkIGluICVzAENIRUNLIGNvbnN0cmFpbnQgZmFpbGVkIGluICVzAG5vbi1kZXRlcm1pbmlzdGljIHVzZSBvZiAlcygpIGluICVzAHJlY292ZXJlZCAlZCBwYWdlcyBmcm9tICVzAG1pc3VzZSBvZiBhbGlhc2VkIGFnZ3JlZ2F0ZSAlcwAlcyAlVCBjYW5ub3QgcmVmZXJlbmNlIG9iamVjdHMgaW4gZGF0YWJhc2UgJXMAY2Fubm90IGRldGFjaCBkYXRhYmFzZSAlcwBhIEpPSU4gY2xhdXNlIGlzIHJlcXVpcmVkIGJlZm9yZSAlcwBjYW5ub3Qgb3BlbiB2YWx1ZSBvZiB0eXBlICVzAGNhbm5vdCBmc3RhdCBkYiBmaWxlICVzAHJlY292ZXJlZCAlZCBmcmFtZXMgZnJvbSBXQUwgZmlsZSAlcwBQUklNQVJZIEtFWSBtaXNzaW5nIG9uIHRhYmxlICVzAHVzZSBEUk9QIFRBQkxFIHRvIGRlbGV0ZSB0YWJsZSAlcwBTRUxFQ1QgJXMgT1JERVIgQlkgcm93aWQgJXMAU0VMRUNUICVzIFdIRVJFIHJvd2lkIEJFVFdFRU4gJWxsZCBBTkQgJWxsZCBPUkRFUiBCWSByb3dpZCAlcwB0aGVyZSBpcyBhbHJlYWR5IGFuIGluZGV4IG5hbWVkICVzAHRhYmxlICVTIGhhcyBubyBjb2x1bW4gbmFtZWQgJXMAdGhlcmUgaXMgYWxyZWFkeSBhIHRhYmxlIG5hbWVkICVzAHN0YXRlbWVudCBhYm9ydHMgYXQgJWQ6IFslc10gJXMAQ09WRVJJTkcgSU5ERVggJXMAU0VMRUNUICVzAHVuc3VwcG9ydGVkIHVzZSBvZiBOVUxMUyAlcwBVU0UgVEVNUCBCLVRSRUUgRk9SICVzAC0tIFRSSUdHRVIgJXMAUklHSFQtSk9JTiAlcwA+PyBBTkQgJXMAJXo6ICVzAHJlY3Vyc2l2ZSByZWZlcmVuY2UgaW4gYSBzdWJxdWVyeTogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGNhbGxlZCByZWN1cnNpdmVseTogJXMAbm8gc3VjaCBpbmRleDogJXMAbm8gc3VjaCB3aW5kb3c6ICVzAGNhbm5vdCBvdmVycmlkZSAlcyBvZiB3aW5kb3c6ICVzAGNhbm5vdCBvcGVuIHZpZXc6ICVzAG5vIHN1Y2ggc2F2ZXBvaW50OiAlcwBubyBzdWNoIHZmczogJXMAbXVsdGlwbGUgcmVjdXJzaXZlIHJlZmVyZW5jZXM6ICVzAGVycm9yIGluICVzICVzJXMlczogJXMAZXJyb3IgaW4gJXMgJXMgYWZ0ZXIgJXM6ICVzAHVua25vd24gdG9rZW5pemVyOiAlcwBlcnJvciBwYXJzaW5nIHByZWZpeCBwYXJhbWV0ZXI6ICVzAHVucmVjb2duaXplZCBwYXJhbWV0ZXI6ICVzAHVucmVjb2duaXplZCBvcmRlcjogJXMAdW5yZWNvZ25pemVkIG1hdGNoaW5mbzogJXMAbm8gc3VjaCBjb2x1bW46ICVzAGZpbGUgcmVuYW1lZCB3aGlsZSBvcGVuOiAlcwBmaWxlIHVubGlua2VkIHdoaWxlIG9wZW46ICVzAHVuc3VwcG9ydGVkIGVuY29kaW5nOiAlcwBjYW5ub3QgbGltaXQgV0FMIHNpemU6ICVzAE1KIGRlbGV0ZTogJXMAdGFyZ2V0IG9iamVjdC9hbGlhcyBtYXkgbm90IGFwcGVhciBpbiBGUk9NIGNsYXVzZTogJXMAb2JqZWN0IG5hbWUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzZTogJXMAdW5rbm93biBkYXRhYmFzZTogJXMAdW5hYmxlIHRvIG9wZW4gZGF0YWJhc2U6ICVzAG5vIHN1Y2ggZGF0YWJhc2U6ICVzAHRoZXJlIGlzIGFscmVhZHkgYW5vdGhlciB0YWJsZSBvciBpbmRleCB3aXRoIHRoaXMgbmFtZTogJXMAZHVwbGljYXRlIGNvbHVtbiBuYW1lOiAlcwBkdXBsaWNhdGUgV0lUSCB0YWJsZSBuYW1lOiAlcwBubyBzdWNoIG1vZHVsZTogJXMAbXVsdGlwbGUgbGlua3MgdG8gZmlsZTogJXMAY2Fubm90IG9wZW4gdmlydHVhbCB0YWJsZTogJXMAbm8gc3VjaCB0YWJsZTogJXMAbXVsdGlwbGUgcmVmZXJlbmNlcyB0byByZWN1cnNpdmUgdGFibGU6ICVzAG5vIHN1Y2ggJXMgbW9kZTogJXMATUogY29sbGlkZTogJXMAbm8gc3VjaCBjb2xsYXRpb24gc2VxdWVuY2U6ICVzAGNpcmN1bGFyIHJlZmVyZW5jZTogJXMAY2Fubm90IG9wZW4gdGFibGUgd2l0aG91dCByb3dpZDogJXMAJXMgbW9kZSBub3QgYWxsb3dlZDogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGZhaWxlZDogJXMAYXV0b21hdGljIGV4dGVuc2lvbiBsb2FkaW5nIGZhaWxlZDogJXMAZGF0YWJhc2UgdGFibGUgaXMgbG9ja2VkOiAlcwBkYXRhYmFzZSBzY2hlbWEgaXMgbG9ja2VkOiAlcwB2dGFibGUgY29uc3RydWN0b3IgZGlkIG5vdCBkZWNsYXJlIHNjaGVtYTogJXMAYWJvcnQgYXQgJWQgaW4gWyVzXTogJXMALS0gJXMAJXogLSAlcwBvc191bml4LmM6JWQ6ICglZCkgJXMoJXMpIC0gJXMAd3IAcmlnaHRzdHIAbGVmdHN0cgBpbnN0cgBzdWJzdHIAZXhwcl9pbXBsaWVzX2V4cHIAaW52YWxpZCBhcmd1bWVudHMgdG8gZnRzNGF1eCBjb25zdHJ1Y3RvcgBtaXNzaW5nICVzIHBhcmFtZXRlciBpbiBmdHM0IGNvbnN0cnVjdG9yAHRoZSAiLiIgb3BlcmF0b3IAZnRzM2N1cnNvcgBuZWFyICIlVCI6IHN5bnRheCBlcnJvcgB1bmtub3duIGVycm9yAGRvbWFpbiBlcnJvcgBub3QgYW4gZXJyb3IAU1FMIGxvZ2ljIGVycm9yAGRpc2sgSS9PIGVycm9yAGZsb29yAHJtZGlyAG1rZGlyAHNlZ2RpcgBmdHMzX3Rva2VuaXplcgB1bmtub3duIHRva2VuaXplcgBwb3dlcgBsb3dlcgBzcWxpdGVfdGVtcF9tYXN0ZXIAc3FsaXRlX21hc3RlcgBwb3J0ZXIAUmVzZXRTb3J0ZXIARmtDb3VudGVyAEFQSSBjYWxsIHdpdGggJXMgZGF0YWJhc2UgY29ubmVjdGlvbiBwb2ludGVyAHN0cmZpbHRlcgBWRmlsdGVyAEVTQ0FQRSBleHByZXNzaW9uIG11c3QgYmUgYSBzaW5nbGUgY2hhcmFjdGVyAHVwcGVyAHByb3BlcgBJZlNtYWxsZXIAY2Fubm90IHVzZSBSRVRVUk5JTkcgaW4gYSB0cmlnZ2VyAERyb3BUcmlnZ2VyAHNlY29uZCBhcmd1bWVudCB0byBudGhfdmFsdWUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAYXJndW1lbnQgb2YgbnRpbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAZnJhbWUgc3RhcnRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBmcmFtZSBlbmRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBJbnRlZ2VyAFJvd2lkICVsbGQgb3V0IG9mIG9yZGVyAFJlbWFpbmRlcgBmcmFtZSBzdGFydGluZyBvZmZzZXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIAZnJhbWUgZW5kaW5nIG9mZnNldCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcgBhZGRyAHBhZHIAY2hhcgB5ZWFyAENsZWFyAEJpdE9yAHNlcQBDb2xsU2VxAEVsc2VFcQByZWdleHAAT3BlbkR1cABOb29wAEp1bXAAL3Vzci90bXAAL3Zhci90bXAAdGVtcABjdXJyZW50X3RpbWVzdGFtcABBZ2dTdGVwAG1vZGVTdGVwAHZhcmlhbmNlU3RlcABtdW5tYXAAbW1hcABtcmVtYXAAdnRhYjolcABzc2Vuc3VvAGlsc3VvAGF1dG8AR290bwBpbnRvAGluY3JlbWVudGFsX3ZhY3V1bSBlbmFibGVkIHdpdGggYSBtYXggcm9vdHBhZ2Ugb2YgemVybwBJZk5vdFplcm8ARGVjckp1bXBaZXJvAEZrSWZaZXJvAHNlcW5vAGluZGV4X3hpbmZvAHRhYmxlX3hpbmZvAG1hdGNoaW5mbwBpbmRleF9pbmZvAHRhYmxlX2luZm8AT3BlblBzZXVkbwBmY2hvd24AQmVnaW5TdWJydG4AUmV0dXJuAGpzb24Abm8gcXVlcnkgc29sdXRpb24AaW5kZXggY29ycnVwdGlvbgBkYXRhYmFzZSBjb3JydXB0aW9uAGZyZWUgc3BhY2UgY29ycnVwdGlvbgB1bmtub3duIGNvbHVtbiAiJXMiIGluIGZvcmVpZ24ga2V5IGRlZmluaXRpb24AJXMueEJlc3RJbmRleCBtYWxmdW5jdGlvbgBhdXRob3JpemVyIG1hbGZ1bmN0aW9uACUjVCgpIG1heSBub3QgYmUgdXNlZCBhcyBhIHdpbmRvdyBmdW5jdGlvbgAnJXMnIGlzIG5vdCBhIGZ1bmN0aW9uAEZ1bmN0aW9uAGNhbm5vdCBzdGFydCBhIHRyYW5zYWN0aW9uIHdpdGhpbiBhIHRyYW5zYWN0aW9uAGNhbm5vdCBjaGFuZ2UgJXMgd2FsIG1vZGUgZnJvbSB3aXRoaW4gYSB0cmFuc2FjdGlvbgB0ZW1wb3Jhcnkgc3RvcmFnZSBjYW5ub3QgYmUgY2hhbmdlZCBmcm9tIHdpdGhpbiBhIHRyYW5zYWN0aW9uAGNhbm5vdCBWQUNVVU0gZnJvbSB3aXRoaW4gYSB0cmFuc2FjdGlvbgBTYWZldHkgbGV2ZWwgbWF5IG5vdCBiZSBjaGFuZ2VkIGluc2lkZSBhIHRyYW5zYWN0aW9uAFRyYW5zYWN0aW9uAFBlcm11dGF0aW9uAHVua25vd24gb3BlcmF0aW9uAHVuc3VwcG9ydGVkIGZyYW1lIHNwZWNpZmljYXRpb24AUkFOR0Ugd2l0aCBvZmZzZXQgUFJFQ0VESU5HL0ZPTExPV0lORyByZXF1aXJlcyBvbmUgT1JERVIgQlkgZXhwcmVzc2lvbgB0b28gbWFueSBsZXZlbHMgb2YgdHJpZ2dlciByZWN1cnNpb24AdXNlcl92ZXJzaW9uAHNxbGl0ZV92ZXJzaW9uAGRhdGFfdmVyc2lvbgBzY2hlbWFfdmVyc2lvbgBzcWxpdGVfZHJvcF9jb2x1bW4Ac3FsaXRlX3JlbmFtZV9jb2x1bW4AYWZ0ZXIgZHJvcCBjb2x1bW4Abm8gc3VjaCBjb2x1bW4AbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBub24tZ2VuZXJhdGVkIGNvbHVtbgBjYW5ub3QgdXNlIERFRkFVTFQgb24gYSBnZW5lcmF0ZWQgY29sdW1uAGFkZCBjb2x1bW4AQ2Fubm90IGFkZCBhIFBSSU1BUlkgS0VZIGNvbHVtbgBDYW5ub3QgYWRkIGEgVU5JUVVFIGNvbHVtbgBjYW5ub3QgYWRkIGEgU1RPUkVEIGNvbHVtbgBWQ29sdW1uAGJ1aWx0aW4AYXNpbgBhdCBtb3N0ICVkIHRhYmxlcyBpbiBhIGpvaW4AbWluAG9yaWdpbgBWQmVnaW4AbWFpbgBFeHBsYWluAHNpZ24Ac3NlbgBvcGVuAElmTm90T3BlbgBTb3J0ZXJPcGVuAFZPcGVuAGhpZGRlbgBhdGFuAG1lZGlhbgBTZWVrU2NhbgBWSW5pdEluAGF1dG9fdmFjdXVtAGluY3JlbWVudGFsX3ZhY3V1bQBJbmNyVmFjdXVtAHN1bQBkcm9wIGNvbHVtbiBmcm9tAC9kZXYvdXJhbmRvbQBBZGRJbW0AcnRyaW0AbHRyaW0AcmVhZG9ubHlfc2htACVzLXNobQB0bmVtAFJBSVNFKCkgbWF5IG9ubHkgYmUgdXNlZCB3aXRoaW4gYSB0cmlnZ2VyLXByb2dyYW0AUHJvZ3JhbQBQYXJhbQBmdWwAZmNudGwAaW9jdGwAaWdvbABsb2NraW5nIHByb3RvY29sAG5jb2wAbm90bnVsbABpZm51bGwAL2Rldi9udWxsAGRhdGFiYXNlIG9yIGRpc2sgaXMgZnVsbABOb3ROdWxsAFNvZnROdWxsAElzTnVsbABaZXJvT3JOdWxsAEhhbHRJZk51bGwAY29sbABjYWNoZV9zcGlsbABSb3dDZWxsAGNlaWwAZGV0YWlsAHBhZGwAdW5peC1leGNsAHRibAB3YWwAdmlydHVhbAB0b3RhbABpbmNyZW1lbnRhbABPcGVuRXBoZW1lcmFsAEFnZ0ZpbmFsAG5vcm1hbABJbmRleCBhbHJlYWR5IG9wdGltYWwAcGFydGlhbAByZWFsAFJlYWwAcGsAb2sAdW5saW5rAHJlYWRsaW5rAEZpbmlzaFNlZWsARGVmZXJyZWRTZWVrAG5vbG9jawBDdXJzb3JVbmxvY2sAYmxvY2sAJXMubG9jawBDdXJzb3JMb2NrAFRhYmxlTG9jawBpbnRlZ3JpdHlfY2hlY2sAZm9yZWlnbl9rZXlfY2hlY2sAcXVpY2tfY2hlY2sAY2VsbF9zaXplX2NoZWNrAGludGVncml0eS1jaGVjawBGa0NoZWNrAFR5cGVDaGVjawBJbnRlZ3JpdHlDawByZXppAG5vaXRhemkAaXRpdmkAc3NlbmV2aQBpdGkAaXNzaXNpAGlzaXNpAHBpAG5vaQBnbmkAc2lzc2lpAGlzc2lzaWkAc3NzaWlpAHNlaQBpdGljaQBldGFjaQBsYWNpAGNvdGgAbW9udGgAanNvbl9hcnJheV9sZW5ndGgAb3ZlcmZsb3cgbGlzdCBsZW5ndGgAd2R0aABzdGF0X3B1c2gAYWNvc2gAYXNpbmgAYXRhbmgAanNvbl9wYXRjaABkYXRhdHlwZSBtaXNtYXRjaABhcmd1bWVudCB0eXBlIG1pc21hdGNoAGFiYnJldmlhdGVkIHF1ZXJ5IGFsZ29yaXRobSBzZWFyY2gAdW5peGVwb2NoAHNxbGl0ZV9hdHRhY2gAc3FsaXRlX2RldGFjaABqc29uX2VhY2gAYXZnAG5hcmcAc3FsaXRlX2xvZwBzdGF0ZW1lbnQgdG9vIGxvbmcAY2Fubm90IG9wZW4gJXMgY29sdW1uIGZvciB3cml0aW5nAHN1YnN0cmluZwBTdHJpbmcAc3FsaXRlX3JldHVybmluZwBlbmNvZGluZwBzdHJpbmcgb3IgYmxvYiB0b28gYmlnAFJlbGVhc2VSZWcAJS4xNmcAJSEuMTVnAHNzZW5sdWYAcHJpbnRmAHR5cGVvZgBtb2Rlb2YAb3V0IG9mAHJlbmFtZSBjb2x1bW5zIG9mAG51bGxpZgBpaWYAb2ZmADAxMjM0NTY3ODlhYmNkZWYASWYAJTA2LjNmACUuKmYAZ2V0cGFnZXNpemUAZG9jc2l6ZQBtbWFwX3NpemUAZGVmYXVsdF9jYWNoZV9zaXplAFBSQUdNQSAlUS5wYWdlX3NpemUAZnRzM3Rva2VuaXplAG9wdGltaXplAGpzb25fcmVtb3ZlAE1vdmUAY2Fubm90IGNvbW1pdCAtIG5vIHRyYW5zYWN0aW9uIGlzIGFjdGl2ZQBjYW5ub3Qgcm9sbGJhY2sgLSBubyB0cmFuc2FjdGlvbiBpcyBhY3RpdmUAZXhjbHVzaXZlAHRydWUASXNUcnVlAHVuaXF1ZQBkZmx0X3ZhbHVlAENhbm5vdCBhZGQgYSBSRUZFUkVOQ0VTIGNvbHVtbiB3aXRoIG5vbi1OVUxMIGRlZmF1bHQgdmFsdWUAQWdnVmFsdWUAanNvbl9xdW90ZQBwd3JpdGUAT3BlbldyaXRlAG9uX2RlbGV0ZQBzZWN1cmVfZGVsZXRlAElkeERlbGV0ZQBwcml2YXRlAGFnZ3JlZ2F0ZQBWQ3JlYXRlAG9uX3VwZGF0ZQBWVXBkYXRlAGN1cnJlbnRfZGF0ZQBmYWxsb2NhdGUAZnRydW5jYXRlAHJlcGxpY2F0ZQBiYWQgcGFyYW1ldGVyIG9yIG90aGVyIEFQSSBtaXN1c2UAdG9vIG1hbnkgdGVybXMgaW4gJXMgQlkgY2xhdXNlAHRvbyBtYW55IHRlcm1zIGluIE9SREVSIEJZIGNsYXVzZQBhZ2dyZWdhdGUgZnVuY3Rpb25zIGFyZSBub3QgYWxsb3dlZCBpbiB0aGUgR1JPVVAgQlkgY2xhdXNlAFBBUlRJVElPTiBjbGF1c2UAYSBOQVRVUkFMIGpvaW4gbWF5IG5vdCBoYXZlIGFuIE9OIG9yIFVTSU5HIGNsYXVzZQBkYXRhYmFzZSAlcyBpcyBhbHJlYWR5IGluIHVzZQBBZ2dJbnZlcnNlAHJldmVyc2UAY2xvc2UAQ2xvc2UAZmFsc2UAYXR0ZW1wdCB0byB3cml0ZSBhIHJlYWRvbmx5IGRhdGFiYXNlAGNvcnJ1cHQgZGF0YWJhc2UAYXR0YWNoZWQgZGF0YWJhc2VzIG11c3QgdXNlIHRoZSBzYW1lIHRleHQgZW5jb2RpbmcgYXMgbWFpbiBkYXRhYmFzZQBmaWxlIGlzIG5vdCBhIGRhdGFiYXNlAHRlbXBfc3RvcmUAJXMgY2xhdXNlIHNob3VsZCBjb21lIGFmdGVyICVzIG5vdCBiZWZvcmUARXhwaXJlAHNxdWFyZQBleHByX2NvbXBhcmUAU29ydGVyQ29tcGFyZQBzdWJ0eXBlAENsclN1YnR5cGUAanNvbl90eXBlAElzTnVsbE9yVHlwZQBJZk5vSG9wZQBpbHRuZQB1bml4LW5vbmUASW5pdENvcm91dGluZQBFbmRDb3JvdXRpbmUAaWNuZQBsb2NhbHRpbWUAc3RyZnRpbWUAZGF0ZXRpbWUAY3VycmVudF90aW1lAHRuZW1lAGFmdGVyIHJlbmFtZQBub24tdGV4dCBmaWxlbmFtZQBWUmVuYW1lAGFtYmlndW91cyBjb2x1bW4gbmFtZQB0ZW1wb3JhcnkgdHJpZ2dlciBtYXkgbm90IGhhdmUgcXVhbGlmaWVkIG5hbWUAc2ltcGxlAGxvd2VyX3F1YXJ0aWxlAHVwcGVyX3F1YXJ0aWxlAHVuaXgtZG90ZmlsZQBjYW5ub3Qgb3BlbiBmaWxlAHVuYWJsZSB0byBvcGVuIGRhdGFiYXNlIGZpbGUAaW1tdXRhYmxlAEFib3J0YWJsZQBsZWdhY3lfYWx0ZXJfdGFibGUAc3FsaXRlX3JlbmFtZV90YWJsZQBjYW5ub3QgY3JlYXRlIHRyaWdnZXIgb24gc3lzdGVtIHRhYmxlAHZpcnR1YWwgdGFibGUAbm8gc3VjaCB0YWJsZQBudW1iZXIgb2YgY29sdW1ucyBpbiBmb3JlaWduIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHJlZmVyZW5jZWQgdGFibGUAbG9jYWwgdGltZSB1bmF2YWlsYWJsZQBhbm90aGVyIHJvdyBhdmFpbGFibGUAbm8gbW9yZSByb3dzIGF2YWlsYWJsZQBWYXJpYWJsZQBEcm9wVGFibGUAdXRmMTZsZQBVVEYxNmxlAFVURi0xNmxlAGNhc2Vfc2Vuc2l0aXZlX2xpa2UAU2V0Q29va2llAFJlYWRDb29raWUAY2FjaGUAY29sdW1uIGluZGV4IG91dCBvZiByYW5nZQBub3RpZmljYXRpb24gbWVzc2FnZQB3YXJuaW5nIG1lc3NhZ2UAaW52YWxpZCByb290cGFnZQBFeHRlbmRzIG9mZiBlbmQgb2YgcGFnZQBqc29uX3RyZWUAQ3JlYXRlQnRyZWUAZGVlAGpvdXJuYWxfbW9kZQBsb2NraW5nX21vZGUAb3Bjb2RlAHVuaWNvZGUASm91cm5hbE1vZGUARGl2aWRlAGNvYWxlc2NlAHNxbGl0ZV9zZXF1ZW5jZQBTZXF1ZW5jZQBkaWZmZXJlbmNlAHZhcmlhbmNlAE9uY2UAVHJhY2UAanNvbl9yZXBsYWNlAHV0ZjE2YmUAVVRGMTZiZQBVVEYtMTZiZQBOZQBMZQBHZQAyMGM6MjBlADIwYjoyMGUAJSEuMjBlAGdldGN3ZABNYWtlUmVjb3JkAHRoc3RuZHJkAGxpa2VsaWhvb2QAZmNobW9kAHJvdW5kAE5vdEZvdW5kAFJld2luZABTZWVrRW5kAEJpdEFuZABvbGQAJWxsZCAlbGxkAG5vIHN1Y2ggcm93aWQ6ICVsbGQAcmVidWlsZABZaWVsZABsYXN0X2luc2VydF9yb3dpZAAlcy5yb3dpZABTRUxFQ1QqRlJPTSIldyIuJXMgT1JERVIgQlkgcm93aWQAU0VMRUNUKkZST00iJXciLiVzIFdIRVJFICVzIE9SREVSIEJZIHJvd2lkAElkeFJvd2lkAE5ld1Jvd2lkAFNlZWtSb3dpZABnZXRldWlkAGludmFsaWQAanNvbl92YWxpZABma2lkAF9fbGFuZ2lkACV6LCBsYW5naWQAbGFuZ3VhZ2VpZABkb2NpZABhcHBsaWNhdGlvbl9pZABzcWxpdGVfc291cmNlX2lkAG5vdCBhdXRob3JpemVkAEluZGV4IG9wdGltaXplZABub3RpbmRleGVkAHVuYWJsZSB0byBpZGVudGlmeSB0aGUgb2JqZWN0IHRvIGJlIHJlaW5kZXhlZAB2aWV3cyBtYXkgbm90IGJlIGluZGV4ZWQAdmlydHVhbCB0YWJsZXMgbWF5IG5vdCBiZSBpbmRleGVkAHRhYmxlICVzIG1heSBub3QgYmUgaW5kZXhlZAByZWFkX3VuY29tbWl0dGVkAHJlY3Vyc2l2ZSBhZ2dyZWdhdGUgcXVlcmllcyBub3Qgc3VwcG9ydGVkAHF1ZXJ5IGFib3J0ZWQAcm93cyBpbnNlcnRlZABpbnRlcnJ1cHRlZABjaGVja3BvaW50ZWQAYWNjZXNzIHRvICV6IGlzIHByb2hpYml0ZWQAYWNjZXNzIHRvIHZpZXcgIiVzIiBwcm9oaWJpdGVkAHJvd3MgZGVsZXRlZABnZW5lcmF0ZWQAcm93cyB1cGRhdGVkAG5vdHVzZWQAcm93IHZhbHVlIG1pc3VzZWQAc3FsaXRlX2NvbXBpbGVvcHRpb25fdXNlZABQYWdlICVkIGlzIG5ldmVyIHVzZWQAQ29sdW1uc1VzZWQAc3RvcmVkAHZpcnR1YWwgdGFibGVzIG1heSBub3QgYmUgYWx0ZXJlZAB2aWV3ICVzIG1heSBub3QgYmUgYWx0ZXJlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGFsdGVyZWQAc2hhcmVkAGluZGV4IGFzc29jaWF0ZWQgd2l0aCBVTklRVUUgb3IgUFJJTUFSWSBLRVkgY29uc3RyYWludCBjYW5ub3QgYmUgZHJvcHBlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGRyb3BwZWQAdmlldyAlcyBpcyBjaXJjdWxhcmx5IGRlZmluZWQAdW5vcGVuZWQAZGF0YWJhc2UgZGlzayBpbWFnZSBpcyBtYWxmb3JtZWQAJXMgY29uc3RyYWludCBmYWlsZWQARk9SRUlHTiBLRVkgY29uc3RyYWludCBmYWlsZWQAbGFyZ2UgZmlsZSBzdXBwb3J0IGlzIGRpc2FibGVkAGZ0czN0b2tlbml6ZSBkaXNhYmxlZABkYXRhYmFzZSAlcyBpcyBsb2NrZWQAZGF0YWJhc2UgaXMgbG9ja2VkAGRhdGFiYXNlIHRhYmxlIGlzIGxvY2tlZABhdXRob3JpemF0aW9uIGRlbmllZABhY2Nlc3MgcGVybWlzc2lvbiBkZW5pZWQAdGFibGUgJVMgaGFzICVkIGNvbHVtbnMgYnV0ICVkIHZhbHVlcyB3ZXJlIHN1cHBsaWVkAHRlbXBvcmFyeSB0YWJsZSBuYW1lIG11c3QgYmUgdW5xdWFsaWZpZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBtb2RpZmllZABjb25mbGljdGluZyBPTiBDT05GTElDVCBjbGF1c2VzIHNwZWNpZmllZABubyB0YWJsZXMgc3BlY2lmaWVkAGRhdGFiYXNlIGlzIGFscmVhZHkgYXR0YWNoZWQAZGF0YWJhc2Ugc2NoZW1hIGhhcyBjaGFuZ2VkAGV4Y2x1ZGVkAFBvaW50ZXIgbWFwIHBhZ2UgJWQgaXMgcmVmZXJlbmNlZABSb3dTZXRBZGQARmlsdGVyQWRkAHByZWFkAFJvd1NldFJlYWQAT3BlblJlYWQAJTA0ZAAlMDNkACUwMmQANDBmLTIxYS0yMWQAc3FsaXRlX3N0YXQlZABjb2x1bW4lZABzcWxpdGVfYXV0b2luZGV4XyVzXyVkAHZhcmlhYmxlIG51bWJlciBtdXN0IGJlIGJldHdlZW4gPzEgYW5kID8lZABGYWlsZWQgdG8gcmVhZCBwdHJtYXAga2V5PSVkAHVuYWJsZSB0byBnZXQgdGhlIHBhZ2UuIGVycm9yIGNvZGU9JWQAT2Zmc2V0ICVkIG91dCBvZiByYW5nZSAlZC4uJWQAayglZABVUERBVEUgJVEuc3FsaXRlX21hc3RlciBTRVQgcm9vdHBhZ2U9JWQgV0hFUkUgIyVkIEFORCByb290cGFnZT0jJWQAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHR5cGU9JyVzJywgbmFtZT0lUSwgdGJsX25hbWU9JVEsIHJvb3RwYWdlPSMlZCwgc3FsPSVRIFdIRVJFIHJvd2lkPSMlZABVUERBVEUgJVEuc3FsaXRlX21hc3RlciBTRVQgdHlwZT0ndGFibGUnLCBuYW1lPSVRLCB0YmxfbmFtZT0lUSwgcm9vdHBhZ2U9MCwgc3FsPSVRIFdIRVJFIHJvd2lkPSMlZAB0b28gbWFueSBhdHRhY2hlZCBkYXRhYmFzZXMgLSBtYXggJWQAdG9vIG1hbnkgYXJndW1lbnRzIG9uICVzKCkgLSBtYXggJWQAZXhwZWN0ZWQgJWQgY29sdW1ucyBmb3IgJyVzJyBidXQgZ290ICVkAGF0dGVtcHQgdG8gb3BlbiAiJXMiIGFzIGZpbGUgZGVzY3JpcHRvciAlZABpbnZhbGlkIHBhZ2UgbnVtYmVyICVkAGZhaWxlZCB0byBnZXQgcGFnZSAlZAAybmQgcmVmZXJlbmNlIHRvIHBhZ2UgJWQAZnJlZWxpc3QgbGVhZiBjb3VudCB0b28gYmlnIG9uIHBhZ2UgJWQAYnRyZWVJbml0UGFnZSgpIHJldHVybnMgZXJyb3IgY29kZSAlZAAlcyBpcyAlZCBidXQgc2hvdWxkIGJlICVkACVyICVzIEJZIHRlcm0gb3V0IG9mIHJhbmdlIC0gc2hvdWxkIGJlIGJldHdlZW4gMSBhbmQgJWQAc3ViLXNlbGVjdCByZXR1cm5zICVkIGNvbHVtbnMgLSBleHBlY3RlZCAlZABJTiguLi4pIGVsZW1lbnQgaGFzICVkIHRlcm0lcyAtIGV4cGVjdGVkICVkACVzTElTVCBTVUJRVUVSWSAlZABSRVVTRSBMSVNUIFNVQlFVRVJZICVkACVzU0NBTEFSIFNVQlFVRVJZICVkAFJFVVNFIFNVQlFVRVJZICVkAElOREVYICVkAHRvbyBtYW55IEZST00gY2xhdXNlIHRlcm1zLCBtYXg6ICVkAHJ3YwB1dGMAZGVzYwBhc2MAY2hlY2twb2ludF9mdWxsZnN5bmMAZnVsbF9mc3luYwBjaGFyaW5kZXhGdW5jAHNxcnRGdW5jAGNvdEZ1bmMAcmlnaHRGdW5jAGxlZnRGdW5jAGFjb3NGdW5jAGZsb29yRnVuYwBwb3dlckZ1bmMAc3RyZmlsdGVyRnVuYwBwcm9wZXJGdW5jAHBhZHJGdW5jAGV4cEZ1bmMAYXNpbkZ1bmMAc2lnbkZ1bmMAYXRhbkZ1bmMAY2VpbEZ1bmMAcGFkbEZ1bmMAY290aEZ1bmMAYWNvc2hGdW5jAGFzaW5oRnVuYwBhdGFuaEZ1bmMAbG9nRnVuYwByYWQyZGVnRnVuYwByZXZlcnNlRnVuYwBQdXJlRnVuYwBzcXVhcmVGdW5jAGRpZmZlcmVuY2VGdW5jAGRlZzJyYWRGdW5jAHBhZGNGdW5jAGF0bjJGdW5jAGxvZzEwRnVuYwBlbmMAbnVtZXJpYwAxPT1hcmdjAFNxbEV4ZWMAcGFkYwAlLjRjJXMlLjE2YwBzcWxpdGUtc3JjL3NxbGl0ZS1hbWFsZ2FtYXRpb24tMzM5MDMwMC9leHRlbnNpb24tZnVuY3Rpb25zLmMAJXMvZXRpbHFzXyVsbHglYwB1bnJlY29nbml6ZWQgbWF0Y2hpbmZvIHJlcXVlc3Q6ICVjAEdvc3ViAGdsb2IAemVyb2Jsb2IAcmFuZG9tYmxvYgBCbG9iAGlsYgBpdGlsaWIAbWVtZGIAQVRUQUNIICVRIEFTIHZhY3V1bV9kYgByb3RhAGV2aXRhAGxhbm9pdGEAZXRhAFJvd0RhdGEAU29ydGVyRGF0YQBpY25hAHNxbGl0ZV90ZW1wX3NjaGVtYQBzcWxpdGVfc2NoZW1hAHdyaXRhYmxlX3NjaGVtYQB0cnVzdGVkX3NjaGVtYQBjb3JydXB0IHNjaGVtYQBQYXJzZVNjaGVtYQBpbGxhAGV6aWxhAGl0aWxhAG1zaWxhAHNxbGl0ZV8AcHJhZ21hXwBTUUxJVEVfAF9ST1dJRF8AJXMgYXQgbGluZSAlZCBvZiBbJS4xMHNdAGJpbmQgb24gYSBidXN5IHByZXBhcmVkIHN0YXRlbWVudDogWyVzXQBtYWxmb3JtZWQgTUFUQ0ggZXhwcmVzc2lvbjogWyVzXQBbJWRdAFtdAFswXQAkWwBMRUZULU1PU1QgU1VCUVVFUlkAQ09NUE9VTkQgUVVFUlkAQU5ZAGdlbmVyYXRlZCBjb2x1bW5zIGNhbm5vdCBiZSBwYXJ0IG9mIHRoZSBQUklNQVJZIEtFWQBBVVRPSU5DUkVNRU5UIGlzIG9ubHkgYWxsb3dlZCBvbiBhbiBJTlRFR0VSIFBSSU1BUlkgS0VZAGRvY2lkIElOVEVHRVIgUFJJTUFSWSBLRVkARk9SRUlHTiBLRVkAUklHSFQgUEFSVCBPRiBPUkRFUiBCWQBHUk9VUCBCWQBpaXNYAGlzaVgAQVVUT01BVElDIFBBUlRJQUwgQ09WRVJJTkcgSU5ERVgAQVVUT01BVElDIENPVkVSSU5HIElOREVYAC1taiUwNlg5JTAyWABTQ0FOIENPTlNUQU5UIFJPVwBWSUVXAGpzb25fb2JqZWN0KCkgbGFiZWxzIG11c3QgYmUgVEVYVABGSVJTVABMQVNUAEVYQ0VQVABOT1QAIElOVABJZHhMVABTZWVrTFQAU0VUIERFRkFVTFQATVVURVhfT01JVABDT01NSVQATElNSVQAUklHSFQASWR4R1QAU2Vla0dUAExFRlQARElTVElOQ1QAUkVTVFJJQ1QASU5URVJTRUNUAHRvbyBtYW55IHRlcm1zIGluIGNvbXBvdW5kIFNFTEVDVAB1bmtub3duIGpvaW4gdHlwZTogJVQlcyVUJXMlVAAtJVQAdG9vIG1hbnkgYXJndW1lbnRzIG9uIGZ1bmN0aW9uICVUAHVua25vd24gZGF0YWJhc2UgJVQAZm9yZWlnbiBrZXkgb24gJXMgc2hvdWxkIHJlZmVyZW5jZSBvbmx5IG9uZSBjb2x1bW4gb2YgdGFibGUgJVQAQ1JFQVRFIFZJUlRVQUwgVEFCTEUgJVQAaGV4IGxpdGVyYWwgdG9vIGJpZzogJXMlI1QAbm8gc3VjaCBmdW5jdGlvbjogJSNUAG5vdCBhdXRob3JpemVkIHRvIHVzZSBmdW5jdGlvbjogJSNUAERFRkFVTFRfUkVDVVJTSVZFX1RSSUdHRVJTAElOUwBFTkFCTEVfRlRTM19QQVJFTlRIRVNJUwBESVNBQkxFX0xGUwAlcyAlUwBubyBzdWNoIGluZGV4OiAlUwBjYW5ub3QgY3JlYXRlICVzIHRyaWdnZXIgb24gdmlldzogJVMAbm8gc3VjaCB0cmlnZ2VyOiAlUwBjYW5ub3QgY3JlYXRlIElOU1RFQUQgT0YgdHJpZ2dlciBvbiB0YWJsZTogJVMATUFURVJJQUxJWkUgJSFTAENPLVJPVVRJTkUgJSFTAFVTSU5HIElOREVYICVzIEZPUiBJTi1PUEVSQVRPUgBVU0lORyBST1dJRCBTRUFSQ0ggT04gVEFCTEUgJXMgRk9SIElOLU9QRVJBVE9SAE1VTFRJLUlOREVYIE9SAFNRTElURV9UTVBESVIAQUZURVIASU5URUdFUgBPUkRFUgBORUFSAERFTEVURSBGUk9NICVRLiVzIFdIRVJFICVzPSVRAG5hbWU9JVEgQU5EIHNxbD0lUQBERUxFVEUgRlJPTSAlUS5zcWxpdGVfc2VxdWVuY2UgV0hFUkUgbmFtZT0lUQAsIHguJVEAU0VMRUNUICogRlJPTSAlUS4lUQBVUERBVEUgIiV3Ii5zcWxpdGVfc2VxdWVuY2Ugc2V0IG5hbWUgPSAlUSBXSEVSRSBuYW1lID0gJVEAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gcHJpbnRmKCclJS4lZHMsICcsc3FsKSB8fCAlUSB8fCBzdWJzdHIoc3FsLDErbGVuZ3RoKHByaW50ZignJSUuJWRzJyxzcWwpKSkgV0hFUkUgdHlwZSA9ICd0YWJsZScgQU5EIG5hbWUgPSAlUQBTRVRVUABHUk9VUABSRUNVUlNJVkUgU1RFUABOYU4AbWFsZm9ybWVkIEpTT04ATk8gQUNUSU9OAE9NSVRfTE9BRF9FWFRFTlNJT04AVU5JT04AIExFRlQtSk9JTgBCRUdJTgAsYXJnIEhJRERFTgAsc2NoZW1hIEhJRERFTgBTQ0FOAERFRkFVTFRfQVVUT1ZBQ1VVTQAgTlVNAFJUUklNAENhbm5vdCBhZGQgYSBOT1QgTlVMTCBjb2x1bW4gd2l0aCBkZWZhdWx0IHZhbHVlIE5VTEwATk9UIE5VTEwAU0VUIE5VTEwAU0VMRUNUIDEgRlJPTSAlUS4nJXFfc2VnbWVudHMnIFdIRVJFIGJsb2NraWQ9PyBBTkQgYmxvY2sgSVMgTlVMTABVTklPTiBBTEwAIFJFQUwAQ0hFQ0sAYWJvcnQgZHVlIHRvIFJPTExCQUNLAE1BVENIAFNFQVJDSABVU0lORwBFTkFCTEVfTk9STUFMSVpFACBVTklRVUUAREVMRVRFAFVQREFURQBSRUxFQVNFAE5PQ0FTRQBCRUZPUkUAQ1JFAE5PTkUASWR4TEUAU2Vla0xFAFRBQkxFADE2TEUASWR4R0UAU2Vla0dFACVzIFVTSU5HIFRFTVAgQi1UUkVFAENBU0NBREUAMTZCRQBBTkQAUk9XSUQAT0lEAERFU0MAU0VMRUNUIGlkeCwgc3RhcnRfYmxvY2ssIGxlYXZlc19lbmRfYmxvY2ssIGVuZF9ibG9jaywgcm9vdCBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsID0gPyBPUkRFUiBCWSBpZHggQVNDAFNFTEVDVCBpZHgsIHN0YXJ0X2Jsb2NrLCBsZWF2ZXNfZW5kX2Jsb2NrLCBlbmRfYmxvY2ssIHJvb3QgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCBCRVRXRUVOID8gQU5EID9PUkRFUiBCWSBsZXZlbCBERVNDLCBpZHggQVNDAFNFTEVDVCBsZXZlbCwgaWR4LCBlbmRfYmxvY2sgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCBCRVRXRUVOID8gQU5EID8gT1JERVIgQlkgbGV2ZWwgREVTQywgaWR4IEFTQwBTRUxFQ1QgaWR4IEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWw9PyBPUkRFUiBCWSAxIEFTQwBTWVNURU1fTUFMTE9DAEJMT0IAQkJCAFVQREFURSBPUiBGQUlMICVRLiclcV9zZWdkaXInIFNFVCBsZXZlbD0tMSxpZHg9PyBXSEVSRSBsZXZlbD0/IEFORCBpZHg9PwBVUERBVEUgJVEuJyVxX3NlZ2RpcicgU0VUIGlkeCA9ID8gV0hFUkUgbGV2ZWw9PyBBTkQgaWR4PT8AJXM9PwBTRUxFQ1QgJXMgV0hFUkUgcm93aWQ9PwBTRUxFQ1Qgc2l6ZSBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBkb2NpZD0/AFNFTEVDVCB2YWx1ZSBGUk9NICVRLiclcV9zdGF0JyBXSEVSRSBpZD0/AD8sPyw/AERFTEVURSBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsIEJFVFdFRU4gPyBBTkQgPwBTRUxFQ1QgbWF4KGxldmVsKSBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsIEJFVFdFRU4gPyBBTkQgPwBERUxFVEUgRlJPTSAlUS4nJXFfc2VnbWVudHMnIFdIRVJFIGJsb2NraWQgQkVUV0VFTiA/IEFORCA/AFVQREFURSAlUS4nJXFfc2VnZGlyJyBTRVQgc3RhcnRfYmxvY2sgPSA/LCByb290ID0gP1dIRVJFIGxldmVsID0gPyBBTkQgaWR4ID0gPwBTRUxFQ1QgaWR4LCBzdGFydF9ibG9jaywgbGVhdmVzX2VuZF9ibG9jaywgZW5kX2Jsb2NrLCByb290IEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgPSA/IEFORCBpZHggPSA/AERFTEVURSBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsID0gPyBBTkQgaWR4ID0gPwBERUxFVEUgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCA9ID8AU0VMRUNUIGNvdW50KCopIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgPSA/AFNFTEVDVCAlcyBXSEVSRSByb3dpZCA9ID8AREVMRVRFIEZST00gJVEuJyVxX2NvbnRlbnQnIFdIRVJFIHJvd2lkID0gPwBERUxFVEUgRlJPTSAlUS4nJXFfZG9jc2l6ZScgV0hFUkUgZG9jaWQgPSA/ACwgPwA8ZXhwcj4APGI+ADxiPi4uLjwvYj4ALT4+AC0+AHNlcGFyYXRvcnM9AHRva2VuY2hhcnM9AGF1dG9tZXJnZT0APABJTlNFUlQgSU5UTyAlUS5zcWxpdGVfbWFzdGVyIFZBTFVFUygnaW5kZXgnLCVRLCVRLCMlZCwlUSk7AENSRUFURSBUQUJMRSAlUS4nJXFfc2VnbWVudHMnKGJsb2NraWQgSU5URUdFUiBQUklNQVJZIEtFWSwgYmxvY2sgQkxPQik7AENSRUFURSBUQUJMRSAlUS4nJXFfZG9jc2l6ZScoZG9jaWQgSU5URUdFUiBQUklNQVJZIEtFWSwgc2l6ZSBCTE9CKTsAQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJVEuJyVxX3N0YXQnKGlkIElOVEVHRVIgUFJJTUFSWSBLRVksIHZhbHVlIEJMT0IpOwBDUkVBVEUgVEFCTEUgJVEuJyVxX3NlZ2RpcicobGV2ZWwgSU5URUdFUixpZHggSU5URUdFUixzdGFydF9ibG9jayBJTlRFR0VSLGxlYXZlc19lbmRfYmxvY2sgSU5URUdFUixlbmRfYmxvY2sgSU5URUdFUixyb290IEJMT0IsUFJJTUFSWSBLRVkobGV2ZWwsIGlkeCkpOwBVUERBVEUgJVEuc3FsaXRlX21hc3RlciBTRVQgdGJsX25hbWUgPSAlUSwgbmFtZSA9IENBU0UgV0hFTiB0eXBlPSd0YWJsZScgVEhFTiAlUSBXSEVOIG5hbWUgTElLRSAnc3FsaXRlWF9hdXRvaW5kZXglJScgRVNDQVBFICdYJyAgICAgIEFORCB0eXBlPSdpbmRleCcgVEhFTiAnc3FsaXRlX2F1dG9pbmRleF8nIHx8ICVRIHx8IHN1YnN0cihuYW1lLCVkKzE4KSBFTFNFIG5hbWUgRU5EIFdIRVJFIHRibF9uYW1lPSVRIENPTExBVEUgbm9jYXNlIEFORCAodHlwZT0ndGFibGUnIE9SIHR5cGU9J2luZGV4JyBPUiB0eXBlPSd0cmlnZ2VyJyk7AERST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9zZWdtZW50cyc7RFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX3NlZ2Rpcic7RFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX2RvY3NpemUnO0RST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9zdGF0JzslcyBEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfY29udGVudCc7AEFMVEVSIFRBQkxFICVRLiclcV9jb250ZW50JyAgUkVOQU1FIFRPICclcV9jb250ZW50JzsAQUxURVIgVEFCTEUgJVEuJyVxX3N0YXQnICBSRU5BTUUgVE8gJyVxX3N0YXQnOwBBTFRFUiBUQUJMRSAlUS4nJXFfc2VnbWVudHMnIFJFTkFNRSBUTyAnJXFfc2VnbWVudHMnOwBBTFRFUiBUQUJMRSAlUS4nJXFfc2VnZGlyJyAgIFJFTkFNRSBUTyAnJXFfc2VnZGlyJzsAQUxURVIgVEFCTEUgJVEuJyVxX2RvY3NpemUnICBSRU5BTUUgVE8gJyVxX2RvY3NpemUnOwA6bWVtb3J5OgBmaWxlOgBTdHJpbmc4AHV0ZjgAMjAyMi0wOS0wNSAxMTowMjoyMyA0NjM1ZjRhNjljOGMyYThkZjI0MmIzODRhOTkyYWVhNzEyMjRlMzlhMmNjYWI0MmQ4YzBiMDYwMmYxZTgyNmU4AFVURjgAVVRGLTgATUFYX0ZVTkNUSU9OX0FSRz0xMjcAREVGQVVMVF9TRUNUT1JfU0laRT00MDk2AERFRkFVTFRfUEFHRV9TSVpFPTQwOTYATUFYX1ZBUklBQkxFX05VTUJFUj0zMjc2NgBNQVhfUEFHRV9TSVpFPTY1NTM2AFVURjE2AFVURi0xNgBwNQB0b28gbWFueSByZWZlcmVuY2VzIHRvICIlcyI6IG1heCA2NTUzNQBzcWxpdGVfc3RhdDQAZnRzNABwNABERUZBVUxUX0ZJTEVfRk9STUFUPTQASW50NjQAcHdyaXRlNjQAcHJlYWQ2NABNQUxMT0NfU09GVF9MSU1JVD0xMDI0AHNxbGl0ZV9zdGF0MwBTQVZFUE9JTlQgZnRzMwBST0xMQkFDSyBUTyBmdHMzAFJFTEVBU0UgZnRzMwBwMwBFTkFCTEVfRlRTMwBNQVhfUEFHRV9DT1VOVD0xMDczNzQxODIzAHAyAGF0bjIAYXRhbjIAcmVtb3ZlX2RpYWNyaXRpY3M9MgBERUZBVUxUX1NZTkNIUk9OT1VTPTIAREVGQVVMVF9XQUxfU1lOQ0hST05PVVM9MgBhcmdjPT0zIHx8YXJnYz09MgBNQVhfREVGQVVMVF9QQUdFX1NJWkU9ODE5MgBTRUxFQ1QgdGJsLGlkeCxzdGF0IEZST00gJVEuc3FsaXRlX3N0YXQxAEFnZ1N0ZXAxAHJlbW92ZV9kaWFjcml0aWNzPTEAQVRPTUlDX0lOVFJJTlNJQ1M9MQBURU1QX1NUT1JFPTEAYXJnYz09MQB1bmljb2RlNjEAVVBEQVRFIE9SIEZBSUwgJVEuJyVxX3NlZ2RpcicgU0VUIGxldmVsPT8gV0hFUkUgbGV2ZWw9LTEAREVGQVVMVF9KT1VSTkFMX1NJWkVfTElNSVQ9LTEAU0VMRUNUIGxldmVsLCBjb3VudCgqKSBBUyBjbnQgRlJPTSAlUS4nJXFfc2VnZGlyJyAgIEdST1VQIEJZIGxldmVsIEhBVklORyBjbnQ+PT8gIE9SREVSIEJZIChsZXZlbCAlJSAxMDI0KSBBU0MsIDIgREVTQyBMSU1JVCAxAFNFTEVDVCAoU0VMRUNUIG1heChpZHgpIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgPSA/KSArIDEAU0VMRUNUJ0lOU0VSVCBJTlRPIHZhY3V1bV9kYi4nfHxxdW90ZShuYW1lKXx8JyBTRUxFQ1QqRlJPTSIldyIuJ3x8cXVvdGUobmFtZSlGUk9NIHZhY3V1bV9kYi5zcWxpdGVfc2NoZW1hIFdIRVJFIHR5cGU9J3RhYmxlJ0FORCBjb2FsZXNjZShyb290cGFnZSwxKT4wAFNFTEVDVCBzcWwgRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0ndGFibGUnQU5EIG5hbWU8PidzcWxpdGVfc2VxdWVuY2UnIEFORCBjb2FsZXNjZShyb290cGFnZSwxKT4wAHJlbW92ZV9kaWFjcml0aWNzPTAATUFYX1dPUktFUl9USFJFQURTPTAAREVGQVVMVF9XT1JLRVJfVEhSRUFEUz0wAE1BWF9NTUFQX1NJWkU9MABERUZBVUxUX01NQVBfU0laRT0wAFRIUkVBRFNBRkU9MAA5MjIzMzcyMDM2ODU0Nzc1ODAAREVGQVVMVF9QQ0FDSEVfSU5JVFNaPTIwAGxvZzEwAE1BWF9BVFRBQ0hFRD0xMABNQVhfQ09NUE9VTkRfU0VMRUNUPTUwMAA/MDAwAE1BWF9DT0xVTU49MjAwMABERUZBVUxUX0NBQ0hFX1NJWkU9LTIwMDAAREVGQVVMVF9XQUxfQVVUT0NIRUNLUE9JTlQ9MTAwMABNQVhfRVhQUl9ERVBUSD0xMDAwAE1BWF9UUklHR0VSX0RFUFRIPTEwMDAATUFYX0xJS0VfUEFUVEVSTl9MRU5HVEg9NTAwMDAATUFYX1ZEQkVfT1A9MjUwMDAwMDAwAE1BWF9MRU5HVEg9MTAwMDAwMDAwMABNQVhfU1FMX0xFTkdUSD0xMDAwMDAwMDAwAHNlY29uZCBhcmd1bWVudCB0byAlI1QoKSBtdXN0IGJlIGEgY29uc3RhbnQgYmV0d2VlbiAwLjAgYW5kIDEuMABDT01QSUxFUj1jbGFuZy0xNi4wLjAAL3Byb2Mvc2VsZi9mZC8AJVEuAE4uACQuAC0tACwAbm9za2lwc2NhbioAdW5vcmRlcmVkKgBzej1bMC05XSoAKHN1YnF1ZXJ5LSV1KQAoam9pbi0ldSkAQ1JFQVRFIFRBQkxFIHgodHlwZSB0ZXh0LG5hbWUgdGV4dCx0YmxfbmFtZSB0ZXh0LHJvb3RwYWdlIGludCxzcWwgdGV4dCkAQ1JFQVRFIFRBQkxFICVRLiVzKCVzKQBhdXRvbWF0aWMgaW5kZXggb24gJXMoJXMpAEFOWSglcykASU5TRVJUIElOVE8gJVEuJyVxX2NvbnRlbnQnIFZBTFVFUyglcykAQ1JFQVRFIFRBQkxFICVRLiclcV9jb250ZW50JyglcykAbWFsZm9ybWVkIGRhdGFiYXNlIHNjaGVtYSAoJXMpAE1FUkdFICglcykAQ1JFQVRFIFRBQkxFICVRLnNxbGl0ZV9zZXF1ZW5jZShuYW1lLHNlcSkAQ1JFQVRFIFRBQkxFIHgoaW5wdXQsIHRva2VuLCBzdGFydCwgZW5kLCBwb3NpdGlvbikAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX2Ryb3BfY29sdW1uKCVkLCBzcWwsICVkKSBXSEVSRSAodHlwZT09J3RhYmxlJyBBTkQgdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UpAG1lbWRiKCVwLCVsbGQpAEJhZCBwdHIgbWFwIGVudHJ5IGtleT0lZCBleHBlY3RlZD0oJWQsJWQpIGdvdD0oJWQsJWQpACVzKCVkKQB6ZXJvYmxvYiglZCkAbWF4IHJvb3RwYWdlICglZCkgZGlzYWdyZWVzIHdpdGggaGVhZGVyICglZCkARlRTIGV4cHJlc3Npb24gdHJlZSBpcyB0b28gbGFyZ2UgKG1heGltdW0gZGVwdGggJWQpAEV4cHJlc3Npb24gdHJlZSBpcyB0b28gbGFyZ2UgKG1heGltdW0gZGVwdGggJWQpAChibG9iKQBVU0UgVEVNUCBCLVRSRUUgRk9SICVzKERJU1RJTkNUKQBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX2NvbHVtbihzcWwsIHR5cGUsIG5hbWUsICVRLCAlUSwgJWQsICVRLCAlZCwgJWQpIFdIRVJFIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcgIEFORCAodHlwZSAhPSAnaW5kZXgnIE9SIHRibF9uYW1lID0gJVEpAENSRUFURSBUQUJMRSB4KGtleSx2YWx1ZSx0eXBlLGF0b20saWQscGFyZW50LGZ1bGxrZXkscGF0aCxqc29uIEhJRERFTixyb290IEhJRERFTikAQ1JFQVRFIFRBQkxFIHgodGVybSwgY29sLCBkb2N1bWVudHMsIG9jY3VycmVuY2VzLCBsYW5ndWFnZWlkIEhJRERFTikAQ1JFQVRFIFRBQkxFIHgoJXMgJVEgSElEREVOLCBkb2NpZCBISURERU4sICVRIEhJRERFTikAKE5VTEwpACVjPykAU0VMRUNUIE5PVCBFWElTVFMoU0VMRUNUIGRvY2lkIEZST00gJVEuJyVxX2NvbnRlbnQnIFdIRVJFIHJvd2lkIT0/KQBSRVBMQUNFIElOVE8gJVEuJyVxX3NlZ2RpcicgVkFMVUVTKD8sPyw/LD8sPyw/KQBSRVBMQUNFIElOVE8gJVEuJyVxX3N0YXQnIFZBTFVFUyg/LD8pAFJFUExBQ0UgSU5UTyAlUS4nJXFfZG9jc2l6ZScgVkFMVUVTKD8sPykALCVzKD8pAFJFUExBQ0UgSU5UTyAlUS4nJXFfc2VnbWVudHMnKGJsb2NraWQsIGJsb2NrKSBWQUxVRVMoPywgPykAU0VMRUNUIGNvYWxlc2NlKChTRUxFQ1QgbWF4KGJsb2NraWQpIEZST00gJVEuJyVxX3NlZ21lbnRzJykgKyAxLCAxKQBJTlNFUlQgSU5UTyB2YWN1dW1fZGIuc3FsaXRlX3NjaGVtYSBTRUxFQ1QqRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZSBJTigndmlldycsJ3RyaWdnZXInKSBPUih0eXBlPSd0YWJsZSdBTkQgcm9vdHBhZ2U9MCkAd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiBzbmlwcGV0KCkAbWlzdXNlIG9mIGFnZ3JlZ2F0ZTogJXMoKQBtaXN1c2Ugb2YgJXMgZnVuY3Rpb24gJSNUKCkAd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAlI1QoKQB1bnNhZmUgdXNlIG9mICUjVCgpAEZJTFRFUiBtYXkgbm90IGJlIHVzZWQgd2l0aCBub24tYWdncmVnYXRlICUjVCgpAHVua25vd24gZnVuY3Rpb246ICUjVCgpAG1pc3VzZSBvZiBhZ2dyZWdhdGU6ICUjVCgpAGFtYmlndW91cyByZWZlcmVuY2UgdG8gJXMgaW4gVVNJTkcoKQBVUERBVEUgdGVtcC5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX2NvbHVtbihzcWwsIHR5cGUsIG5hbWUsICVRLCAlUSwgJWQsICVRLCAlZCwgMSkgV0hFUkUgdHlwZSBJTiAoJ3RyaWdnZXInLCAndmlldycpAFVQREFURSBzcWxpdGVfdGVtcF9zY2hlbWEgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfdGFibGUoJVEsIHR5cGUsIG5hbWUsIHNxbCwgJVEsICVRLCAxKSwgdGJsX25hbWUgPSBDQVNFIFdIRU4gdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UgQU5EICAgc3FsaXRlX3JlbmFtZV90ZXN0KCVRLCBzcWwsIHR5cGUsIG5hbWUsIDEsICdhZnRlciByZW5hbWUnLCAwKSBUSEVOICVRIEVMU0UgdGJsX25hbWUgRU5EIFdIRVJFIHR5cGUgSU4gKCd2aWV3JywgJ3RyaWdnZXInKQAsJXMoeC4nYyVkJXEnKQBJTlNFUlQgSU5UTyAlUS5zcWxpdGVfbWFzdGVyIFZBTFVFUygndHJpZ2dlcicsJVEsJVEsMCwnQ1JFQVRFIFRSSUdHRVIgJXEnKQBTRUxFQ1QgMiAqIHRvdGFsKDEgKyBsZWF2ZXNfZW5kX2Jsb2NrIC0gc3RhcnRfYmxvY2spICAgRlJPTSAoU0VMRUNUICogRlJPTSAlUS4nJXFfc2VnZGlyJyAgICAgICAgIFdIRVJFIGxldmVsID0gPyBPUkRFUiBCWSBpZHggQVNDIExJTUlUID8gICkACikAQkxPT00gRklMVEVSIE9OICVTICgAU0VMRUNUIHNxbCBGUk9NICIldyIuc3FsaXRlX3NjaGVtYSBXSEVSRSB0eXBlPSdpbmRleCcAREVMRVRFIEZST00gJVEuc3FsaXRlX21hc3RlciBXSEVSRSBuYW1lPSVRIEFORCB0eXBlPSdpbmRleCcAbmFtZT0nJXEnIEFORCB0eXBlPSdpbmRleCcAREVMRVRFIEZST00gJVEuJyVxX2NvbnRlbnQnAERFTEVURSBGUk9NICVRLiclcV9zdGF0JwBERUxFVEUgRlJPTSAlUS4nJXFfc2VnbWVudHMnAERFTEVURSBGUk9NICVRLiclcV9zZWdkaXInAFNFTEVDVCA/IFVOSU9OIFNFTEVDVCBsZXZlbCAvICgxMDI0ICogPykgRlJPTSAlUS4nJXFfc2VnZGlyJwBTRUxFQ1QgbWF4KCBsZXZlbCAlJSAxMDI0ICkgRlJPTSAlUS4nJXFfc2VnZGlyJwBERUxFVEUgRlJPTSAlUS5zcWxpdGVfbWFzdGVyIFdIRVJFIG5hbWU9JVEgQU5EIHR5cGU9J3RyaWdnZXInAERFTEVURSBGUk9NICVRLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgdGJsX25hbWU9JVEgYW5kIHR5cGUhPSd0cmlnZ2VyJwB0YmxfbmFtZT0nJXEnIEFORCB0eXBlIT0ndHJpZ2dlcicAJyUuKnEnACV6LCAnYyVkJXEnAHR5cGU9J3RyaWdnZXInIEFORCBuYW1lPSclcScALCB4LiclcScAaW5kZXggJyVxJwBKU09OIHBhdGggZXJyb3IgbmVhciAnJXEnAERFTEVURSBGUk9NICVRLiclcV9kb2NzaXplJwBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3RhYmxlKCVRLCB0eXBlLCBuYW1lLCBzcWwsICVRLCAlUSwgJWQpIFdIRVJFICh0eXBlIT0naW5kZXgnIE9SIHRibF9uYW1lPSVRIENPTExBVEUgbm9jYXNlKUFORCAgIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcAU0VMRUNUIENBU0UgV0hFTiBxdWlja19jaGVjayBHTE9CICdDSEVDSyonIFRIRU4gcmFpc2UoQUJPUlQsJ0NIRUNLIGNvbnN0cmFpbnQgZmFpbGVkJykgRUxTRSByYWlzZShBQk9SVCwnTk9UIE5VTEwgY29uc3RyYWludCBmYWlsZWQnKSBFTkQgIEZST00gcHJhZ21hX3F1aWNrX2NoZWNrKCVRLCVRKSBXSEVSRSBxdWlja19jaGVjayBHTE9CICdDSEVDSyonIE9SIHF1aWNrX2NoZWNrIEdMT0IgJ05VTEwqJwBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3F1b3RlZml4KCVRLCBzcWwpV0hFUkUgbmFtZSBOT1QgTElLRSAnc3FsaXRlWF8lJScgRVNDQVBFICdYJyBBTkQgc3FsIE5PVCBMSUtFICdjcmVhdGUgdmlydHVhbCUlJwBVUERBVEUgdGVtcC5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3F1b3RlZml4KCd0ZW1wJywgc3FsKVdIRVJFIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcgQU5EIHNxbCBOT1QgTElLRSAnY3JlYXRlIHZpcnR1YWwlJScAc3FsaXRlXF8lACQAU0VMRUNUKkZST00iJXciAFNFTEVDVCByYWlzZShBQk9SVCwlUSkgRlJPTSAiJXciLiIldyIAQU5BTFlaRSAiJXciLiIldyIAZm9yZWlnbiBrZXkgbWlzbWF0Y2ggLSAiJXciIHJlZmVyZW5jaW5nICIldyIAZG91YmxlLXF1b3RlZCBzdHJpbmcgbGl0ZXJhbDogIiV3IgBzeW50YXggZXJyb3IgYWZ0ZXIgY29sdW1uIG5hbWUgIiUuKnMiACVjIiVzIgAoIiVzIgBjYW5ub3QgJXMgJXMgIiVzIgBnZW5lcmF0ZWQgY29sdW1uIGxvb3Agb24gIiVzIgBjYW5ub3QgSU5TRVJUIGludG8gZ2VuZXJhdGVkIGNvbHVtbiAiJXMiAGVycm9yIGluIGdlbmVyYXRlZCBjb2x1bW4gIiVzIgBjYW5ub3QgVVBEQVRFIGdlbmVyYXRlZCBjb2x1bW4gIiVzIgAlcyBpbiAiJXMiAFVQU0VSVCBub3QgaW1wbGVtZW50ZWQgZm9yIHZpcnR1YWwgdGFibGUgIiVzIgB1bnNhZmUgdXNlIG9mIHZpcnR1YWwgdGFibGUgIiVzIgBjYW5ub3QgY3JlYXRlIGEgVEVNUCBpbmRleCBvbiBub24tVEVNUCB0YWJsZSAiJXMiAG5vIHN1Y2ggaW5kZXg6ICIlcyIAdW5rbm93biBkYXRhdHlwZSBmb3IgJXMuJXM6ICIlcyIAY2Fubm90IGRyb3AgJXMgY29sdW1uOiAiJXMiAG5vIHN1Y2ggY29sdW1uOiAiJXMiAG5vIHN1Y2ggY29sdW1uOiAiJVQiAHVucmVjb2duaXplZCB0b2tlbjogIiVUIgB3ZWVrZGF5IABub24tdW5pcXVlIGVudHJ5IGluIGluZGV4IAB3cm9uZyAjIG9mIGVudHJpZXMgaW4gaW5kZXggACBtaXNzaW5nIGZyb20gaW5kZXggAHJvdyAAJXIgAHN0YXJ0IG9mIAAlZCAlZCAlZCAlZCAAIFVTSU5HIENPVkVSSU5HIElOREVYIABTRUxFQ1QgMSBGUk9NICIldyIuc3FsaXRlX21hc3RlciBXSEVSRSBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnIEFORCBzcWwgTk9UIExJS0UgJ2NyZWF0ZSB2aXJ0dWFsJSUnIEFORCBzcWxpdGVfcmVuYW1lX3Rlc3QoJVEsIHNxbCwgdHlwZSwgbmFtZSwgJWQsICVRLCAlZCk9TlVMTCAAU0VMRUNUIDEgRlJPTSB0ZW1wLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZSBOT1QgTElLRSAnc3FsaXRlWF8lJScgRVNDQVBFICdYJyBBTkQgc3FsIE5PVCBMSUtFICdjcmVhdGUgdmlydHVhbCUlJyBBTkQgc3FsaXRlX3JlbmFtZV90ZXN0KCVRLCBzcWwsIHR5cGUsIG5hbWUsIDEsICVRLCAlZCk9TlVMTCAAIFVTSU5HIABDUkVBVEUgAENSRUFURSBUQUJMRSAAIEFORCAAQ09SUkVMQVRFRCAAUFJBR01BIABQYWdlICV1OiAATWFpbiBmcmVlbGlzdDogAE9uIHBhZ2UgJXUgYXQgcmlnaHQgY2hpbGQ6IABPbiB0cmVlIHBhZ2UgJXUgY2VsbCAlZDogAC0tIAAleiVRLCAAIiV3IiAAQCAgACwKICAAKioqIGluIGRhdGFiYXNlICVzICoqKgoAAABkCgEQAABzAAQFAABnAAEDHgB6AAQGAABxAAQJAABRAAQKAAB3AAQOAABjAAAIAABvCAAAAAJ1CgAQAAB4EAAAEAFYEAAAAARmAAEBAABlAAECHgBFAAECDgBHAAEDDgBpCgEQAABuAAAEAAAlAAAHAABwEAANAAFUAAALAABTAAAMAAByCgEPAAAAAAAAAAAwMTIzNDU2Nzg5QUJDREVGMDEyMzQ1Njc4OWFiY2RlZgAteDAAWDAAQfbmAQvKA+A/mpmZmZmZqT97FK5H4Xp0P/yp8dJNYkA/LUMc6+I2Cj/xaOOItfjUPo3ttaD3xqA+SK+8mvLXaj46jDDijnk1PpXWJugLLgE+AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/wEAAAEBAAABAAEAAQEAAQAAAQAAfwAAAIAAAACBAAAABAUDBQEFAQUCBQIFAQUBBQQFAwUBBQEFAgUCBQEFAQUCBQMFAgUCBQIFAgUCBQIFBAUDBQIFAgUCBQIFAgUCBakAAABwAAAAHgAFAV4AAAFUAQAARgAAACo/WwAlXwABAEHJ6gELBQEBAQEBAEHg6gEL5QEBAIAAQAAAgAAAAAAAAAAADAwMDAwMDAwMDAAAAAAAAAAKCgoKCgoCAgICAgICAgICAgICAgICAgICAoAAAABAgCoqKioqKiIiIiIiIiIiIiIiIiIiIiIiIiIiAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAEEAwIFAEHQ7AELxgdSRUlOREVYRURFU0NBUEVBQ0hFQ0tFWUJFRk9SRUlHTk9SRUdFWFBMQUlOU1RFQUREQVRBQkFTRUxFQ1RBQkxFRlRIRU5ERUZFUlJBQkxFTFNFWENMVURFTEVURU1QT1JBUllJU05VTExTQVZFUE9JTlRFUlNFQ1RJRVNOT1ROVUxMSUtFWENFUFRSQU5TQUNUSU9OQVRVUkFMVEVSQUlTRVhDTFVTSVZFWElTVFNDT05TVFJBSU5UT0ZGU0VUUklHR0VSQU5HRU5FUkFURURFVEFDSEFWSU5HTE9CRUdJTk5FUkVGRVJFTkNFU1VOSVFVRVJZV0lUSE9VVEVSRUxFQVNFQVRUQUNIQkVUV0VFTk9USElOR1JPVVBTQ0FTQ0FERUZBVUxUQ0FTRUNPTExBVEVDUkVBVEVDVVJSRU5UX0RBVEVJTU1FRElBVEVKT0lOU0VSVE1BVENIUExBTkFMWVpFUFJBR01BVEVSSUFMSVpFREVGRVJSRURJU1RJTkNUVVBEQVRFVkFMVUVTVklSVFVBTFdBWVNXSEVOV0hFUkVDVVJTSVZFQUJPUlRBRlRFUkVOQU1FQU5EUk9QQVJUSVRJT05BVVRPSU5DUkVNRU5UQ0FTVENPTFVNTkNPTU1JVENPTkZMSUNUQ1JPU1NDVVJSRU5UX1RJTUVTVEFNUFJFQ0VESU5HRkFJTEFTVEZJTFRFUkVQTEFDRUZJUlNURk9MTE9XSU5HRlJPTUZVTExJTUlUSUZPUkRFUkVTVFJJQ1RPVEhFUlNPVkVSRVRVUk5JTkdSSUdIVFJPTExCQUNLUk9XU1VOQk9VTkRFRFVOSU9OVVNJTkdWQUNVVU1WSUVXSU5ET1dCWUlOSVRJQUxMWVBSSU1BUlkAAAAAAAAAAAIAAgAIAAkADgAQABQAFwAZABkAHQAhACQAKQAuADAANQA2ADsAPgBBAEMARQBOAFEAVgBaAFoAXgBjAGUAaQBvAHcAewB7AHsAfgCBAIQAiQCOAJIAkwCYAJwAoACoAK4AtQC4ALgAuwC9AMMAxgDOANMA2ADbAN4A4gDsAO8A9AD0APgA/AADAQkBDwEVARUBGwEcASABJwErATIBOAFEAU0BTwFVAVoBXAFjAWcBcgF5AXoBgQGHAY0BkgGYAZwBnwGoAa0BsQG3AbkBvAHFAccByQHSAdYB3AHiAeoB7wHvAe8B/wEIAgsCDwIUAhsCIAIpAi0CMAI1AjcCOwJDAkkCTAJVAloCYgJiAmYCbwJ0AnkCfwKCAoUCiAKKAo8CkwIAQaD0AQuTAQcHBQQGBAUDBgcDBgYHBwMIAgYFBAQDCgQHBgkEAgYFCQkEBwMCBAQGCwYCBwUFCQYKBAYCAwcFCQYGBAUFCgYFBwQFBwYHBwYFBwMHBAcGDAkEBgUEBwYMCAgCBgYHBgQFCQUFBgMECQ0CAgQGBggFEQwHCQQEBgcFCQQEBQIFCAYECQUIBAMJBQUGBAYCAgkDBwBBwPUBC8UD6gMAAABAAADrAwAAAAAEAPcDAAAAAACA7AMAAAAAQADtAwAAAAABAO4DAAAACAAA7wMAAAAAgADwAwAAAAAAAfEDAAAAAAAC8gMAAAAAABDzAwAAAQAACPQDAAAAAAAE9gMAAAAAACD1AwAAAAAAQPgDAAACAAAA+QMAAIAAAAAAypo7AMqaO9AHAADoAwAA9AEAAICy5g5/AAAACgAAAFDDAAD+fwAA6AMAAAAAAAADAAAAggAAAIMAAACEAAAAhQAAAIYAAACHAAAAiAAAAIkAAACKAAAAiwAAAIwAAACNAAAAjgAAAI8AAACQAAAAkQAAAJIAAACTAAAAAwAAAKoAAACDAAAAhAAAAIUAAACGAAAAhwAAAKsAAACsAAAArQAAAIsAAACMAAAAjQAAAAAAAACPAAAAkAAAAJEAAACSAAAAkwAAAAEAAACuAAAAgwAAAIQAAACFAAAAhgAAAIcAAACvAAAAsAAAALEAAACLAAAAjAAAAI0AAAAAAAAAjwAAAJAAAACRAAAAkgAAAJMAAAADAAAAsgAAALMAAAC0AAAAtQAAALYAAAC3AAAAuAAAALgAAAAAAAAAuQAAAAAAAAC6AEGY+QELBbsAAAC8AEGo+QELGQEAAAC9AAAAvgAAAL8AAADAAAAAwQAAAMIAQfT5AQsI2dUF+SChY9cAQaD6AQtWU1FMaXRlIGZvcm1hdCAzAAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fAAECAwQFBgcICQoLDA0ODwABAgMEBQYHAAECAwABAABCSU5BUlkAQYD7AQumBhFSAABqVwAAn0wAAM5MAACcCQAANgsAAIsnAACRCQAAYDYAADkqAAA0IgAAmDAAAMwkAACuQwAAITMAAHY3AADjCgAAUiQAAKk2AAD7LgAANgkAAPsyAACjBgAAOAkAAK9GAACSTAAAqkwAAOZGAADXKQAACDMAAH0MAAAtNwAAMDcAAPY3AADCDQAA5ggAAHYiAAD1CAAA+wgAADY3AADBBwAAFwcAAM0HAACMTAAA4EYAAKlGAACkTAAAKCQAAEg3AABaPQAAyQgAAMAqAAAkJQAAuhEAADwrAAArKwAA2jYAADskAAAMDQAA3TYAAAkNAADgNgAANyQAAA0lAAAXJQAANSoAAMwHAAA1IgAAMQsAAMVCAACDJgAAiSUAAC8zAABOKwAAGwsAAHsjAABBWAAAVS4AAH0lAABUKwAAMysAAM1DAABaNQAAcS8AANkEAADYBAAA0AQAAKgsAACZBgAALyQAAGIqAAAZBAAA6wgAAJcnAADWMgAA2S8AAEMrAADaCwAAeSkAALAsAAAdBAAAATcAAGkJAACkNQAAmjUAAP0FAABFNwAAJSQAANALAADACwAAUD0AALMMAADnBAAAbDYAAJsjAAACDQAAZT0AAEgwAAAvCQAARSQAALkFAAD/VgAArysAAOEpAADUCAAAayUAAOMxAAAsOgAABSoAAI8LAACMNgAA7TcAABwJAABqKwAAbTAAAGQJAADQMgAAGUQAABFEAAD6NwAApQYAAD03AAAMCQAAFgkAAGowAAAWLAAA5DcAAAssAADfBAAAHyQAAOchAAAnNgAAJEMAAHhEAABuEwAAYzUAAO8FAADwKwAAoiIAALosAABAPQAAyCoAAPMhAAAPBgAAgwsAAMoxAACAJAAAelkAAC0wAAC9KwAAtTIAAEUsAAAqLAAAUCwAALQpAACGMAAA3gQAAOwpAAAOKgAAeCkAAI8zAAA8CQAArQoAAOYyAABKPQAArjYAAAIKAACNLgAATSQAAMApAABFNAAAAAAAALRLAABYTAAAF0wAANhFAAAAAAAAAQIAAgIAAQIBAQECAQIQAAICAEGxgQILgwEBAgMEBggIAAAAAAAAAQECAgMDBAQFBQYGBwcICAkJCgoLCwwMDQ0ODg8PEBARERISExMUFBUVFhYXFxgYGRkaGhsbHBwdHR4eHx8gICEhIiIjIyQkJSUmJicnKCgpKSoqKyssLC0tLi4vLzAwMTEyMjMzNDQ1NTY2Nzc4ODk5EEACQABBwIICCzWlRgAAEkwAAIlGAACRTgAAAkwAAAABAgMEBggAAAAAAHYzAACnKAAAFykAACEAIAAeABwAGgBBgIMCCyFjMAAAKggAAOYuAAC4MAAAogQAAJErAAABAQMABQAGAAgAQbiDAgsBAQBB0IMCC5MEHRwcHBwcHBwcBwccBwccHBwcHBwcHBwcHBwcHBwcHBwHDwgFBBYYCBESFRQXCxoQAwMDAwMDAwMDAwUTDA4NBgUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQACAgkcHBwCCAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAICHAocGRwbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxseGxsbGxsbGxsbGxsbGxsbG1RchlJpHQAAXgBVSAA1I1YPACphNlmHEwAAjAAogQAWawAJAAB7UABOBgBBZ5MAiHMAADAAWhgAEQAbRhcaBTyObnoASVtHkT14SgAxAAspAHEAAABtCm90fQ4yfABkABJ5kDiCi1hTJR5+AABsM4OAACIAAIQAYiYnABQtdV0AYnShJzopfEMhhD4/LwJBoyYYihB2nwuDoFuAFRUrMlINiV4zE0J5L4gGHHN2okcJFHeXRUSCTVlfKJMvBXZ9ewMaUXYOIDCYXJIjH3idcRFkCI9/LgQeRmEHjC2Bi1BgnpVIGx1jLIVXfg8xJDwKJXZkZFVYKlSmSVNWjnaUEpFKXaWWdgxMS1qGkE5PpD0iQId6AEH0hwILNAQAKwAAanIAAAACAACPAAAADQAAAACNAAB3NAAAiQwAAD4AigCFAAAkAAAcTQAAAAA7AC8AQbKIAgsmRQAAAAAAkgMAOgABSwAAAB8AAAAAAH8AaABAQj8AAAAAAC4AEAgAQeKIAgshUWUAcBUHQwBPYHYAAEQAAGMsADcATABfICE5GQBmAABXAEGUiQILnQEQAAEAAQEBAwMBAQMDAwESCQkJCQEJCQkJCQkBAQEBAQEBAQEBAQEmJiMLAQEDAwMLCwsLCwsBAwMBAQEBAAACAggAEBAQABAAEBAAABAQAAAAAgICAAASHiAAAAAAEBAAACYmJiYmJiYmJiYAABIAABAAAAAAAAAAABAQAAAAAAAAABAAAAQEAAAQABAAABAAAAAAABAAAAYQAAQaAEG+igILBhAAABAQAgBB0IoCCy4LJAAAUTYAAIBZAADSWAAAqVgAAChYAADsVwAAUAoAAGI4AAAWCgAA4jkAAHcrAEGIiwILKcMAAADEAAAAxQAAAAAAAADGAAAAxwAAAMgAAADJAAAAygAAAMsAAADMAEHgiwILBkELAAABEABB8IsCCxZFOAAAAhQAAAgAAAAAAAAAFioAAAOVAEGQjAILJscFAAAEFAAAAIAAAAAAAADjBwAABRA4AQAAAAAAAAAAMC8AAAaVAEHAjAILBl4rAAAHlABB0IwCCwaGNQAACAIAQeCMAgs2iCwAAAQUAAAAACAAAAAAALhBAAAEFAAAEAAAAAAAAABcCAAACRAmAgAAAAAAAAAAwBEAAAoQAEGgjQILZqYVAAAEFAAAAAAAAAEAAABdKAAAAhgAAA8AAAAAAAAAawgAAAwQLwMAAAAAAAAAACgvAAANlTcBAAAAAAAAAAAPDQAABBQAAAAACAAAAAAAVxMAAAQUAAAAAQAAAAAAAG0uAAAOFABBkI4CCzZqLAAAD3ErBAAAAAAAAAAAMggAABBhAAgAAAAAAAAAABUNAAAEFAAAAEAAAAAAAABGCQAAAhgAQdCOAgs2GBQAAAQUAAAEAAAAAAAAAMNBAAAEFAAACAAAAAAAAABOCAAAERAbBgAAAAAAAAAAYAsAABIQAEGQjwILFswNAAAEFAAAAAIAAAAAAAAiKgAAEwMAQbCPAgs2VSUAABRhFQMAAAAAAAAAAEMIAAAVYSYFAAAAAAAAAAAzJQAAFGEVBgEAAAAAAAAAWiwAABZxAEHwjwILBjc2AAAXkQBBgJACCwZwCwAAGJAAQZCQAgsWTzQAAAQUAAAAAAAEAAAAAEQ2AAAakABBsJACCwZVCQAAG5EAQcCQAgsFHi8AABwAQdCQAgsWeQgAAB0QCQEAAAAAAAAAAFwvAAAeIQBB8JACCwZZCQAAG5EAQYCRAgsGRS8AAB+UAEGQkQILJpcIAAAgEAkBAAAAAAAAAADwBAAABBQAAAAAEAAAAAAAfCwAABZxAEHAkQILRhQ5AAAEFAAAAAQAAAAAAAA9EAAABBQAAAAgAAAAAAAAKQ8AAAQUAAAAEAAAAAAAAGooAAACFAAAAQAAAAAAAABcMAAAIRAAQZCSAgsWBRQAAAQUAABAAAAAAAAAAGcEAAAiAgBBsJICCwZQCwAAIxAAQcCSAgsGVA0AACSVAEHQkgILNmAlAAAlYQgGAAAAAAAAAACMCAAAJiEPBgAAAAAAAAAAPyUAACVhCAcBAAAAAAAAAIAyAAAnFABBkJMCCwYrBAAAKAQAQaCTAgsG9BUAACkQAEGwkwILJVpEAAAEFAAAgAAAAAAAAABBKAAAAhQAAAYAAAAAAAAAbwkAACoAQeCTAguHAoIJAAArATIDAAAAAAAAAABKRAAABBQAAAEAAAgAAAAAYjgAACskAAAQNQAAUCoAANMkAACOMAAAUjAAAKktAABBOAAA1jMAAPYyAAD5KgAA5y8AAPUrAADyKQAAcUQAANYzAAD2MgAA9CoAAHkgAAB2DAAALSUAAEE4AADWMwAAr0EAAFkrAAA1BQAA1jMAAIApAAD2MgAAEEMAAAYuAACAEwAAjSsAAPkFAABaLQAAywsAAHsTAAArJAAA1jMAAOAvAACtKQAA4ysAABA1AADeNwAAFgoAABs4AAArJAAA1jMAADY0AAAmBAAAEi4AAHc5AAB3MgAATQ0AADAvAADoBwAAAwIBAEH0lQILJzsAOwA7ADsAAAA7ADsAOwAAADsAOwA7ADsAAAAAAAAAOwAAAAAAOwBBpJYCCys7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAAAAAAAAAOwA7AEHolgILUTsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwBB8JgCC5QD//3//QD////+/v79+/r/AP3/APv+AP3+//4A/Pr+AAD+/fz8/P39+/78/P/+/fwA/wD+/v39/f7+///+/f4A/v4A//75+/v2AAD9AP7///z+APf8//38//3//v/39vz7//8AAPv9+/4AAP7+APv6+Pr6AP7//f/9+/3//v38/vwAAP3+AP37/f//AP7+AAD9AP4A/vz8+gD+AP7+/Pf7+f37+fgA/vT3+/j+/v8A/f3//f///fv//////fr7/Pr7//v9/f39/f39/f79+/79/fz6+/7+/v3//vv//vv9+/v8+/v8/gD/AAD9/wD99P8AAP37/QD+/P79/gD9+/r7+v7++/X//gD///0A/v3+/f3+9/j6/fz6/////Pr9AP7//f/9+vn6//j//PgA//3//v3//v36//3//fv7+vz7//4A/fr///7//v7+AP7+/v/+/v///P77//7///79AP/+/wD+//z+//////////4A/vz+/v3/AP/////+//8A////////////AP3/AP8AAP///f4A/P4AQZCcAgvWLHAGxQX4BEIBQgEBACcFxgXTBS0HLQctB9cBAAAAANYARQQtBy0HLQctBy0HLQctBy0HLQctBy0HLQctBw8BDwHDBMME2ABYAAEAAQABAAEAAQAoAG8AAgFpAdUBAAJHAm4CtQLcAiMDSgORAzEERQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRFBEUEWQRFBMAEvQO9A2MGfgbxBi0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HiQC1ALUAtQC1ALUAtQC1AF4ArgFCAEEAcABuARUCFQLkAu0EFQIVAk8ATwAVApwBnAGcAU0AnAF7AHEAcQAWABYAMggyCEgBSAFIAe8A1AHUAdQB1AH3A/cDmQFuAWkEogQVAhUCFQIVAhUCFQIVAhUCFQIVAhUCFQIVAhUCFQIVAhUCFQIVAhUCyQNtAm0CFQKCAhQDFAPMBMwENgM2A0MA+gQyCDIIMggyCDIIMggyCBsFugO6A0kC2AGAAoMBtwIaAh0CvAIVAhUCFQIVAhUCFQIVAhUCFQIVAt4AFQIVAhUCFQIVAhUCFQIVAhUCFQIVAhUCmwSbBJsEFQIVAhUCNQIVAhUCFQKUA3gEFQIVAggFFQIVAhUCFQIVAhUCFQIVAn8CMgXRADQENAQ0BDQERALRANEAIQUAA5UDiQKdBCQFlQEkBdYE+QCdBJ0E+QCdBJUB1gRZBdAB6wT0A/QD9ANYBVgFWAVYBbgAuAAuBYgDBwXIBbAGsAZhBmEG3QbdBmEGbwZzBvcG5Ab/Bv8G/wb/BmEGDgeNBnMGcwaNBvcG5AaNBuQGjQZhBg4HigbzBmEGDgcfB2EGDgdhBg4HHwfEBsQGxAYCBzAHMAcfB8QGygbEBgIHxAbEBqUGNAfeBt4GHwdhBv0G/QYPBw8HzgbYBlUHYQbPBs4G3wblBo0GVwdpB2kHegd6B3oHMggyCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDIIzwBHBEsBbAKHAyYDMgTLBZgFyQUqBVoFcgXrBQsFCgYLBhUGOwY+Bj8GmgWtBVIGtgUfBtEFbAZ2BlAGfAYMBg0GkgaVBj0G5gKVB5kHhwf7BpEHlAeOB5AHHQcSBygHkgeSB5YHHgebByAHnQewByQHMQeSBzIHeAeTB5IHIgeBB4IHhQeGBzoHSQecBzMHvge8B6wHUAcjB4gHsgeJB4MHpgc4B10HuQe/B8EHTwdYB8AHlwfCB8MHxAfGB5oHowfHB3cHxQfKB58HyAfMB1EHzgfQB9EH0gfTB9QHzweNB2IH2QfaB3YH1QfcB2QH2wfWB9cH2AfdB54HqgelB94HsQegB98H5wfqB+sH6QfsB+IHeQd7B+8H2wfxB/QH9Qf2B/cH+Af7BwMI/Af9B/4H/wcBCAIIAAiYB48HoQeiB6QHBAgHCAUIGQgaCMEAwQDBABIBEwEUAcEAEgETARQBwQDfANsA4QDOANIA0wDUAMEAEwDbAOkA2ADYANkA2ADZAMEAJwHYANkAHwDBANgA2QDBAOQA1QDmACcAzgDYANkAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAwQATALkAugC7ALwAvQC+AP0AEgETARQBwwDBAMUAwQAFARIBEwEUAf0AzADuAMwAUQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQASARMBFAEGAWYAZwBoAGkAagBrAGwAbQBuAG8AcABxAO8A8ADvAPAA0gDTANQAOgE7AToBOwA8AVYA/ABYAPwAEwA6ATsBAAEBAXEAGQBIACgBigCLAAoBZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAUQAkATsAJAEqAWwAbQBuAG8AcABxAEUAdAB1AHYASABqAGsAwQBvAHAAcQA2ADcAOAA5ADoAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAeAAZANgA2QCRAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAOcAigCLAHQAdQB2AKQAmQATAJsANgA3ADgAOQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQCAAIEALgAvADAAMQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQDYAMEAGQA7AMEAEwClAKYAwQBDABgAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEASQDYANkAOwDYANkAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAeQCRADsAwQB0AHUAdgB3ABEBzAB6AHsAfAATABQAhgAWAIgAiQATAIQAfwCAAIEAGAAWABcAdAB1AHYAJADBAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAO8A8AA3ATgB1wBqAGsA8QATADsA2ADZAN8A/ABzAHQAdQB2AJcAeAAaAEcAwQA0ATUBwQCVAIAAOQHYAA0BUQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQD9ANgA2QBkAF8AmQA7AJsABQFqAGsAGQDBAGUAwQDBAOcAcgAZAHQAdQB2AHEAMAF5AMEAzAA7AHcAeAB5AHoAewB8AH0A2ADZAMEA2ADZAIMAigCLAOYAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAmQCaAJsAnACdAO8A8AB0AHUAdgBMAMEAFwATABkAFgD9ABcA/AD9AGwAVwDMAFkABQHGAFwABQF0AHUAdgDBADIBMwHYANkAlgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA7AMEA2ADZABMA7wDwABsBFwBqAGsAbABtAG4AbwBwAHEASQD8AP0AjgA0ATUBigCLAFEAOQGRACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADMBZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAGQF0AHUAdgAdARcAwQAZAHcAOwDBAHoAewB8ADsAfwDLADsAzQATAAwBhAAZABcAFgDBAIoAiwD5AMwA+wBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQATABYAFwA7ABcAGQDvAPAAdAB1AHYAwQALAHQAdQB2AHQAdQB2APwADQEWAMEADwArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQARAY8AwQB2AI8AZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEATAB2ADsA8QB0AHUAdgAwAdgA2QAkAY8APABZAPEAEwBcAMEAwQAXABYANwE4AecAZQAWAI8AZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAEwDBAMEAOwAXAHQAdQB2ADsAyQAVAPEAMAEWAM4AfwCAAIEAwQCAAIEA6wDsADABKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAFgDBANgA2QDBAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAOcAwQDBAMEAdAB1AHYA2ADZAHQAdQB2AOIAUADBABMA6wDsADABFwDTANQA5wDMANgA2QDNAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ABMAwQB7AEwA7wDwAMEA/QDvAPAA7wDwAMEAagBrAMEAWQD8AMEAXAA7APwAjQD8ACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ABwBoQDYANkAwQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQDnAMEAEAC7ALwAvQC+AAcACAAJADUBwwAZAMUAOQETAH8AgACBAAYBzAAWAHUAGADYANkABwFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQDBAO8A8ADBADsAEwC8AP0AvgBNAOIATwDBAMMA/ADFAMEAEwAtAS4BwQDBAMwA2ADZAOIA2ADZAAoBzACfAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEADADvAPAA6AAqAe4AdQD9AO8A8ADuAAMBBAHBAPwAGwAfAMEAwQCOAMwA/ADBAMEAJwAGAcEAZAAKARYBKgDMAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHUAnwDYANkAeQDYANkAPwDBAMEAwQDvAPAAcwB0AMEAKgFJAO4A7gDnABMA7wDwAPwAFgAYANMA1AAYAMEA2ADZANgA2QD8AJkAmgCbAP0AEAATAJAA1QAMASsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AO4AEwA7AMEAOwArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQAWABcAwQAZAMEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAHAFNAMEATwBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQAeAcEAwQDBAHUAIwF1AOgAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAzAAWABcAQgAZANgA2QAjAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAMEADAFVAGUAwQA1ATUB8AATADkBOQFeANAA0QDBAO8A8ADBAEIA/AATAAwB9ADYANkAwQBKANUA/AChABMABwH+ACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQDBANgA2QAFADsAwQATAPQACgALAAwADQAOAGUANQERAJIA/gA5AcEAwQBMAHMA2ADZADUBDAAHAR4AOQEgAC4AVwAuAFkAggDBAFwAKAAWAAcBGwDYANkAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAKgCWACMB2ADZAHQAdQB2ABMAFADBABYARgAEAXQAwQAYAAgBwQAHAU4APwA9AFEAdAAkAMEABAHBAB0AwQAIAcEAIQCRAMEAOwAwANgA2QBiANgA2QDBAHMAwQBzAMEAOwDYANkA2ADZANgA2QDYANkA/wDYANkARwDBAIMAwQAZAEEA2ADZANgA2QDYANkA0ADRAFUAhQDBAGQAwQBaAIoAiwCKAIsA2ADZANgA2QDBAGQAwQBsAIcAdAB1AGoAawCMAHkA2ADZANgA2QByAKIAdAB1AHYAKwEsAXkA2ADZANgA2QDBAPQAwQCHAPQAwQAAAQEBjAD0AMEA/gDBAMEA/gCZAJoAmwCNAP4AlQCWAAIB2ADZANgA2QCZAJoAmwCcAJ0AAAABAAIA2ADZAAUAcwCeAMEAoAAKAAsADAANAA4AwQA7ABEAfgDBABMAFACBABYAwQAWABYAGADBABcAHgAZACAAEwAUAJAAFgAkANgA2QAoAMEA2ADZAMEAmACBANgA2QDBACQA2ADZAMEAYwDBAMEANQDBAMEAOwAXAMEAGQDYANkAwQDYANkAmABGADsARwA7AHUAwQDYANkATgDYANkAUQDYANkAPgFHAFUAwQCFAMEAwQBaABcAFwAZABkAeAB5AGIAVQDBAGQAwQAXAFoAGQB5AGoAawATANgA2QDYANkAZAByAIMAdAB1AHYAagBrAHkA2ADZANgA2QDBAHIAdQB0AHUAdgCFAMEAeQDBAMEAigCLAMEAFwDBABkAFwAXABkAGQAHAAgA2ADZAMEAwQCZAJoAmwCcAJ0A2ADZAMEAogDYANkA2ADZAJkAmgCbAJwAnQABAAIAwQDBAAUAEwAUADsAFgAKAAsADAANAA4AwQBhABEAwQAXAMEAGQAgASQAwQDyANgA2QDsABcAHgAZACAAEwAUABcAFgAZANgA2QAoANgA2QDYANkAwQA7ANgA2QDBACQAUwBUAJkAmQCbAJsAFwBHABkAFwDBABkAwQDBAMEAdQDBAMEAwQBGAMEAwQA7AMEA/wD/AB8BTgD/APMAUQC/AP8AKQFHAA8BZAAlAfUACwHWAPYAagBrAGwA9gAPAWIA9QAlAXIA3AB0AHUAdgALAQ8BeQAPAeEA2wDlANsAZADbAAMBAwEDAQMBagBrAPkAxAA8ABgBjQDzAHIA+QB0AHUAdgCFAPUAeQDIACkBigCLAJkAmgCbAJwAnQApAcgAJgATABQAlwAWAMgAlgCMACYBJgEWABABKwDqABIAogAOAcgAJADtAJkAmgCbAJwAnQDtABsB7QDtABIAxwCVAPYAEAEOARAByACeAPYA9gDqADsA6gD2AMcAIgE+ACEByADHABYA3QBzAEcAyADIAMcAxwDdANoA2gATABQAQAAWANoA4wAWAOAAfgDgAKUA3QAYADEByABxADgBJADaANwA2gBkABoB2gBbANoAPQFqAGsA3QDjABoBPQFSAJQAcgAJAXQAdQB2ADsAkQB5ABYAFQGeAMgACQEZAMoAkwD6AEcAFwENAJIAwgDCAPkA+AD6AIwA9wD2AAYAwADAAMAALwEvAdUAzwAsAdUAmQCaAJsAnACdANUA1QBkANUA3gDPANYA1gBqAGsABADeAM8AAwAWAKMAcgAPAHQAdQB2ABAAFwB5ABcAiwCXAIIAGQCOABAAGAAUAJAAAQCOAIIAggA9ADUANQAlAJcANQA1AIIAdAAiAAEAjQAFABYAcwChAI0AmQCaAJsAnACdABkARABEAEsAKQBzABgAgwAUABMAfQAWAGAAFgAWAEMAFwAWAEMAOwAYABYAHABDABcAFgAWAJUAFwAXABcAdAAXABkAJQBhAI0AFwAXABYAjwAZAEsAWAAiACIAIgAiAFYASwBdABcAIgAWACIAGQAYACIAGQAXAI4AFwCOACwAFwAXABcACwAXABkAFgAWABYADwAXABcAFgAWABkAAQABAI0AGQAXAIcAPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AY0AjQA/AY0APwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AQBB8MgCC+QgOALQADgCdgBzAOUAOAJ2AHMA5QA4AiIFeQENBZgBMgIyAjICOAKZAXoBIgX8BCkAKQApACkA0AD2BUcARwDLA6MBKQApAOsBLwEXAS8BzAONAUcARwB9AH4AUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfADcAZkB2QQBAAEAPwICAN0EJgJ2AHMA5QA9AeABkgDgAQwCdgBzAOUAEQIvBaEBCwKOAH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AHYAcwDlAEcBegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBHAEcARwBHAG6AboBugEfBngBIQaoBHcBiwQ1AosENQKZAR8GGQIDAeIAvAFlAJEAwQE8AS8C8AB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAF9AH4AUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfACOACYBqARTAcABeAB4AHgAdwB0ALwBfwCoBKkEqgSUALkBuAE4AncAdAC8AXwAfAB8AHwAdQB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAHGAXEADQANACICegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBpgE8AS8CqASpBKoElQDIBJkByAR8AHwAfAB8AHoAegB6AHoAeQB5AHgAeAB4AHcAdAC8AdEBVgENBA0EGwQeBH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AP8ECgLeAKgEOAKZAeAAAgKvAFIAUwB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAHvAxAAEACoBIUAhQB9AH4AUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfAB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAERBCICqAR1AagEqQSqBPwAmgWPAfgB9QH0AW8AMAI2AgQAngOeA7EB8wFUAcwBSAFoAYoB1QSoBKkEqgQzAjgCegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBHAEcAXEBLAZHBrkBuAGaAJkBvQFHAEcABgU1AsUEqASpBKoEVQDHBA8BLQIfAgMCGQY4AmIAxgQGAP4E2AGOAH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8ACYCDQANAAME+wHIBKgEyAQlAm0AbQDeADgC1gSvADgCqwFuAMUAvQE6AjkCrgEQBvkDRQEnAqgEDgEfAXAB/gFrAf0BAQFHAEcAHwJHAEcAZwE8AS8CTQZ6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAH5A/kD+wP8AxsAHAEcAagEqQSqBIYEOAJMBpkBhQO+ACYCZAE1AiYCqQMVAgUChgQEAp0BhgQoAqgEqQSqBDgCIAISBjMAMwDWAH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AKgE2gGHAIcAmQEcARwB0gX5AXkAeQB4AHgAeAB3AHQAvAHvAzUCBgLZAB0CGQY8AS8CjgAGABQCfQB+AFAAwQTBBBoEHQQQBBAEewB7AHwAfAB8AHwAEwZ6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAHlAagEqQSqBOIBGQHzBL0D/ACoBHUB+AH1AfQBqARUATsCqAQ7ApkBJAHzAb0DbAO/AOABPAEvAoABIgF8AXoAegB6AHoAeQB5AHgAeAB4AHcAdAC8AX0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AJkBigFwBKgEZQNkABwBHAGoBKkEqgR1AUUEqASpBKoEqASpBKoENQLHASAAdQHpAH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AJkFvwM4AuQAvgN6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAGGBOQAqASdAKgEqQSqBBEGDQANAC0BvQPQBIYEmQCZAYYEdQEvBpgEBQBxASwGrQHWBAMAvQN6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAF9AH4AUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfACZAdAANwKoBAQEqASpBKoEqASEAVQDmwAQBh4BkgFKBEoE6AE4AtEBVgEnBScFEAZ9AH4AUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfACBADgCDQANAHYBegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBLgE4AsUBEAKoBKkEqgQNAA0AqASpBKoEEQXPAfMEmQElBSUFEAb0A8UBxAHIACsBRwBHAPEEegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBfQB+AFAAwQTBBBoEHQQQBBAEewB7AHwAfAB8AHwAmQHjADEEhgQcARwBowE4ARYBFgEdAR0BiwWWAZUBfgGGBDUCOAKGBKwENQJABjUCfQB+AFAAwQTBBBoEHQQQBBAEewB7AHwAfAB8AHwAxQHKBQ0ADQAABnoAegB6AHoAeQB5AHgAeAB4AHcAdAC8AckAOAJiATIGPwICAN0ESANJA0oDGgY9AbwEkgAGAJkB/wD+AP0AzgAvBQkArAQGAUcARwCoAXoAegB6AHoAeQB5AHgAeAB4AHcAdAC8AX0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8ADgCHAEcATgCvQSZAT4COQHdBF0BEAVgAaMBPQE1ApIA6wENAmsGiwFzAesBLwVGAEYADwVHAEcA8AAtBWgAUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfAB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAFaBBwBHAGsAcAB9QW9BLcBHAEcAdEFSAU3AdoBNQJbBMsD6wHrAdkA7wQ1AgIGOALMA88AOAIDBPAAfwFcBAcCegB6AHoAegB5AHkAeAB4AHgAdwB0ALwB+gNrAEcARwD5Aw0ADQCQAzgC1wU4AhwBHAFhAA4C6wHAAZEDLgUqBSECmQEcARwBNQKXANEA1wXZBQYBwgE3ADcAOAA4ADUC+QP5A/sDuwFMAZkBDwIMACcBfQB+AFAAwQTBBBoEHQQQBBAEewB7AHwAfAB8AHwAWwGZAWAD/gW9BH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AHEEaQbaAWkGcwF9AHIAUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfADXBUkB2gFLAXoAegB6AHoAeQB5AHgAeAB4AHcAdAC8AcsAiwU4Ag4FYAPQAb0EtAF6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAEpAnEEagYbAmoGDwAPAHwDegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBOAIqARoCbwSLBRcGGAYzBZkBBgAGAJEE9ASfAUABHAEcAYsF/AE1Ag0CLAHJASsAKwA4An0DDAA1AkoB3gGpAZcBfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8ADgCOQA5ACABqASLBfABygGIAYgBhwERAYUBbwQWBlEDkQSXAQYAOAJBAYYE1gEsACwAFQZaBKoB6gAGAEMBAAEcAgABhgSvATgChgRCAREA5wFbBDoAOgB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAFcBNgA4QE7ADsAqASpBKoEbwAwAkQBBADsAMgBDgI4Au0AyAE4ArUBqAAsAqQBjQDfATMCOAIlATgCRwQ4AiUBOAJHBBMCOAJoAwgAPAA8AOsAPQA9ADgCngE4Ap4BOAK9AT4APgAtAC0ALgAuAC8ALwDHADEAMQAtAjgCZwE4AmQA5gEyADIAPwA/AEAAQAAxAp8BFwKaATgCAwQ4AhYCPAEvAjwBLwJBAEEADgAOADgCAwQ4AgACpANoA/oDbQBtAKMD+QNCAEIAgwCDAG4AwwG9AToCOQKgAbEA+QOEAIQAQwBDADgC0wE4AqQD1wFUBRsB4gCjAzsBUwWXATgCywGXAfkD+QP7A+8AlwFWANUARgU0ADQARABEAPkD+QP7A/wDGwAxBpwEvwFFAEUAIAFhAGwABQZqAIgBiAGHAREBhQE4Am8DUQNzAzgCbwAwAtIBBAA4ApgAHgAmADgCbATqAIwBQwFvADACDwIEADMCNQA1AEIBOAKjAKMAOAJRAdQBpACkAE0BMwJMAEwAOAIhAeoFOAIfAOkFOAK9AVIB4wFkADYANgBYAUgASAAoAewAOAQtAr0BbwNQBYYAhgCoAEkASQCNAKEAoQAmBi0CFwI4Aj8BOAJcARgC8QPZAQUBBQF7A3oD6wAXAjgCAwQ4AtsBFgIFAW8BbQBtAAkCiACIAIIAggADBG4AbgG9AToCOQJtAG0A+QOiAKIAnACcADgCbgA4BL0BOgI5ApoBXwH5AzgCYQE8AS8COAJXATgCZADxAWUBAgFkAIIDgwOMAIwAYwEeBfkD+QP7A/wDGwCLAIsAagHDAYkAiQCKAIoA+QP5A/sD/AMbAJwEvwE4AnQBIAFvADAC/QMEAIgBiAGHAREBhQE4AnUEUQM4AjQEOAICAewBMwI4AtMASwBLACsCwgPqAAUBQwFvADACoQMEAHEATQBNAEIBSgBKACoAKgBdBb0BMAAwAIoFMwLOA88DRARDBEQEQwReAy0ClgCiA0IFcQBOBSoCkAX9A/sE8gTmBOwA5QTnBL0BOQY/BTQBFAGoADUBCwCNAIkBNgHoAC0CfQUDBE8BIwF4BdsAUAFtAG0AqAMpAYIF6wBVAd0BbgD2Ab0BOgI5AnEFgQX5A5ABDQVtAd8AzgUDBM0FSwVMBUoFSQVtAG0AzAA8BtAELgIJAdoAbgDNAL0BOgI5ApoBgwH5A/0FswA8AS8C+QP5A/sD/AMbAOYA+wXNBE8AMAJVAAQAogHXACQCUQBUALwAfgWtALUAzQHDASMAzgEzArcA+QP5A/sD/AMbALgA0wW5ALoA7wHyAGIAjgGEBSQAgwXkAVsA1QGRAYYFvQHAAMgF9gDeBeoBWgEVAfgAxADtAf8BLQJeAegE+QD6AJMBIQUgBW8AMAKwAQQAHwUYBV0ASwZzA0oG4ACUAbIBCAIHAbMBKwYzAgMFAgVsAQMEMgEBBQgBSQYdBm0AbQByARcFMwEcBrYBgABuAGIFvQE6AjkCvQEiAvkDCgC6BWkAfQFhBSIAPAJjADgFLQI6AaIEEgIQARIBewHSADcFIwKBAYIBEwE9AuME3gSbAZwB7gWlALIA7wX5A/kD+wP8AxsA7QXsBQMETgCTAKYA3ADdAG0AbQBEAzABpwC+AdQAPgFuAOcAvQE6AjkCkABCBPkDQARGAbQAqQC8BLYATgHuAJMD8QBQBLsAqgCrAKUBVwBYAKcBvQBZAFoArABTBPMATwT0AJ4AEgD1AFkB9wD5A/kD+wP8AxsABQFIBMEAygTpAcIAJQBuAVMD7gH7AMMA+gFcABMA8gFmARQA9wFxA2kBXgB+AzEBnwABAicAXwCWBKAAIATGA3cEYACuAHYE4QAYARoBxgDAA3EAjASIBAQBFQAWABcAigSQBI8EfAQYACEAGQDKAB4CGgBkAC8EZgAhBGcABwAfBCMEWQQkBFgECgELARwAKACGAf4DXwNwAB0ANAKeBJ0EDAGwAI8AnQPaBNoE2gTaBNoE2gTaBNoE2gTaBNoE2gTaBNoEDQFCBtoEQQYAQeDpAguBCW8GbwZvBsMF2ARHBdgE2ATYBMMFwwXDBdgEZQVlBfgF+QTYBNgE2ATYBNgE2ATYBNgE2ATYBMIF2ATYBNgE2AQbBhsG2ATYBNgE2ATYBNgE2ATYBG4F2AR1BdgE2ATYBNgE2ATEBcUF2ATYBNgE9wX5BdQFfAV7BXoFeQXmBVkFcwVsBXAFvgW/Bb0FwQXFBcQF2ARvBZ4FrgWdBdgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgEpgWtBawFqwW0BaoFpwWgBZ8FoQWiBdgE2ATwBNgE2ATtBCMF2ATYBNgE2ATYBAsGCgbYBKMF2AT5BJgFlwWxBaQFsAWvBf8FPwY+BtUF2ATYBNgE2ATYBNgEGwbYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgEWwUbBhsG2AT5BBsGGwZcBVwF9QT1BF8F2AQGBj4FPgU+BT4FRwU+BdgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBPwF+gXYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ARDBdgE2ATYBNgE2ATYBNgE2ATYBNgE2AQ4BtgE4QUxBUMFQwVDBUMFRQUyBTAFPQX6BN8EZwZ/BXQFRAV0BWQGcgV/BX8FcgV/BUQFZAYKBU8GBQVlBWUFZQVbBVsFWwVbBV8FXwXABUQFPQXYBGcGZwZNBU0FZgZmBk0F1QVXBogFJgUsBSwFLAUsBU0F6gRyBVcGVwZyBYgFJgVyBSYFcgVNBeoE5QVhBk0F6gTLBU0F6gRNBeoEywUkBSQFJAUZBdgE2ATLBSQFCgUkBRkFJAUkBS0G2ATPBc8FywVNBSUGJQZoBWgFbQVfBcYFTQXYBG0FawVpBXIFHAU7BjsGNwY3BjcGbAZsBgYGSAb5BPkE+QT5BEgGDAUMBfoE+gT5BEgG2ATYBNgE2ATYBNgEQwbYBAEG1gVRBdgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2AQMBtgE2ATYBNgE2ATYBNgE2ATYBNgEjQXYBNsEAwbYBNgE2ATYBNgE2ATYBNgEdgV3BVIF2ATYBNgE2ATYBNgE2ASFBdgE2ATYBIAF2ATYBNgE2ATYBNgE2ATYBGMG2ATYBNgE2ATYBNgE5AXjBdgE2ARPBdgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgECAXYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgEagXYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgEKgZgBdgE2ATYBNgEWgbYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgEUwY0BY8F2ASOBZIF7gTYBOQE2ATYBAkAQYDzAgvnBr0AvQC8AL4AvwC/AL8AvwC+AL4AvgC+AL4AwwDFAMcAxwDGAMYAxADEAMsAywDNAM0AzgDQANAA0ADRANUA1gDXANcA1wDXANcA1wDXANcA1wDXANcA1wDXAOAA4ADcANwA3gDeAOEA4QDhAOEA4gDiAOIA4gDiAN8A3wDjAOMA4wDKAOUA5gDmAOYA5gDmAOkA2gDaAOoA6gDrAOsAvgDtAO0AvgC+AL4AzADMAMwA7wDyAPIA8gDwAPAA/AD8APMA8wDzAP4A9AD0APQA/wD/APUA9QABAQEBAAEAAQABAAEAAcgAyADuAO4ABgEGAQYBBgECAQIBAgECAQMBAwEDAQgBBAEEAfkA+QDnAOcA2wDbANsACQEJAQkB9wD3APgA+AD6APoA+gD6AL4A9gD2AAsBCwELAQsBvgAMAQwBDAEMAb4AvgAPAQ8BDwEPAQ8BDwEQAQ0BDQEOAQ4BBwEHAdkA2QDZANkA2QDYANgA2ADZANkA2QDZANkA2QDZANgA2QDZANkA2QDZANkA2QDZANkAEgHZANkA2QDZANkA2QDZANkA2QDZANkA2QATARMB2QAUARQB2QDZANkA2QDZANkAFwEXARgBGAEWARYBBQH9AP0AFQEVAb4AGQEZAd0A3QDoAOgAGgEaAb4AvgC+ABsBGwG+AL4AvgC+AL4A0wDUAL4AHQEfAR8BHwEgASABIAEiASIBHgEeASQBJQElASMBIwEjASMB2QDZAOwA7ADsAL4AvgC+ACcBJwG+AL4AvgC+AL4AvgC+ACgBvgC+AL4AKgEsAS0BLQEuAQoBCgExATEBMQEwAfEA8QAyATIBMwE0ATQBNAE0ATQBNAE1ATUBNQE5ATsBOwE8ATwBOgE6AT0BPQE+AT4BPgH7ABEBEQERATgBOAE3AbkAugC6ALsAuwC7AMAAwADAAMIAwgC+AMsAyQDJAMEAwQDBANAA0QDSANIAzwDP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IGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE11bHRpaG9wIGF0dGVtcHRlZAAAAAAApQJbAPABtQWMBSUBgwYdA5QE/wDHAzEDCwa8AY8BfwPKBCsA2gavAEIDTgPcAQ4EFQChBg0BlAILAjgGZAK8Av8CXQPnBAsHzwLLBe8F2wXhAh4GRQKFAIICbANvBPEA8wMYBdkA2gNMBlQCewGdA70EAABRABUCuwCzA20A/wGFBC8F+QQ4AGUBRgGfALcGqAFzAlMBAEGY7wMLDCEEAAAAAAAAAAAvAgBBuO8DCwY1BEcEVgQAQc7vAwsCoAQAQeLvAwuIAUYFYAVuBWEGAADPAQAAAAAAAAAAyQbpBvkGAAAAAAL/AARkACAAAAT//wYAAQABAAEA//8B/wH//////wH/Af8B/wH/Af8B/wH/Af//////Cv8gAP//A/8B/wT/HgAAAQX//////2MAAAhjAOgDAgAAAP//////AAAAAf8B//////////////8AQfnwAwsBBABBhvEDC0QB/wH//////wABIAAEAIAAAAj//wH/Af////////8B/wb/B/8I/wn//////7wCvAIBAP//AQABAP//AAD//////////wBB2vEDCwEUAEH68QMLHv//AQAK////////////Af8B/wAAAAAAAAH/Af8B/wBBqvIDC0gB/wAAAAAAAAH/Af8BAAAAAQAAAAH//////wAAAAAB////AAAAAP////////////8oAAr//////wEACv////8A//////////8AQdbzAwscAf8B////AQD//////////////////wr//////wBBgPQDCx8BAAAAAQAAAQABAAD+//9/AAAAALAEAAAoAAAAAAABAEHA9QMLARQAQcz1AwsB+gBB+/UDCwFAAEGM9gMLCP7//3////9/AEGs9gMLKQcAAAADAAAANAAAAAACAAAAAAAAZwUAANR0AABzAAAAdAAAAHUAAAB2AEHo9gMLRXcAAAB4AAAAeQAAAHoAAAB7AAAAfAAAAH0AAAB+AAAAAwAAADQAAAAAAgAAAAAAABczAADYdAAAcwAAAHQAAAB1AAAAdgBBwPcDC0V3AAAAeAAAAHkAAAB6AAAAewAAAHwAAAB9AAAAfgAAAAMAAAA0AAAAAAIAAAAAAAAANAAA3HQAAHMAAAB0AAAAdQAAAHYAQZj4AwtFdwAAAHgAAAB5AAAAegAAAHsAAAB8AAAAfQAAAH4AAAADAAAANAAAAAACAAAAAAAAgysAANR0AABzAAAAdAAAAHUAAAB2AEHw+AMLJHcAAAB4AAAAeQAAAHoAAAB7AAAAfAAAAH0AAAB+AAAAAAAAQABBoPkDC27SKQAAlAAAAAAAAADdMQAAlQAAAAAAAAArEAAAlgAAAAAAAAD6NgAAlwAAAAAAAADYDAAAmAAAAAAAAADCDAAAmQAAAAAAAAC3MAAAmgAAAAAAAADSKgAAmwAAAAAAAABVPQAA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");

// src/utils/db/sqljs.js
var import_sql = __toESM(require_sql_wasm());
var loadSQL = async () => {
  const sql = await (0, import_sql.default)({
    wasmBinary: sql_wasm_default
  });
  return sql;
};

// src/main.ts
var import_view2 = require("@codemirror/view");

// src/render/DocumentDirection.ts
var DocumentDirectionSettings = class {
  constructor() {
    this.fileDirections = {};
    this.defaultDirection = "ltr";
    this.rememberPerFile = true;
    this.setNoteTitleDirection = true;
    this.setYamlDirection = false;
  }
  toJson() {
    return JSON.stringify(this);
  }
  fromJson(content) {
    const obj = JSON.parse(content);
    this.fileDirections = obj["fileDirections"];
    this.defaultDirection = obj["defaultDirection"];
    this.rememberPerFile = obj["rememberPerFile"];
    this.setNoteTitleDirection = obj["setNoteTitleDirection"];
  }
};

// src/render/EmojiList.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_language = require("@codemirror/language");
var EmojiListPlugin = class {
  constructor(view) {
    this.decorations = this.buildDecorations(view);
  }
  update(update2) {
    if (update2.docChanged || update2.viewportChanged) {
      this.decorations = this.buildDecorations(update2.view);
    }
  }
  destroy() {
  }
  buildDecorations(view) {
    const builder = new import_state.RangeSetBuilder();
    for (const { from: from2, to: to2 } of view.visibleRanges) {
      (0, import_language.syntaxTree)(view.state).iterate({
        from: from2,
        to: to2,
        enter(node) {
          if (node.type.name.startsWith("list")) {
            const listCharFrom = node.from - 2;
            builder.add(listCharFrom, listCharFrom + 1, import_view.Decoration.replace({
              widget: new EmojiWidget()
            }));
          }
        }
      });
    }
    return builder.finish();
  }
};
var pluginSpec = {
  decorations: (value) => value.decorations
};
var EmojiWidget = class extends import_view.WidgetType {
  toDOM(view) {
    const div = document.createElement("span");
    div.innerText = "\u{1F449}";
    return div;
  }
};
var emojiListPlugin = import_view.ViewPlugin.fromClass(EmojiListPlugin, pluginSpec);

// src/main.ts
var media = window.matchMedia("(prefers-color-scheme: dark)");
var ObsidianManagerPlugin = class extends import_obsidian16.Plugin {
  constructor(app2, manifest) {
    super(app2, manifest);
    this.docDirSettings = new DocumentDirectionSettings();
    this.useSnippet = true;
    this.saveSpacesDB = (0, import_obsidian16.debounce)(() => saveDBAndKeepAlive(this.spaceDBInstance(), this.spacesDBPath), 1e3, true);
    this.app = app2;
    this.reminders = new Reminders(() => {
      this.pluginDataIO.changed = true;
    });
    this.undoHistory = [];
    this.undoHistoryTime = new Date();
    this.pluginDataIO = new PluginDataIO(this, this.reminders);
    this.reminders.reminderTime = SETTINGS.reminderTime;
    DATE_TIME_FORMATTER.setTimeFormat(SETTINGS.dateFormat, SETTINGS.dateTimeFormat, SETTINGS.strictDateFormat);
    this.editDetector = new EditDetector(SETTINGS.editDetectionSec);
    this.remindersController = new RemindersController(app2.vault, this.reminders);
    this.reminderModal = new ReminderModal(this.app, SETTINGS.useSystemNotification, SETTINGS.laters);
    this.bindFunction();
    initLogger(SETTINGS.debugEnable);
  }
  bindFunction() {
    this.resizeFunction = this.customizeResize.bind(this);
    this.clickFunction = this.customizeClick.bind(this);
    this.editorMenuFunction = this.customizeEditorMenu.bind(this);
    this.editorChangeFunction = this.customizeEditorChange.bind(this);
    this.editorPasteFunction = this.customizeEditorPaste.bind(this);
    this.fileMenuFunction = this.customizeFileMenu.bind(this);
    this.vaultCreateFunction = this.customizeVaultCreate.bind(this);
    this.vaultModifyFunction = this.customizeVaultModify.bind(this);
    this.vaultDeleteFunction = this.customizeVaultDelete.bind(this);
    this.vaultRenameFunction = this.customizeVaultRename.bind(this);
  }
  async sqlJS() {
    const sqljs = await loadSQL();
    return sqljs;
  }
  mdbChange(e3) {
    logger_default.log(this, e3);
  }
  pomodoroChange(e3) {
    this.refreshPomodoroTarget();
  }
  spaceDBInstance() {
    return this.spaceDB;
  }
  async startPomodoro(task) {
    const createTime = (0, import_moment8.default)().format("YYYY-MM-DD HH:mm:ss");
    const tags = getTagsFromTask(task);
    const content = getTaskContentFromTask(task);
    const tagsStr = tags.join(",");
    insertIntoDB(this.spaceDB, {
      pomodoro: {
        uniques: pomodoroSchema.uniques,
        cols: pomodoroSchema.cols,
        rows: [
          {
            timestamp: new Date().getTime() + "",
            task: content,
            createTime,
            spend: "0",
            breaknum: "0",
            expectedTime: (SETTINGS.expectedTime.value * 60 * 1e3).toString(),
            status: "todo",
            tags: tagsStr
          }
        ]
      }
    });
    saveDBAndKeepAlive(this.spaceDB, this.spacesDBPath);
    const evt = new CustomEvent(eventTypes.pomodoroChange);
    window.dispatchEvent(evt);
    logger_default.log(selectDB(this.spaceDBInstance(), pomodoroDB));
  }
  get snippetPath() {
    return this.app.customCss.getSnippetPath(customSnippetPath);
  }
  addTag(tag) {
    if (!tag)
      return;
    const rules = buildTagRules(tag);
    rules.forEach((rule) => {
      var _a3;
      return (_a3 = this.style.sheet) == null ? void 0 : _a3.insertRule(rule, this.style.sheet.cssRules.length);
    });
    this.updateSnippet();
  }
  generateCssString() {
    const sheet = [
      `/* This snippet was auto-generated by the awesome-brain-manager plugin on ${new Date().toLocaleString()} */

`,
      `
            body {
                --tag-border-width: 1px;
                --font-size-tag: 0.85em;
                --tag-questions: #d4bdff;
                --tag-questions-bg: #6640ae;
                --tag1: #3674bb;
                --stag1-bg: #bd1919;
                --white: white;
                --font-family-special-tag: "Lucida Handwriting", "Segoe UI Emoji";
                --font-size-emoji-after-tag: 1.5625em;
            }


            `
    ];
    for (const rule of Array.from(this.style.sheet.cssRules)) {
      sheet.push(rule.cssText);
    }
    return sheet.join("\n\n");
  }
  async updateSnippet() {
    if (!this.useSnippet)
      return;
    if (await this.app.vault.adapter.exists(this.snippetPath)) {
      await this.app.vault.adapter.write(this.snippetPath, this.generateCssString());
    } else {
      await this.app.vault.create(this.snippetPath, this.generateCssString());
    }
    this.app.customCss.setCssEnabledStatus(customSnippetPath, true);
    this.app.customCss.readSnippets();
  }
  isDailyNotesEnabled() {
    var _a3, _b2;
    const dailyNotesPlugin = this.app.internalPlugins.plugins["daily-notes"];
    const dailyNotesEnabled = dailyNotesPlugin && dailyNotesPlugin.enabled;
    const periodicNotesPlugin = this.app.plugins.getPlugin("periodic-notes");
    const periodicNotesEnabled = periodicNotesPlugin && ((_b2 = (_a3 = periodicNotesPlugin.settings) == null ? void 0 : _a3.daily) == null ? void 0 : _b2.enabled);
    return dailyNotesEnabled || periodicNotesEnabled;
  }
  getLastDailyNote() {
    const { folder = "", format: format2 } = (0, import_obsidian_daily_notes_interface2.getDailyNoteSettings)();
    const dailyNoteFiles = this.app.vault.getAllLoadedFiles().filter((file) => file.path.startsWith(folder)).filter((file) => file.basename != null);
    const todayMoment = (0, import_moment8.default)();
    const dailyNotesTodayOrEarlier = [];
    dailyNoteFiles.forEach((file) => {
      if ((0, import_moment8.default)(file.basename, format2).isSameOrBefore(todayMoment, "day")) {
        dailyNotesTodayOrEarlier.push(file);
      }
    });
    const sorted = dailyNotesTodayOrEarlier.sort((a4, b2) => (0, import_moment8.default)(b2.basename, format2).valueOf() - (0, import_moment8.default)(a4.basename, format2).valueOf());
    return sorted[1];
  }
  async getAllUnfinishedTodos(file) {
    const contents = await this.app.vault.read(file);
    const unfinishedTodosRegex = /\t*- \[ \].*/g;
    const unfinishedTodos = Array.from(contents.matchAll(unfinishedTodosRegex)).map(([todo]) => todo);
    return unfinishedTodos;
  }
  async sortHeadersIntoHeirarchy(file) {
    const templateContents = await this.app.vault.read(file);
    const allHeadings = Array.from(templateContents.matchAll(/#{1,} .*/g)).map(([heading]) => heading);
    if (allHeadings.length > 0) {
    }
  }
  async sayHello() {
    notify2("test", {});
  }
  async rollover(file) {
    const { folder = "", format: format2 } = (0, import_obsidian_daily_notes_interface2.getDailyNoteSettings)();
    let ignoreCreationTime = false;
    if (file == void 0) {
      const allDailyNotes = (0, import_obsidian_daily_notes_interface2.getAllDailyNotes)();
      file = (0, import_obsidian_daily_notes_interface2.getDailyNote)((0, import_moment8.default)(), allDailyNotes);
      ignoreCreationTime = true;
    }
    if (!file)
      return;
    if (!file.path.startsWith(folder))
      return;
    const today = new Date();
    const todayFormatted = (0, import_moment8.default)(today).format(format2);
    if (todayFormatted !== file.basename)
      return;
    if (today.getTime() - file.stat.ctime > MAX_TIME_SINCE_CREATION && !ignoreCreationTime)
      return;
    if (!this.isDailyNotesEnabled()) {
      new import_obsidian16.Notice("ObsidianManagerPlugin unable to rollover unfinished todos: Please enable Daily Notes, or Periodic Notes (with daily notes enabled).", 1e4);
    } else {
      const { templateHeading, deleteOnComplete, removeEmptyTodos } = SETTINGS;
      const lastDailyNote = this.getLastDailyNote();
      if (lastDailyNote == null)
        return;
      const todos_yesterday = await this.getAllUnfinishedTodos(lastDailyNote);
      if (todos_yesterday.length == 0) {
        logger_default.log(`rollover-daily-todos: 0 todos found in ${lastDailyNote.basename}.md`);
        return;
      }
      let todosAdded = 0;
      let emptiesToNotAddToTomorrow = 0;
      const todos_today = !removeEmptyTodos.value ? todos_yesterday : [];
      if (removeEmptyTodos.value) {
        todos_yesterday.forEach((line, i3) => {
          const trimmedLine = (line || "").trim();
          if (trimmedLine != "- [ ]" && trimmedLine != "- [  ]") {
            todos_today.push(line);
            todosAdded++;
          } else {
            emptiesToNotAddToTomorrow++;
          }
        });
      } else {
        todosAdded = todos_yesterday.length;
      }
      let templateHeadingNotFoundMessage = "";
      const templateHeadingSelected = templateHeading.value !== "none";
      let today2;
      if (todos_today.length > 0) {
        let dailyNoteContent = await this.app.vault.read(file);
        today2 = new OneDay(file, `${dailyNoteContent}`);
        const todos_todayString = `
${todos_today.join("\n")}`;
        if (templateHeadingSelected) {
          const contentAddedToHeading = dailyNoteContent.replace(templateHeading.value, `${templateHeading.value}${todos_todayString}`);
          if (contentAddedToHeading == dailyNoteContent) {
            templateHeadingNotFoundMessage = `Rollover couldn't find '${templateHeading.value}' in today's daily not. Rolling todos to end of file.`;
          } else {
            dailyNoteContent = contentAddedToHeading;
          }
        }
        if (!templateHeadingSelected || templateHeadingNotFoundMessage.length > 0) {
          dailyNoteContent += todos_todayString;
        }
        await this.app.vault.modify(file, dailyNoteContent);
      }
      let previousDay;
      if (deleteOnComplete.value) {
        const lastDailyNoteContent = await this.app.vault.read(lastDailyNote);
        previousDay = new OneDay(lastDailyNote, `${lastDailyNoteContent}`);
        const lines = lastDailyNoteContent.split("\n");
        for (let i3 = lines.length; i3 >= 0; i3--) {
          if (todos_yesterday.includes(lines[i3])) {
            lines.splice(i3, 1);
          }
        }
        const modifiedContent = lines.join("\n");
        await this.app.vault.modify(lastDailyNote, modifiedContent);
      }
      const todosAddedString = todosAdded == 0 ? "" : `- ${todosAdded} todo${todosAdded > 1 ? "s" : ""} rolled over.`;
      const emptiesToNotAddToTomorrowString = emptiesToNotAddToTomorrow == 0 ? "" : deleteOnComplete.value ? `- ${emptiesToNotAddToTomorrow} empty todo${emptiesToNotAddToTomorrow > 1 ? "s" : ""} removed.` : "";
      const part1 = templateHeadingNotFoundMessage.length > 0 ? `${templateHeadingNotFoundMessage}` : "";
      const part2 = `${todosAddedString}${todosAddedString.length > 0 ? " " : ""}`;
      const part3 = `${emptiesToNotAddToTomorrowString}${emptiesToNotAddToTomorrowString.length > 0 ? " " : ""}`;
      const allParts = [part1, part2, part3];
      const nonBlankLines = [];
      allParts.forEach((part) => {
        if (part.length > 0) {
          nonBlankLines.push(part);
        }
      });
      const message = nonBlankLines.join("\n");
      if (message.length > 0) {
        new import_obsidian16.Notice(message, 4e3 + message.length * 3);
      }
      this.undoHistoryTime = new Date();
      this.undoHistory = [new UndoHistoryInstance(previousDay, today2)];
    }
  }
  async customizeResize() {
  }
  async customizeClick(evt) {
    logger_default.log("customizeClick");
  }
  async customizeEditorMenu(menu, editor, info) {
    menu.addItem((item) => {
      item.setTitle(i18n_default2.menu.setBannerForCurrent).setIcon("image").onClick((async) => {
        new ImageOriginModal(this.app, this, this.app.workspace.getActiveFile()).open();
      });
    });
    menu.addItem((item) => {
      item.setTitle(i18n_default2.menu.planPomodoro).setIcon("clock").onClick(async () => {
        const cursorPos = editor.getCursor();
        let task = editor.getSelection();
        if (!task) {
          if (cursorPos) {
            task = editor.getLine(cursorPos.line);
          }
        }
        task = task.replace("- [x] ", "");
        task = task.replace("- [ ] ", "").trim();
        if (!task) {
          task = i18n_default2.menu.defaultTask + Date.now();
        }
        this.startPomodoro(task);
      });
    });
  }
  async customizeEditorChange(editor, info) {
    onCodeMirrorChange(editor);
  }
  async customizeEditorPaste(evt, editor, markdownView) {
    return;
  }
  async customizeFileMenu(menu, file, source, leaf) {
    menu.addItem((item) => {
      item.setTitle(i18n_default2.menu.setBannerForTheFolder).setIcon("image").onClick(async () => {
        new ImageOriginModal(this.app, this, file).open();
      });
    });
  }
  async customizeVaultCreate(file) {
  }
  async customizeVaultModify(file) {
    this.remindersController.reloadFile(file, true);
  }
  async customizeVaultDelete(file) {
    const { format: format2 } = (0, import_obsidian_daily_notes_interface2.getDailyNoteSettings)();
    const today = new Date();
    const todayFormatted = (0, import_moment8.default)(today).format(format2);
    if (file.name == todayFormatted + ".md" && this.app.commands.commands["obsidian-day-planner:app:unlink-day-planner-from-note"]) {
      this.app.commands.executeCommandById("obsidian-day-planner:app:unlink-day-planner-from-note");
    }
    this.remindersController.removeFile(file.path);
  }
  async customizeVaultRename(file, oldPath) {
    if (await this.remindersController.removeFile(oldPath)) {
      await this.remindersController.reloadFile(file);
    }
  }
  async onload() {
    await this.pluginDataIO.load();
    this.setupUI();
    this.setupCommands();
    this.registerMarkdownPostProcessor(codeEmoji);
    this.spacesDBPath = (0, import_obsidian15.normalizePath)(app.vault.configDir + "/plugins/awesome-brain-manager/ObsidianManager.mdb");
    this.spaceDB = await getDB(await loadSQL(), this.spacesDBPath);
    const tables = dbResultsToDBTables(this.spaceDBInstance().exec("SELECT name FROM sqlite_schema WHERE type ='table' AND name NOT LIKE 'sqlite_%';"));
    if (tables.length == 0) {
      initiateDB(this.spaceDBInstance());
    }
    this.refreshPomodoroTarget();
    this.app.workspace.onLayoutReady(async () => {
      if (SETTINGS.debugEnable.value) {
        monkeyPatchConsole(this);
      }
      this.watchVault();
      this.startPomodoroTask();
    });
  }
  async refreshPomodoroTarget() {
    var _a3;
    const pomodoroList = await ((_a3 = selectDB(this.spaceDBInstance(), pomodoroDB)) == null ? void 0 : _a3.rows) || [];
    this.pomodoroTarget = pomodoroList.filter((pomodoro) => pomodoro.status === "ing")[0] || null;
  }
  startPomodoroTask() {
    this.registerInterval(window.setInterval(() => {
      const pomodoro = this.pomodoroTarget;
      if (!pomodoro) {
        return;
      }
      const pomodoroStatus = new PomodoroStatus(pomodoro);
      if (pomodoroStatus.isOutTime()) {
        new PomodoroReminderModal(this.app, pomodoro).open();
        const changed = pomodoroStatus.changeState("done");
        if (changed) {
          this.updatePomodoro(pomodoro);
          this.pomodoroTarget = null;
        } else {
          logger_default.error("Update failed", pomodoro);
        }
      }
    }, 1 * 1e3));
  }
  deletePomodoro(pomodoro) {
    deleteFromDB(this.spaceDBInstance(), pomodoroDB, `timestamp = ${pomodoro.timestamp}`);
    saveDBAndKeepAlive(this.spaceDBInstance(), this.spacesDBPath);
    const evt = new CustomEvent(eventTypes.pomodoroChange);
    window.dispatchEvent(evt);
  }
  updatePomodoro(pomodoro) {
    updateDBConditionally(this.spaceDBInstance(), {
      pomodoro: {
        uniques: pomodoroSchema.uniques,
        cols: pomodoroSchema.cols,
        rows: [pomodoro]
      }
    }, `timestamp = ${pomodoro.timestamp}`);
    saveDBAndKeepAlive(this.spaceDBInstance(), this.spacesDBPath);
    const evt = new CustomEvent(eventTypes.pomodoroChange);
    window.dispatchEvent(evt);
  }
  startPeriodicTask() {
    let intervalTaskRunning = true;
    this.periodicTask().finally(() => {
      intervalTaskRunning = false;
    });
    this.registerInterval(window.setInterval(() => {
      if (intervalTaskRunning) {
        logger_default.log("Skip reminder interval task because task is already running.");
        return;
      }
      intervalTaskRunning = true;
      this.periodicTask().finally(() => {
        intervalTaskRunning = false;
      });
    }, SETTINGS.reminderCheckIntervalSec.value * 1e3));
  }
  async periodicTask() {
    if (!this.pluginDataIO.scanned.value) {
      this.remindersController.reloadAllFiles().then(() => {
        this.pluginDataIO.scanned.value = true;
        this.pluginDataIO.save();
      });
    }
    this.pluginDataIO.save(false);
    if (this.editDetector.isEditing()) {
      return;
    }
    const expired = this.reminders.getExpiredReminders(SETTINGS.reminderTime.value);
    let previousReminder = void 0;
    for (const reminder of expired) {
      if (this.app.workspace.layoutReady) {
        if (reminder.muteNotification) {
          continue;
        }
        if (previousReminder) {
          while (previousReminder.beingDisplayed) {
            await this.sleep(100);
          }
        }
        this.showReminder(reminder);
        logger_default.log(reminder);
        previousReminder = reminder;
      }
    }
  }
  async sleep(milliseconds) {
    return new Promise((resolve2) => setTimeout(resolve2, milliseconds));
  }
  showReminder(reminder) {
    reminder.muteNotification = true;
    this.reminderModal.show(reminder, (time2) => {
      logger_default.info("Remind me later: time=%o", time2);
      reminder.time = time2;
      reminder.muteNotification = false;
      this.remindersController.updateReminder(reminder, false);
      this.pluginDataIO.save(true);
    }, () => {
      logger_default.info("done");
      reminder.muteNotification = false;
      this.remindersController.updateReminder(reminder, true);
      this.reminders.removeReminder(reminder);
      this.pluginDataIO.save(true);
    }, () => {
      logger_default.info("Mute");
      reminder.muteNotification = true;
    }, () => {
      logger_default.info("Open");
      this.openReminderFile(reminder);
    });
  }
  async openReminderFile(reminder) {
    const leaf = this.app.workspace.getUnpinnedLeaf();
    await this.remindersController.openReminder(reminder, leaf);
  }
  async addACheck(path, filename, time2, content) {
    const normalizedPath = await getNotePath(path, filename);
    const todayMoment = (0, import_moment8.default)();
    const fileContents = await app.vault.adapter.read(normalizedPath);
    const newFileContent = await insertAfterHandler("## \u6253\u5361", `- [ ] ${time2} ${content} \u23F3 ${todayMoment.format("YYYY-MM-DD")}`, fileContents);
    await app.vault.adapter.write(normalizedPath, newFileContent.content);
  }
  async removeACheck(path, filename, time2, content) {
    const normalizedPath = await getNotePath(path, filename);
    const todayMoment = (0, import_moment8.default)();
    const fileContents = await app.vault.adapter.read(normalizedPath);
    const originalLine = `- [ ] ${time2} ${content} \u23F3 ${todayMoment.format("YYYY-MM-DD")}`;
    const newContent = fileContents.replace(originalLine, "");
    await app.vault.adapter.write(normalizedPath, newContent);
  }
  async habitCheckIn() {
    checkInList.forEach((habit) => {
      const { path, filename, time: time2, content } = habit;
      this.addACheck(path || checkInDefaultPath, filename, time2, content);
    });
  }
  async removeHabitCheckIn() {
    checkInList.forEach((habit) => {
      const { path, filename, time: time2, content } = habit;
      this.removeACheck(path || checkInDefaultPath, filename, time2, content);
    });
  }
  getLocalRandom(title, path) {
    return getLocalRandom(title, this.app.vault.getAbstractFileByPath(path));
  }
  getCleanTitle(title) {
    return getCleanTitle(title);
  }
  async getWeather(city) {
    return "";
  }
  async setRandomBanner(path, origin) {
    const ignorePath = [];
    const allFilePathNeededHandle = await getAllFiles(path, ignorePath, ["md"], []);
    allFilePathNeededHandle.forEach(async (file) => {
      const hash = this.app.metadataCache.fileCache[file.path].hash;
      const frontmatter = this.app.metadataCache.metadataCache[hash].frontmatter;
      const banner = frontmatter == null ? void 0 : frontmatter.banner;
      const title = frontmatter == null ? void 0 : frontmatter.title;
      const newBanner = await searchPicture(origin, title);
      if (newBanner) {
        await setBanner(file.path, banner, newBanner);
      }
    });
  }
  setupCommands() {
    this.addCommand({
      id: "awesome-brain-manager-check-in",
      name: i18n_default2.command["awesome-brain-manager-check-in"],
      callback: () => {
        this.habitCheckIn();
      }
    });
    this.addCommand({
      id: "awesome-brain-manager-remove-check-in",
      name: i18n_default2.command["awesome-brain-manager-remove-check-in"],
      callback: () => {
        this.removeHabitCheckIn();
      }
    });
    this.addCommand({
      id: "demo show",
      name: "demo show",
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "t" }],
      editorCallback: (editor, view) => {
        this.sayHello();
      }
    });
    this.addCommand({
      id: "awesome-brain-manager-rollover",
      name: i18n_default2.command["awesome-brain-manager-rollover"],
      callback: () => this.rollover(void 0)
    });
    this.addCommand({
      id: "awesome-brain-manager-undo",
      name: i18n_default2.command["awesome-brain-manager-undo"],
      checkCallback: (checking) => {
        if (this.undoHistory.length > 0) {
          const now = (0, import_moment8.default)();
          const lastUse = (0, import_moment8.default)(this.undoHistoryTime);
          const diff = now.diff(lastUse, "seconds");
          if (diff > 2 * 60) {
            return false;
          }
          return true;
        }
        return false;
      }
    });
  }
  toggleDocumentDirection() {
    const newDirection = this.getDocumentDirection() === "ltr" ? "rtl" : "ltr";
    this.setDocumentDirection(newDirection);
    if (this.docDirSettings.rememberPerFile && this.currentFile && this.currentFile.path) {
      this.docDirSettings.fileDirections[this.currentFile.path] = newDirection;
    }
  }
  getDocumentDirection() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian16.MarkdownView);
    if (!view)
      return i18n_default2.info.unknown;
    const rtlEditors = view.contentEl.getElementsByClassName("is-rtl");
    if (rtlEditors.length > 0)
      return "rtl";
    else
      return "ltr";
  }
  setDocumentDirection(newDirection) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian16.MarkdownView);
    if (!view || !(view == null ? void 0 : view.editor))
      return;
    const editorDivs = view.contentEl.getElementsByClassName("cm-editor");
    for (const editorDiv of editorDivs) {
      if (editorDiv instanceof HTMLDivElement)
        this.setDocumentDirectionForEditorDiv(editorDiv, newDirection);
    }
    const markdownPreviews = view.contentEl.getElementsByClassName("markdown-preview-view");
    for (const preview of markdownPreviews) {
      if (preview instanceof HTMLDivElement)
        this.setDocumentDirectionForReadingDiv(preview, newDirection);
    }
    this.replacePageStyleByString("List indent fix", "/* List indent fix */ .is-rtl .HyperMD-list-line { text-indent: 0px !important; }", true);
    this.replacePageStyleByString("CodeMirror-rtl pre", ".CodeMirror-rtl pre { text-indent: 0px !important; }", true);
    this.replacePageStyleByString("Embedded links always LTR", "/* Embedded links always LTR */ .embedded-backlinks { direction: ltr; }", true);
    this.replacePageStyleByString("Fold symbol fix", "/* Fold symbol fix*/ .is-rtl .cm-fold-indicator { right: -15px !important; }", true);
    if (this.docDirSettings.setNoteTitleDirection) {
      const container = view.containerEl.parentElement;
      const header = container == null ? void 0 : container.getElementsByClassName("view-header-title-container");
      header[0].style.direction = newDirection;
    }
    view.editor.refresh();
    this.setExportDirection(newDirection);
  }
  setDocumentDirectionForEditorDiv(editorDiv, newDirection) {
    var _a3, _b2;
    editorDiv.style.direction = newDirection;
    if (newDirection === "rtl") {
      (_a3 = editorDiv.parentElement) == null ? void 0 : _a3.classList.add("is-rtl");
    } else {
      (_b2 = editorDiv.parentElement) == null ? void 0 : _b2.classList.remove("is-rtl");
    }
  }
  setDocumentDirectionForReadingDiv(readingDiv, newDirection) {
    readingDiv.style.direction = newDirection;
    if (newDirection === "rtl")
      readingDiv.classList.add("is-rtl");
    else
      readingDiv.classList.remove("is-rtl");
    if (this.docDirSettings.setYamlDirection)
      this.replacePageStyleByString("Patch YAML", "/* Patch YAML RTL */ .is-rtl .language-yaml code { text-align: right; }", true);
  }
  setExportDirection(newDirection) {
    this.replacePageStyleByString("searched and replaced", `/* This is searched and replaced by the plugin */ @media print { body { direction: ${newDirection}; } }`, false);
  }
  replacePageStyleByString(searchString, newStyle, addIfNotFound) {
    let alreadyExists = false;
    const style2 = this.findPageStyle(searchString);
    if (style2) {
      if (style2.getText() === searchString)
        alreadyExists = true;
      else
        style2.setText(newStyle);
    } else if (addIfNotFound) {
      const style3 = document.createElement("style");
      style3.textContent = newStyle;
      document.head.appendChild(style3);
    }
    return style2 && !alreadyExists;
  }
  findPageStyle(regex) {
    const styles = document.head.getElementsByTagName("style");
    for (const style2 of styles) {
      if (style2.getText().match(regex))
        return style2;
    }
    return null;
  }
  setupUI() {
    this.style = document.head.createEl("style", {
      attr: { id: "OBSIDIAN_MANAGER_CUSTOM_STYLE_SHEET" }
    });
    toggleBlast(SETTINGS.powerMode.value);
    toggleShake(SETTINGS.shakeMode);
    toggleCursorEffects(SETTINGS.cursorEffect.value);
    const obsidianManagerDocumentDirectionDirStatusBar = this.addStatusBarItem();
    obsidianManagerDocumentDirectionDirStatusBar.setText("\u{1F4C4}:" + this.getDocumentDirection().toUpperCase());
    obsidianManagerDocumentDirectionDirStatusBar.onClickEvent((evt) => {
      this.toggleDocumentDirection();
      obsidianManagerDocumentDirectionDirStatusBar.setText("\u{1F4C4}:" + this.getDocumentDirection().toUpperCase());
    });
    const obsidianManagerPomodoroStatusBar = this.addStatusBarItem();
    obsidianManagerPomodoroStatusBar.createEl("span", { text: "\u{1F345}" });
    obsidianManagerPomodoroStatusBar.onClickEvent(async (evt) => {
      this.app.workspace.detachLeavesOfType(POMODORO_HISTORY_VIEW);
      await this.app.workspace.getRightLeaf(true).setViewState({
        type: POMODORO_HISTORY_VIEW,
        active: true
      });
      this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(POMODORO_HISTORY_VIEW)[0]);
    });
    this.addSettingTab(new ReminderSettingTab(this.app, this, this.pluginDataIO));
    this.registerView(POMODORO_HISTORY_VIEW, (leaf) => new PomodoroHistoryView(leaf, this));
    this.addTag(new Tag("yellow", "blue", "juck", { name: "" }, { fontFamily: "" }));
    this.addTag(new Tag("blue", "yellow", "juckz", { name: "" }, { fontFamily: "" }));
    this.addRibbonIcon("settings-2", "Awesome Brain Manager", (event) => {
      const menu = new import_obsidian16.Menu();
      menu.addItem((item) => item.setTitle(i18n_default2.menu.showPomodoroHistory).setIcon("alarm-clock").onClick(async () => {
        this.app.workspace.detachLeavesOfType(POMODORO_HISTORY_VIEW);
        await this.app.workspace.getLeaf(true).setViewState({
          type: POMODORO_HISTORY_VIEW,
          active: true
        });
        this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(POMODORO_HISTORY_VIEW)[0]);
      }));
      menu.showAtMouseEvent(event);
    });
  }
  watchVault() {
    const callback2 = () => {
      if (media.matches) {
        logger_default.log("Dark mode active");
      } else {
        logger_default.log("Light mode active");
      }
    };
    media.addEventListener("change", callback2);
    this.register(() => media.removeEventListener("change", callback2));
    window.addEventListener(eventTypes.pomodoroChange, this.pomodoroChange.bind(this));
    window.addEventListener(eventTypes.mdbChange, this.mdbChange.bind(this));
    [
      this.app.workspace.on("click", this.clickFunction),
      this.app.workspace.on("resize", this.resizeFunction),
      this.app.workspace.on("editor-change", this.editorChangeFunction),
      this.app.workspace.on("editor-paste", this.editorPasteFunction),
      this.app.workspace.on("file-menu", this.fileMenuFunction),
      this.app.workspace.on("editor-menu", this.editorMenuFunction),
      this.app.vault.on("create", this.vaultCreateFunction),
      this.app.vault.on("modify", this.vaultModifyFunction),
      this.app.vault.on("delete", this.vaultDeleteFunction),
      this.app.vault.on("rename", this.vaultRenameFunction)
    ].forEach((eventRef) => {
      this.registerEvent(eventRef);
    });
  }
  async onunload() {
    toggleBlast("0");
    this.app.workspace.detachLeavesOfType(POMODORO_HISTORY_VIEW);
    this.style.detach();
  }
};
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v4.2.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! moment.js
//! momentjs.com
//! version : 2.29.4
